<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Elisp 学习笔记（一） |
    
    六加的博客</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
<main class="content">
  <section class="outer">
  <article id="post-Elisp-学习笔记（一）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
    <h1 class="article-title" itemprop="name">
      Elisp 学习笔记（一）
    </h1>
  
  




    </header>
    

    
    <div class="article-meta">
      <a href="/2019/10/05/Elisp-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2019-10-04T16:00:00.000Z" itemprop="datePublished">2019-10-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
  </div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      


      
  <div class="article-gallery">
    <div class="article-gallery-photos">
      
        
          <img src="/images/Emacs.png" itemprop="image">
        
      
        
          <img src="/images/gnu.jpg" itemprop="image">
        
      
    </div>
  </div>


      
      <p>[TOC]</p>
<hr>
<h1>Elisp 学习笔记（一）</h1>
<h2 id="基础知识"><a class="header-anchor" href="#基础知识">¶</a>基础知识</h2>
<h3 id="函数和变量"><a class="header-anchor" href="#函数和变量">¶</a>函数和变量</h3>
<h4 id="函数"><a class="header-anchor" href="#函数">¶</a>函数</h4>
<ul>
<li>
<p>elisp 函数的一般形式：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> function-name (<span class="name">arguments-list</span>)</span><br><span class="line">  <span class="string">"document string"</span></span><br><span class="line">  body)</span><br></pre></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> hello-world (<span class="name">name</span>)</span><br><span class="line">  <span class="string">"Say hello to user whose name is NAME."</span></span><br><span class="line">  (<span class="name">message</span> <span class="string">"Hello, %s"</span> name))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>每个函数都有一个返回值。这个返回值一般是函数定义里的最后一个表达式的值。</p>
</li>
<li>
<p>elisp 中函数是全局的。</p>
</li>
</ul>
<h4 id="lambda-表达式"><a class="header-anchor" href="#lambda-表达式">¶</a><code>lambda</code> 表达式</h4>
<p>它的形式和 <code>defun</code> 是完全一样的：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">lambda</span> (<span class="name">arguments-list</span>)</span><br><span class="line">  <span class="string">"documentation string"</span></span><br><span class="line">  body)</span><br></pre></td></tr></table></figure>
<p>调用 <code>lambda</code> 方法如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">funcall</span> (<span class="name">lambda</span> (<span class="name">name</span>)</span><br><span class="line">           (<span class="name">message</span> <span class="string">"Hello, %s!"</span> name)) <span class="string">"Emacser"</span>)</span><br></pre></td></tr></table></figure>
<p>你也可以把 <code>lambda</code> 表达式赋值给一个变量，然后用 <code>funcall</code> 调用：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> foo (<span class="name">lambda</span> (<span class="name">name</span>)</span><br><span class="line">            (<span class="name">message</span> <span class="string">"Hello, %s!"</span> name)))</span><br><span class="line">(<span class="name">funcall</span> foo <span class="string">"Emacser"</span>)                   <span class="comment">; =&gt; "Hello, Emacser!"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>lambda</code> 表达式最常用的是作为参数传递给其它函数，比如 <code>mapc</code>。</p>
</blockquote>
<h4 id="变量"><a class="header-anchor" href="#变量">¶</a>变量</h4>
<ul>
<li>
<p>elisp 里的变量使用无需象 C 语言那样需要声明，你可以用 <code>setq</code> 直接对一个变量赋值。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> foo <span class="string">"I'm foo"</span>)                    <span class="comment">; =&gt; "I'm foo"</span></span><br><span class="line">(<span class="name">message</span> foo)                           <span class="comment">; =&gt; "I'm foo"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>有一个特殊表达式（special form）<code>defvar</code>，它可以声明一个变量，一般的形式是：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defvar</span> variable-name value</span><br><span class="line">  <span class="string">"document string"</span>)</span><br></pre></td></tr></table></figure>
<p>它与 <code>setq</code> 的区别：</p>
<ol>
<li>
<p>如果变量在声明之前，这个变量已经有一个值的话，用 <code>defvar</code> 声明的变量值不会改变成声明的那个值。</p>
</li>
<li>
<p><code>defvar</code> 可以为变量提供文档字符串，当变量是在文件中定义的话，<code>C-h v</code> 后能给出变量定义的位置。比如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defvar</span> foo <span class="string">"Did I have a value?"</span></span><br><span class="line">  <span class="string">"A demo variable"</span>)                    <span class="comment">; =&gt; foo</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; "I'm foo"</span></span><br><span class="line">(<span class="name">defvar</span> bar <span class="string">"I'm bar"</span></span><br><span class="line">  <span class="string">"A demo variable named \"bar\""</span>)      <span class="comment">; =&gt; bar</span></span><br><span class="line">bar                                     <span class="comment">; =&gt; "I'm bar"</span></span><br></pre></td></tr></table></figure>
<p>用 <code>C-h v</code> 查看 <code>foo</code> 的文档，可以看到它已经变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo&#39;s value is &quot;I&#39;m foo&quot;</span><br><span class="line">	</span><br><span class="line">Documentation:</span><br><span class="line">A demo variable</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>局部作用域的变量</p>
<p>如果没有局部作用域的变量，都使用 <strong>全局变量</strong>，函数会相当难写。elisp 里可以用 <code>let</code> 和 <code>let*</code> 进行局部变量的绑定。</p>
<ul>
<li>
<p><code>let</code> 使用的形式是：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> (<span class="name">bindings</span>)</span><br><span class="line">  body)</span><br></pre></td></tr></table></figure>
<p><code>bingdings</code> 可以是 <code>(var value)</code> 这样对 <code>var</code> 赋初始值的形式，或者用 <code>var</code> 声明一个初始值为 <code>nil</code> 的变量。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> circle-area (<span class="name">radix</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">pi</span> <span class="number">3.1415926</span>)</span><br><span class="line">        area)</span><br><span class="line">    (<span class="name">setq</span> area (<span class="name">*</span> pi radix radix))</span><br><span class="line">    (<span class="name">message</span> <span class="string">"直径为 %.2f 的圆面积是 %.2f"</span> radix area)))</span><br><span class="line">(<span class="name">circle-area</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><code>C-h v</code> 查看 <code>area</code> 和 <code>pi</code> 应该没有这两个变量。</p>
</li>
<li>
<p><code>let*</code> 和 <code>let</code> 的使用形式完全相同，唯一的区别是在 <code>let*</code> 声明中就能使用前面声明的变量，比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> circle-area (<span class="name">radix</span>)</span><br><span class="line">  (<span class="name">let*</span> ((<span class="name">pi</span> <span class="number">3.1415926</span>)</span><br><span class="line">        (<span class="name">area</span> (<span class="name">*</span> pi radix radix)))</span><br><span class="line">   (<span class="name">message</span> <span class="string">"直径为 %.2f 的圆面积是 %.2f"</span> radix area)))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="控制结构"><a class="header-anchor" href="#控制结构">¶</a>控制结构</h4>
<ul>
<li>
<p>顺序执行</p>
<p>一般来说程序都是按表达式顺序依次执行的。这在 <code>defun</code> 等特殊环境中是自动进行的。**但是一般情况下都不是这样的。比如你无法用 <code>eval-last-sexp</code> 同时执行两个表达式，在 <code>if</code> 表达式中的条件为真时执行的部分也只能运行一个表达式。**这时就需要用 <code>progn</code> 这个特殊表达式。它的使用形式如下：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">progn</span> A B C ...)</span><br></pre></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">progn</span></span><br><span class="line">  (<span class="name">setq</span> foo <span class="number">3</span>)</span><br><span class="line">  (<span class="name">message</span> <span class="string">"Square of %d is %d"</span> foo (<span class="name">*</span> foo foo)))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>条件判断</p>
<ul>
<li>
<p><code>if</code> ：</p>
<p>形式：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">if</span> condition</span><br><span class="line">    then</span><br><span class="line">	else)</span><br></pre></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> my-max (<span class="name">a</span> b)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> a b)</span><br><span class="line">      a b))</span><br><span class="line">(<span class="name">my-max</span> <span class="number">3</span> <span class="number">4</span>)                            <span class="comment">; =&gt; 4</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>cond</code> ：</p>
<p>形式：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cond</span> (<span class="name">case1</span> do-when-case1)</span><br><span class="line">	(<span class="name">case2</span> do-when-case2)</span><br><span class="line">  ...</span><br><span class="line">	(<span class="name">t</span> do-when-none-meet))</span><br></pre></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> fib (<span class="name">n</span>)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">=</span> n <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">       ((<span class="name">=</span> n <span class="number">1</span>) <span class="number">1</span>)</span><br><span class="line">       (<span class="name">t</span> (<span class="name">+</span> (<span class="name">fib</span> (<span class="name">-</span> n <span class="number">1</span>))</span><br><span class="line">	      (<span class="name">fib</span> (<span class="name">-</span> n <span class="number">2</span>))))))</span><br><span class="line">(<span class="name">fib</span> <span class="number">10</span>)                                <span class="comment">; =&gt; 55</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>when</code> ：</p>
<p>形式：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">when</span> condition</span><br><span class="line">    ...)</span><br><span class="line"><span class="comment">;; 等同于</span></span><br><span class="line"><span class="comment">;;	(if condition</span></span><br><span class="line"><span class="comment">;;	    (progn</span></span><br><span class="line"><span class="comment">;;			...))</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>unless</code> ：</p>
<p>等同于：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">when</span> not condition</span><br><span class="line">	...)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>循环</p>
<p>循环使用的是 <code>while</code> 表达式。它的形式是：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">while</span> condition</span><br><span class="line">  body)</span><br></pre></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> factorial (<span class="name">n</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">res</span> <span class="number">1</span>))</span><br><span class="line">    (<span class="name">while</span> (<span class="name">&gt;</span> n <span class="number">1</span>)</span><br><span class="line">      (<span class="name">setq</span> res (<span class="name">*</span> res n)</span><br><span class="line">           n (<span class="name">-</span> n <span class="number">1</span>)))</span><br><span class="line">    res))</span><br><span class="line">(<span class="name">factorial</span> <span class="number">10</span>)                          <span class="comment">; =&gt; 3628800</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="逻辑运算"><a class="header-anchor" href="#逻辑运算">¶</a>逻辑运算</h4>
<p>条件的逻辑运算和其它语言都是很类似的，使用 <code>and</code>、<code>or</code>、<code>not</code>。<code>and</code> 和 <code>or</code> 也同样具有短路性质。很多人喜欢在表达式短路时，用 <code>and</code> 代替 <code>when</code>，<code>or</code> 代替 <code>unless</code>。<strong>当然这时一般不关心它们的返回值，而是在于表达式其它子句的副作用</strong>。比如 <code>or</code> 经常用于设置函数的缺省值，而 <code>and</code> 常用于参数检查：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> hello-world (<span class="name">&amp;optional</span> name)</span><br><span class="line">  (<span class="name">or</span> name (<span class="name">setq</span> name <span class="string">"Emacser"</span>))</span><br><span class="line">  (<span class="name">message</span> <span class="string">"Hello, %s"</span> name))           <span class="comment">; =&gt; hello-world</span></span><br><span class="line">(<span class="name">hello-world</span>)                           <span class="comment">; =&gt; "Hello, Emacser"</span></span><br><span class="line">(<span class="name">hello-world</span> <span class="string">"Ye"</span>)                      <span class="comment">; =&gt; "Hello, Ye"</span></span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> square-number-p (<span class="name">n</span>)</span><br><span class="line">  (<span class="name">and</span> (<span class="name">&gt;=</span> n <span class="number">0</span>)</span><br><span class="line">       (<span class="name">=</span> (<span class="name">/</span> n (<span class="name">sqrt</span> n)) (<span class="name">sqrt</span> n))))</span><br><span class="line">(<span class="name">square-number-p</span> <span class="number">-1</span>)                    <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">square-number-p</span> <span class="number">25</span>)                    <span class="comment">; =&gt; t</span></span><br></pre></td></tr></table></figure>
<h2 id="基本数据类型"><a class="header-anchor" href="#基本数据类型">¶</a>基本数据类型</h2>
<ul>
<li>
<p>内建的 emacs 数据类型称为 primitive types，包括：</p>
<ul>
<li>整数</li>
<li>浮点数</li>
<li>cons</li>
<li>符号 (symbol)</li>
<li>字符串</li>
<li>向量 (vector)</li>
<li>散列表 (hash-table)</li>
<li>subr（内建函数，比如 <code>cons</code>, <code>if</code>, <code>and</code> 之类）</li>
<li>byte-code function</li>
<li>其它特殊类型，例如缓冲区（buffer）</li>
</ul>
</li>
<li>
<p>读入语法和输出形式</p>
<ul>
<li>
<p>读入语法是让 elisp 解释器明白输入字符所代表的对象。简单的来说，一种数据类型有（也可能没有，比如散列表）对应的规则来让解释器产生这种数据类型，比如 <code>123</code> 产生整数 <code>123</code>，<code>(a . b)</code> 产生一个 cons。</p>
</li>
<li>
<p>所谓输出形式是解释器用产生一个字符串来表示一个数据对象。比如整数 <code>123</code> 的输出形式就是 <code>12</code>3，<code>cons cell (a . b)</code> 的输出形式是 <code>(a . b)</code>。与读入语法不同的是，<strong>数据对象都有输出形式</strong>。比如散列表的输出可能是这样的：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&lt;hash-table 'eql <span class="literal">nil</span> <span class="number">0/65</span> <span class="number">0</span>xa7344c8&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="数字"><a class="header-anchor" href="#数字">¶</a>数字</h3>
<p>emacs 的数字分为 <strong>整数</strong> 和 <strong>浮点数</strong>（<strong>和 C 比没有双精度数 double</strong>）。<code>1</code>， <code>1.</code>，<code>+1</code>, <code>-1</code>, <code>536870913</code>, <code>0</code>, <code>-0</code> 这些都是整数。整数的范围是和机器是有关的，一般来最小范围是在 <code>-268435456</code> to <code>268435455</code>（29位，<code>-2**28</code> ~ <code>2**28-1</code>）。<strong>可以从 <code>most-positive-fixnum</code> 和 <code>most-negative-fixnum</code> 两个变量得到整数的范围。</strong></p>
<ul>
<li>
<p>整数</p>
<p>你可以用多种进制来输入一个整数。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">#b101100</span> =&gt; <span class="number">44</span>      <span class="comment">; 二进制</span></span><br><span class="line"><span class="number">#o54</span> =&gt; <span class="number">44</span>          <span class="comment">; 八进制</span></span><br><span class="line"><span class="number">#x2c</span> =&gt; <span class="number">44</span>          <span class="comment">; 十进制</span></span><br></pre></td></tr></table></figure>
<p>最神奇的是你可以用 <code>2</code> 到 <code>36</code> 之间任意一个数作为基数，比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#24r1k =&gt; <span class="number">44</span>        <span class="comment">; 二十四进制</span></span><br></pre></td></tr></table></figure>
<p>之所以最大是 36，是因为只有 <code>0-9</code> 和 <code>a-z</code> 36 个。</p>
</li>
<li>
<p>浮点数</p>
<p><code>1500.0</code>, <code>15e2</code>, <code>15.0e2</code>, <code>1.5e3</code>, 和 <code>.15e4</code> 都可以用来表示一个浮点数 <code>1500.</code>。遵循 IEEE 标准，elisp 也有一个特殊类型的值称为 <code>NaN</code> (not-a-number)。你可以用 <code>(/ 0.0 0.0)</code> 产生这个数。</p>
</li>
</ul>
<h4 id="测试函数"><a class="header-anchor" href="#测试函数">¶</a>测试函数</h4>
<p>整数类型测试函数是 <code>integerp</code>，浮点数类型测试函数是 <code>floatp</code>。数字类型测试用 <code>numberp</code>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">integerp</span> <span class="number">1</span>.)                           <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">integerp</span> <span class="number">1.0</span>)                          <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">floatp</span> <span class="number">1</span>.)                             <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">floatp</span> <span class="number">-0.0</span>e+NaN)                      <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">numberp</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>还提供一些特殊测试，比如测试是否是零的 <code>zerop</code>，还有非负整数测试的 <code>wholenump</code>。</p>
<blockquote>
<p>注：<strong>elisp 测试函数一般都是用 p 来结尾，p 是 predicate 的第一个字母。如果函数名是一个单词，通常只是在这个单词后加一个 p，如果是多个单词，一般是加 -p</strong>。</p>
</blockquote>
<h4 id="数的比较"><a class="header-anchor" href="#数的比较">¶</a>数的比较</h4>
<p>常用的比较操作符号是我们在其它言中都很熟悉的，比如 <code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>，不一样的是，由于赋值是使用 <code>set</code> 函数，所以 <strong><code>=</code> 不再是一个赋值运算符了，而是测试数字相等符号</strong>。和其它语言类似，<strong>对于浮点数的相等测试都是不可靠的</strong>。比如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> foo (<span class="name">-</span> (<span class="name">+</span> <span class="number">1.0</span> <span class="number">1.0e-3</span>) <span class="number">1.0</span>))       <span class="comment">; =&gt; 0.0009999999999998899</span></span><br><span class="line">(<span class="name">setq</span> bar <span class="number">1.0e-3</span>)                       <span class="comment">; =&gt; 0.001</span></span><br><span class="line">(<span class="name">=</span> foo bar)                             <span class="comment">; =&gt; nil</span></span><br></pre></td></tr></table></figure>
<p>所以一定要确定两个浮点数是否相同，是要在一定误差内进行比较。这里给出一个函数：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defvar</span> fuzz-factor <span class="number">1.0e-6</span>)</span><br><span class="line">(<span class="name">defun</span> approx-equal (<span class="name">x</span> y)</span><br><span class="line">  (<span class="name">or</span> (<span class="name">and</span> (<span class="name">=</span> x <span class="number">0</span>) (<span class="name">=</span> y <span class="number">0</span>))</span><br><span class="line">      (<span class="name">&lt;</span> (<span class="name">/</span> (<span class="name">abs</span> (<span class="name">-</span> x y))</span><br><span class="line">            (<span class="name">max</span> (<span class="name">abs</span> x) (<span class="name">abs</span> y)))</span><br><span class="line">         fuzz-factor)))</span><br><span class="line">(<span class="name">approx-equal</span> foo bar)                  <span class="comment">; =&gt; t</span></span><br></pre></td></tr></table></figure>
<p>还有一个测试数字是否相等的函数 <code>eql</code>，这是函数不仅测试数字的值是否相等，还测试数字类型是否一致，比如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">=</span> <span class="number">1.0</span> <span class="number">1</span>)                               <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">eql</span> <span class="number">1.0</span> <span class="number">1</span>)                             <span class="comment">; =&gt; nil</span></span><br></pre></td></tr></table></figure>
<p><strong>elisp 没有 <code>+=</code>, <code>-=</code>, <code>/=</code>, <code>*=</code> 这样的命令式语言里常见符号</strong>，如果你想实现类似功能的语句，只能用赋值函数 setq 来实现了。 <strong><code>/=</code> 符号被用来作为不等于的测试了</strong>。</p>
<h4 id="数的转换"><a class="header-anchor" href="#数的转换">¶</a>数的转换</h4>
<ul>
<li>
<p>整数向浮点数转换是通过 <code>float</code> 函数进行的。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">float</span> <span class="number">1</span>)                             <span class="comment">; =&gt; 1.0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>浮点数转换成整数有这样几个函数：</p>
<ul>
<li>
<p><code>truncate</code> 转换成靠近 0 的整数：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">truncate</span> <span class="number">1.2</span>)                      <span class="comment">; =&gt; 1 (#o1, #x1)</span></span><br><span class="line">(<span class="name">truncate</span> <span class="number">1.7</span>)                      <span class="comment">; =&gt; 1 (#o1, #x1)</span></span><br><span class="line">(<span class="name">truncate</span> <span class="number">-1.2</span>)                     <span class="comment">; =&gt; 1 (#o3777777777777, #x3ffffffffff)</span></span><br><span class="line">(<span class="name">truncate</span> <span class="number">-1.7</span>)                     <span class="comment">; =&gt; 1 (#o3777777777777, #x3ffffffffff)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>floor</code> 转换成最接近的不比本身大的整数</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">floor</span> <span class="number">1.2</span>)                      <span class="comment">; =&gt; 1 (#o1, #x1)</span></span><br><span class="line">(<span class="name">floor</span> <span class="number">1.7</span>)                      <span class="comment">; =&gt; 1 (#o1, #x1)</span></span><br><span class="line">(<span class="name">floor</span> <span class="number">-1.2</span>)                     <span class="comment">; =&gt; 1 (#o3777777777776, #x3fffffffffe)</span></span><br><span class="line">(<span class="name">floor</span> <span class="number">-1.7</span>)                     <span class="comment">; =&gt; 1 (#o3777777777776, #x3fffffffff6)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>ceiling</code> 转换成最接近的不比本身小的整数</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">ceiling</span> <span class="number">1.2</span>)                      <span class="comment">; =&gt; 2 (#o2, #x2)</span></span><br><span class="line">(<span class="name">ceiling</span> <span class="number">1.7</span>)                      <span class="comment">; =&gt; 2 (#o2, #x2)</span></span><br><span class="line">(<span class="name">ceiling</span> <span class="number">-1.2</span>)                     <span class="comment">; =&gt; -1 (#o3777777777777, #x3ffffffffff)</span></span><br><span class="line">(<span class="name">ceiling</span> <span class="number">-1.7</span>)                     <span class="comment">; =&gt; -1 (#o3777777777776, #x3fffffffff6)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>round</code> 四舍五入后的整数，换句话说和它的差绝对值最小的整数</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">round</span> <span class="number">1.2</span>)                      <span class="comment">; =&gt; 1 (#o1, #x1)</span></span><br><span class="line">(<span class="name">round</span> <span class="number">1.7</span>)                      <span class="comment">; =&gt; 2 (#o2, #x2)</span></span><br><span class="line">(<span class="name">ceiling</span> <span class="number">-1.2</span>)                     <span class="comment">; =&gt; -1 (#o3777777777777, #x3ffffffffff)</span></span><br><span class="line">(<span class="name">ceiling</span> <span class="number">-1.7</span>)                     <span class="comment">; =&gt; -2 (#o3777777777776, #x3fffffffff6)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这里提一个问题，浮点数的范围是无穷大的，而整数是有范围的。如果用前面的函数转换 <code>1e20</code> 将会报错。</p>
</blockquote>
</li>
</ul>
<h4 id="数的运算"><a class="header-anchor" href="#数的运算">¶</a>数的运算</h4>
<ul>
<li>
<p>四则运算 <code>+</code> <code>-</code> <code>*</code> <code>/</code></p>
<p><strong>和 C 语言类似，如果参数都是整数，作除法时要记住 <code>(/ 5 6)</code> 是会等于 <code>0</code> 的。如果参数中有浮点数，整数会自动转换成浮点数进行运算，所以 <code>(/ 5 6.0)</code> 的值才会是 <code>5/6</code>。</strong></p>
</li>
<li>
<p><code>++</code> 和 <code>--</code></p>
<p>没有 <code>++</code> 和 <code>--</code> 操作了，类似的两个函数是 <code>1+</code> 和 <code>1-</code>。可以用 <code>setq</code> 赋值来代替 <code>++</code> 和 <code>--</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> foo <span class="number">10</span>)                           <span class="comment">; =&gt; 10</span></span><br><span class="line">(<span class="name">setq</span> foo (<span class="number">1</span>+ foo))                     <span class="comment">; =&gt; 11</span></span><br><span class="line">(<span class="name">setq</span> foo (<span class="number">1</span>- foo))                     <span class="comment">; =&gt; 10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可能有人看过有 <code>incf</code> 和 <code>decf</code> 两个实现 <code>++</code> 和 <code>--</code> 操作。这两个宏是可以用的。这两个宏是 Common Lisp 里的，emacs 有模拟的 Common Lisp 的库 <code>cl</code>。但是 RMS 认为最好不要使用这个库。但是你可以在你的 elisp 包中使用这两个宏，只要在文件头写上：</p>
</blockquote>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">eval-when-compile</span></span><br><span class="line">  (<span class="name">require</span> 'cl))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <code>abs</code> 取数的绝对值。</p>
</li>
<li>
<p>取整</p>
<p>有两个取整的函数，一个是符号 <code>%</code>，一个是函数 <code>mod</code>。这两个函数的区别是：</p>
<ol>
<li>
<p><code>%</code> 的第一个参数必须是整数，而 <code>mod</code> 的第一个参数可以是整数也可以是浮点数。</p>
</li>
<li>
<p>即使对相同的参数，两个函数也不一定有相同的返回值：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">+</span> (% DIVIDEND DIVISOR)</span><br><span class="line">   (<span class="name">*</span> (<span class="name">/</span> DIVIDEND DIVISOR) DIVISOR))</span><br></pre></td></tr></table></figure>
<p>和 <code>DIVIDEND</code> 是相同的。而：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">+</span> (<span class="name">mod</span> DIVIDEND DIVISOR)</span><br><span class="line">   (<span class="name">*</span> (<span class="name">floor</span> DIVIDEND DIVISOR) DIVISOR))</span><br></pre></td></tr></table></figure>
<p>和 <code>DIVIDEND</code> 是相同的。</p>
<blockquote>
<p>注：<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Arithmetic-Operations.html" target="_blank" rel="noopener">原文</a></p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>三角函数</p>
<ul>
<li><code>sin</code></li>
<li><code>cos</code></li>
<li><code>tan</code></li>
<li><code>asin</code></li>
<li><code>acos</code></li>
<li><code>atan</code></li>
</ul>
</li>
<li>
<p>开方</p>
<p><code>sqrt</code></p>
</li>
<li>
<p>指数和对数</p>
<ul>
<li><code>exp</code>：以 e 为底指数运算。</li>
<li><code>expt</code>：指定底数指数运算。</li>
<li><code>log</code>：对数运算，<strong>默认底数是 e</strong>。</li>
<li><code>logb</code>：以 2 为底的对数运算，但<strong>返回的是一个整数</strong>。用于计算数的位。</li>
</ul>
</li>
<li>
<p>随机数</p>
<p><code>random</code> 可以产生随机数。可以用 <code>(random t)</code> 来产生一个新种子。虽然 emacs 每次启动后调用 <code>random</code> 总是产生相同的随机数，但是运行过程中，你不知道调用了多少次，所以使用时还是不需要再调用一次 <code>(random t)</code> 来产生新的种子。</p>
</li>
<li>
<p>整数位运算</p>
<p>位运算在 emacs lisp 中仅适用于整数。</p>
<ul>
<li>
<p><code>(lsh integer1 count)</code>：逻辑位移。如果 <code>count</code> 为正数，则将 <code>integer1</code> 左移 <code>count</code> 位；如果 <code>count</code> 为负数，则将 <code>integer1</code> 右移 <code>-count</code> 位，空位补 <code>0</code>，并且，<code>count</code> 为负数时，<code>lsh</code> 的补 <code>0</code> 方式是在<strong>最高有效位依次插 <code>0</code></strong>。</p>
<p>例（仅考虑低8位，其它位为 0）：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">lsh</span> <span class="number">5</span> <span class="number">1</span>)  <span class="comment">;; 十进制 5 逻辑左移 1 位变为 10；二进制 00000101 变为 00001010</span></span><br><span class="line">(<span class="name">lsh</span> <span class="number">3</span> <span class="number">2</span>)  <span class="comment">;; 十进制 3 逻辑左移 2 位变为 12；二进制 00000011 变为 00001100</span></span><br><span class="line">(<span class="name">lsh</span> <span class="number">6</span> <span class="number">-1</span>)  <span class="comment">;; 十进制 6 逻辑右移 1 位变为 3；二进制 00000110 变为 00000011</span></span><br></pre></td></tr></table></figure>
<p>与所有 emacs lisp 算术运算函数一样，位移运算不检查溢出，所以左移操作可能会忽略符号位（significant bits）并改变数的正负。例如在 28 位计算机上将 <code>134217727</code> 左移 1 位将会得到 <code>-2</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">lsh</span> <span class="number">134217727</span> <span class="number">1</span>)  <span class="comment">;; 十进制 134217727 逻辑左移 1 位变为 -2；二进制 0111  1111 1111  1111 1111  1111 1111 变为 1111  1111 1111  1111 1111  1111 1110</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>(ash integer1 count)</code>：算术位移。除非 <code>integer1</code> 和 <code>count</code> 全是负数，否则 <code>ash</code> 和 <code>lsh</code> 返回的结果是一样的。当 <code>integer1</code> 和 <code>count</code> 全为负时，<code>lsh</code> 会在左侧补 <code>0</code>，而 <code>ash</code> 会在左侧补 <code>1</code>。</p>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">ash</span> <span class="number">-6</span> <span class="number">-1</span>) <span class="comment">;; 十进制 -6 算术右移 1 位变为 -3；二进制1111  1111 1111  1111 1111  1111 1010 变为 1111  1111 1111  1111 1111  1111 1101</span></span><br><span class="line">(<span class="name">lsh</span> <span class="number">-6</span> <span class="number">-1</span>) <span class="comment">;; 十进制 -6 逻辑右移 1 位变为 134217725；二进制1111  1111 1111  1111 1111  1111 1010 变为 0111  1111 1111  1111 1111  1111 1101</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>logand</code>、<code>logior</code>、<code>logexor</code> 和 <code>lognot</code> 参考<a href="http://ftp.gnu.org/old-gnu/Manuals/elisp-manual-21-2.8/html_node/elisp_65.html" target="_blank" rel="noopener">这里</a>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="字符和字符串"><a class="header-anchor" href="#字符和字符串">¶</a>字符和字符串</h3>
<p>在 emacs 里<strong>字符串是有序的字符数组</strong>。和 C 语言的字符串数组不同，emacs 的字符串可以容纳任何字符，包括 <code>\0</code>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> foo <span class="string">"abc\000abc"</span>)                 <span class="comment">; =&gt; "abc^@abc"</span></span><br></pre></td></tr></table></figure>
<h4 id="字符的读入"><a class="header-anchor" href="#字符的读入">¶</a>字符的读入</h4>
<p>构成字符串的字符其实就是一个整数。一个字符 <code>'A'</code> 就是一个整数 <code>65</code>。但是目前字符串中的字符被限制在 0-524287 之间。字符的读入语法是在字符前加上一个问号，比如 <code>?A</code> 代表字符 <code>'A'</code>。<br>
对于标点来说，也可以用同样的语法，但是最好在前面加上转义字符 <code>\</code>，因为有些标点会有岐义，比如 <code>?\(</code>。<code>\</code> 必须用 <code>?\\</code> 表示。控制字符，退格、制表符，换行符，垂直制表符，换页符，空格，回车，删除和 escape 分别表示为 <code>?\a</code>, <code>?\b</code>, <code>?\t</code>, <code>?\n</code>, <code>?\v</code>, <code>?\f</code>, <code>?\s</code>, <code>?\r</code>, <code>?\d</code>, 和 <code>?\e</code>。**对于没有特殊意义的字符，加上转义字符 <code>\</code> 是没有副作用的，比如 <code>?\+</code> 和 <code>?+</code> 是完全一样的。**所以标点还是都用转义字符来表示吧。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">?\a =&gt; 7                 ; control-g, `C-g'</span><br><span class="line">?\b =&gt; 8                 ; backspace, &lt;BS&gt;, `C-h'</span><br><span class="line">?\t =&gt; 9                 ; tab, &lt;TAB&gt;, `C-i'</span><br><span class="line">?\n =&gt; 10                ; newline, `C-j'</span><br><span class="line">?\v =&gt; 11                ; vertical tab, `C-k'</span><br><span class="line">?\f =&gt; 12                ; formfeed character, `C-l'</span><br><span class="line">?\r =&gt; 13                ; carriage return, &lt;RET&gt;, `C-m'</span><br><span class="line">?\e =&gt; 27                ; escape character, &lt;ESC&gt;, `C-['</span><br><span class="line">?\s =&gt; 32                ; space character, &lt;SPC&gt;</span><br><span class="line">?\\ =&gt; 92                ; backslash character, `\'</span><br><span class="line">?\d =&gt; 127               ; delete character, &lt;DEL&gt;</span><br></pre></td></tr></table></figure>
<p>控制字符可以有多种表示方式，比如 <code>C-i</code>，这些都是对的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?\^I  ?\^i  ?\C-I  ?\C-i</span><br></pre></td></tr></table></figure>
<p>它们都对应数字 <code>9</code>。<br>
meta 字符是用 修饰键（通常就是 Alt 键）输入的字符。之所以称为修饰键，是因为这样输入的字符就是在其修饰字符的第 27 位由 <code>0</code> 变成 <code>1</code> 而成，也就是如下操作：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">logior</span> (<span class="name">lsh</span> <span class="number">1</span> <span class="number">27</span>) ?A)                  <span class="comment">; =&gt; 134217793</span></span><br><span class="line">?\M-A                                   ; =&gt; 134217793</span><br></pre></td></tr></table></figure>
<p>你可以用 <code>\M-</code> 代表 meta 键，加上修饰的字符就是新生成的字符。比如：<code>?\M-A</code>, <code>?\M-\C-b</code>。 后面这个也可以写成 <code>?\C-\M-b</code>。</p>
<p>如果你还记得前面说过字符串里的字符不能超过 524287 的话，这就可以看出字符串是不能放下一个 meta 字符的。所以按键序列在这时只能用 vector 来储存。</p>
<p>其它的修饰键也是类似的。emacs 用 <code>2**25</code> 位来表示 shift 键，<code>2**24</code> 对应 hyper，<code>2**23</code> 对应 super，<code>2**22</code> 对应 alt。</p>
<h4 id="测试函数-v2"><a class="header-anchor" href="#测试函数-v2">¶</a>测试函数</h4>
<ul>
<li>字符串测试使用 <code>stringp</code>，没有 <code>charp</code>，因为字符就是整数。</li>
<li><code>string-or-null-p</code> 当对象是一个字符或 <code>nil</code> 时返回 <code>t</code>。</li>
<li><code>char-or-string-p</code> 测试是否是字符串或者字符类型。</li>
</ul>
<p>比较头疼的是 emacs 没有测试字符串是否为空的函数。这是我用的这个测试函数，使用前要测试字符串是否为 <code>nil</code>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> string-emptyp (<span class="name">str</span>)</span><br><span class="line">  (<span class="name">not</span> (<span class="name">string&lt;</span> <span class="string">""</span> str)))</span><br></pre></td></tr></table></figure>
<h4 id="构造函数"><a class="header-anchor" href="#构造函数">¶</a>构造函数</h4>
<ul>
<li>
<p>产生一个字符串可以用 <code>make-string</code>。这样生成的字符串包含的字符都是一样的。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">make-string</span> <span class="number">5</span> ?x)                      <span class="comment">; =&gt; "xxxxx"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>要生成不同的字符串可以用 <code>string</code> 函数。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">string</span> ?a ?b ?c)                       <span class="comment">; =&gt; "abc"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在已有的字符串生成新的字符串的方法有 <code>substring</code>, <code>concat</code>。</p>
<ul>
<li>
<p><code>substring</code> 的后两个参数是起点和终点的位置。如果终点越界或者终点比起点小都会产生一个错误。这个在使用 <code>substring</code> 时要特别小心。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">substring</span> <span class="string">"0123456789"</span> <span class="number">3</span>)              <span class="comment">; =&gt; "3456789"</span></span><br><span class="line">(<span class="name">substring</span> <span class="string">"0123456789"</span> <span class="number">3</span> <span class="number">5</span>)            <span class="comment">; =&gt; "34"</span></span><br><span class="line">(<span class="name">substring</span> <span class="string">"0123456789"</span> <span class="number">-3</span> <span class="number">-1</span>)          <span class="comment">; =&gt; "78"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>concat</code> 函数相对简单，就是把几个字符串连接起来：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">concat</span> <span class="string">"foo"</span> <span class="string">"bar"</span>)                    <span class="comment">; =&gt; "foobar"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="字符串比较"><a class="header-anchor" href="#字符串比较">¶</a>字符串比较</h4>
<ul>
<li>
<p><code>char-equal</code> 可以比较两个字符是否相等。与整数比较不同，这个函数还考虑了大小写。<strong>如果 <code>case-fold-search</code> 变量是 <code>t</code> 时，这个函数的字符比较是忽略大小写的。</strong></p>
<blockquote>
<p>编程时要小心，因为通常 <code>case-fold-search</code> 都是 <code>t</code>，这样如果要考虑字符的大小写时就不能用 <code>char-equal</code> 函数了。</p>
</blockquote>
</li>
<li>
<p>字符串比较使用 <code>string=</code>，<code>string-equal</code> 是一个别名。</p>
</li>
<li>
<p><code>string&lt;</code> 是按字典序比较两个字符串，<code>string-less</code> 是它的别名。**空字符串小于所有字符串，除了空字符串。**前面 <code>string-emptyp</code> 就是用这个特性。当然直接用 <code>length</code> 检测字符串长度应该也可以，还可以省去检测字符串是否为空。</p>
<blockquote>
<p>没有 <code>string&gt;</code> 函数。</p>
</blockquote>
</li>
</ul>
<h4 id="转换函数"><a class="header-anchor" href="#转换函数">¶</a>转换函数</h4>
<ul>
<li>
<p>字符转换成字符串可以用 <code>char-to-string</code> 函数。</p>
</li>
<li>
<p>字符串转换成字符可以用 <code>string-to-char</code>。当然只是返回字符串的第一个字符。</p>
</li>
<li>
<p>数字转换成字符串可以用 <code>number-to-string </code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">number-to-string</span> <span class="number">256</span>)                  <span class="comment">; =&gt; "256"</span></span><br></pre></td></tr></table></figure>
<p><code>number-to-string</code> 只能转换成十进制的数字。如果要输出八进制或者十六进制，可以用 <code>format</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="string">"%#o"</span> <span class="number">256</span>)                      <span class="comment">; =&gt; "0400"</span></span><br><span class="line">(<span class="name">format</span> <span class="string">"%#x"</span> <span class="number">256</span>)                      <span class="comment">; =&gt; "0x100"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>字符串转换成数字可以用 <code>string-to-number</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">string-to-number</span> <span class="string">"256"</span>)                <span class="comment">; =&gt; 256</span></span><br></pre></td></tr></table></figure>
<p><code>string-to-number</code> 可以设置字符串的进制，可以从 <code>2</code> 到 <code>16</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">string-to-number</span> <span class="string">"111000"</span> <span class="number">2</span>)                <span class="comment">; =&gt; 56</span></span><br><span class="line">(<span class="name">string-to-number</span> <span class="string">"256"</span> <span class="number">8</span>)                   <span class="comment">; =&gt; 174</span></span><br><span class="line">(<span class="name">string-to-number</span> <span class="string">"256"</span> <span class="number">16</span>)                  <span class="comment">; =&gt; 598</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>concat</code> 可以把一个字符构成的列表或者向量转换成字符串：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">concat</span> '(?a ?b ?c ?d ?e))              <span class="comment">; =&gt; "abcde"</span></span><br><span class="line">(<span class="name">concat</span> [?a ?b ?c ?d ?e])               <span class="comment">; =&gt; "abcde"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>vconcat</code> 可以把一个字符串转换成一个向量：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">vconcat</span> <span class="string">"abdef"</span>)                       <span class="comment">; =&gt; [97 98 100 101 102]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>append</code> 可以把一个字符串转换成一个列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">append</span> <span class="string">"abcdef"</span> <span class="literal">nil</span>)                   <span class="comment">; =&gt; (97 98 99 100 101 102)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>downcase</code> 可以把一个字符串或者字符转换成小写：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">downcase</span> <span class="string">"The cat in the hat"</span>)         <span class="comment">; =&gt; "the cat in the hat"</span></span><br><span class="line">(<span class="name">downcase</span> ?X)                           <span class="comment">; =&gt; 120</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>upcase</code> 可以把一个字符串或者字符转换成大写：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">upcase</span> <span class="string">"The cat in the hat"</span>)           <span class="comment">; =&gt; "THE CAT IN THE HAT"</span></span><br><span class="line">(<span class="name">upcase</span> ?x)                             <span class="comment">; =&gt; 88</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>capitalize</code> 可以使字符串中单词的第一个字符大写，其它字符小写：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">capitalize</span> <span class="string">"The CAT in tHe hat"</span>)       <span class="comment">; =&gt; "The Cat In The Hat"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code> upcase-initials</code> 只使第一个单词的第一个字符大写，其它字符小写：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">upcase-initials</span> <span class="string">"The CAT in the hAt"</span>)  <span class="comment">; =&gt; "The CAT In The HAt"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="格式化字符串"><a class="header-anchor" href="#格式化字符串">¶</a>格式化字符串</h4>
<p><code>format</code> 类似于 C 语言里的 <code>printf</code> 可以实现对象的字符串化。数字的格式化和 <code>printf</code> 的参数差不多。</p>
<blockquote>
<p>值得一提的是 <code>%S</code> 这个格式化形式，它可以把对象的输出形式转换成字符串，这在调试时是很有用的。</p>
</blockquote>
<h4 id="查找和替换"><a class="header-anchor" href="#查找和替换">¶</a>查找和替换</h4>
<h5 id="查找"><a class="header-anchor" href="#查找">¶</a>查找</h5>
<p>字符串查找的核心函数是 <code>string-match</code>。这个函数可以从指定的位置对字符串进行正则表达式匹配，如果匹配成功，则返回匹配的起点，如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">string-match</span> <span class="string">"34"</span> <span class="string">"01234567890123456789"</span>)    <span class="comment">; =&gt; 3</span></span><br><span class="line">(<span class="name">string-match</span> <span class="string">"34"</span> <span class="string">"01234567890123456789"</span> <span class="number">10</span>) <span class="comment">; =&gt; 13</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 <code>string-match</code> 的参数是一个正则表达式。emacs 好象没有内建的查找子串的函数。如果你想把 <code>string-match</code> 作为一个查找子串的函数，可以先用 <code>regexp-quote</code> 函数先处理一下子串。比如：</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">string-match</span> <span class="string">"2*"</span> <span class="string">"232*3=696"</span>)                <span class="comment">; =&gt; 0</span></span><br><span class="line">(<span class="name">string-match</span> (<span class="name">regexp-quote</span> <span class="string">"2*"</span>) <span class="string">"232*3=696"</span>) <span class="comment">; =&gt; 2</span></span><br></pre></td></tr></table></figure>
<p><code>string-match</code> 在查找的同时，还会记录下每个要捕捉的字符串的位置。这个位置可以在匹配后用 <code>match-data</code>、<code>match-beginning</code> 和 <code>match-end</code> 等函数来获得。先看一下例子：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">progn</span></span><br><span class="line">  (<span class="name">string-match</span> <span class="string">"3\\(4\\)"</span> <span class="string">"01234567890123456789"</span>)</span><br><span class="line">  (<span class="name">match-data</span>))                         <span class="comment">; =&gt; (3 5 4 5)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&quot;3\\(4\\)&quot;</code> 并未在正则表达式中转义括号。参照本文《<a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a>》一章。</p>
</blockquote>
<p>正则表达式捕捉的字符串按括号的顺序对应一个序号，整个模式对应序号 <code>0</code>，第一个括号对应序号 <code>1</code>，第二个括号对应序号 <code>2</code>，以此类推。所以 <code>&quot;3\(4\)&quot;</code> 这个正则表达式中有序号 <code>0</code> 和 <code>1</code>，最后 <code>match-data</code> 返回的一系列数字对应的分别是要捕捉字符串的起点和终点位置，也就是说子串 <code>&quot;34&quot;</code> 起点从位置 <code>3</code> 开始，到位置 <code>5</code> 结束，而捕捉的字符串 <code>&quot;4&quot;</code> 的起点是从 <code>4</code> 开始，到 <code>5</code> 结束。这些位置可以用 <code>match-beginning</code> 和 <code>match-end</code> 函数用对应的序号得到。</p>
<blockquote>
<p>注意：起点位置是捕捉字符串的第一个字符的位置，而终点位置不是捕捉的字符串最后一个字符的位置，而是下一个字符的位置。这个性质对于循环是很方便的。比如要查找上面这个字符串中所有 <code>34</code> 出现的位置：</p>
</blockquote>
<blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">start</span> <span class="number">0</span>))</span><br><span class="line">  (<span class="name">while</span> (<span class="name">string-match</span> <span class="string">"34"</span> <span class="string">"01234567890123456789"</span> start)</span><br><span class="line">    (<span class="name">princ</span> (<span class="name">format</span> <span class="string">"find at %d\n"</span> (<span class="name">match-beginning</span> <span class="number">0</span>)))</span><br><span class="line">    (<span class="name">setq</span> start (<span class="name">match-end</span> <span class="number">0</span>))))</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="替换"><a class="header-anchor" href="#替换">¶</a>替换</h5>
<p>替换使用的函数是 <code>replace-match</code>。这个函数既可以用于字符串的替换，也可以用于缓冲区的文本替换。对于字符串的替换，<code>replace-match</code> 只是按给定的序号把字符串中的那一部分用提供的字符串替换了而已：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">str</span> <span class="string">"01234567890123456789"</span>))</span><br><span class="line">  (<span class="name">string-match</span> <span class="string">"34"</span> str)</span><br><span class="line">  (<span class="name">princ</span> (<span class="name">replace-match</span> <span class="string">"x"</span> <span class="literal">nil</span> <span class="literal">nil</span> str <span class="number">0</span>))</span><br><span class="line">  (<span class="name">princ</span> <span class="string">"\n"</span>)</span><br><span class="line">  (<span class="name">princ</span> str))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看出 <code>replace-match</code> 返回的字符串是替换后的新字符串，原字符串被没有改变。</p>
</blockquote>
<p>如果你想挑战一下，想想怎样把上面这个字符串中所有的 <code>34</code> 都替换掉？如果想就使用同一个字符串来存储，可能对于固定的字符串，这个还容易一些，如果不是的话，就要花一些脑筋了，<strong>因为替换之后，新的字符串下一个搜索起点的位置就不能用 <code>(match-end 0)</code> 给出来的位置了，而是要扣除替换的字符串和被替换的字符串长度的差值。</strong></p>
<p>emacs 对字符串的替换有一个函数 <code>replace-regexp-in-string</code>。这个函数的实现方法是把每次匹配部分之前的子串收集起来，最后再把所有字符串连接起来。</p>
<p>单字符的替换有 <code>subst-char-in-string</code> 函数。但是 emacs 没有类似 perl函数或者程序 tr 那样进行字符替换的函数。只能自己建表进行循环操作了。</p>
<h3 id="cons-cell-和列表"><a class="header-anchor" href="#cons-cell-和列表">¶</a>cons cell 和列表</h3>
<h4 id="cons-cell"><a class="header-anchor" href="#cons-cell">¶</a>cons cell</h4>
<p>cons cell 其实非常简单的，就是两个有顺序的元素。<br>
cons cell 的读入语法是用 . 分开两个部分，比如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">'(<span class="number">1</span> . <span class="number">2</span>)                                <span class="comment">; =&gt; (1 . 2)</span></span><br><span class="line">'(?a . <span class="number">1</span>)                               <span class="comment">; =&gt; (97 . 1)</span></span><br><span class="line">'(<span class="number">1</span> . <span class="string">"a"</span>)                              <span class="comment">; =&gt; (1 . "a")</span></span><br><span class="line">'(<span class="number">1</span> . nil)                              <span class="comment">; =&gt; (1)</span></span><br><span class="line">'(nil . nil)                            <span class="comment">; =&gt; (nil)</span></span><br></pre></td></tr></table></figure>
<p>上述代码中关于 <code>'</code> 的解释：</p>
<p><code>eval-last-sexp</code> 其实包含了两个步骤，一是读入前一个 S-表达式，二是对读入的 S-表达式求值。这样如果读入的 S-表达式是一个 cons cell 的话，求值时会把这个 cons cell 的第一个元素作为一个函数来调用。而事实上，前面这些例子的第一个元素都不是一个函数，这样就会产生一个错误 invalid-function。之所以前面没有遇到这个问题，<strong>那是因为前面数字和字符串是一类特殊的 S-表达式，它们求值后和求值前是不变，称为自求值表达式（self-evaluating form）</strong>。’ 号其实是一个特殊的函数 <code>quote</code>，它的作用是将它的参数返回而不作求值。<code>'(1 . 2)</code> 等价于 <code>(quote (1 . 2))</code>。为了证明 cons cell 的读入语法确实就是它的输出形式。</p>
<h4 id="列表"><a class="header-anchor" href="#列表">¶</a>列表</h4>
<p>列表包括了 cons cell。但是列表中有一个特殊的元素──空表 <code>nil</code>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">nil</span>                                     <span class="comment">; =&gt; nil</span></span><br><span class="line">'()                                     <span class="comment">; =&gt; nil</span></span><br></pre></td></tr></table></figure>
<p>空表不是一个 cons cell，因为它没有 CAR 和 CDR 两个部分，事实上空表里没有任何内容。<strong>但是为了编程的方便，可以认为 <code>nil</code> 的 CAR 和 CDR 都是 <code>nil</code></strong>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">car</span> <span class="literal">nil</span>)                               <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">cdr</span> <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>按列表<strong>最后一个 cons cell</strong> 的 CDR 部分的类型分，可以把列表分为三类：</p>
<ul>
<li>如果它是 <code>nil</code> 的话，这个列表也称为**“真列表”(true list)**。</li>
<li>如果既不是 <code>nil</code> 也不是一个 cons cell，则这个列表称为**“点列表”(dotted list)。**</li>
<li>还有一种可能，它指向列表中之前的一个 cons cell，则称为<strong>环形列表(circular list)。</strong></li>
</ul>
<p>这里分别给出一个例子：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">'(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)                                  <span class="comment">; =&gt; (1 2 3)</span></span><br><span class="line">'(<span class="number">1</span> <span class="number">2</span> . <span class="number">3</span>)                                <span class="comment">; =&gt; (1 2 . 3)</span></span><br><span class="line">'(<span class="number">1</span> . #1=(<span class="number">2</span> <span class="number">3</span> . #1#))                     <span class="comment">; =&gt; (1 2 3 . #1)</span></span><br></pre></td></tr></table></figure>
<p>如果把真列表最后一个 cons cell 的 <code>nil</code> 省略不写，也就是 <code>(1 . nil)</code> 简写成 <code>(1)</code>，把 <code>( obj1 . ( obj2 . list))</code> 简写成 <code>(obj1 obj2 . list)</code>，那么列表最后可以写成一个用括号括起的元素列表：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">'(<span class="number">1</span> . (<span class="number">2</span> . (<span class="number">3</span> . <span class="literal">nil</span>)))                  <span class="comment">; =&gt; (1 2 3)</span></span><br></pre></td></tr></table></figure>
<h4 id="测试函数-v3"><a class="header-anchor" href="#测试函数-v3">¶</a>测试函数</h4>
<ul>
<li>
<p>测试一个对象是否是 cons cell 用 <code>consp</code>，是否是列表用 <code>listp</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">consp</span> '(<span class="number">1</span> . <span class="number">2</span>))                        <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">consp</span> '(<span class="number">1</span> . (<span class="number">2</span> . <span class="literal">nil</span>)))                <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">consp</span> <span class="literal">nil</span>)                             <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">listp</span> '(<span class="number">1</span> . <span class="number">2</span>))                        <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">listp</span> '(<span class="number">1</span> . (<span class="number">2</span> . <span class="literal">nil</span>)))                <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">listp</span> <span class="literal">nil</span>)                             <span class="comment">; =&gt; t</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>测试一个对象是否是 <code>nil</code> 用 <code>null</code> 函数。只有当对象是空表时，<code>null</code> 才返回空值。</p>
</li>
</ul>
<h4 id="span-id-constructors-in-list-构造函数-span"><a class="header-anchor" href="#span-id-constructors-in-list-构造函数-span">¶</a><span id="constructors_in_list">构造函数</span></h4>
<ul>
<li>
<p>生成一个 cons cell 可以用 <code>cons</code> 函数。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cons</span> <span class="number">1</span> <span class="number">2</span>)                              <span class="comment">; =&gt; (1 . 2)</span></span><br><span class="line">(<span class="name">cons</span> <span class="number">1</span> '())                            <span class="comment">; =&gt; (1)</span></span><br></pre></td></tr></table></figure>
<p>也可以使用在列表前面增加元素的方法。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> foo '(a b))                       <span class="comment">; =&gt; (a b)</span></span><br><span class="line">(<span class="name">cons</span> 'x foo)                           <span class="comment">; =&gt; (x a b)</span></span><br></pre></td></tr></table></figure>
<p><strong>值得注意的是前面这个例子的 <code>foo</code> 值并没有改变。</strong><br>
事实上有一个宏 <code>push</code> 可以加入元素的同时改变列表的值：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">push</span> 'x foo)                           <span class="comment">; =&gt; (x a b)</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; (x a b)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>生成一个列表的函数是 <code>list</code>。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)                            <span class="comment">; =&gt; (1 2 3)</span></span><br></pre></td></tr></table></figure>
<p>可能这时你有一个疑惑，前面产生一个列表，我常用 <code>quote</code>（也就是 <code>'</code> 符号）这个函数，它和这个 <code>cons</code> 和 <code>list</code> 函数有什么区别呢？其实区别是很明显的，<strong><code>quote</code> 是把参数直接返回不进行求值，而 <code>list</code> 和 <code>cons</code> 是对参数求值后再生成一个列表或者 cons cell</strong>。看下面这个例子：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">'((+ <span class="number">1</span> <span class="number">2</span>) <span class="number">3</span>)                            <span class="comment">; =&gt; ((+ 1 2) 3)</span></span><br><span class="line">(<span class="name">list</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>) <span class="number">3</span>)                        <span class="comment">; =&gt; (3 3)</span></span><br></pre></td></tr></table></figure>
<p>前一个生成的列表的 CAR 部分是 <code>(+ 1 2)</code> 这个列表，而后一个是先对 <code>(+ 1 2)</code> 求值得到 <code>3</code> 后再生成列表。</p>
</li>
</ul>
<blockquote>
<p>思考题<br>
怎样用 <code>list</code> 函数构造一个 <code>(a b c)</code> 这样的列表呢？<br>
答：<code>(list 'a 'b 'c)</code></p>
</blockquote>
<ul>
<li>
<p><strong>前面提到在列表前端增加元素的方法是用 <code>cons</code></strong>，在列表后端增加元素的函数是用 <code>append</code>。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">append</span> '(a b) '(c))                    <span class="comment">; =&gt; (a b c)</span></span><br><span class="line">(<span class="name">append</span> '(a b) '(c) '(d))               <span class="comment">; =&gt; (a b c d)</span></span><br></pre></td></tr></table></figure>
<p><code>append</code> 的功能可以认为它是把第一个参数最后一个列表的 <code>nil</code> 换成第二个参数。<br>
一般来说 <code>append</code> 的参数都要是列表，但是最后一个参数可以不是一个列表，这也不违背前面说的，因为 cons cell 的 CDR 部分本来就可以是任何对象：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">append</span> '(a b) 'c)                      <span class="comment">; =&gt; (a b . c)</span></span><br></pre></td></tr></table></figure>
<p><strong>但这样得到的结果就不再是一个真列表了，如果再进行 <code>append</code> 操作就会产生一个错误。</strong></p>
<p><code>append</code> 的参数不限于列表，还可以是字符串或者向量。前面字符串里已经提到可以把一个字符串转换成一个字符列表，同样可能把向量转换成一个列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">append</span> [a b] <span class="string">"cd"</span> <span class="literal">nil</span>)                 <span class="comment">; =&gt; (a b 99 100)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：前面最后一个参数 <code>nil</code> 是必要的，不然你可以想象得到的结果是什么。</p>
</blockquote>
</li>
</ul>
<h4 id="把列表当数组用"><a class="header-anchor" href="#把列表当数组用">¶</a>把列表当数组用</h4>
<h5 id="访问"><a class="header-anchor" href="#访问">¶</a>访问</h5>
<ul>
<li>
<p>可以用 <code>nth</code> 函数来访问第 <code>n</code> 个元素：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">nth</span> <span class="number">3</span> '(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))                  <span class="comment">; =&gt; 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>取得序列里第 <code>n</code> 个元素也可以用 <code>elt</code> 函数。但是我建议，对于已知类型的序列，还是用对应的函数比较好。也就是说，如果是列表就用 <code>nth</code>，如果是数组就用 <code>aref</code>。这样一方面是省去 <code>elt</code> 内部的判断，另一方面读代码时能很清楚知道序列的类型。</p>
</blockquote>
</li>
<li>
<p><code>nthcdr</code> 函数返回第 <code>n</code> 个元素后的列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">nthcdr</span> <span class="number">2</span> '(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))               <span class="comment">; =&gt; (2 3 4 5)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>last</code> 函数返回倒数 <code>n</code> 个长度的列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">last</span> '(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>) <span class="number">2</span>)                 <span class="comment">; =&gt; (4 5)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>butlast</code> 返回的除了倒数 <code>n</code> 个元素的列表。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">butlast</span> '(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>) <span class="number">2</span>)              <span class="comment">; =&gt; (0 1 2 3)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>链表这种数据结构是不适合随机访问的，代价比较高，如果你的代码中频繁使用这样的函数或者对一个很长的列表使用这样的函数，就应该考虑是不是应该用数组来实现。</p>
</blockquote>
<h5 id="修改"><a class="header-anchor" href="#修改">¶</a>修改</h5>
<ul>
<li>
<p><code>setcar</code> 和 <code>setcdr</code> 可以修改一个 cons cell 的 CAR 部分和 CDR 部分。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> foo '(a b c))                     <span class="comment">; =&gt; (a b c)</span></span><br><span class="line">(<span class="name">setcar</span> foo 'x)                         <span class="comment">; =&gt; x</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; (x b c)</span></span><br><span class="line">(<span class="name">setcdr</span> foo '(y z))                     <span class="comment">; =&gt; (y z)</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; (x y z)</span></span><br></pre></td></tr></table></figure>
<p>要像数组那样直接修改列表。使用 <code>setcar</code> 和 <code>nthcdr</code> 的组合就可以实现了：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> foo '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))                     <span class="comment">; =&gt; (1 2 3)</span></span><br><span class="line">(<span class="name">setcar</span> foo 'a)                         <span class="comment">; =&gt; a</span></span><br><span class="line">(<span class="name">setcar</span> (<span class="name">cdr</span> foo) 'b)                   <span class="comment">; =&gt; b</span></span><br><span class="line">(<span class="name">setcar</span> (<span class="name">nthcdr</span> <span class="number">2</span> foo) 'c)              <span class="comment">; =&gt; c</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; (a b c)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="把列表当堆栈用"><a class="header-anchor" href="#把列表当堆栈用">¶</a>把列表当堆栈用</h4>
<p>前面已经提到过可以用 <code>push</code> 向列表头端增加元素，在结合 <code>pop</code> 函数，列表就可以做为一个堆栈了：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> foo <span class="literal">nil</span>)                          <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">push</span> 'a foo)                           <span class="comment">; =&gt; (a)</span></span><br><span class="line">(<span class="name">push</span> 'b foo)                           <span class="comment">; =&gt; (b a)</span></span><br><span class="line">(<span class="name">pop</span> foo)                               <span class="comment">; =&gt; b</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; (a)</span></span><br></pre></td></tr></table></figure>
<h4 id="重排列表"><a class="header-anchor" href="#重排列表">¶</a>重排列表</h4>
<ul>
<li>
<p>列表反序 <code>reverse</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> foo '(a b c))                     <span class="comment">; =&gt; (a b c)</span></span><br><span class="line">(<span class="name">reverse</span> foo)                           <span class="comment">; =&gt; (c b a)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：使用 <code>reverse</code> 后 <code>foo</code> 值并没有改变。<code>nreverse</code> 和 <code>reverse</code> 差别就在于它是一个有破坏性的函数，也就是说它会修改它的参数：</p>
</blockquote>
<blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">nreverse</span> foo)                          <span class="comment">; =&gt; (c b a)</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; (a)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>elisp 还有一些是具有破坏性的函数。最常用的就是 <code>sort</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> foo '(<span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">5</span>))                 <span class="comment">; =&gt; (3 2 4 1 5)</span></span><br><span class="line">(<span class="name">sort</span> foo '&lt;)                           <span class="comment">; =&gt; (1 2 3 4 5)</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; (3 4 5)</span></span><br></pre></td></tr></table></figure>
<p>如果我既要保留原列表，又要进行 <code>sort</code> 操作怎么办呢？可以用 <code>copy-sequence</code> 函数。这个函数只对列表进行复制，<strong>返回的列表的元素还是原列表里的元素，不会拷贝列表的元素</strong>。</p>
<blockquote>
<p><code>nconc</code> 和 <code>append</code> 功能相似，但是它会修改除最后一个参数以外的所有的参数，<code>nbutlast</code> 和 <code>butlast</code> 功能相似，也会修改参数。这些函数都是在效率优先时才使用。总而言之，以 <code>n</code> 开头的函数都要慎用。<br>
<code>copy-sequence</code> 不能用于点列表和环形列表。对于点列表可以用 <code>copy-tree</code> 函数。环形列表就没有办法复制了。 好在这样的数据结构很少用到。</p>
</blockquote>
</li>
</ul>
<h4 id="把列表当集合用"><a class="header-anchor" href="#把列表当集合用">¶</a>把列表当集合用</h4>
<p>列表可以作为无序的集合。</p>
<ul>
<li>
<p>合并集合用 <code>append</code> 函数。</p>
</li>
<li>
<p>去除重复的 <code>equal</code> 元素用 <code>delete-dups</code>。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">delete-dups</span> (<span class="name">list</span> <span class="string">"foo"</span> <span class="string">"bar"</span> <span class="literal">nil</span> <span class="string">"moo"</span> <span class="string">"bar"</span> <span class="string">"moo"</span> <span class="literal">nil</span> <span class="string">"affe"</span>)) <span class="comment">; =&gt; ("foo" "bar" nil "moo" "affe")</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查找一个元素是否在列表中，返回以此元素开头的列表，如果找不到，则返回 <code>nil</code></p>
<ul>
<li>如果测试函数是用 <code>eq</code>，就用 <code>memq</code>；</li>
<li>如果测试用 <code>equal</code>，可以用 <code>member</code>。</li>
</ul>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">member</span> 'foo '(foo bar quux))           <span class="comment">; =&gt; non-nil</span></span><br><span class="line">(<span class="name">member</span> <span class="string">"foo"</span> '(<span class="string">"foo"</span> <span class="string">"bar"</span> <span class="string">"quux"</span>))    <span class="comment">; =&gt; non-nil</span></span><br><span class="line">(<span class="name">member</span> <span class="number">111</span> '(<span class="number">111</span> <span class="number">222</span> <span class="number">333</span>))             <span class="comment">; =&gt; non-nil</span></span><br><span class="line"></span><br><span class="line">(<span class="name">memq</span>   'foo '(foo bar quux))           <span class="comment">; =&gt; non-nil</span></span><br><span class="line">(<span class="name">memq</span>   <span class="string">"foo"</span> '(<span class="string">"foo"</span> <span class="string">"bar"</span> <span class="string">"quux"</span>))    <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">memq</span>   <span class="number">111</span> '(<span class="number">111</span> <span class="number">222</span> <span class="number">333</span>))             <span class="comment">; =&gt; non-nil</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除列表中的指定的元素，删除列表中所有的该元素</p>
<ul>
<li>测试函数为 <code>eq</code> 对应 <code>delq</code> 函数，<strong>原列表被破坏并返回一个新的列表</strong>；</li>
<li>测试函数为 <code>equal</code> 对应 <code>delete</code>，<strong>原列表被破坏并返回一个新的列表</strong>；</li>
<li><code>remove</code> 与 <code>delete</code> 相同，但<strong>不破坏原列表</strong>；</li>
<li><code>remq</code> 与 <code>delq</code> 相同，但<strong>不破坏原列表</strong>。</li>
</ul>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> xx '(<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; always set result to the same var. because original is usually destroyed</span></span><br><span class="line">(<span class="name">setq</span> xx (<span class="name">delete</span> <span class="number">4</span> xx)) <span class="comment">; (3 5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; on vector</span></span><br><span class="line">(<span class="name">setq</span> xx [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>])</span><br><span class="line">(<span class="name">setq</span> xx (<span class="name">delete</span> <span class="number">4</span> xx)) <span class="comment">; [3 5]</span></span><br><span class="line"></span><br><span class="line">setq xx '(3 4 5))</span><br><span class="line">(<span class="name">remove</span> <span class="number">4</span> xx) <span class="comment">;; (3 5)</span></span><br><span class="line">xx <span class="comment">; (3 4 5)</span></span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> xx '(<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; always set result to the same var</span></span><br><span class="line">(<span class="name">setq</span> xx (<span class="name">delq</span> <span class="number">4</span> xx)) <span class="comment">; (3 5)</span></span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> xx '(<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br><span class="line">(<span class="name">remq</span> <span class="number">4</span> xx) <span class="comment">; (3 5)</span></span><br><span class="line">xx <span class="comment">; (3 4 5)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>eq</code> ：当且仅当 <code>x</code> 和 <code>y</code> 是同一个对象 (identical object) 时（笔记：同一个内存地址。并且应该仅应用于结构：conses、数组、结构、对象），返回 <code>t</code>。</li>
<li><code>eql</code> ：当其参数判断为 <code>eq</code>，或它们是相同的非结构化值（即相同类型的数字或字符值的相同数值）时，返回 <code>t</code>。</li>
<li><code>equal</code> ：当其参数为结构相似对象 (structurally similar (isomorphic)) 时，返回 <code>t</code>。粗略地从经验来看就是如果两个对象输出形式一样，那它们就是 <code>equal</code> 的。</li>
<li><code>equalp</code> ：当两个对象是 <code>equal</code> 的，那它们也是 <code>equalp</code> 的。另外如果它们是字符，且是 char-equal 的，即忽略大小写和特定的其它字符属性后是 <code>equal</code> 的，或者说它们是数字且有相同的数字值，而不管它们是否是同的类型，或者说它们的组成部分是 <code>equalp</code> 的，那么它们就是 <code>equalp</code> 的。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="把列表当关联表"><a class="header-anchor" href="#把列表当关联表">¶</a>把列表当关联表</h4>
<p>所谓关联表，就是可以用一个字符串（通常叫关键字，key）来查找对应值的数据结构。由列表实现的关联表有一个专门的名字叫 association list。尽管 elisp 里也有 hash table，但是 hash table 相比于 association list 至少这样几个缺点：</p>
<ul>
<li>hash table 里的关键字（key）是无序的，而 association list 的关键字 可以按想要的顺序排列；</li>
<li>hash table 没有列表那样丰富的函数，只有一个 <code>maphash</code> 函数可以遍历列表。而 association list 就是一个列表，所有列表函数都能适用；</li>
<li>hash table 没有读入语法和输入形式，这对于调试和使用都带来很多不便。</li>
</ul>
<p>只要不对效率要求很高，通常直接用association list。<br>
根据比较方法的不同，有 <code>assq</code> 和 <code>assoc</code> 两个函数，它们分别对应查找使用 <code>eq</code> 和 <code>equal</code> 两种方法。例如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assoc</span> <span class="string">"a"</span> '((<span class="string">"a"</span> <span class="number">97</span>) (<span class="string">"b"</span> <span class="number">98</span>)))        <span class="comment">; =&gt; ("a" 97)</span></span><br><span class="line">(<span class="name">assq</span> 'a '((a . <span class="number">97</span>) (b . <span class="number">98</span>)))          <span class="comment">; =&gt; (a . 97)</span></span><br></pre></td></tr></table></figure>
<p>通常我们只需要查找对应的数据，所以一般来说都要用 <code>cdr</code> 来得到对应的数据：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cdr</span> (<span class="name">assoc</span> <span class="string">"a"</span> '((<span class="string">"a"</span> <span class="number">97</span>) (<span class="string">"b"</span> <span class="number">98</span>))))  <span class="comment">; =&gt; (97)</span></span><br><span class="line">(<span class="name">cdr</span> (<span class="name">assq</span> 'a '((a . <span class="number">97</span>) (b . <span class="number">98</span>))))    <span class="comment">; =&gt; 97</span></span><br></pre></td></tr></table></figure>
<p><code>assoc-default</code> 可以一步完成这样的操作：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assoc-default</span> <span class="string">"a"</span> '((<span class="string">"a"</span> <span class="number">97</span>) (<span class="string">"b"</span> <span class="number">98</span>)))          <span class="comment">; =&gt; (97)</span></span><br></pre></td></tr></table></figure>
<p>还可以用 <code>rassoc</code> 和 <code>rassq</code> 来根据数据查找键值：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">rassoc</span> '(<span class="number">97</span>) '((<span class="string">"a"</span> <span class="number">97</span>) (<span class="string">"b"</span> <span class="number">98</span>)))     <span class="comment">; =&gt; ("a" 97)</span></span><br><span class="line">(<span class="name">rassq</span> '<span class="number">97</span> '((a . <span class="number">97</span>) (b . <span class="number">98</span>)))        <span class="comment">; =&gt; (a . 97)</span></span><br></pre></td></tr></table></figure>
<p>如果要修改关键字对应的值</p>
<ul>
<li>
<p>最省事的作法就是用 <code>cons</code> 把新的键值对加到列表的头端。但是这会让列表越来越长，浪费空间。</p>
</li>
<li>
<p>如果要替换已经存在的值，一个想法就是用 <code>setcdr</code> 来更改键值对应的数据。但是在更改之前要先确定这个键值在对应的列表里，否则会产生一个错误。</p>
</li>
<li>
<p>另一个想法是用 <code>assoc</code> 查找到对应的元素，再用 <code>delq</code> 删除这个数据，然后用 <code>cons</code> 加到列表里：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> foo '((<span class="string">"a"</span> . <span class="number">97</span>) (<span class="string">"b"</span> . <span class="number">98</span>)))     <span class="comment">; =&gt; (("a" . 97) ("b" . 98))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; update value by setcdr</span></span><br><span class="line">(<span class="name">if</span> (<span class="name">setq</span> bar (<span class="name">assoc</span> <span class="string">"a"</span> foo))</span><br><span class="line">    (<span class="name">setcdr</span> bar <span class="string">"this is a"</span>)</span><br><span class="line">  (<span class="name">setq</span> foo (<span class="name">cons</span> '(<span class="string">"a"</span> . <span class="string">"this is a"</span>) foo))) <span class="comment">; =&gt; "this is a"</span></span><br><span class="line">foo                         <span class="comment">; =&gt; (("a" . "this is a") ("b" . 98))</span></span><br><span class="line"><span class="comment">;; update value by delq and cons</span></span><br><span class="line">(<span class="name">setq</span> foo (<span class="name">cons</span> '(<span class="string">"a"</span> . <span class="number">97</span>)</span><br><span class="line">               (<span class="name">delq</span> (<span class="name">assoc</span> <span class="string">"a"</span> foo) foo))) <span class="comment">; =&gt; (("a" . 97) ("b" . 98))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果不对顺序有要求的话，推荐用后一种方法。</p>
<h4 id="把列表当树用"><a class="header-anchor" href="#把列表当树用">¶</a>把列表当树用</h4>
<p>列表的第一个元素如果作为结点的数据，其它元素看作是子节点，就是一个树了。</p>
<h4 id="遍历列表"><a class="header-anchor" href="#遍历列表">¶</a>遍历列表</h4>
<ul>
<li>
<p>遍历列表最常用的函数就是 <code>mapc</code> 和 <code>mapcar</code> 了。它们的第一个参数都是一个函数，这个函数只接受一个参数，每次处理一个列表里的元素。这两个函数唯一的差别是前者返回的还是输入的列表，而 <code>mapcar</code> 返回的函数返回值构成的列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">mapc</span> '<span class="number">1</span>+ '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))                     <span class="comment">; =&gt; (1 2 3)</span></span><br><span class="line">(<span class="name">mapcar</span> '<span class="number">1</span>+ '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))                   <span class="comment">; =&gt; (2 3 4)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>另一个比较常用的遍历列表的方法是用 <code>dolist</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">dolist</span> (<span class="name">var</span> list [result]) body...)</span><br></pre></td></tr></table></figure>
<p>其中 <code>var</code> 是一个临时变量，在 <code>body</code> 里可以用来得到列表中元素的值。使用 <code>dolist</code> 的好处是不用写 lambda 函数。一般情况下它的返回值是 <code>nil</code>，但是你也可以指定一个值作为返回值（我觉得这个特性没有什么用，只省了一步而已）：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">dolist</span> (<span class="name">foo</span> '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">  (<span class="name">incf</span> foo))                           <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">setq</span> bar <span class="literal">nil</span>)</span><br><span class="line">(<span class="name">dolist</span> (<span class="name">foo</span> '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) bar)</span><br><span class="line">  (<span class="name">push</span> (<span class="name">incf</span> foo) bar))                <span class="comment">; =&gt; (4 3 2)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="散列表"><a class="header-anchor" href="#散列表">¶</a>散列表</h4>
<p>散列表，也就是 hash-table，在编程过程中会经常使用到，它以“关键字–数值”这样的对应关系保存数据，适合用于保存那些需要通过关键字查找数值的数据。</p>
<ul>
<li>
<p>创建散列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> my-hash-t (<span class="name">make-hash-table</span>))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>需要获取散列表中某一个关键字对应的数值，可以使用 <code>gethash</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">gethash</span> 'NB001 my-hash-t)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为了给散列表添加元素，可以直接使用 <code>setq</code> 函数，第一个参数是 <code>gethash</code> 获得的关键字位置，第二个参数是希望添加的数值，如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> (<span class="name">gethash</span> 'NB002 my-hash-t) <span class="string">"Tom"</span>)</span><br></pre></td></tr></table></figure>
<p>需要注意的是<strong>散列表中一个关键字只能对应一个数值，同一个关键字无法赋予两个不同的值</strong>。如下面的代码会将 <code>NB001</code> 的数值设置为 <code>&quot;Jerry&quot;</code>。后面那句 <code>setq</code> 生效，这个和变量的赋值的类似的：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> (<span class="name">gethash</span> 'NB001 my-hash-t) <span class="string">"Mike"</span>)</span><br><span class="line"> (<span class="name">setq</span> (<span class="name">gethash</span> 'NB001 my-hash-t) <span class="string">"Jerry"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>散列表的遍历，elisp 中的散列表可以通过 <code>maphash</code> 函数进行迭代，形式如下：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">maphash</span> #'(lambda (key value) </span><br><span class="line">	(format *query-io* <span class="string">"key: ~a  value: ~a  ~%"</span> key value))</span><br><span class="line">  my-hash-t)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="其它常用函数"><a class="header-anchor" href="#其它常用函数">¶</a>其它常用函数</h4>
<ul>
<li>
<p><code>fold</code> 和 <code>filter</code><br>
如果看过一些函数式语言教程的话，一定对 <code>fold</code>（或叫 <code>accumulate</code>、<code>reduce</code>）和 <code>filter</code> 这些函数记忆深刻。不过 elisp 里好像没有提供这样的函数。<code>remove-if</code> 和 <code>remove-if-not</code> 可以作 <code>filter</code> 函数，但是它们是 cl 里的，自己用用没有关系，不能强迫别人也跟着用，所以不能写到 elisp 里。如果不用这两个函数，也不用别人的函数的话，自己实现不妨用这样的方法：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> my-remove-if (<span class="name">predicate</span> list)</span><br><span class="line">  (<span class="name">delq</span> <span class="literal">nil</span> (<span class="name">mapcar</span> (<span class="name">lambda</span> (<span class="name">n</span>)</span><br><span class="line">                      (<span class="name">and</span> (<span class="name">not</span> (<span class="name">funcall</span> predicate n)) n))</span><br><span class="line">                    list)))</span><br><span class="line">(<span class="name">defun</span> evenp (<span class="name">n</span>)</span><br><span class="line">  (<span class="name">=</span> (% n <span class="number">2</span>) <span class="number">0</span>))</span><br><span class="line">(<span class="name">my-remove-if</span> 'evenp '(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))    <span class="comment">; =&gt; (1 3 5)</span></span><br></pre></td></tr></table></figure>
<p><code>fold</code> 的操作只能用变量加循环或 <code>mapc</code> 操作来代替了：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> my-fold-left (<span class="name">op</span> initial list)</span><br><span class="line">  (<span class="name">dolist</span> (<span class="name">var</span> list initial)</span><br><span class="line">    (<span class="name">setq</span> initial (<span class="name">funcall</span> op initial var))))</span><br><span class="line">(<span class="name">my-fold-left</span> '+ <span class="number">0</span> '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))          <span class="comment">; =&gt; 10</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>产生数列常用的方法是用 <code>number-sequence</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">number-sequence</span> <span class="number">5</span>)         <span class="comment">; =&gt; (5)</span></span><br><span class="line">(<span class="name">number-sequence</span> <span class="number">1</span> <span class="number">5</span>)       <span class="comment">; =&gt; (1 2 3 4 5)</span></span><br><span class="line">(<span class="name">number-sequence</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span>)     <span class="comment">; =&gt; (1 3 5)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>解析文本时一个很常用的操作是把字符串按分隔符分解，可以用 <code>split-string</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">split-string</span> <span class="string">"key = val"</span> <span class="string">"\\s-*=\\s-*"</span>)  <span class="comment">; =&gt; ("key" "val")</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>与 <code>split-string</code> 对应是把几个字符串用一个分隔符连接起来，这可以用 <code>mapconcat</code> 完成。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">mapconcat</span> 'identity '(<span class="string">"a"</span> <span class="string">"b"</span> <span class="string">"c"</span>) <span class="string">"\t"</span>) <span class="comment">; =&gt; "a   b   c"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>identity</code> 是一个特殊的函数，它会直接返回参数。<code>mapconcat</code> 第一个参数是一个函数，可以很灵活的使用。</p>
</blockquote>
</li>
<li>
<p>函数 <code>length</code> 可以得到序列的长度。但是这个函数只对真列表有效。对于一个点列表和环形列表这个函数就不适用了。点列表会出参数类型不对的错误，而环形列表就更危险，会陷入死循环。如果不确定参数类型，不妨用 <code>safe-length</code>。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">safe-length</span> '(a . b))                  <span class="comment">; =&gt; 1</span></span><br><span class="line">(<span class="name">safe-length</span> '#1=(<span class="number">1</span> <span class="number">2</span> . #1#))           <span class="comment">; =&gt; 3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组和序列"><a class="header-anchor" href="#数组和序列">¶</a>数组和序列</h3>
<p>序列是列表和数组的统称，也就是说列表和数组都是序列。它们的共性是内部的元素都是有序的。elisp 里的数组包括字符串、向量、char-table 和布尔向量。它们的关系可以用下面图表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> _____________________________________________</span><br><span class="line">|                                             |</span><br><span class="line">|          Sequence                           |</span><br><span class="line">|  ______   ________________________________  |</span><br><span class="line">| |      | |                                | |</span><br><span class="line">| | List | |             Array              | |</span><br><span class="line">| |      | |    ________       ________     | |</span><br><span class="line">| |______| |   |        |     |        |    | |</span><br><span class="line">|          |   | Vector |     | String |    | |</span><br><span class="line">|          |   |________|     |________|    | |</span><br><span class="line">|          |  ____________   _____________  | |</span><br><span class="line">|          | |            | |             | | |</span><br><span class="line">|          | | Char-table | | Bool-vector | | |</span><br><span class="line">|          | |____________| |_____________| | |</span><br><span class="line">|          |________________________________| |</span><br><span class="line">|_____________________________________________|</span><br></pre></td></tr></table></figure>
<p>数组有这样一些特性：</p>
<ul>
<li>数组内的元素都对应一个下标，第一个元素下标为 <code>0</code>，接下来是 <code>1</code>。数组内 的元素可以在常数时间内访问。</li>
<li>数组在创建之后就无法改变它的长度。</li>
<li>数组是自求值的。</li>
<li>数组里的元素都可以用 <code>aref</code> 来访问，用 <code>aset</code> 来设置。</li>
</ul>
<h4 id="数组类型"><a class="header-anchor" href="#数组类型">¶</a>数组类型</h4>
<ul>
<li><strong>向量</strong>可以看成是一种通用的数组，它的元素可以是任意的对象。</li>
<li><strong>字符串</strong>是一种特殊的数组，它的元素只能是字符。如果元素是字符时，使用字符串相比向量更好，因为字符串需要的空间更少（只需要向量的 1/4），输出更直观，能用文本属性（text property），能使用 emacs 的 IO 操作。但是有时必须使用向量，比如存储按键序列。</li>
<li><strong>char-table</strong>与向量类似，只不过它的索引是字符码。任何无修改器的字符码都可作为 char-table 的索引。可以通过 <code>aref</code> 和 <code>aset</code> 像访问数组一样访问 char-table。另外，一个 char-table 可以包含一些与特定字符码无关的额外数据。与向量一样，char-table 求值以后（evaluated）就不允许改变。char-table 的元素可以是任意对象。</li>
<li><strong>bool-vector</strong>与向量类似，只不过它只存储 <code>t</code> 和 <code>nil</code>。如果向其中存入任意非 <code>nil</code> 值，则会变为存储 <code>t</code>。与数组一样，bool-vector 的索引是从 <code>0</code> 开始的，并且 bool-vector 一旦生成，它的长度即固定。</li>
</ul>
<h5 id="测试函数-v4"><a class="header-anchor" href="#测试函数-v4">¶</a>测试函数</h5>
<p><code>sequencep</code> 用来测试一个对象是否是一个序列。<code>arrayp</code> 测试对象是否是数组。<code>vectorp</code>、<code>char-table-p</code> 和 <code>bool-vector-p</code> 分别测试对象是否是向量、char-table、bool-vector。</p>
<h5 id="序列的通用函数"><a class="header-anchor" href="#序列的通用函数">¶</a>序列的通用函数</h5>
<ul>
<li>获取数组长度使用 <code>length</code> 或 <code>safe-length</code>。(见<a href="#%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">上一章</a>)</li>
<li>取得数组里第 <code>n</code> 个元素可以用 <code>elt</code> 函数或 <code>aref</code> 函数。(见<a href="#%E8%AE%BF%E9%97%AE">上一章</a>)</li>
<li>复制数组使用 <code>copy-sequence</code> 函数。(见<a href="#%E9%87%8D%E6%8E%92%E5%88%97%E8%A1%A8">上一章</a>)</li>
</ul>
<h5 id="数组操作"><a class="header-anchor" href="#数组操作">¶</a>数组操作</h5>
<ul>
<li>
<p>创建向量</p>
<ul>
<li>
<p>创建向量可以用 <code>vector</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">vector</span> 'foo <span class="number">23</span> [bar baz] <span class="string">"rats"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当然也可以直接用向量的读入语法创建向量，但是由于 <strong>数组是自求值的</strong>，所以这样得到的向量和原来是一样的，也就是说参数不进行求值，看下面的例子就明白了：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo                                     <span class="comment">; =&gt; (a b)</span></span><br><span class="line">[foo]                                   ; =&gt; [foo]</span><br><span class="line">(<span class="name">vector</span> foo)                            <span class="comment">; =&gt; [(a b)]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用 <code>make-vector</code> 可以生成元素相同的向量：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">make-vector</span> <span class="number">9</span> 'Z)                      <span class="comment">; =&gt; [Z Z Z Z Z Z Z Z Z]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>fillarray</code> 可以把整个数组用某个元素填充：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">fillarray</span> (<span class="name">make-vector</span> <span class="number">3</span> 'Z) <span class="number">5</span>)        <span class="comment">; =&gt; [5 5 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>aref</code> 和 <code>aset</code> 可以用于访问和修改数组的元素。如果使用下标超出数组长度的话，会产生一个错误。所以要先确定数组的长度才能用这两个函数：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> myarray [a b c d e])      <span class="comment">; =&gt; [a b c d e]</span></span><br><span class="line">(<span class="name">aref</span> myarray <span class="number">0</span>)                <span class="comment">; =&gt; a</span></span><br><span class="line">(<span class="name">aref</span> myarray <span class="number">3</span>)                <span class="comment">; =&gt; d</span></span><br><span class="line">(<span class="name">aset</span> myarray <span class="number">2</span> 'guai)          <span class="comment">; =&gt; guai</span></span><br><span class="line">myarray                         <span class="comment">; =&gt; [a b guai d e]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>vconcat</code> 可以把多个序列连接成一个向量。但是<strong>这些个序列必须是真列表</strong>。这也是把列表转换成向量的方法。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">vconcat</span> [A B C] <span class="string">"aa"</span> '(foo (<span class="number">6</span> <span class="number">7</span>)))     <span class="comment">; =&gt; [A B C 97 97 foo (6 7)]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>把向量转换成列表可以用 <code>append</code> 函数，这在<a href="#constructors_in_list">上一章</a>中已经提到。</p>
</li>
</ul>
<h3 id="符号"><a class="header-anchor" href="#符号">¶</a>符号</h3>
<p>符号是有名字的对象。可能这么说有点抽象。作个不恰当的比方，<strong>符号可以看作是 C 语言里的指针</strong>。通过符号你可以得到和这个符号相关联的信息，比如值，函数，属性列表等等。</p>
<h4 id="符号的命名规则"><a class="header-anchor" href="#符号的命名规则">¶</a>符号的命名规则</h4>
<ul>
<li>
<p>符号名字可以含有任何字符。</p>
</li>
<li>
<p>名字前缀要足够把符号名和数字区分开来，如果需要的话，可以在前面用 <code>\</code> 表示为符号，比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">symbolp</span> '+1)                           <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">symbolp</span> '\<span class="number">+1</span>)                          <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">symbol-name</span> '\<span class="number">+1</span>)                      <span class="comment">; =&gt; "+1"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>其它字符 <code>_~!@$%^&amp;amp;:&lt;&gt;{}?</code> 用的比较少。但是也可以直接作为符号的名字。</p>
</li>
<li>
<p>任何其它字符都可以用 <code>\</code> 转义后用在符号名字里。</p>
<blockquote>
<p>**注意：**和字符串里字符表示不同，<code>\</code> 转义后只是表示其后的字符，比如 <code>\t</code> 代表的字符 <code>t</code>，而不是制表符。如果要在符号名里使用制表符，必须在 <code>\</code> 后加上制表符本身。</p>
</blockquote>
</li>
<li>
<p>符号名是区分大小写的。</p>
</li>
</ul>
<p>这里有一些符号名的例子：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo                 <span class="comment">; 名为 `foo' 的符号</span></span><br><span class="line">FOO                 <span class="comment">; 名为 `FOO' 的符号，和 `foo' 不同</span></span><br><span class="line">char-to-string      <span class="comment">; 名为 `char-to-string' 的符号</span></span><br><span class="line"><span class="number">1</span>+                  <span class="comment">; 名为 `1+' 的符号 (不是整数 `+1')</span></span><br><span class="line">\+1                 ; 名为 `+1' 的符号 (可读性很差的名字)</span><br><span class="line">\(*\ 1\ 2\)         ; 名为 `(* 1 2)' 的符号 (更差劲的名字).</span><br><span class="line">+-*/_~!@$%^&amp;=:&lt;&gt;&#123;&#125;  ; 名为 `+-*/_~!@$%^&amp;=:&lt;&gt;&#123;&#125;' 的符号.</span><br><span class="line">                    <span class="comment">;   这些字符无须转义</span></span><br></pre></td></tr></table></figure>
<h4 id="创建符号"><a class="header-anchor" href="#创建符号">¶</a>创建符号</h4>
<p>符号名要有唯一性，所以一定会有一个表与名字关联，这个表在 elisp 里称为 obarray。从这个名字可以看出这个表是用数组类型，<strong>事实上是一个向量</strong>。</p>
<h5 id="intern"><a class="header-anchor" href="#intern">¶</a><code>intern</code></h5>
<p>当 lisp 读入一个符号时，通常会先查找这个符号是否在 obarray 里出现过，如果没有则会把这个符号加入到 obarray 里。这样查找并加入一个符号的过程称为是 <code>intern</code>。<code>intern</code> 函数可以查找或加入一个名字到 obarray 里，返回对应的符号。默认是全局的 obarray，也可以指定一个 obarray。</p>
<h5 id="intern-soft"><a class="header-anchor" href="#intern-soft">¶</a><code>intern-soft</code></h5>
<p><code>intern-soft</code> 与 <code>intern</code> 不同的是，当名字不在 obarray 里时，<code>intern-soft</code> 会返回 <code>nil</code>，而 <code>intern</code> 会加入到 obarray里。为了不污染 obarray，我下面的例子中尽量在 <code>foo</code> 这个 obarray 里进行。一般来说，去了 <code>foo</code> 参数，则会在 obarray 里进行。其结果应该是相同的：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> foo (<span class="name">make-vector</span> <span class="number">10</span> <span class="number">0</span>))           <span class="comment">; =&gt; [0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line">(<span class="name">intern-soft</span> <span class="string">"abc"</span> foo)                 <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">intern</span> <span class="string">"abc"</span> foo)                      <span class="comment">; =&gt; abc</span></span><br><span class="line">(<span class="name">intern-soft</span> <span class="string">"abc"</span> foo)                 <span class="comment">; =&gt; abc</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>lisp 每读入一个符号都会 <code>intern</code> 到 obarray 里，如果想避免，可以用在符号名前加上 <code>#:</code>：</p>
</blockquote>
<blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">intern-soft</span> <span class="string">"abc"</span>)                     <span class="comment">; =&gt; nil</span></span><br><span class="line">'abc                                    <span class="comment">; =&gt; abc</span></span><br><span class="line">(<span class="name">intern-soft</span> <span class="string">"abc"</span>)                     <span class="comment">; =&gt; abc</span></span><br><span class="line">(<span class="name">intern-soft</span> <span class="string">"abcd"</span>)                    <span class="comment">; =&gt; nil</span></span><br><span class="line">'#:abcd                                 ; =&gt; abcd</span><br><span class="line">(<span class="name">intern-soft</span> <span class="string">"abcd"</span>)                    <span class="comment">; =&gt; nil</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="unintern"><a class="header-anchor" href="#unintern">¶</a><code>unintern</code></h5>
<p>如果想除去 obarray 里的符号，可以用 <code>unintern</code> 函数。<code>unintern</code> 可以用符号名或符号作参数在指定的 obarray 里去除符号，成功去除则返回 t，如果没有查找到对应的符号则返回 <code>nil</code>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">intern-soft</span> <span class="string">"abc"</span> foo)                 <span class="comment">; =&gt; abc</span></span><br><span class="line">(<span class="name">unintern</span> <span class="string">"abc"</span> foo)                    <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">intern-soft</span> <span class="string">"abc"</span> foo)                 <span class="comment">; =&gt; nil</span></span><br></pre></td></tr></table></figure>
<h5 id="mapatoms"><a class="header-anchor" href="#mapatoms">¶</a><code>mapatoms</code></h5>
<p><a href="#%E6%95%A3%E5%88%97%E8%A1%A8">和 hash-table 一样</a>，obarray 也提供一个 <code>mapatoms</code> 函数来遍历整个 obarray。比如要计算 obarray 里所有的符号数量：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> count <span class="number">0</span>)                          <span class="comment">; =&gt; 0</span></span><br><span class="line">(<span class="name">defun</span> count-syms (<span class="name">s</span>)</span><br><span class="line">  (<span class="name">setq</span> count (<span class="number">1</span>+ count)))              <span class="comment">; =&gt; count-syms</span></span><br><span class="line">(<span class="name">mapatoms</span> 'count-syms)                  <span class="comment">; =&gt; nil</span></span><br><span class="line">count                                   <span class="comment">; =&gt; 28371</span></span><br><span class="line">(<span class="name">length</span> obarray)                        <span class="comment">; =&gt; 1511</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>由前面的例子可以看出 elisp 中的向量长度都是有限的，而 obarray 里的符号有成千上万个。那这些符号是怎样放到 obarray 里的呢？<br>
其实<strong>这和散列的的实现是一样的</strong>。obarray 里的每一个元素通常称为 bucket。 一个 bucket 是可以容纳多个相同 hash 值的字符串和它们的数据。</p>
</blockquote>
<h4 id="符号的组成"><a class="header-anchor" href="#符号的组成">¶</a>符号的组成</h4>
<p>每个符号可以对应四个组成部分：名字、值、函数部分和属性列表(property list)。</p>
<h5 id="符号的名字和值"><a class="header-anchor" href="#符号的名字和值">¶</a>符号的名字和值</h5>
<ul>
<li>
<p>符号的名字可以用 <code>symbol-name</code> 访问。符号的值。</p>
</li>
<li>
<p>符号的值可以通过 <code>set</code> 函数来设置，用 <code>symbol-value</code> 来访问：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">set</span> (<span class="name">intern</span> <span class="string">"abc"</span> foo) <span class="string">"I'm abc"</span>)      <span class="comment">; =&gt; "I'm abc"</span></span><br><span class="line">(<span class="name">symbol-value</span> (<span class="name">intern</span> <span class="string">"abc"</span> foo))       <span class="comment">; =&gt; "I'm abc"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可能大家最常见到 <code>setq</code> 函数，而 <code>set</code> 函数确很少见到。<code>setq</code> 可以看成是一个宏，它可以让你用 <code>(setq sym val)</code> 代替 <code>(set (quote sym) val)</code>。事实上这也是它名字的来源 (q 代表 quoted)。但是 <strong><code>setq</code> 只能设置 obarray 里的变量，前面这个例子中就只能用 <code>set</code> 函数</strong>。</p>
</blockquote>
<blockquote>
<p>如果一个符号的值已经有设置过的话，则 <code>boundp</code> 测试返回 <code>t</code>，否则为 <code>nil</code>。对于 <code>boundp</code> 测试返回 <code>nil</code> 的符号，使用符号的值会引起一个变量值为 void 的错误。</p>
</blockquote>
</li>
<li>
<p>符号的第三个组成部分是函数。它可以用 <code>symbol-function</code> 来访问，用 <code>fset</code> 来设置：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">fset</span> (<span class="name">intern</span> <span class="string">"abc"</span> foo) (<span class="name">symbol-function</span> 'car)) <span class="comment">; =&gt; #&lt;subr car&gt;</span></span><br><span class="line">(<span class="name">funcall</span> (<span class="name">intern</span> <span class="string">"abc"</span> foo) '(a . b))            <span class="comment">; =&gt; a</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>类似的，可以用 <code>fboundp</code> 测试一个符号的函数部分是否有设置。</p>
</blockquote>
</li>
<li>
<p>符号的第四个组成部分是属性列表(property list)。通常属性列表用于存储和符号相关的信息，比如变量和函数的文档，定义的文件名和位置，语法类型。属性名和值可以是任意的 lisp 对象，但是通常名字是符号，可以用 <code>get</code> 和 <code>put</code> 来访问和修改属性值，用 <code>symbol-plist</code> 得到所有的属性列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">put</span> (<span class="name">intern</span> <span class="string">"abc"</span> foo) 'doc <span class="string">"this is abc"</span>)      <span class="comment">; =&gt; "this is abc"</span></span><br><span class="line">(<span class="name">get</span> (<span class="name">intern</span> <span class="string">"abc"</span> foo) 'doc)                    <span class="comment">; =&gt; "this is abc"</span></span><br><span class="line">(<span class="name">symbol-plist</span> (<span class="name">intern</span> <span class="string">"abc"</span> foo))                <span class="comment">; =&gt; (doc "this is abc")</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关联列表和属性列表很相似。符号的属性列表在内部表示上是用 <code>(prop1 value1 prop2 value2 ...)</code> 的形式，和关联列表也是很相似的。属性列表在查找和这个符号相关的信息时，要比直接用关联列表要简单快捷的多。所以变量的文档等信息都是放在符号的属性列表里。但是关联表在头端加入元素是很快的，而且它可以删除表里的元素。而属性列表则不能删除一个属性。</p>
</blockquote>
<blockquote>
<p>如果已经把属性列表取出，那么还可以用 plist-get 和 plist-put 的方法来访问和设置属性列表</p>
</blockquote>
  <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">plist-get</span> '(foo <span class="number">4</span>) 'foo)               <span class="comment">; =&gt; 4</span></span><br><span class="line">(<span class="name">plist-get</span> '(foo <span class="number">4</span> bad) 'bar)           <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">setq</span> my-plist '(bar t foo <span class="number">4</span>))          <span class="comment">; =&gt; (bar t foo 4)</span></span><br><span class="line">(<span class="name">setq</span> my-plist (<span class="name">plist-put</span> my-plist 'foo <span class="number">69</span>)) <span class="comment">; =&gt; (bar t foo 69)</span></span><br><span class="line">(<span class="name">setq</span> my-plist (<span class="name">plist-put</span> my-plist 'quux '(a))) <span class="comment">; =&gt; (bar t foo 69 quux (a))</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rabbituzki.com.cn/2019/10/05/Elisp-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="ckidwlghb0007sgv4bd2ff5p9" class="article-share-link">
        分享
      </a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Emacs/" rel="tag">Emacs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lisp/" rel="tag">Lisp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li></ul>

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2019/10/05/Elisp-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">前一篇</strong>
        <div class="article-nav-title">
          
            Elisp 学习笔记（二）
          
        </div>
      </a>
    
    
      <a href="/2019/08/14/davfs%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">davfs2 自动挂载</div>
      </a>
    
  </nav>


  

  
  
  
  

</article>
</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 六加的博客</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="六加的博客"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>



<script src="/js/ocean.js"></script>


</body>
</html>