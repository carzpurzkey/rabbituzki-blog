<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Rust 程序设计语言学习笔记（二） |
    
    六加的博客</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
<main class="content">
  <section class="outer">
  <article id="post-Rust-程序设计语言学习笔记（二）" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
    <h1 class="article-title" itemprop="name">
      Rust 程序设计语言学习笔记（二）
    </h1>
  
  




    </header>
    

    
    <div class="article-meta">
      <a href="/2019/03/03/Rust-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time datetime="2019-03-02T16:00:00.000Z" itemprop="datePublished">2019-03-03</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%99%E7%A8%8B/">教程</a>
  </div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      


      
  <div class="article-gallery">
    <div class="article-gallery-photos">
      
        
          <img src="/images/rust-language.jpg" itemprop="image">
        
      
    </div>
  </div>


      
      <h1>Rust 程序设计语言学习笔记（二）</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="6-枚举与模式匹配"><a class="header-anchor" href="#6-枚举与模式匹配">¶</a>6. 枚举与模式匹配</h2>
<h3 id="6-1-定义枚举"><a class="header-anchor" href="#6-1-定义枚举">¶</a>6.1 定义枚举</h3>
<h4 id="枚举值"><a class="header-anchor" href="#枚举值">¶</a>枚举值</h4>
<p>仅仅使用枚举并将数据直接放进每一个枚举成员而不是将枚举作为结构体的一部分。<code>IpAddr</code> 枚举的新定义表明了 <code>V4</code> 和 <code>V6</code> 成员都关联了 <code>String</code> 值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">String</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br></pre></td></tr></table></figure>
<p>我们直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了。</p>
<p>来看看下面另一个枚举的例子：它的成员中内嵌了多种多样的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个枚举有四个含有不同类型的成员：</p>
<ul>
<li><code>Quit</code> 没有关联任何数据。</li>
<li><code>Move</code> 包含一个匿名结构体。</li>
<li><code>Write</code> 包含单独一个 <code>String</code>。</li>
<li><code>ChangeColor</code> 包含三个 <code>i32</code>。</li>
</ul>
<p>就像可以使用 <code>impl</code> 来为结构体定义方法那样，也可以在枚举上定义方法。这是一个定义于我们 <code>Message</code> 枚举上的叫做 <code>call</code> 的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Message &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这里定义方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = Message::Write(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">m.call();</span><br></pre></td></tr></table></figure>
<p>方法体使用了 <code>self</code> 来获取调用方法的值。这个例子中，创建了一个值为 <code>Message::Write(String::from(&quot;hello&quot;))</code> 的变量 <code>m</code>，而且这就是当 <code>m.call()</code> 运行时 <code>call</code> 方法中的 <code>self</code> 的值。</p>
<h4 id="Option-枚举和其相对于空值的优势"><a class="header-anchor" href="#Option-枚举和其相对于空值的优势">¶</a><code>Option</code> 枚举和其相对于空值的优势</h4>
<p>空值尝试表达的概念仍然是有意义的：空值是一个因为某种原因目前无效或缺失的值。<br>
问题不在于概念而在于具体的实现。为此，Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 <code>Option&lt;T&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只要一个值不是 <code>Option&lt;T&gt;</code> 类型，你就 <strong>可以</strong> 安全的认定它的值不为空。</p>
</blockquote>
<h3 id="6-2-match-控制流运算符"><a class="header-anchor" href="#6-2-match-控制流运算符">¶</a>6.2 <code>match</code> 控制流运算符</h3>
<p>一个枚举和一个以枚举成员作为模式的 <code>match</code> 表达式的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果分支代码较短的话通常不使用大括号，正如上例 中的每个分支都只是返回一个值。如果想要在分支中运行多行代码，可以使用大括号。例如，如下代码在每次使用<code>Coin::Penny</code> 调用时都会打印出 “Lucky penny!”，同时仍然返回代码块最后的值，<code>1</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Lucky penny!"</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配是穷尽的"><a class="header-anchor" href="#匹配是穷尽的">¶</a>匹配是穷尽的</h3>
<p>match 还有另一方面需要讨论。考虑一下 <code>plus_one</code> 函数的这个版本，它有一个 bug 并不能编译：<br>
这些代码不能编译！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们没有处理 <code>None</code> 的情况，所以这些代码会造成一个 bug。幸运的是，这是一个 Rust 知道如何处理的 bug。如果尝试编译这段代码，会得到这个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error[E0004]: non-exhaustive patterns: &#96;None&#96; not covered</span><br><span class="line"> --&gt;</span><br><span class="line">  |</span><br><span class="line">6 |         match x &#123;</span><br><span class="line">  |               ^ pattern &#96;None&#96; not covered</span><br></pre></td></tr></table></figure>
<p>Rust 知道我们没有覆盖所有可能的情况甚至知道哪些模式被忘记了！Rust 中的匹配是 穷尽的（<em>exhaustive</em>）：必须穷举到最后的可能性来使代码有效。特别的在这个 <code>Option&lt;T&gt;</code> 的例子中，Rust 防止我们忘记明确的处理 <code>None</code> 的情况，这使我们免于假设拥有一个实际上为空的值。</p>
<h4 id="通配符"><a class="header-anchor" href="#通配符">¶</a><code>_</code> 通配符</h4>
<p>Rust 也提供了一个模式用于不想列举出所有可能值的场景：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="number">0u8</span>;</span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one"</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">    <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"five"</span>),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">"seven"</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_</code> 模式会匹配所有的值。通过将其放置于其他分支之后，<code>_</code> 将会匹配所有之前没有指定的可能的值。<code>()</code> 就是 <code>unit</code> 值，所以 <code>_</code> 的情况什么也不会发生。</p>
<h3 id="6-3-if-let-简洁控制流"><a class="header-anchor" href="#6-3-if-let-简洁控制流">¶</a>6.3 <code>if let</code> 简洁控制流</h3>
<p>为了满足 <code>match</code> 表达式（穷尽性）的要求，必须在处理完这唯一的成员后加上 <code>_ =&gt; ()</code>，这样也要增加很多样板代码。<br>
我们可以使用 <code>if let</code> 这种更短的方式编写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在 <code>if let</code> 中包含一个 <code>else</code>。<code>else</code> 块中的代码与 <code>match</code> 表达式中的 <code>_</code> 分支块中的代码相同，这样的 <code>match</code> 表达式就等同于 <code>if let</code> 和 <code>else</code>。这样一个 match 表达式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">match</span> coin &#123;</span><br><span class="line">    Coin::Quarter(state) =&gt; <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state),</span><br><span class="line">    _ =&gt; count += <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> Coin::Quarter(state) = coin &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-包、crate-与模块"><a class="header-anchor" href="#7-包、crate-与模块">¶</a>7. 包、crate 与模块</h2>
<h3 id="7-1-包和-crate-用来创建库和二进制项目"><a class="header-anchor" href="#7-1-包和-crate-用来创建库和二进制项目">¶</a>7.1 包和 crate 用来创建库和二进制项目</h3>
<ul>
<li><em>crate</em> 是一个二进制或库项目。</li>
<li><strong>crate 根</strong>（<em>crate root</em>）是一个用来描述如何构建 crate 的文件。</li>
<li>带有 <em>Cargo.toml</em> 文件的 <strong>包</strong> 用以描述如何构建一个或多个 crate。一个包中至多可以有一个库项目。</li>
</ul>
<p>所以当运行 <code>cargo new</code> 时是在创建一个包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new my-project</span><br><span class="line">     Created binary (application) `my-project` package</span><br><span class="line">$ ls my-project</span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line">$ ls my-project/src</span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>Cargo 的约定是如果在代表包的 <em>Cargo.toml</em> 的同级目录下包含 <em>src</em> 目录且其中包含 <em><a href="http://main.rs" target="_blank" rel="noopener">main.rs</a></em> 文件的话，Cargo 就知道这个包带有一个与包同名的二进制 crate，且 <em>src/main.rs</em> 就是 crate 根。</li>
<li>另一个约定如果包目录中包含 <em>src/lib.rs</em>，则包带有与其同名的库 crate，且 <em>src/lib.rs</em> 是 crate 根。crate 根文件将由 Cargo 传递给 <code>rustc</code> 来实际构建库或者二进制项目。</li>
</ul>
</blockquote>
<h3 id="7-2-模块系统用来控制作用域和私有性"><a class="header-anchor" href="#7-2-模块系统用来控制作用域和私有性">¶</a>7.2 模块系统用来控制作用域和私有性</h3>
<h4 id="使用-super-开始相对路径"><a class="header-anchor" href="#使用-super-开始相对路径">¶</a>使用 <code>super</code> 开始相对路径</h4>
<p>可以使用 <code>super</code> 开头来构建相对路径。这么做类似于文件系统中以 <code>..</code> 开头：该路径从 <strong>父</strong> 模块开始而不是当前模块。这在下面示例这样的情况下有用处，在这里 clarinet 函数通过指定以 <code>super</code> 开头的路径调用 <code>breathe_in</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> instrument &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;</span><br><span class="line">        super::breathe_in();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">breathe_in</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>clarinet</code> 函数位于 <code>instrument</code> 模块中，所以可以使用 <code>super</code> 进入 <code>instrument</code> 的父模块，也就是根 <code>crate</code>。从这里可以找到 <code>breathe_in</code>。成功！</p>
<h4 id="对结构体和枚举使用-pub"><a class="header-anchor" href="#对结构体和枚举使用-pub">¶</a>对结构体和枚举使用 <code>pub</code></h4>
<p>如果在结构体定义中使用 <code>pub</code>，可以使结构体公有。然而结构体的字段仍是私有的。可以在每一个字段的基准上选择其是否公有：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> plant &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vegetable</span></span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> name: <span class="built_in">String</span>,</span><br><span class="line">        id: <span class="built_in">i32</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Vegetable &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name: &amp;<span class="built_in">str</span>) -&gt; Vegetable &#123;</span><br><span class="line">            Vegetable &#123;</span><br><span class="line">                name: <span class="built_in">String</span>::from(name),</span><br><span class="line">                id: <span class="number">1</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = plant::Vegetable::new(<span class="string">"squash"</span>);</span><br><span class="line"></span><br><span class="line">    v.name = <span class="built_in">String</span>::from(<span class="string">"butternut squash"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125; are delicious"</span>, v.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果将如下行取消注释代码将无法编译:</span></span><br><span class="line">    <span class="comment">// println!("The ID is &#123;&#125;", v.id);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相反，如果有一个公有枚举，其所有成员都是公有。只需在 <code>enum</code> 关键词前加上 <code>pub</code>。</p>
<h4 id="使用-use-关键字将名称引入作用域"><a class="header-anchor" href="#使用-use-关键字将名称引入作用域">¶</a>使用 <code>use</code> 关键字将名称引入作用域</h4>
<p>有一次性将路径引入作用域然后就像调用本地项那样的方法：使用 <code>use</code> 关键字。</p>
<p>如果希望通过 use 和相对路径来将项引入作用域，则与直接通过相对路径调用项有些小的区别：不同于从当前作用域的名称开始，use 中的路径必须以 self</p>
<h4 id="use-函数路径使用习惯-VS-其他项"><a class="header-anchor" href="#use-函数路径使用习惯-VS-其他项">¶</a><code>use</code> 函数路径使用习惯 VS 其他项</h4>
<ul>
<li>
<p>对于函数来说，通过 <code>use</code> 指定函数的父模块接着指定父模块来调用方法被认为是习惯用法。这么做而不是像下面示例那样通过 <code>use</code> 指定函数的路径，清楚的表明了函数不是本地定义的，同时仍最小化了指定全路径时的重复：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> sound &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> instrument &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;</span><br><span class="line">            <span class="comment">// 函数体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::sound::instrument::clarinet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    clarinet();</span><br><span class="line">    clarinet();</span><br><span class="line">    clarinet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对于结构体、枚举和其它项，通过 <code>use</code> 指定项的全路径是习惯用法。例如，下面示例展示了将标准库中 <code>HashMap</code> 结构体引入作用域的习惯用法。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">    map.insert(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这个习惯的一个例外是如果 <code>use</code> 语句会将两个同名的项引入作用域时，这是不允许的。下面示例展示了如何将两个不同父模块的 <code>Result</code> 类型引入作用域并引用它们。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function1</span></span>() -&gt; fmt::<span class="built_in">Result</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function2</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为如果我们指定 <code>use std::fmt::Result</code> 和 <code>use std::io::Result</code>，则作用域中会有两个 <code>Result</code> 类型，Rust 无法知道我们想用哪个 <code>Result</code>。</p>
</li>
</ul>
<h4 id="使用-pub-use-重导出名称"><a class="header-anchor" href="#使用-pub-use-重导出名称">¶</a>使用 <code>pub use</code> 重导出名称</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> sound &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> instrument &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;</span><br><span class="line">            <span class="comment">// 函数体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> performance_group &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">use</span> crate::sound::instrument;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clarinet_trio</span></span>() &#123;</span><br><span class="line">        instrument::clarinet();</span><br><span class="line">        instrument::clarinet();</span><br><span class="line">        instrument::clarinet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    performance_group::clarinet_trio();</span><br><span class="line">    performance_group::instrument::clarinet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>pub use</code>，现在 <code>main</code> 函数可以通过新路径 <code>performance_group::instrument::clarinet</code> 来调用 <code>clarinet</code> 函数。如果没有指定 <code>pub use</code>，<code>clarinet_trio</code> 函数可以在其作用域中调用 <code>instrument::clarinet</code> 但 <code>main</code> 则不允许使用这个新路径。</p>
<h4 id="嵌套路径来消除大量的-use-行"><a class="header-anchor" href="#嵌套路径来消除大量的-use-行">¶</a>嵌套路径来消除大量的 <code>use</code> 行</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp:Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br></pre></td></tr></table></figure>
<p>另外：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io:Write;</span><br></pre></td></tr></table></figure>
<h4 id="通过-glob-运算符将所有的公有定义引入作用域"><a class="header-anchor" href="#通过-glob-运算符将所有的公有定义引入作用域">¶</a>通过 <code>glob</code> 运算符将所有的公有定义引入作用域</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></table></figure>
<p>这个 <code>use</code> 语句将 <code>std::collections</code> 中定义的所有公有项引入当前作用域。</p>
<blockquote>
<p>使用 glob 运算符时请多加小心！<strong>如此难以推导作用域中有什么名称和它们是在何处定义的</strong>。<br>
glob 运算符经常用于测试模块 <code>tests</code> 中，这时会将所有内容引入作用域。</p>
</blockquote>
<h4 id="将模块分割进不同文件"><a class="header-anchor" href="#将模块分割进不同文件">¶</a>将模块分割进不同文件</h4>
<p><em>src/sound/instrument.rs</em> 中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>src/sound.rs</em> 中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> instrument;</span><br></pre></td></tr></table></figure>
<p><em>src/main.rs</em> 中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> sound;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::sound::instrument::clarinet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    sound::instrument::clarinet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-通用集合类型"><a class="header-anchor" href="#8-通用集合类型">¶</a>8. 通用集合类型</h2>
<h3 id="8-1-vector"><a class="header-anchor" href="#8-1-vector">¶</a>8.1 vector</h3>
<h4 id="新建-vector"><a class="header-anchor" href="#新建-vector">¶</a>新建 vector</h4>
<p>为了创建一个新的空 vector，可以调用 <code>Vec::new</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br></pre></td></tr></table></figure>
<p>在更实际的代码中，一旦插入值 Rust 就可以推断出想要存放的类型，所以你很少会需要这些类型注解。更常见的做法是使用初始值来创建一个 <code>Vec</code>，而且为了方便 Rust 提供了 <code>vec!</code> 宏。这个宏会根据我们提供的值来创建一个新的 <code>Vec</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h4 id="更新-vector"><a class="header-anchor" href="#更新-vector">¶</a>更新 vector</h4>
<p>对于新建一个 vector 并向其增加元素，可以使用 <code>push</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">v.push(<span class="number">5</span>);</span><br><span class="line">v.push(<span class="number">6</span>);</span><br><span class="line">v.push(<span class="number">7</span>);</span><br><span class="line">v.push(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>放入其中的所有值都是 <code>i32</code> 类型的，而且 Rust 也根据数据做出如此判断，所以不需要 <code>Vec&lt;i32&gt;</code> 注解。</p>
<h4 id="读取-vector-的元素"><a class="header-anchor" href="#读取-vector-的元素">¶</a>读取 vector 的元素</h4>
<p>有两种方法引用 vector 中储存的值，索引语法或者 <code>get</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The third element is &#123;&#125;"</span>, third);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">"The third element is &#123;&#125;"</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"There is no third element."</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个需要注意的地方：</p>
<blockquote>
<ul>
<li>我们使用索引值 <code>2</code> 来获取第三个元素，索引是从 <code>0</code> 开始的。</li>
<li>这两个不同的获取第三个元素的方式分别为：使用 <code>&amp;</code> 和 <code>[]</code> 返回一个引用；或者使用 <code>get</code> 方法以索引作为参数来返回一个 <code>Option&lt;&amp;T&gt;</code>。</li>
</ul>
</blockquote>
<p>一旦程序获取了一个有效的引用，借用检查器将会执行所有权和借用规则来确保 vector 内容的这个引用和任何其他引用保持有效。回忆一下不能在相同作用域中同时存在可变和不可变引用的规则。当我们获取了 vector 的 <strong>第一个元素</strong> 的不可变引用并尝试在 vector 末尾增加一个元素的时候，这是行不通的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = &amp;v[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">v.push(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The first element is: &#123;&#125;"</span>, first);</span><br></pre></td></tr></table></figure>
<p>编译会给出这个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow &#96;v&#96; as mutable because it is also borrowed as immutable</span><br><span class="line">  --&gt; src&#x2F;main.rs:10:5</span><br><span class="line">   |</span><br><span class="line">8  |     let first &#x3D; &amp;v[0];</span><br><span class="line">   |                  - immutable borrow occurs here</span><br><span class="line">9  |</span><br><span class="line">10 |     v.push(6);</span><br><span class="line">   |     ^^^^^^^^^ mutable borrow occurs here</span><br><span class="line">11 |</span><br><span class="line">12 |     println!(&quot;The first element is: &#123;&#125;&quot;, first);</span><br><span class="line">   |                                          ----- borrow later used here</span><br></pre></td></tr></table></figure>
<p>为什么第一个元素的引用会关心 vector 结尾的变化？不能这么做的原因是由于 vector 的工作方式：在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况。</p>
<h4 id="遍历-vector-中的元素"><a class="header-anchor" href="#遍历-vector-中的元素">¶</a>遍历 vector 中的元素</h4>
<p>使用 <code>for</code> 循环来获取 <code>i32</code> 值的 vector 中的每一个元素的不可变引用并将其打印：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以遍历可变 vector 的每一个元素的可变引用以便能改变他们：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用枚举来储存多种类型"><a class="header-anchor" href="#使用枚举来储存多种类型">¶</a>使用枚举来储存多种类型</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">    Int(<span class="built_in">i32</span>),</span><br><span class="line">    Float(<span class="built_in">f64</span>),</span><br><span class="line">    Text(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">"blue"</span>)),</span><br><span class="line">    SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h3 id="8-2-字符串"><a class="header-anchor" href="#8-2-字符串">¶</a>8.2 字符串</h3>
<h4 id="什么是字符串"><a class="header-anchor" href="#什么是字符串">¶</a>什么是字符串</h4>
<p><strong>Rust 的核心语言中只有一种字符串类型：<code>str</code>，字符串 slice，它通常以被借用的形式出现，<code>&amp;str</code>。</strong></p>
<h4 id="新建字符串"><a class="header-anchor" href="#新建字符串">¶</a>新建字符串</h4>
<p>很多 <code>Vec</code> 可用的操作在 <code>String</code> 中同样可用，从以 <code>new</code> 函数创建字符串开始：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br></pre></td></tr></table></figure>
<p>这新建了一个叫做 <code>s</code> 的空的字符串，接着我们可以向其中装载数据。通常字符串会有初始数据，因为我们希望一开始就有这个字符串。为此，可以使用 <code>to_string</code> 方法，<strong>它能用于任何实现了 <code>Display</code> trait 的类型，字符串字面值也实现了它 </strong>。</p>
<p>使用 <code>to_string</code> 方法从字符串字面值创建 <code>String</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="string">"initial contents"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = data.to_string();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法也可直接用于字符串字面值：</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">"initial contents"</span>.to_string();</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>String::from</code> 函数来从字符串字面值创建 <code>String</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"initial contents"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="更新字符串"><a class="header-anchor" href="#更新字符串">¶</a>更新字符串</h4>
<p><code>String</code> 的大小可以增长其内容也可以改变，就像可以放入更多数据来改变 <code>Vec</code> 的内容一样。另外，可以方便的使用 <code>+</code> 运算符或 <code>format!</code> 宏来拼接 <code>String</code> 值。</p>
<h5 id="使用-push-str-和-push-附加字符串"><a class="header-anchor" href="#使用-push-str-和-push-附加字符串">¶</a>使用 <code>push_str</code> 和 <code>push</code> 附加字符串</h5>
<p><code>push_str</code> 方法获取字符串 slice，因为我们<strong>并不需要获取参数的所有权</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s1 = <span class="built_in">String</span>::from(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">"bar"</span>;</span><br><span class="line">s1.push_str(s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"s2 is &#123;&#125;"</span>, s2);</span><br></pre></td></tr></table></figure>
<p><code>push</code> 方法被定义为获取一个单独的字符作为参数，并附加到 <code>String</code> 中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"lo"</span>);</span><br><span class="line">s.push(<span class="string">'l'</span>);</span><br></pre></td></tr></table></figure>
<h5 id="使用-运算符或-format-宏拼接字符串"><a class="header-anchor" href="#使用-运算符或-format-宏拼接字符串">¶</a>使用 <code>+</code> 运算符或 <code>format!</code> 宏拼接字符串</h5>
<p>通常你会希望将两个已知的字符串合并在一起。一种办法是像这样使用 <code>+</code> 运算符：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"Hello, "</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"world!"</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = s1 + &amp;s2; <span class="comment">// 注意 s1 被移动了，不能继续使用</span></span><br></pre></td></tr></table></figure>
<h4 id="索引字符串"><a class="header-anchor" href="#索引字符串">¶</a>索引字符串</h4>
<p>Rust 的字符串不支持索引。</p>
<h5 id="内部表现"><a class="header-anchor" href="#内部表现">¶</a>内部表现</h5>
<p><code>String</code> 是一个 <code>Vec&lt;u8&gt;</code> 的封装。为了避免返回意想不到值并造成不能立刻发现的 bug。Rust 选择不编译这些代码并及早杜绝了误会的发生。</p>
<h5 id="字节、标量值和字形簇！天呐！"><a class="header-anchor" href="#字节、标量值和字形簇！天呐！">¶</a>字节、标量值和字形簇！天呐！</h5>
<p>最后一个 Rust 不允许使用索引获取 <code>String</code> 字符的原因是索引操作预期总是需要常数时间 (O(1))。但是对于 <code>String</code> 不可能保证这样的性能，因为 Rust 不得不检查从字符串的开头到索引位置的内容来确定这里有多少有效的字符。</p>
<h4 id="字符串-slice"><a class="header-anchor" href="#字符串-slice">¶</a>字符串 slice</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">"Здравствуйте"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>这里，<code>s</code> 会是一个 <code>&amp;str</code>，它包含字符串的头四个字节。早些时候，我们提到了这些字母都是两个字节长的，所以这意味着 <code>s</code> 将会是 “Зд”。</p>
<p>如果获取 <code>&amp;hello[0..1]</code> 会发生什么呢？答案是：在运行时会 <code>panic</code>，就跟访问 vector 中的无效索引时一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread &#39;main&#39; panicked at &#39;byte index 1 is not a char boundary; it is inside &#39;З&#39; (bytes 0..2) of &#96;Здравствуйте&#96;&#39;, src&#x2F;libcore&#x2F;str&#x2F;mod.rs:2188:4</span><br></pre></td></tr></table></figure>
<h4 id="遍历字符串的方法"><a class="header-anchor" href="#遍历字符串的方法">¶</a>遍历字符串的方法</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">"नमस्ते"</span>.chars() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码会打印出如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">न</span><br><span class="line">म</span><br><span class="line">स</span><br><span class="line">्</span><br><span class="line">त</span><br><span class="line">े</span><br></pre></td></tr></table></figure>
<p><code>bytes</code> 方法返回每一个原始字节，这可能会适合你的使用场景：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">"नमस्ते"</span>.bytes() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码会打印出组成 <code>String</code> 的 18 个字节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">224</span><br><span class="line">164</span><br><span class="line">&#x2F;&#x2F; --snip--</span><br><span class="line">165</span><br><span class="line">135</span><br></pre></td></tr></table></figure>
<h3 id="8-3-哈希-map"><a class="header-anchor" href="#8-3-哈希-map">¶</a>8.3 哈希 map</h3>
<h4 id="新建一个哈希-map"><a class="header-anchor" href="#新建一个哈希-map">¶</a>新建一个哈希 map</h4>
<p>可以使用 <code>new</code> 创建一个空的 <code>HashMap</code>，并使用 <code>insert</code> 增加元素：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>另一个构建哈希 map 的方法是使用一个元组的 vector 的 <code>collect</code> 方法，其中每个元组包含一个键值对。<code>collect</code> 方法可以将数据收集进一系列的集合类型，包括 <code>HashMap</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> teams  = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)];</span><br><span class="line"><span class="keyword">let</span> initial_scores = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();</span><br></pre></td></tr></table></figure>
<p>这里 <code>HashMap&lt;_, _&gt;</code> 类型注解是必要的，因为可能 <code>collect</code> 很多不同的数据结构，而除非显式指定否则 Rust 无从得知你需要的类型。但是对于键和值的类型参数来说，可以使用下划线占位，而 Rust 能够根据 vector 中数据的类型推断出 <code>HashMap</code> 所包含的类型。</p>
<h4 id="哈希-map-和所有权"><a class="header-anchor" href="#哈希-map-和所有权">¶</a>哈希 map 和所有权</h4>
<p>对于像 <code>i32</code> 这样的实现了 <code>Copy</code> trait 的类型，其值可以拷贝进哈希 map。对于像 <code>String</code> 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> field_name = <span class="built_in">String</span>::from(<span class="string">"Favorite color"</span>);</span><br><span class="line"><span class="keyword">let</span> field_value = <span class="built_in">String</span>::from(<span class="string">"Blue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">map.insert(field_name, field_value);</span><br><span class="line"><span class="comment">// 这里 field_name 和 field_value 不再有效，</span></span><br><span class="line"><span class="comment">// 尝试使用它们看看会出现什么编译错误！</span></span><br></pre></td></tr></table></figure>
<h4 id="访问哈希-map-中的值"><a class="header-anchor" href="#访问哈希-map-中的值">¶</a>访问哈希 map 中的值</h4>
<p>可以通过 <code>get</code> 方法并提供对应的键来从哈希 map 中获取值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> team_name = <span class="built_in">String</span>::from(<span class="string">"Blue"</span>);</span><br><span class="line"><span class="keyword">let</span> score = scores.get(&amp;team_name);</span><br></pre></td></tr></table></figure>
<p>这里，<code>score</code> 是与蓝队分数相关的值，应为 <code>Some(10)</code>。因为 <code>get</code> 返回 <code>Option&lt;V&gt;</code>，所以结果被装进 <code>Some</code>；如果某个键在哈希 map 中没有对应的值，<code>get</code> 会返回 <code>None</code>。</p>
<h4 id="更新哈希-map"><a class="header-anchor" href="#更新哈希-map">¶</a>更新哈希 map</h4>
<h5 id="覆盖一个值"><a class="header-anchor" href="#覆盖一个值">¶</a>覆盖一个值</h5>
<p><strong>如果我们插入了一个键值对，接着用相同的键插入一个不同的值，与这个键相关联的旧值将被替换：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br></pre></td></tr></table></figure>
<p>这会打印出 <code>{&quot;Blue&quot;: 25}</code>。原始的值 <code>10</code> 则被覆盖了。</p>
<h5 id="只在键没有对应值时插入"><a class="header-anchor" href="#只在键没有对应值时插入">¶</a>只在键没有对应值时插入</h5>
<p>我们经常会检查某个特定的键是否有值，如果没有就插入一个值。为此哈希 map 有一个特有的 API，叫做 <code>entry</code>，它获取我们想要检查的键作为参数。<code>entry</code> 函数的返回值是一个枚举，<code>Entry</code>，它代表了可能存在也可能不存在的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br></pre></td></tr></table></figure>
<p><code>Entry</code> 的 <code>or_insert</code> 方法在键对应的值存在时就返回这个值的 <code>Entry</code>，如果不存在则将参数作为新值插入并返回修改过的 <code>Entry</code>。这比编写自己的逻辑要简明的多，另外也与借用检查器结合得更好。</p>
<h5 id="根据旧值更新一个值"><a class="header-anchor" href="#根据旧值更新一个值">¶</a>根据旧值更新一个值</h5>
<p>另一个常见的哈希 map 的应用场景是找到一个键对应的值并根据旧的值更新它。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">"hello world wonderful world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = map.entry(word).or_insert(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, map);</span><br></pre></td></tr></table></figure>
<h2 id="9-错误处理"><a class="header-anchor" href="#9-错误处理">¶</a>9. 错误处理</h2>
<h3 id="9-1-panic-与不可恢复的错误"><a class="header-anchor" href="#9-1-panic-与不可恢复的错误">¶</a>9.1 <code>panic!</code> 与不可恢复的错误</h3>
<h4 id="对应-panic-时的栈展开或终止"><a class="header-anchor" href="#对应-panic-时的栈展开或终止">¶</a>对应 panic 时的栈展开或终止</h4>
<p>当出现 panic 时，程序默认会开始 <strong>展开</strong>（<em>unwinding</em>），这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。另一种选择是直接 <strong>终止</strong>（<em>abort</em>），这会不清理数据就退出程序。那么程序所使用的内存需要由操作系统来清理。如果你需要项目的最终二进制文件越小越好，panic 时通过在 <em>Cargo.toml</em> 的 <code>[profile]</code> 部分增加 <code>panic = 'abort'</code>，可以由展开切换为终止。例如，如果你想要在release模式中 panic 时直接终止：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">'abort'</span></span><br></pre></td></tr></table></figure>
<h4 id="使用-panic-的-backtrace"><a class="header-anchor" href="#使用-panic-的-backtrace">¶</a>使用 <code>panic!</code> 的 backtrace</h4>
<p>我们可以设置 <code>RUST_BACKTRACE</code> 环境变量来得到一个 backtrace <em>backtrace</em> 是一个执行到目前位置所有被调用的函数的列表。</p>
<p>你实际看到的输出可能因不同的操作系统和 Rust 版本而有所不同。为了获取带有这些信息的 backtrace，必须启用 debug 标识。当不使用 <code>--release</code> 参数运行 cargo build 或 cargo run 时 debug 标识会默认启用。</p>
<h4 id="失败时-panic-的简写：unwrap-和-expect"><a class="header-anchor" href="#失败时-panic-的简写：unwrap-和-expect">¶</a>失败时 panic 的简写：<code>unwrap</code> 和 <code>expect</code></h4>
<p><code>unwrap</code> 实现就类似于 <code>match</code> 语句。如果 <code>Result</code> 值是成员 <code>Ok</code>，<code>unwrap</code> 会返回 <code>Ok</code> 中的值。如果 <code>Result</code> 是成员 <code>Err</code>，<code>unwrap</code> 会为我们调用 <code>panic!</code>。这里是一个实践 <code>unwrap</code> 的例子：</p>
<p>如果调用这段代码时不存在 <em>hello.txt</em> 文件，我们将会看到一个 <code>unwrap</code> 调用 <code>panic!</code> 时提供的错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread &#39;main&#39; panicked at &#39;called &#96;Result::unwrap()&#96; on an &#96;Err&#96; value: Error &#123;</span><br><span class="line">repr: Os &#123; code: 2, message: &quot;No such file or directory&quot; &#125; &#125;&#39;,</span><br><span class="line">src&#x2F;libcore&#x2F;result.rs:906:4</span><br></pre></td></tr></table></figure>
<p>还有另一个类似于 <code>unwrap</code> 的方法它还允许我们选择 <code>panic!</code> 的错误信息：<code>expect</code>。使用 <code>expect</code> 而不是 <code>unwrap</code> 并提供一个好的错误信息可以表明你的意图并更易于追踪 panic 的根源。<code>expect</code> 的语法看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>).expect(<span class="string">"Failed to open hello.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread &#39;main&#39; panicked at &#39;Failed to open hello.txt: Error &#123; repr: Os &#123; code:</span><br><span class="line">2, message: &quot;No such file or directory&quot; &#125; &#125;&#39;, src&#x2F;libcore&#x2F;result.rs:906:4</span><br></pre></td></tr></table></figure>
<h4 id="传播错误的简写："><a class="header-anchor" href="#传播错误的简写：">¶</a>传播错误的简写：<code>?</code></h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(<span class="string">"hello.txt"</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    f.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>Result</code> 的值是 <code>Ok</code>，这个表达式将会返回 <code>Ok</code> 中的值而程序将继续执行。如果值是 <code>Err</code>，<code>Err</code> 中的值将作为整个函数的返回值，就好像使用了 return 关键字一样，这样错误值就被传播给了调用者。</p>
<blockquote>
<p><code>?</code> 所使用的错误值被传递给了 from 函数，它定义于标准库的 <code>From</code> trait 中，其用来将错误从一种类型转换为另一种类型。当 <code>?</code> 调用 <code>from</code> 函数时，收到的错误类型被转换为定义为当前函数返回的错误类型。</p>
</blockquote>
<p><code>?</code> 消除了大量样板代码并使得函数的实现更简单。我们甚至可以在 <code>?</code> 之后直接使用链式方法调用来进一步缩短代码，：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line"></span><br><span class="line">    File::open(<span class="string">"hello.txt"</span>)?.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至还有一个更短的写法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::read_to_string(<span class="string">"hello.txt"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将文件读取到一个字符串是相当常见的操作，所以 Rust 提供了名为 <code>fs::read_to_string</code> 的函数，它会打开文件、新建一个 <code>String</code>、读取文件的内容，并将内容放入 <code>String</code>，接着返回它。当然，这样做就没有展示所有这些错误处理的机会了，所以我们最初就选择了艰苦的道路。</p>
<h4 id="只能被用于返回-Result-的函数"><a class="header-anchor" href="#只能被用于返回-Result-的函数">¶</a><code>?</code> 只能被用于返回 <code>Result</code> 的函数</h4>
<p><code>?</code> 只能被用于返回值类型为 <code>Result</code> 的函数。<br>
在 <code>main</code> 函数中使用 <code>?</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>)?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会得到如下错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: the &#96;?&#96; operator can only be used in a function that returns &#96;Result&#96; or &#96;Option&#96; (or another type that implements &#96;std::ops::Try&#96;)</span><br><span class="line"> --&gt; src&#x2F;main.rs:4:13</span><br><span class="line">  |</span><br><span class="line">4 |     let f &#x3D; File::open(&quot;hello.txt&quot;)?;</span><br><span class="line">  |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the &#96;?&#96; operator in a function that returns &#96;()&#96;</span><br><span class="line">  |</span><br><span class="line">  &#x3D; help: the trait &#96;std::ops::Try&#96; is not implemented for &#96;()&#96;</span><br><span class="line">  &#x3D; note: required by &#96;std::ops::Try::from_error&#96;</span><br></pre></td></tr></table></figure>
<p>不过 <code>main</code> 函数可以返回一个 <code>Result&lt;T, E&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-泛型、trait-与生命周期"><a class="header-anchor" href="#10-泛型、trait-与生命周期">¶</a>10. 泛型、trait 与生命周期</h2>
<h3 id="10-1-泛型数据类型"><a class="header-anchor" href="#10-1-泛型数据类型">¶</a>10.1 泛型数据类型</h3>
<h4 id="方法定义中的泛型"><a class="header-anchor" href="#方法定义中的泛型">¶</a>方法定义中的泛型</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p.x = &#123;&#125;"</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意必须在 <code>impl</code> 后面声明 <code>T</code>，这样就可以在 <code>Point&lt;T&gt;</code> 上实现的方法中使用它了。在 <code>impl</code> 之后声明泛型 <code>T</code> ，这样 Rust 就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型。</p>
<p>例如，可以选择为 <code>Point&lt;f32&gt;</code> 实例实现方法，而不是为泛型 <code>Point</code> 实例。下面示例展示了一个没有在 <code>impl</code> 之后（的尖括号）声明泛型的例子，这里使用了一个具体类型，<code>f32</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Point&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">distance_from_origin</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.powi(<span class="number">2</span>) + <span class="keyword">self</span>.y.powi(<span class="number">2</span>)).sqrt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-trait：定义共享的行为"><a class="header-anchor" href="#10-2-trait：定义共享的行为">¶</a>10.2 trait：定义共享的行为</h3>
<h4 id="为类型实现-trait"><a class="header-anchor" href="#为类型实现-trait">¶</a>为类型实现 trait</h4>
<blockquote>
<p>实现 trait 时需要注意的是，只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait。例如，可以为多媒体聚合库 crate 的自定义类型 <code>Tweet</code> 实现如标准库中的 <code>Display</code> trait，这是因为 <code>Tweet</code> 类型位于多媒体聚合库 crate 本地的作用域中。类似地，也可以在多媒体聚合库 crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Summary</code>，这是因为 <code>Summary</code> trait 位于多媒体聚合库 crate 本地作用域中。</p>
</blockquote>
<blockquote>
<p>但是不能为外部类型实现外部 trait。例如，不能在多媒体聚合库 crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Display</code> trait。这是因为 <code>Display</code> 和 Vec<T> 都定义于标准库中，它们并不位于多媒体聚合库的 crate 本地作用域中。这个限制是被称为 <strong>相干性</strong>（<em>coherence</em>） 的程序属性的一部分，或者更具体的说是 <strong>孤儿规则</strong>（<em>orphan rule</em>），其得名于不存在父类型。这条规则确保了其他人编写的代码不会破坏你代码，反之亦然。没有这条规则的话，两个 crate 可以分别对相同类型实现相同的 trait，而 Rust 将无从得知应该使用哪一个实现。</p>
</blockquote>
<h4 id="默认实现"><a class="header-anchor" href="#默认实现">¶</a>默认实现</h4>
<p>有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"(Read more...)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要对 <code>NewsArticle</code> 实例使用这个默认实现，而不是定义一个自己的实现，则可以通过 <code>impl Summary for NewsArticle {}</code> 指定一个空的 <code>impl</code> 块。</p>
<blockquote>
<p>注意无法从相同方法的重载实现中调用默认方法。</p>
</blockquote>
<h4 id="trait-作为参数"><a class="header-anchor" href="#trait-作为参数">¶</a>trait 作为参数</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>notify</code> 函数体中，可以调用任何来自 <code>Summary</code> trait 的方法，比如 <code>summarize</code>。</p>
<h5 id="Trait-Bounds"><a class="header-anchor" href="#Trait-Bounds">¶</a>Trait Bounds</h5>
<p><code>impl Trait</code> 语法适用于短小的例子，它不过是一个较长形式的语法糖。这被称为 <em>trait bound</em>，这看起来像：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然 <code>impl Trait</code> 适用于短小的例子，trait bound 则适用于更复杂的场景。例如，比如需要获取两个实现了 <code>Summary</code> 的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item1: <span class="keyword">impl</span> Summary, item2: <span class="keyword">impl</span> Summary) &#123;</span><br></pre></td></tr></table></figure>
<p>这适用于 <code>item1</code> 和 <code>item2</code> 允许是不同类型的情况（只要它们都实现了 <code>Summary</code>）。不过如果你希望强制它们都是相同类型呢？这只有在使用 trait bound 时才有可能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item1: T, item2: T) &#123;</span><br></pre></td></tr></table></figure>
<h5 id="通过-指定多个-trait"><a class="header-anchor" href="#通过-指定多个-trait">¶</a>通过 <code>+</code> 指定多个 trait</h5>
<p>如果 <code>notify</code> 需要显示 <code>item</code> 的格式化形式，同时也要使用 <code>summarize</code> 方法，那么 <code>item</code> 就需要同时实现两个不同的 trait：<code>Display</code> 和 <code>Summary</code>。这可以通过 <code>+</code> 语法实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary + Display) &#123;</span><br></pre></td></tr></table></figure>
<p>这个语法也适用于泛型的 trait bound：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display&gt;(item: T) &#123;</span><br></pre></td></tr></table></figure>
<h5 id="通过-where-简化代码"><a class="header-anchor" href="#通过-where-简化代码">¶</a>通过 <code>where</code> 简化代码</h5>
<p>Rust 有另一个在函数签名之后的 <code>where</code> 从句中指定 trait bound 的语法。所以除了这么写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: T, u: U) -&gt; <span class="built_in">i32</span> &#123;</span><br></pre></td></tr></table></figure>
<p>还可以像这样使用 <code>where</code> 从句：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T, U&gt;(t: T, u: U) -&gt; <span class="built_in">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<h4 id="返回-trait"><a class="header-anchor" href="#返回-trait">¶</a>返回 trait</h4>
<p>也可以在返回值中使用 impl Trait 语法，来返回实现了某个 trait 的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>() -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"horse_ebooks"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"of course, as you probably already know, people"</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这只适用于返回 <strong>单一类型</strong> 的情况。例如，这样就 <strong>不行</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>(switch: <span class="built_in">bool</span>) -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        NewsArticle &#123;</span><br><span class="line">            headline: <span class="built_in">String</span>::from(<span class="string">"Penguins win the Stanley Cup Championship!"</span>),</span><br><span class="line">            location: <span class="built_in">String</span>::from(<span class="string">"Pittsburgh, PA, USA"</span>),</span><br><span class="line">            author: <span class="built_in">String</span>::from(<span class="string">"Iceburgh"</span>),</span><br><span class="line">            content: <span class="built_in">String</span>::from(<span class="string">"The Pittsburgh Penguins once again are the best</span></span><br><span class="line"><span class="string">            hockey team in the NHL."</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Tweet &#123;</span><br><span class="line">            username: <span class="built_in">String</span>::from(<span class="string">"horse_ebooks"</span>),</span><br><span class="line">            content: <span class="built_in">String</span>::from(<span class="string">"of course, as you probably already know, people"</span>),</span><br><span class="line">            reply: <span class="literal">false</span>,</span><br><span class="line">            retweet: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-trait-bound-有条件地实现方法"><a class="header-anchor" href="#使用-trait-bound-有条件地实现方法">¶</a>使用 trait bound 有条件地实现方法</h4>
<p>下面示例中的类型 <code>Pair&lt;T&gt;</code> 总是实现了 <code>new</code> 方法，不过只有那些为 <code>T</code> 类型实现了 <code>PartialOrd</code> trait （来允许比较） 和 <code>Display</code> trait （来启用打印）的 <code>Pair&lt;T&gt;</code> 才会实现 <code>cmp_display</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T, y: T) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            x,</span><br><span class="line">            y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cmp_display</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is x = &#123;&#125;"</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is y = &#123;&#125;"</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以对任何实现了特定 trait 的类型有条件地实现 trait。例如，标准库为任何实现了 <code>Display</code> trait 的类型实现了 <code>ToString</code> trait。这个 <code>impl</code> 块看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> T &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对任何满足特定 trait bound 的类型实现 trait 被称为 <em>blanket implementations</em>。</p>
</blockquote>
<h3 id="10-3-生命周期与引用有效期"><a class="header-anchor" href="#10-3-生命周期与引用有效期">¶</a>10.3 生命周期与引用有效期</h3>
<h4 id="生命周期省略（Lifetime-Elision）"><a class="header-anchor" href="#生命周期省略（Lifetime-Elision）">¶</a>生命周期省略（Lifetime Elision）</h4>
<p>函数或方法的参数的生命周期被称为 <strong>输入生命周期</strong>（<em>input lifetimes</em>），而返回值的生命周期被称为 <strong>输出生命周期</strong>（<em>output lifetimes</em>）。</p>
<p>编译器采用三条规则来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误：</p>
<ol>
<li>每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>，有两个引用参数的函数有两个不同的生命周期参数，<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>，依此类推。</li>
<li>如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>。</li>
<li>如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那么 <code>self</code> 的生命周期被赋给所有输出生命周期参数。这使得方法更容易读写，因为只需更少的符号。</li>
</ol>
<h4 id="方法定义中的生命周期注解"><a class="header-anchor" href="#方法定义中的生命周期注解">¶</a>方法定义中的生命周期注解</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; ImportantExcerpt&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">level</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>impl</code> 之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注 <code>self</code> 引用的生命周期。</p>
<h4 id="静态生命同期"><a class="header-anchor" href="#静态生命同期">¶</a>静态生命同期</h4>
<p>这里有一种特殊的生命周期值得讨论：<code>'static</code>，其生命周期存活于整个程序期间。所有的字符串字面值都拥有 <code>'static</code> 生命周期，我们也可以选择像下面这样标注出来：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"I have a static lifetime."</span>;</span><br></pre></td></tr></table></figure>
<h4 id="结合泛型类型参数、trait-bounds-和生命周期"><a class="header-anchor" href="#结合泛型类型参数、trait-bounds-和生命周期">¶</a>结合泛型类型参数、trait bounds 和生命周期</h4>
<p>让我们简要的看一下在同一函数中指定泛型类型参数、trait bounds 和生命周期的语法！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest_with_an_announcement</span></span>&lt;<span class="symbol">'a</span>, T&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, ann: T) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span></span><br><span class="line">    <span class="keyword">where</span> T: Display</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Announcement! &#123;&#125;"</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是示例中那个返回两个字符串 slice 中较长者的 <code>longest</code> 函数，不过带有一个额外的参数 <code>ann</code>。<code>ann </code>的类型是泛型 <code>T</code>，它可以被放入任何实现了 <code>where</code> 从句中指定的 <code>Display</code> trait 的类型。这个额外的参数会在函数比较字符串 slice 的长度之前被打印出来，这也就是为什么 <code>Display</code> trait bound 是必须的。因为生命周期也是泛型，所以生命周期参数 <code>'a</code> 和泛型类型参数 <code>T</code> 都位于函数名后的同一尖括号列表中。</p>
<h2 id="11-测试"><a class="header-anchor" href="#11-测试">¶</a>11. 测试</h2>
<h3 id="11-1-编写测试"><a class="header-anchor" href="#11-1-编写测试">¶</a>11.1. 编写测试</h3>
<p>Rust 中的测试函数是用来验证非测试代码是否按照期望的方式运行的。测试函数体通常执行如下三种操作：</p>
<ol>
<li>设置任何所需的数据或状态</li>
<li>运行需要测试的代码</li>
<li>断言其结果是我们所期望的</li>
</ol>
<h4 id="测试函数剖析"><a class="header-anchor" href="#测试函数剖析">¶</a>测试函数剖析</h4>
<p>我们创建一个新的库项目 <code>adder</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new adder --lib</span><br><span class="line">     Created library `adder` project</span><br><span class="line">$ <span class="built_in">cd</span> adder</span><br></pre></td></tr></table></figure>
<p>由 cargo new 自动生成的测试模块和函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义失败信息"><a class="header-anchor" href="#自定义失败信息">¶</a>自定义失败信息</h4>
<p>让我们为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 greeting 函数的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">greeting_contains_name</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = greeting(<span class="string">"Carol"</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(</span><br><span class="line">        result.contains(<span class="string">"Carol"</span>),</span><br><span class="line">        <span class="string">"Greeting did not contain name, value was `&#123;&#125;`"</span>, result</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-should-panic-检查-panic"><a class="header-anchor" href="#使用-should-panic-检查-panic">¶</a>使用 <code>should_panic</code> 检查 panic</h4>
<p>下面示例展示了一个检查 Guess::new 是否按照我们的期望出错的测试：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Guess</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Guess &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(value: <span class="built_in">i32</span>) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Guess value must be between 1 and 100, got &#123;&#125;."</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123;</span><br><span class="line">            value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greater_than_100</span></span>() &#123;</span><br><span class="line">        Guess::new(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>#[should_panic]</code> 属性位于 <code>#[test]</code> 之后，对应的测试函数之前。<br>
一个会带有特定错误信息的 <code>panic!</code> 条件的测试：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Guess &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(value: <span class="built_in">i32</span>) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Guess value must be greater than or equal to 1, got &#123;&#125;."</span>,</span><br><span class="line">                   value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Guess value must be less than or equal to 100, got &#123;&#125;."</span>,</span><br><span class="line">                   value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123;</span><br><span class="line">            value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic(expected = <span class="meta-string">"Guess value must be less than or equal to 100"</span>)]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greater_than_100</span></span>() &#123;</span><br><span class="line">        Guess::new(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="将-Result-T-E-用于测试"><a class="header-anchor" href="#将-Result-T-E-用于测试">¶</a>将 Result&lt;T, E&gt; 用于测试</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span> &#123;</span><br><span class="line">            <span class="literal">Ok</span>(())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">Err</span>(<span class="built_in">String</span>::from(<span class="string">"two plus two does not equal four"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们将 <code>it\_works</code> 改为返回 Result。同时在函数体中，在成功时返回 <code>Ok(())</code> 而不是 <code>assert_eq!</code>，而失败时返回带有 <code>String</code> 的 <code>Err</code>。跟之前一样，这个测试可能成功或失败，不过不再通过 panic，可以通过 <code>Result&lt;T, E&gt;</code> 来判断结果。为此不能在对这些函数使用 <code>#[should_panic]</code>；而是应该返回 <code>Err</code>！</p>
<h3 id="11-2-运行测试"><a class="header-anchor" href="#11-2-运行测试">¶</a>11.2 运行测试</h3>
<h4 id="并行或连续的运行测试"><a class="header-anchor" href="#并行或连续的运行测试">¶</a>并行或连续的运行测试</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> -- --<span class="built_in">test</span>-threads=1</span><br></pre></td></tr></table></figure>
<p>这里将测试线程设置为 <code>1</code>，告诉程序不要使用任何并行机制。这也会比并行运行花费更多时间，不过在有共享的状态时，测试就不会潜在的相互干扰了。</p>
<h4 id="显示函数输出"><a class="header-anchor" href="#显示函数输出">¶</a>显示函数输出</h4>
<p>默认情况下，当测试通过时，Rust 的测试库会截获打印到标准输出的所有内容。比如在测试中调用了 <code>println!</code> 而测试通过了，我们将不会在终端看到 <code>println!</code> 的输出：只会看到说明测试通过的提示行。如果测试失败了，则会看到所有标准输出和其他错误信息：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">prints_and_returns_10</span></span>(a: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"I got the value &#123;&#125;"</span>, a);</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">this_test_will_pass</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> value = prints_and_returns_10(<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">10</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">this_test_will_fail</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> value = prints_and_returns_10(<span class="number">8</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">5</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 cargo test 将会看到这些测试的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">running 2 tests</span><br><span class="line">test tests::this_test_will_pass ... ok</span><br><span class="line">test tests::this_test_will_fail ... FAILED</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::this_test_will_fail stdout ----</span><br><span class="line">        I got the value 8</span><br><span class="line">thread &#39;tests::this_test_will_fail&#39; panicked at &#39;assertion failed: &#96;(left &#x3D;&#x3D; right)&#96;</span><br><span class="line">  left: &#96;5&#96;,</span><br><span class="line"> right: &#96;10&#96;&#39;, src&#x2F;lib.rs:19:8</span><br><span class="line">note: Run with &#96;RUST_BACKTRACE&#x3D;1&#96; for a backtrace.</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::this_test_will_fail</span><br><span class="line"></span><br><span class="line">test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out</span><br></pre></td></tr></table></figure>
<h4 id="通过指定名字来运行部分测试"><a class="header-anchor" href="#通过指定名字来运行部分测试">¶</a>通过指定名字来运行部分测试</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_two</span></span>(a: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add_two_and_two</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, add_two(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add_three_and_two</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">5</span>, add_two(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">one_hundred</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">102</span>, add_two(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="运行单个测试"><a class="header-anchor" href="#运行单个测试">¶</a>运行单个测试</h5>
<p>可以向 <code>cargo test</code> 传递任意测试的名称来只运行这个测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cargo test one_hundred</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs</span><br><span class="line">     Running target&#x2F;debug&#x2F;deps&#x2F;adder-06a75b4a1f2515e9</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::one_hundred ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out</span><br></pre></td></tr></table></figure>
<h5 id="过滤运行多个测试"><a class="header-anchor" href="#过滤运行多个测试">¶</a>过滤运行多个测试</h5>
<p>我们可以指定部分测试的名称，任何名称匹配这个名称的测试会被运行。例如，因为头两个测试的名称包含 <code>add</code>，可以通过 <code>cargo test add</code> 来运行这两个测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cargo test add</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs</span><br><span class="line">     Running target&#x2F;debug&#x2F;deps&#x2F;adder-06a75b4a1f2515e9</span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line">test tests::add_two_and_two ... ok</span><br><span class="line">test tests::add_three_and_two ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out</span><br></pre></td></tr></table></figure>
<p>这运行了所有名字中带有 <code>add</code> 的测试，也过滤掉了名为 <code>one_hundred</code> 的测试。</p>
<blockquote>
<p><strong>同时注意测试所在的模块也是测试名称的一部分，所以可以通过模块名来运行一个模块中的所有测试。</strong></p>
</blockquote>
<h4 id="忽略某些测试"><a class="header-anchor" href="#忽略某些测试">¶</a>忽略某些测试</h4>
<p>对于想要排除的测试，我们在 <code>#[test]</code> 之后增加了 <code>#[ignore]</code> 行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">expensive_test</span></span>() &#123;</span><br><span class="line">    <span class="comment">// code that takes an hour to run</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果我们只希望运行被忽略的测试，可以使用 <code>cargo test -- --ignored</code>。</p>
</blockquote>
<h3 id="11-3-测试的组织结构"><a class="header-anchor" href="#11-3-测试的组织结构">¶</a>11.3 测试的组织结构</h3>
<h4 id="单元测试"><a class="header-anchor" href="#单元测试">¶</a>单元测试</h4>
<h5 id="测试模块和-cfg-test"><a class="header-anchor" href="#测试模块和-cfg-test">¶</a>测试模块和 <code>cfg(test)</code></h5>
<p>测试模块的 <code>#[cfg(test)]</code> 注解告诉 Rust 只在执行 <code>cargo test</code> 时才编译和运行测试代码，而在运行 <code>cargo build</code> 时不这么做。</p>
<blockquote>
<p>与之对应的集成测试因为位于另一个文件夹，所以它们并不需要 <code>#[cfg(test)]</code> 注解。</p>
</blockquote>
<h5 id="测试私有函数"><a class="header-anchor" href="#测试私有函数">¶</a>测试私有函数</h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_two</span></span>(a: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    internal_adder(a, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">internal_adder</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">internal</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, internal_adder(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <code>internal_adder</code> 函数并没有标记为 <code>pub</code>，不过因为测试也不过是 Rust 代码同时 <code>tests</code> 也仅仅是另一个模块，我们完全可以在测试中导入和调用 <code>internal_adder</code>。</p>
<h4 id="集成测试"><a class="header-anchor" href="#集成测试">¶</a>集成测试</h4>
<p>在 Rust 中，集成测试对于你需要测试的库来说完全是外部的。同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 API 。为了创建集成测试，你需要先创建一个 <em>tests</em> 目录。</p>
<h5 id="tests-目录"><a class="header-anchor" href="#tests-目录">¶</a><em>tests</em> 目录</h5>
<p>为了编写集成测试，需要在项目根目录创建一个 <em>tests</em> 目录，与 <em>src</em> 同级。Cargo 知道如何去寻找这个目录中的集成测试文件。接着可以随意在这个目录中创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译。</p>
<p>创建一个 <em>tests</em> 目录，新建一个文件 <em>tests/integration_test.rs</em>。一个 <code>adder</code> crate 中函数的集成测试：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">it_adds_two</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::add_two(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与单元测试不同，我们需要在文件顶部添加 <code>use adder</code>。这是因为每一个 <em>tests</em> 目录中的测试文件都是完全独立的 crate，所以需要在每一个文件中导入库。</p>
<h2 id="12-一个I-O项目：构建命令行程序"><a class="header-anchor" href="#12-一个I-O项目：构建命令行程序">¶</a>12. 一个I/O项目：构建命令行程序</h2>
<h3 id="12-1-接受命令行参数"><a class="header-anchor" href="#12-1-接受命令行参数">¶</a>12.1. 接受命令行参数</h3>
<h4 id="读取参数"><a class="header-anchor" href="#读取参数">¶</a>读取参数</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><code>args</code> 函数和无效的 Unicode</strong><br>
注意 <code>std::env::args</code> 在其任何参数包含无效 Unicode 字符时会 panic。如果你需要接受包含无效 Unicode 字符的参数，使用 <code>std::env::args_os</code> 代替。这个函数返回 <code>OsString</code> 值而不是 <code>String</code> 值。这里出于简单考虑使用了 <code>std::env::args</code>，因为 <code>OsString</code> 值每个平台都不一样而且比 <code>String</code> 值处理起来更为复杂。</p>
</blockquote>
<h4 id="将参数保存进变量"><a class="header-anchor" href="#将参数保存进变量">¶</a>将参数保存进变量</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> query = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> filename = &amp;args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Searching for &#123;&#125;"</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"In file &#123;&#125;"</span>, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-2-读取文件"><a class="header-anchor" href="#12-2-读取文件">¶</a>12.2. 读取文件</h3>
<p>poem.txt：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I&#39;m nobody! Who are you?</span><br><span class="line">Are you nobody, too?</span><br><span class="line">Then there&#39;s a pair of us - don&#39;t tell!</span><br><span class="line">They&#39;d banish us, you know.</span><br><span class="line"></span><br><span class="line">How dreary to be somebody!</span><br><span class="line">How public, like a frog</span><br><span class="line">To tell your name the livelong day</span><br><span class="line">To an admiring bog!</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> query = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> filename = &amp;args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Searching for &#123;&#125;"</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"In file &#123;&#125;"</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(filename)</span><br><span class="line">        .expect(<span class="string">"Something went wrong reading the file"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"With text:\n&#123;&#125;"</span>, contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-3-重构以改进模块化错误处理"><a class="header-anchor" href="#12-3-重构以改进模块化错误处理">¶</a>12.3. 重构以改进模块化错误处理</h3>
<h4 id="二进制项目的关注分离"><a class="header-anchor" href="#二进制项目的关注分离">¶</a>二进制项目的关注分离</h4>
<p><code>main</code> 函数负责多个任务的组织问题在许多二进制项目中很常见。所以 Rust 社区开发出一类在 <code>main</code> 函数开始变得庞大时进行二进制程序的关注分离的指导性过程。这些过程有如下步骤：</p>
<ol>
<li>将程序拆分成 <em><a href="http://main.rs" target="_blank" rel="noopener">main.rs</a></em> 和 <em><a href="http://lib.rs" target="_blank" rel="noopener">lib.rs</a></em> 并将程序的逻辑放入 <em><a href="http://lib.rs" target="_blank" rel="noopener">lib.rs</a></em> 中。</li>
<li>当命令行解析逻辑比较小时，可以保留在 <em><a href="http://main.rs" target="_blank" rel="noopener">main.rs</a></em> 中。</li>
<li>当命令行解析开始变得复杂时，也同样将其从 <em><a href="http://main.rs" target="_blank" rel="noopener">main.rs</a></em> 提取到 <em><a href="http://lib.rs" target="_blank" rel="noopener">lib.rs</a></em> 中。</li>
<li>经过这些过程之后保留在 <code>main</code> 函数中的责任应该被限制为：
<ul>
<li>使用参数值调用命令行解析逻辑</li>
<li>设置任何其他的配置</li>
<li>调用 <em><a href="http://lib.rs" target="_blank" rel="noopener">lib.rs</a></em> 中的 <code>run</code> 函数</li>
<li>如果 <code>run</code> 返回错误，则处理这个错误</li>
</ul>
</li>
</ol>
<h4 id="提取参数解析器"><a class="header-anchor" href="#提取参数解析器">¶</a>提取参数解析器</h4>
<p>从 <code>main</code> 中提取出 <code>parse_config</code> 函数:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (query, filename) = parse_config(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Searching for &#123;&#125;"</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"In file &#123;&#125;"</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(filename)</span><br><span class="line">        .expect(<span class="string">"Something went wrong reading the file"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"With text:\n&#123;&#125;"</span>, contents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_config</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; (&amp;<span class="built_in">str</span>, &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> query = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> filename = &amp;args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    (query, filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组合配置值"><a class="header-anchor" href="#组合配置值">¶</a>组合配置值</h4>
<blockquote>
<p>将在复杂类型更为合适的场景下使用基本类型的反模式称为 <strong>基本类型偏执</strong>（<em>primitive obsession</em>）。</p>
</blockquote>
<p>下面示例展示了新定义的结构体 <code>Config</code>，它有字段 <code>query</code> 和 <code>filename</code>。我们也改变了 <code>parse_config</code> 函数来返回一个 <code>Config</code> 结构体的实例，并更新 <code>main</code> 来使用结构体字段而不是单独的变量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> config = parse_config(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Searching for &#123;&#125;"</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"In file &#123;&#125;"</span>, config.filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(config.filename)</span><br><span class="line">        .expect(<span class="string">"Something went wrong reading the file"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"With text:\n&#123;&#125;"</span>, contents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">    query: <span class="built_in">String</span>,</span><br><span class="line">    filename: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_config</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; Config &#123;</span><br><span class="line">    <span class="keyword">let</span> query = args[<span class="number">1</span>].clone();</span><br><span class="line">    <span class="keyword">let</span> filename = args[<span class="number">2</span>].clone();</span><br><span class="line"></span><br><span class="line">    Config &#123; query, filename &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>parse_config</code> 的签名表明它现在返回一个 <code>Config</code> 值。在之前的 <code>parse_config</code> 函数体中，我们返回了引用 <code>args</code> 中 <code>String</code> 值的字符串 slice，现在我们定义 <code>Config</code>来包含拥有所有权的 <code>String</code> 值。<code>main</code> 中的 <code>args</code> 变量是参数值的所有者并只允许 <code>parse_config</code> 函数借用他们，这意味着如果 <code>Config</code> 尝试获取 <code>args</code> 中值的所有权将违反 Rust 的借用规则。</p>
<h4 id="创建一个-Config-构造函数"><a class="header-anchor" href="#创建一个-Config-构造函数">¶</a>创建一个 Config 构造函数</h4>
<p>将 <code>parse_config</code> 变为 <code>Config::new</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> config = Config::new(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Searching for &#123;&#125;"</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"In file &#123;&#125;"</span>, config.filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(config.filename)</span><br><span class="line">        .expect(<span class="string">"Something went wrong reading the file"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"With text:\n&#123;&#125;"</span>, contents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">    query: <span class="built_in">String</span>,</span><br><span class="line">    filename: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Config &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; Config &#123;</span><br><span class="line">        <span class="keyword">let</span> query = args[<span class="number">1</span>].clone();</span><br><span class="line">        <span class="keyword">let</span> filename = args[<span class="number">2</span>].clone();</span><br><span class="line"></span><br><span class="line">        Config &#123; query, filename &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复错误处理"><a class="header-anchor" href="#修复错误处理">¶</a>修复错误处理</h4>
<h5 id="改善错误信息"><a class="header-anchor" href="#改善错误信息">¶</a>改善错误信息</h5>
<p>增加一个参数数量检查：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; Config &#123;</span><br><span class="line">    <span class="keyword">if</span> args.len() &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">"not enough arguments"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>
<h5 id="从-new-中返回-Result-而不是调用-panic"><a class="header-anchor" href="#从-new-中返回-Result-而不是调用-panic">¶</a>从 <code>new</code> 中返回 <code>Result</code> 而不是调用 <code>panic!</code></h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Config &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; <span class="built_in">Result</span>&lt;Config, &amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.len() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">Err</span>(<span class="string">"not enough arguments"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> query = args[<span class="number">1</span>].clone();</span><br><span class="line">        <span class="keyword">let</span> filename = args[<span class="number">2</span>].clone();</span><br><span class="line"></span><br><span class="line">        <span class="literal">Ok</span>(Config &#123; query, filename &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Config-new-调用并处理错误"><a class="header-anchor" href="#Config-new-调用并处理错误">¶</a><code>Config::new</code> 调用并处理错误</h5>
<p>如果新建 <code>Config</code> 失败则使用错误码退出：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> config = Config::new(&amp;args).unwrap_or_else(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Problem parsing arguments: &#123;&#125;"</span>, err);</span><br><span class="line">        process::exit(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>
<h4 id="从-main-提取逻辑"><a class="header-anchor" href="#从-main-提取逻辑">¶</a>从 <code>main</code> 提取逻辑</h4>
<p>下面示例展示了提取出来的 <code>run</code> 函数。目前我们只进行小的增量式的提取函数的改进：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Searching for &#123;&#125;"</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"In file &#123;&#125;"</span>, config.filename);</span><br><span class="line"></span><br><span class="line">    run(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(config: Config) &#123;</span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(config.filename)</span><br><span class="line">        .expect(<span class="string">"something went wrong reading the file"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"With text:\n&#123;&#125;"</span>, contents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>
<h5 id="从-run-函数中返回错误"><a class="header-anchor" href="#从-run-函数中返回错误">¶</a>从 <code>run</code> 函数中返回错误</h5>
<p>下面示例展示了 run 签名和函数体中的改变：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(config: Config) -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(config.filename)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"With text:\n&#123;&#125;"</span>, contents);</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们做出了三个明显的修改：</p>
<ol>
<li>将 <code>run</code> 函数的返回类型变为 R<code>esult&lt;(), Box&lt;Error&gt;&gt;</code>。之前这个函数返回 unit 类型 <code>()</code>，现在它仍然保持作为 <code>Ok</code> 时的返回值。<br>
对于错误类型，使用了 trait 对象 <code>Box&lt;dyn Error&gt;</code>（在开头使用了 <code>use</code> 语句将 <code>std::error::Error</code> 引入作用域）。目前只需知道 <code>Box&lt;dyn Error&gt;</code> 意味着函数会返回实现了 <code>Error</code> trait 的类型，不过无需指定具体将会返回的值的类型。这提供了在不同的错误场景可能有不同类型的错误返回值的灵活性。这也就是 <code>dyn</code>，它是 “动态的”（“dynamic”）的缩写。</li>
<li>第二个改变是去掉了 <code>expect</code> 调用并替换为第九章讲到的 <code>?</code>。不同于遇到错误就 <code>panic!</code>，<code>?</code> 会从函数中返回错误值并让调用者来处理它。</li>
<li>第三个修改是现在成功时这个函数会返回一个 <code>Ok</code> 值。因为 <code>run</code> 函数签名中声明成功类型返回值是 <code>()</code>，这意味着需要将 unit 类型值包装进 <code>Ok</code> 值中。<code>Ok(())</code> 一开始看起来有点奇怪，不过这样使用 <code>()</code> 是表明我们调用 <code>run</code> 只是为了它的副作用的惯用方式；它并没有返回什么有意义的值。</li>
</ol>
<h5 id="处理-main-中-run-返回的错误"><a class="header-anchor" href="#处理-main-中-run-返回的错误">¶</a>处理 <code>main</code> 中 <code>run</code> 返回的错误</h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Searching for &#123;&#125;"</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"In file &#123;&#125;"</span>, config.filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(e) = run(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Application error: &#123;&#125;"</span>, e);</span><br><span class="line"></span><br><span class="line">        process::exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只关心检测错误，所以并不需要 <code>unwrap_or_else</code> 来返回未封装的值，因为它只会是 <code>()</code>。</p>
<h4 id="将代码拆分到库-crate"><a class="header-anchor" href="#将代码拆分到库-crate">¶</a>将代码拆分到库 crate</h4>
<p>让我们将所有不是 <code>main</code> 函数的代码从 <em>src/main.rs</em> 移动到新文件 <em>src/lib.rs</em> 中：</p>
<ul>
<li><code>run</code> 函数定义</li>
<li>相关的 <code>use</code> 语句</li>
<li><code>Config</code> 的定义</li>
<li><code>Config::new</code> 函数定义</li>
</ul>
<p>现在代码还不能编译：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Config &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; <span class="built_in">Result</span>&lt;Config, &amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(config: Config) -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>minigrep</code> crate 引入 <em>src/main.rs</em> 的作用域中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> minigrep;</span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(e) = minigrep::run(config) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-6-将错误信息输出到标准错误而不是标准输出"><a class="header-anchor" href="#12-6-将错误信息输出到标准错误而不是标准输出">¶</a>12.6. 将错误信息输出到标准错误而不是标准输出</h3>
<h4 id="将错误打印到标准错误"><a class="header-anchor" href="#将错误打印到标准错误">¶</a>将错误打印到标准错误</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> config = Config::new(&amp;args).unwrap_or_else(|err| &#123;</span><br><span class="line">        eprintln!(<span class="string">"Problem parsing arguments: &#123;&#125;"</span>, err);</span><br><span class="line">        process::exit(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(e) = minigrep::run(config) &#123;</span><br><span class="line">        eprintln!(<span class="string">"Application error: &#123;&#125;"</span>, e);</span><br><span class="line"></span><br><span class="line">        process::exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>println!</code> 改为 <code>eprintln!</code> 之后，让我们再次尝试用同样的方式运行程序，不使用任何参数并通过 <code>&gt;</code> 重定向标准输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run &gt; output.txt</span><br><span class="line">Problem parsing arguments: not enough arguments</span><br></pre></td></tr></table></figure>
<p>现在我们看到了屏幕上的错误信息，同时 <em>output.txt</em> 里什么也没有，这正是命令行程序所期望的行为。<br>
如果使用不会造成错误的参数再次运行程序，不过仍然将标准输出重定向到一个文件，像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run to poem.txt &gt; output.txt</span><br></pre></td></tr></table></figure>
<p>我们并不会在终端看到任何输出，同时 <em>output.txt</em> 将会包含其结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Are you nobody, too?</span><br><span class="line">How dreary to be somebody!</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rabbituzki.com.cn/2019/03/03/Rust-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="ckidwlghi000nsgv412ys2bfv" class="article-share-link">
        分享
      </a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust/" rel="tag">Rust</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li></ul>

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2019/04/24/%E8%BF%81%E7%A7%BBWin10%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-nav-link">
        <strong class="article-nav-caption">前一篇</strong>
        <div class="article-nav-title">
          
            迁移Win10的Linux子系统
          
        </div>
      </a>
    
    
      <a href="/2019/02/23/Rust-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">Rust 程序设计语言学习笔记（一）</div>
      </a>
    
  </nav>


  

  
  
  
  

</article>
</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 六加的博客</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="六加的博客"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>



<script src="/js/ocean.js"></script>


</body>
</html>