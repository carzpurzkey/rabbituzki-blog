<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《C++ Primer （第五版）》学习笔记 -- 之三</title>
    <url>/2020/03/21/C++-Primer-%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1>C++ Primer 第五版学习笔记（三）</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="第三章-字符串、向量和数组"><a class="header-anchor" href="#第三章-字符串、向量和数组">¶</a>第三章 字符串、向量和数组</h2>
<h3 id="3-1-命名空间的-using-声明"><a class="header-anchor" href="#3-1-命名空间的-using-声明">¶</a>3.1 命名空间的 <code>using</code> 声明</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// using 声明，当我们使用名字 cin 时，从命名空间 std 中获取它</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;         <span class="comment">// 正确：cin 和 std::cin 含义相同</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i;        <span class="comment">// 错误：没有对应的 using 声明，必须使用完整的名字</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;   <span class="comment">// 正确：显式地从 std 中使用 cout</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第个名字都需要独立的-using-声明"><a class="header-anchor" href="#第个名字都需要独立的-using-声明">¶</a>第个名字都需要独立的 <code>using</code> 声明</h4>
<p>用到的每个名字都必须有自己的声明语句，而且每句话都得以分号结束。</p>
<h4 id="头文件不应该包含-using-声明"><a class="header-anchor" href="#头文件不应该包含-using-声明">¶</a>头文件不应该包含 <code>using</code> 声明</h4>
<p>这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个 <code>using</code> 声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p>
<h4 id="一点注意事项"><a class="header-anchor" href="#一点注意事项">¶</a>一点注意事项</h4>
<p>略。见 P75。</p>
<h4 id="3-1-节练习"><a class="header-anchor" href="#3-1-节练习">¶</a>3.1 节练习</h4>
<ul>
<li>
<p>练习 3.1：使用恰当的 <code>using</code> 声明重做 1.4.1 节 (第 11 页) 和 2.6.2 节 (第 67 页) 的练习。</p>
<p>解：</p>
<ul>
<li>
<p>练习 1.9：编写程序，使用 <code>while</code> 循环将 50 到 100 的整数相加。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>:<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">49</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(v &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        sum += (++v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 50 ~ 100 is "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 1.10：除了 <code>++</code> 运算符将运算对象增加 <code>1</code> 之外，还有一个递减运算符 (<code>--</code>) 实现将值减少 <code>1</code>。编写程序，使用递减运算符在循环中顺序打印 <code>10</code> 到 <code>0</code> 之间的整数。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">while</span>(v &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; --v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 1.11：编写程序，提示用户输入两个整数，打印出这两个整数所指定的范围内的所有整数。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>, <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v_start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> v_end = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter start number: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v_start;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter end number: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v_end;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"The integers between "</span></span><br><span class="line">         &lt;&lt; v_start &lt;&lt; <span class="string">" and "</span> &lt;&lt; v_end &lt;&lt; <span class="string">" are: "</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(v_end &gt;= v_start) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v_start &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++v_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 2.41：使用你自己的 <code>Sales_data</code> 类重写 1.5.1 节 (P20)、1.5.2 节 (P21) 和 1.6 节 (P22) 的练习。眼下先把 <code>Sales_data</code> 类的定义和 <code>main</code> 函数放在同一个文件里。</p>
<p>解：略。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-标准库类型-string"><a class="header-anchor" href="#3-2-标准库类型-string">¶</a>3.2 标准库类型 <code>string</code></h3>
<p>标准库类型 <code>string</code> 表示 <strong>可变长</strong> 的字符序列，<strong>使用 <code>string</code> 类型必须首先包含 <em>string</em> 头文件</strong>。作为标准库的一部分，<strong><code>string</code> 定义在命名空间 <code>std</code> 中</strong>。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>C++ 标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现者做出一些性能上的需求。因此，标准库类型对于一般应用场合来说有足够的效率。</p>
</blockquote>
<h4 id="3-2-1-定义和初始化-string-对象"><a class="header-anchor" href="#3-2-1-定义和初始化-string-对象">¶</a>3.2.1 定义和初始化 <code>string</code> 对象</h4>
<p>一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别：或者是初始值的数量不同，或者是初始值的类型不同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;               <span class="comment">// 默认初始化，s1 是一个空字符串</span></span><br><span class="line"><span class="built_in">string</span> s2 = s1;          <span class="comment">// s2 是 s1 的副本</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"hiya"</span>;      <span class="comment">// s3 是该字符串字面值的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>;      <span class="comment">// s4 的内容是 cccccccccc</span></span><br></pre></td></tr></table></figure>
<table>
    <thead>
        <tr>
            <th colspan="2" style="text-align: center">表 3.1：初始化 string 对象的方式</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>string s1</td>
            <td>默认初始化，s1 是一个空串</td>
        </tr>
        <tr>
            <td>string s2(s1)</td>
            <td>s2 是 s1 的副本</td>
        </tr>
        <tr>
            <td>string s2 = s1</td>
            <td>等价于 s2(s1)，s2 是 s1 的副本</td>
        </tr>
        <tr>
            <td>string s3("value")</td>
            <td>s3 是字面值 "value" 的副本，除了字面值最后的那个空字符外</td>
        </tr>
        <tr>
            <td>string s3 = "value"</td>
            <td>等价于 s3("value")，s3 是字面值 "value" 的副本</td>
        </tr>
        <tr>
            <td>string s4(n, 'c')</td>
            <td>把 s4 初始化为由连续 n 个字符 c 组成的串</td>
        </tr>
    </tbody>
</table>
<h5 id="直接初始化和拷贝初始化"><a class="header-anchor" href="#直接初始化和拷贝初始化">¶</a>直接初始化和拷贝初始化</h5>
<p>由第 2.2.1 节 (P39) 的学习可知：</p>
<ul>
<li><strong>如果使用等号 (<code>=</code>) 初始化一个变量，实际上执行的是 <span style="border-bottom: 3px black double">拷贝初始化</span> (copy initialization)，编译器把等号右侧的初始值拷贝到新创建的对象中去</strong>。</li>
<li>与之相反，如果不使用等号，则执行的是 <strong>直接初始化</strong> (direct initialization)。</li>
</ul>
<p>当初始值只有一个时，使用直接初始化或拷贝初始化都行。如果像上面的 <code>s4</code> 那样初始化要用到的值有多个，一般来说只能使用 <strong>直接初始化</strong> 的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hiya"</span>;     <span class="comment">// 拷贝初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(<span class="string">"hiya"</span>)</span></span>;      <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>;     <span class="comment">// 直接初始化，s7 的内容是 cccccccccc</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Elisp 学习笔记（二）</title>
    <url>/2019/10/05/Elisp-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h1>Elisp 学习笔记（二）</h1>
<h2 id="求值规则"><a class="header-anchor" href="#求值规则">¶</a>求值规则</h2>
<p>求值是 lisp 解释器的核心，理解了求值过程也就学会了 lisp 编程的一半。正因为这样，我有点担心自己说得不清楚或者理解错误，会误导了你。所以如果真想深入了解的话，还是自己看 info elisp - Evaluation 这一章吧。<br>
一个要求值的 lisp 对象被称为表达式（form）。所有的表达式可以分为三种：符号、列表和其它类型（废话）。下面一一说明各种表达式的求值规则。</p>
<ul>
<li>
<p>第一种表达式是最简单的，自求值表达式。前面说过数字、字符串、向量都是自求值表达式。还有两个特殊的符号 <code>t</code> 和 <code>nil</code> 也可以看成是自求值表达式。</p>
</li>
<li>
<p>第二种表达式是符号。符号的求值结果就是符号的值。如果它没有值，就会出现 void-variable 的错误。</p>
</li>
<li>
<p>第三种表达式是列表表达式。而列表表达式又可以根据第一个元素分为函数调用、宏调用和特殊表达式（special form）三种。列表的第一个表达式如果是一个符号，解释器会查找这个表达式的函数值。</p>
<ul>
<li>
<p>如果函数值是另一个符号，则会继续查找这个符号的函数值。这称为“symbol function indirection”。最后直到某个符号的函数值是一个 lisp 函数（lambda 表达式）、byte-code 函数、原子函数（primitive function）、宏、特殊表达式或 autoload 对象。如果不是这些类型，比如某个符号的函数值是前面出现的某个符号导致无限循环，或者某个符号函数值为空，都会导致一个错误 invalid-function。</p>
<p>这个函数显示 indirection function</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">symbol-function</span> 'car)                  <span class="comment">; =&gt; #&lt;subr car&gt;</span></span><br><span class="line">(<span class="name">fset</span> 'first 'car)                      <span class="comment">; =&gt; car</span></span><br><span class="line">(<span class="name">fset</span> 'erste 'first)                    <span class="comment">; =&gt; first</span></span><br><span class="line">(<span class="name">erste</span> '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))                        <span class="comment">; =&gt; 1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果第一个元素是一个宏对象，列表里的其它元素不会立即求值，而是根据宏定义进行扩展。如果扩展后还是一个宏调用，则会继续扩展下去，直到扩展的结果不再是一个宏调用为止。例如：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defmacro</span> cadr (<span class="name">x</span>)</span><br><span class="line">  (<span class="name">list</span> 'car (<span class="name">list</span> 'cdr x)))</span><br></pre></td></tr></table></figure>
<p>这样 <code>(cadr (assq 'handler list))</code> 扩展后成为 <code>(car (cdr (assq 'handler list)))</code>。</p>
</li>
<li>
<p>第一个元素如果是一个特殊表达式时，它的参数可能并不会全求值。这些特殊表达式通常是用于控制结构或者变量绑定。每个特殊表达式都有对应的求值规则。这在下面会提到。</p>
</li>
</ul>
</li>
</ul>
<p>最后用这个伪代码来说明一下 elisp 中的求值规则：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> (<span class="name">eval</span> exp)</span><br><span class="line">  (<span class="name">cond</span></span><br><span class="line">   ((<span class="name">numberp</span> exp) exp)</span><br><span class="line">   ((<span class="name">stringp</span> exp) exp)</span><br><span class="line">   ((<span class="name">arrayp</span> exp) exp)</span><br><span class="line">   ((<span class="name">symbolp</span> exp) (<span class="name">symbol-value</span> exp))</span><br><span class="line">   ((<span class="name">special-form-p</span> (<span class="name">car</span> exp))</span><br><span class="line">    (<span class="name">eval-special-form</span> exp))</span><br><span class="line">   ((<span class="name">fboundp</span> (<span class="name">car</span> exp))</span><br><span class="line">    (<span class="name">apply</span> (<span class="name">car</span> exp) (<span class="name">cdr</span> exp)))</span><br><span class="line">   (<span class="name">t</span></span><br><span class="line">    (<span class="name">error</span> <span class="string">"Unknown expression type -- EVAL %S"</span> exp))))</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a class="header-anchor" href="#变量">¶</a>变量</h2>
<p><strong>当同一个变量名既是全局变量也是局部变量，或者用 <code>let</code> 多层绑定，只有最里层的那个变量是有效的，用 <code>setq</code> 改变的也只是最里层的变量，而不影响外层的变量。</strong><br>
比如：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="name">progn</span></span><br><span class="line">  (<span class="name">setq</span> foo <span class="string">"I'm global variable!"</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">foo</span> <span class="number">5</span>))</span><br><span class="line">    (<span class="name">message</span> <span class="string">"foo value is: %S"</span> foo)</span><br><span class="line">    (<span class="name">let</span> (<span class="name">foo</span>)</span><br><span class="line">      (<span class="name">setq</span> foo <span class="string">"I'm local variable!"</span>)</span><br><span class="line">      (<span class="name">message</span> foo))</span><br><span class="line">    (<span class="name">message</span> <span class="string">"foo value is still: %S"</span> foo))</span><br><span class="line">  (<span class="name">message</span> foo))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外需要注意一点的是局部变量的绑定不能超过一定的层数，也就是说，你不能把 <code>foo</code> 用 <code>let</code> 绑定 10000 层。当然普通的函数是不可能写成这样的，但是递归函数就不一定了。限制层数的变量在 <code>max-specpdl-size</code> 中定义。如果你写的递归函数有这个需要的话，可以先设置这个变量的值</p>
</blockquote>
<h3 id="buffer-local-变量"><a class="header-anchor" href="#buffer-local-变量">¶</a>buffer-local 变量</h3>
<p>emacs 能有如此丰富的模式，各个缓冲区之间能不相互冲突，很大程度上要归功于 buffer-local 变量。<br>
声明一个 buffer-local 的变量可以用 <code>make-variable-buffer-local</code> 或用 <code>make-local-variable</code>。这两个函数的区别在于前者是相当于在所有缓冲区中都产生一个 buffer-local 的变量。而后者只在声明时所在的缓冲区内产生一个局部变量，而其它缓冲区仍然使用的是全局变量。一般来说推荐使用 <code>make-local-variable</code>。</p>
<ul>
<li>
<p><code>with-current-buffer</code> 的使用形式是</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">with-current-buffer</span> buffer</span><br><span class="line">  body)</span><br></pre></td></tr></table></figure>
<p>其中 <code>buffer</code> 可以是一个缓冲区对象，也可以是缓冲区的名字。它的作用是使其中的 <code>body</code> 表达式在指定的缓冲区里执行。</p>
</li>
<li>
<p><code>get-buffer</code> 可以用缓冲区的名字得到对应的缓冲区对象。如果没有这样名字的缓冲区会返回 <code>nil</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Emacs</tag>
        <tag>Lisp</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL 自签发配置有多域名或 IP 地址的证书</title>
    <url>/2020/02/19/OpenSSL-%E8%87%AA%E7%AD%BE%E5%8F%91%E9%85%8D%E7%BD%AE%E6%9C%89%E5%A4%9A%E5%9F%9F%E5%90%8D%E6%88%96-IP-%E5%9C%B0%E5%9D%80%E7%9A%84%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h1>OpenSSL 自签发配置有多域名或 IP 地址的证书</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2>
<p>HTTPS 服务是工作在 SSL/TLS上 的 HTTP。<br>
首先简单区分一下 HTTPS、SSL 、TLS 和 OpenSSL 这四者的关系：</p>
<ul>
<li>SSL：（Secure Socket Layer，安全套接字层）是在客户端和服务器之间建立一条 SSL 安全通道的安全协议；</li>
<li>TLS：（Transport Layer Security，传输层安全协议），用于两个应用程序之间提供保密性和数据完整性；</li>
<li>TLS 的前身是 SSL；</li>
<li>OpenSSL 是 TLS/SSL 协议的开源实现，提供开发库和命令行程序；</li>
<li>HTTPS 是 HTTP 的加密版，底层使用的加密协议是 TLS。</li>
</ul>
<p>结论：SSL/TLS 是协议，OpenSSL 是协议的代码实现。</p>
<h3 id="用-OpenSSL-配置带有-SubjectAltName-的-SSL-请求"><a class="header-anchor" href="#用-OpenSSL-配置带有-SubjectAltName-的-SSL-请求">¶</a>用 OpenSSL 配置带有 SubjectAltName 的 SSL 请求</h3>
<p>对于多域名，只需要一个证书就可以保护非常多的域名。</p>
<p>SubjectAltName 是 X509 Version 3 (RFC 2459) 的扩展，允许 SSL 证书指定多个可以匹配的名称。</p>
<p>SubjectAltName 可以包含 Email 地址，IP 地址，正则匹配 DNS 主机名，等等。SSL 这样的一个特性叫做：SubjectAlternativeName（简称：SAN）。</p>
<h2 id="第一部分-生成证书"><a class="header-anchor" href="#第一部分-生成证书">¶</a>第一部分 生成证书</h2>
<h3 id="第一步-生成证书请求文件"><a class="header-anchor" href="#第一步-生成证书请求文件">¶</a>第一步 生成证书请求文件</h3>
<p>对于一个通用的 SSL 证书请求文件（CSR），OpenSSL 不需要很多操作。因为我们可能需要添加一个或者两个 SAN 到我们 CSR，我们需要在 OpenSSL 配置文件中添加一些东西：你需要告诉 OpenSSL 创建一个包含 x509 V3 扩展的 CSR，并且你也需要告诉 OpenSSL 在你的 CSR 中包含 SubjectAlternativeNames 列表。</p>
<p>创建一个<code>OpenSSL</code>配置文件（<em>openssl.cnf</em>），并启用 SubjectAlternativeNames：</p>
<ol>
<li>
<p>找到 <code>req</code> 段落。这段落的内容将会告诉 OpenSSL如何去处理证书请求（CSR）。</p>
</li>
<li>
<p>在 <code>req</code> 段落中应该要包含一个以 <code>req_extensions</code> 开始的行。如下：</p>
 <figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[req]</span></span><br><span class="line"><span class="attr">distinguished_name</span> = req_distinguished_name</span><br><span class="line"><span class="attr">req_extensions</span> = v3_req</span><br></pre></td></tr></table></figure>
<p>这个配置是告诉  OpenSSL 在 CSR 中要包含 <code>v3_req</code> 段落的部分。</p>
</li>
<li>
<p>现在我们来配置 <code>v3_req</code>，如下：</p>
 <figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[req_distinguished_name]</span></span><br><span class="line"><span class="attr">countryName</span> = Country Name (<span class="number">2</span> letter code)</span><br><span class="line"><span class="attr">countryName_default</span> = US</span><br><span class="line"><span class="attr">stateOrProvinceName</span> = State or Province Name (full name)</span><br><span class="line"><span class="attr">stateOrProvinceName_default</span> = MN</span><br><span class="line"><span class="attr">localityName</span> = Locality Name (eg, city)</span><br><span class="line"><span class="attr">localityName_default</span> = Minneapolis</span><br><span class="line"><span class="attr">organizationalUnitName</span>  = Organizational Unit Name (eg, section)</span><br><span class="line"><span class="attr">organizationalUnitName_default</span>  = Domain Control Validated</span><br><span class="line"><span class="attr">commonName</span> = Internet Widgits Ltd</span><br><span class="line"><span class="attr">commonName_max</span>  = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ v3_req ]</span></span><br><span class="line"><span class="comment"># Extensions to add to a certificate request</span></span><br><span class="line"><span class="attr">basicConstraints</span> = CA:<span class="literal">FALSE</span></span><br><span class="line"><span class="attr">keyUsage</span> = nonRepudiation, digitalSignature, keyEncipherment</span><br><span class="line"><span class="attr">subjectAltName</span> = @alt_names</span><br><span class="line"></span><br><span class="line"><span class="section">[alt_names]</span></span><br><span class="line"><span class="attr">DNS.1</span> = kb.example.com</span><br><span class="line"><span class="attr">DNS.2</span> = helpdesk.example.org</span><br><span class="line"><span class="attr">DNS.3</span> = systems.example.net</span><br><span class="line"><span class="attr">IP.1</span> = <span class="number">192.168</span>.<span class="number">1.1</span></span><br><span class="line"><span class="attr">IP.2</span> = <span class="number">192.168</span>.<span class="number">69.14</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>无论 <code>v3_req</code> 放哪里，都是可以的，都会在所有生成的 CSR 中。<br>
要是之后，你又想生成一个不同的 SAN 的 CSR 文件，你需要编辑这个配置文件，并改变 <code>DNS.x</code> 列表。</p>
</blockquote>
</li>
</ol>
<h3 id="第二步-生成私钥"><a class="header-anchor" href="#第二步-生成私钥">¶</a>第二步 生成私钥</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out san_domain_com.key 2048</span><br><span class="line"><span class="comment"># 如果是生成 ca 的使用，建议这样</span></span><br><span class="line">openssl genrsa -out ca.key 2048</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>这里的 <code>san_domain_com</code>，是你正式使用的服务器的全称地址，这不是必须的，也就是说，你可以随便取名字；但是按照这个格式去，会更清晰点。</p>
</blockquote>
<h3 id="第三步-创建-CSR-文件"><a class="header-anchor" href="#第三步-创建-CSR-文件">¶</a>第三步 创建 CSR 文件</h3>
<ol>
<li>
<p>执行下面语句：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -new -out san_domain_com.csr -key san_domain_com.key -config openssl.cnf</span><br><span class="line"><span class="comment"># 注意这里指定了openssl.cnf，使用了上面我们创建的，因为默认是没有`san`。</span></span><br><span class="line"><span class="comment"># 如果之前创建的是ca.key</span></span><br><span class="line">openssl req -new -out ca.csr -key ca.key -config openssl.cnf</span><br></pre></td></tr></table></figure>
<p>执行后，系统会提示你要你输入组织信息，并询问你是否想要包含密码（你可以不需要）。接着你将会看到 <em>san_domain_com.csr</em> 被创建。</p>
</li>
<li>
<p>我们可以使用下面的命令来查看 CSR 包含的信息：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl req -text -noout -in san_domain_com.csr</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果是ca.csr</span></span><br><span class="line">openssl req -text -noout -in ca.csr</span><br></pre></td></tr></table></figure>
<p>你将会看到类似如下的信息：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Certificate Request:</span><br><span class="line">Data:</span><br><span class="line">Version: 0 (0x0)</span><br><span class="line">Subject: C&#x3D;US, ST&#x3D;Texas, L&#x3D;Fort Worth, O&#x3D;My Company, OU&#x3D;My Department, CN&#x3D;server.example</span><br><span class="line">Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public Key: (2048 bit)</span><br><span class="line">Modulus (2048 bit): blahblahblah</span><br><span class="line">Exponent: 65537 (0x10001)</span><br><span class="line">Attributes:</span><br><span class="line">Requested Extensions: X509v3</span><br><span class="line">Basic Constraints: CA:FALSE</span><br><span class="line">X509v3 Key Usage: Digital Signature, Non Repudiation, Key Encipherment</span><br><span class="line">X509v3 Subject Alternative Name: DNS:kb.example.com, DNS:helpdesk.example.com</span><br><span class="line">Signature Algorithm: sha1WithRSAEncryption</span><br><span class="line">blahblahblah</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="第四步-自签名并创建证书"><a class="header-anchor" href="#第四步-自签名并创建证书">¶</a>第四步 自签名并创建证书</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -<span class="keyword">in</span> san_domain_com.csr -signkey san_domain_com.key</span><br><span class="line"> -out san_domain_com.crt -extensions v3_req -extfile openssl.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是ca.csr</span></span><br><span class="line">openssl x509 -req -days 3650 -<span class="keyword">in</span> ca.csr -signkey ca.key</span><br><span class="line"> -out ca.crt -extensions v3_req -extfile openssl.cnf</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>上面的证书 有效期是 3650 天。</p>
</blockquote>
<h2 id="第二部分-使用-CA-证书签名客户端证书"><a class="header-anchor" href="#第二部分-使用-CA-证书签名客户端证书">¶</a>第二部分 使用 CA 证书签名客户端证书</h2>
<h3 id="第一步-创建客户端私钥"><a class="header-anchor" href="#第一步-创建客户端私钥">¶</a>第一步 创建客户端私钥</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out client.key 1024</span><br></pre></td></tr></table></figure>
<h3 id="第二步-创建证书请求文件-CSR"><a class="header-anchor" href="#第二步-创建证书请求文件-CSR">¶</a>第二步 创建证书请求文件 CSR</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -new -key client.key -out client.csr -config openssl.cnf -extensions v3_req</span><br></pre></td></tr></table></figure>
<h3 id="第三步-利用-ca-crt-来签署-client-csr"><a class="header-anchor" href="#第三步-利用-ca-crt-来签署-client-csr">¶</a>第三步 利用 <em>ca.crt</em> 来签署 <em>client.csr</em></h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -sha256 -extfile v3.ext -CA ca.crt -CAkey ca.key -CAcreateserial -<span class="keyword">in</span> client.csr -out client.crt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者 把v3.ext 改为 openssl.cnf</span></span><br><span class="line">openssl x509 -req -sha256 -extfile openssl.cnf -CA ca.crt -CAkey ca.key -CAcreateserial -<span class="keyword">in</span> client.csr -out client.crt</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<ol>
<li><code>sha256</code> 是哈希算法</li>
<li><code>v3.ext</code> 是要自己创建的</li>
</ol>
</blockquote>
<p><em>v3.ext</em> 内容：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">authorityKeyIdentifier</span>=keyid,issuer</span><br><span class="line"><span class="attr">basicConstraints</span>=CA:<span class="literal">FALSE</span></span><br><span class="line"><span class="attr">keyUsage</span>=digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line"><span class="attr">subjectAltName</span>=@alt_names</span><br><span class="line"></span><br><span class="line"><span class="section">[alt_names]</span></span><br><span class="line"><span class="attr">DNS.1</span>=www.test.com</span><br><span class="line"><span class="attr">IP.1</span> = <span class="number">192.168</span>.<span class="number">1.1</span></span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a class="header-anchor" href="#笔记">¶</a>笔记</h2>
<ul>
<li>第一部分生成了服务端证书和 CA 证书，CA 证书可以不用配置 <code>v3_req</code>。</li>
<li>对于服务端证书，将其导入客户端即可。</li>
<li>对于 CA 证书，使用它按第二部分步骤签名服务端证书，然后在客户端导入 CA 证书即可信任以该 CA 证书签名的网站。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 下迁移 MariaDB 数据库文件</title>
    <url>/2020/02/07/Windows-%E4%B8%8B%E8%BF%81%E7%A7%BB-MariaDB-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1>Windows 下迁移 MariaDB 数据库文件</h1>
<ol>
<li>
<p>运行 MySQL Client (MariaDB 10.4 (x64))，输入密码后登录。</p>
<p><img src="/images/Move-MariaDB-database-file-on-windows/1.PNG" alt="图1"></p>
</li>
<li>
<p>执行语句 <code>show global variables like &quot;%datadir%&quot;;</code>，查询结果中的 <code>Value</code> 列所示即为 MariaDB 数据库文件存储位置。</p>
<p><img src="/images/Move-MariaDB-database-file-on-windows/2.PNG" alt="图2"></p>
</li>
<li>
<p>停止 MariaDB 服务。</p>
<p><img src="/images/Move-MariaDB-database-file-on-windows/3.png" alt="图3"></p>
</li>
<li>
<p>进入上一步数据库文件存储路径，将以数据库名命名的文件夹及 <em>mysql</em> 文件夹和以 <em>ib</em> 开头的文件复制至将要迁移的目标目录。</p>
<p><img src="/images/Move-MariaDB-database-file-on-windows/4.PNG" alt="图4"></p>
</li>
<li>
<p>(可选) 删除原始目录中上一步相应文件。</p>
</li>
<li>
<p>启动数据库即完成迁移。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>MariaDB</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 下 138a:0090、138a:0097 和 06cb:009a 指纹识别器驱动及指纹认证</title>
    <url>/2020/07/15/Ubuntu-%E4%B8%8B-138a0090%E3%80%81138a0097-%E5%92%8C-06cb009a-%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E5%99%A8%E9%A9%B1%E5%8A%A8%E5%8F%8A%E6%8C%87%E7%BA%B9%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h1>Ubuntu 下 <code>138a:0090</code>、<code>138a:0097</code> 和 <code>06cb:009a</code> 指纹识别器驱动及指纹认证</h1>
<p><code>06cb:009a</code> (Thinkpad L480、Thinkpad L580 及 Thinkpad T480 等设备所使用的指纹设备) 在 Ubuntu 20.04 和 Kubuntu 20.04 下测试通过。</p>
<h2 id="1、安装驱动及-open-fprintd"><a class="header-anchor" href="#1、安装驱动及-open-fprintd">¶</a>1、安装驱动及 open-fprintd</h2>
<p>项目地址：<a href="https://github.com/uunicorn/python-validity" target="_blank" rel="noopener">https://github.com/uunicorn/python-validity</a></p>
<ol>
<li>
<p>卸载系统自带的 fprintd。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt remove fprintd</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加 open-fprintd 软件源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:uunicorn:open-fprintd</span><br><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装 open-fprintd、fprintd 客户端及 python3-validity (驱动程序)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install open-fprintd fprintd-clients python3-validity</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注册指纹，此处需将同一指纹进行多次录入。如要录入多个指纹，再运行此命令即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ fprintd-enroll</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>如果注册指纹报错，可能需要运行下面命令将指纹识别器重置成出厂设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/share/python3-validity/playground</span><br><span class="line">$ python3 ./factory-reset.py</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2、设置指纹登录"><a class="header-anchor" href="#2、设置指纹登录">¶</a>2、设置指纹登录</h2>
<blockquote>
<p><strong>提示</strong>：</p>
<hr>
<p>项目已更新自动注册程序，指纹登录和其它基本指纹认证 (如第三步的 <code>su</code> 和 <code>sudo</code> 认证等) 可以在 <strong>注册指纹后</strong> 使用如下命令自动添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo pam-auth-update</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Gnome “设置” -&gt; “用户” -&gt; “指纹登录” -&gt; “启用”。</p>
<h2 id="3、设置其它指纹认证"><a class="header-anchor" href="#3、设置其它指纹认证">¶</a>3、设置其它指纹认证</h2>
<ol>
<li>
<p><code>su</code> 指纹认证。</p>
<p>编辑 <em>/etc/pam.d/su</em> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/pam.d/su</span><br></pre></td></tr></table></figure>
<p>在文件开始处加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auth sufficient pam_fprintd.so</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>sudo</code> 指纹认证。</p>
<p>编辑 <em>/etc/pam.d/sudo</em> 文件：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/pam.d/sudo</span><br></pre></td></tr></table></figure>
<p>在文件开始处加入：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auth sufficient pam_fprintd.so</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><strong>常见异常</strong>：</p>
<hr>
<p>如果 <code>fprintd-enroll</code> 命令返回 <code>list_devices failed:</code> 异常，那么请使用 <code>$ sudo systemctl status python3-validity</code> 查看 python3-validity 守护进程运行状态，如果未运行，则根据状态信息选择使用 <code>$ sudo systemctl enable python3-validity</code> 或 <code>$ sudo systemctl start python3-validity</code> 启用或启动守护进程。</p>
<p>如果上一步守护进程状态显示 python3-validity 守护启动过程中发生错误，那么可能需要将指纹芯片恢复出厂设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl stop python3-validity</span><br><span class="line">$ sudo validity-sensors-firmware</span><br><span class="line">$ sudo python3 /usr/share/python-validity/playground/factory-reset.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述步骤中可以会出现"device busy"异常，此时需要根据 systemctl 状态信息杀死相关进程，或重新运行 systemctl stop python3-validity 命令以防止其已重新运行或杀死其它相关进程。</span></span><br><span class="line"></span><br><span class="line">$ sudo systemctl start python3-validity</span><br><span class="line">$ fprintd-enroll</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>疑难</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
        <tag>疑难</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 下 Wine 安装并运行微信</title>
    <url>/2020/07/15/Ubuntu-%E4%B8%8B-Wine-%E5%AE%89%E8%A3%85%E5%B9%B6%E8%BF%90%E8%A1%8C%E5%BE%AE%E4%BF%A1/</url>
    <content><![CDATA[<h1>Ubuntu 下 Wine 安装并运行微信</h1>
<ol>
<li>
<p>安装 wine：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install wine</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置 wine：</p>
<ul>
<li>
<p>运行 winecfg：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ winecfg</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>“应用程序”标签中，“Windows 版本”选择”Windows 7“。</p>
<p><img src="/images/Wine-Wechat/1.png" alt="图1"></p>
</li>
<li>
<p>”函数库“标签中，依图中所示添加函数库顶替：</p>
<p><img src="/images/Wine-Wechat/2.png" alt="图2"></p>
<blockquote>
<p><strong>说明</strong></p>
<hr>
<ul>
<li>
<p>如果不配置 riched20 和 riched32 的话则安装好后微信或 TIM 后无法输入用户名。</p>
</li>
<li>
<p>不停用 txplatform.exe 则微信或 TIM 无法完整退出，导致关掉重开后提示文件被占用。</p>
</li>
<li>
<p>禁用 ntoskrnl.exe 是为了规避可能出现微信 或 TIM 无法启动的 bug。</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>”显示“标签中，屏幕分辨率设置为 120。(可选，主要解决 hidpi 笔记本文字过小问题)</p>
<p><img src="/images/Wine-Wechat/3.png" alt="图3"></p>
</li>
<li>
<p>拷贝喜欢的中文字体至 <em>$HOME/.wine/drive_c/windows/Fonts</em> 下，以 Noto Sans CJK Regular 为例 (文件名为 <em>NotoSansCJK-Regular.ttc</em>)。</p>
</li>
<li>
<p>新建 <em>fonts.reg</em> 文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REGEDIT4</span><br><span class="line"> </span><br><span class="line">[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink]</span><br><span class="line">&quot;Lucida Sans Unicode&quot;&#x3D;&quot;NotoSansCJK-Regular.ttc&quot;</span><br><span class="line">&quot;Microsoft Sans Serif&quot;&#x3D;&quot;NotoSansCJK-Regular.ttc&quot;</span><br><span class="line">&quot;MS Sans Serif&quot;&#x3D;&quot;NotoSansCJK-Regular.ttc&quot;</span><br><span class="line">&quot;Tahoma&quot;&#x3D;&quot;NotoSansCJK-Regular.ttc&quot;</span><br><span class="line">&quot;Tahoma Bold&quot;&#x3D;&quot;NotoSansCJK-Regular.ttc&quot;</span><br><span class="line">&quot;SimSun&quot;&#x3D;&quot;NotoSansCJK-Regular.ttc&quot;</span><br><span class="line">&quot;Arial&quot;&#x3D;&quot;NotoSansCJK-Regular.ttc&quot;</span><br><span class="line">&quot;Arial Black&quot;&#x3D;&quot;NotoSansCJK-Regular.ttc&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运行 Wine 的注册表编辑器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wine regedit</span><br></pre></td></tr></table></figure>
<p>并将 <em>fonts.reg</em> 导入注册表。</p>
</li>
<li>
<p><strong>下载 Windows 7 系统的 <em>riched20.dll</em> (<span style="border-bottom: 3px black double">32 位</span>) 和  <em>riched32.dll</em> (<span style="border-bottom: 3px black double">32 位</span>)，替换 <em>$HOME/.wine/drive_c/windows/<span style="border-bottom: 3px black double">syswow64</span></em> 下同名文件。</strong></p>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>本步可解决微信输入文字无法显示的问题。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>疑难</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
        <tag>疑难</tag>
      </tags>
  </entry>
  <entry>
    <title>davfs2 自动挂载</title>
    <url>/2019/08/14/davfs%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD/</url>
    <content><![CDATA[<h1>davfs2 自动挂载</h1>
<ol>
<li>
<p>安装 davfs2，以 Ubuntu 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># apt install davfs2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将用户加入 <code>davfs2</code> 组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># usermod -aG davfs2 $USER</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建挂载点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir &#x2F;mnt&#x2F;dav</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>手动挂载一下测试：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mount -t davfs http(s):&#x2F;&#x2F;webdav.dav.com&#x2F;dav&#x2F; &#x2F;mnt&#x2F;dav</span><br><span class="line"># umount &#x2F;mnt&#x2F;dav</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果出现 <code>server does not support WebDAV</code>，则编辑文件 <em>/etc/davfs2/davfs2.conf</em>，将 <code>ignore_dav_header</code> 项设为 <code>1</code>。</p>
</blockquote>
</li>
<li>
<p>若服务器需要身份认证，则需配置 WebDAV 自动挂载时的认证信息。编辑文件 <em>/etc/davfs2/secrets</em>。加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http(s):&#x2F;&#x2F;webdav.dav.com&#x2F;dav&#x2F; username password</span><br></pre></td></tr></table></figure>
<blockquote>
<p>地址或密码中如果有空格，则需用 <code>\</code> 转义，或用双引号包裹。密码中如果有类似 <code>\</code>、<code>#</code> 和 <code>&quot;</code> 之类的特殊符号也要用 <code>\</code> 转义。</p>
</blockquote>
</li>
<li>
<p>编写 systemd 挂载脚本：</p>
<ul>
<li>
<p>mount 脚本。<em>/etc/systemd/system/mnt-dav.mount</em>：</p>
  <figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Mount WebDAV Service</span><br><span class="line"><span class="attr">After</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"><span class="attr">Wants</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Mount]</span></span><br><span class="line"><span class="attr">What</span>=http(s)://webdav.dav.com/dav/</span><br><span class="line"><span class="attr">Where</span>=/mnt/dav</span><br><span class="line"><span class="attr">Options</span>=uid=<span class="number">1000</span>,file_mode=<span class="number">0644</span>,dir_mode=<span class="number">2775</span>,grpid</span><br><span class="line"><span class="attr">Type</span>=davfs</span><br><span class="line"><span class="attr">TimoutSec</span>=<span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>automount 脚本，可选，主要用来空闲时 unmount 用。<em>/etc/systemd/system/mnt-dav.automount</em>：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Mount WebDAV Service</span><br><span class="line"><span class="attr">After</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"><span class="attr">Wants</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Automount]</span></span><br><span class="line"><span class="attr">Where</span>=/mnt/dav</span><br><span class="line"><span class="attr">TimeoutIdleSec</span>=<span class="number">300</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=remote-fs.target</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注意：mount 和 automount 脚本文件名必须和文件中的 <code>Where</code> 字段对应。</p>
</blockquote>
</li>
<li>
<p>启用 systemd 脚本：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl enable mnt-dav.mount</span><br></pre></td></tr></table></figure>
<p>​	或有 automount 脚本时：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># systemctl enable mnt-dav.automount</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>疑难</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ibus-rime设置候选词横排</title>
    <url>/2019/01/12/ibus-rime%E8%AE%BE%E7%BD%AE%E5%80%99%E9%80%89%E8%AF%8D%E6%A8%AA%E6%8E%92/</url>
    <content><![CDATA[<h1>ibus-rime 设置候选词横排</h1>
<p>************—</p>
<p>[TOC]</p>
<hr>
<ul>
<li>当ibus-setup和设置<code>gsettings set org.freedesktop.ibus.panel lookup-table-orientation 0</code>都无效时，临时办法是创建 <code>~/.config/ibus/rime/build/ibus_rime.yaml</code>，添加如下内容：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">style:</span></span><br><span class="line">    <span class="attr">horizontal:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原贴：<a href="https://www.bountysource.com/issues/67221114-ibus-rime%E3%80%82" target="_blank" rel="noopener">https://www.bountysource.com/issues/67221114-ibus-rime。</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>rime</tag>
      </tags>
  </entry>
  <entry>
    <title>mod_wsgi出现503 service temporarily unavailable解决办法</title>
    <url>/2018/10/24/mod_wsgi%E5%87%BA%E7%8E%B0503-service-temporarily-unavailable%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h1>mod_wsgi出现503 service temporarily unavailable解决办法</h1>
<hr>
<h2 id="现象"><a class="header-anchor" href="#现象">¶</a>现象</h2>
<p>前端显示：</p>
<pre><code>503 service temporarily unavailable
</code></pre>
<p>后台日志：</p>
<pre><code>[wsgi:error] [pid 21399:tid 140274344871680] (11)Resource temporarily unavailable: [client 172.68.27.190:18983] mod_wsgi (pid=21399): Unable to connect to WSGI daemon process 'site' on '/var/run/wsgi.21137.0.1.sock' after multiple attempts as listener backlog limit was exceeded.
</code></pre>
<h2 id="解决方案："><a class="header-anchor" href="#解决方案：">¶</a>解决方案：</h2>
<p>根据<a href="http://modwsgi.readthedocs.io/en/develop/configuration-directives/WSGIDaemonProcess.html" target="_blank" rel="noopener">mod_wsgi文档</a>修改相关配置，例如：</p>
<pre><code>WSGIDaemonProcess site python-path=/var/www/site:/var/www/site/env/lib/python3.6/site-packages home=/var/www/site processes=2 threads=60 graceful-timeout=30 maximum-requests=1000 restart-interval=30
</code></pre>
<blockquote>
<p><a href="https://github.com/GrahamDumpleton/mod_wsgi/issues/228" target="_blank" rel="noopener">Github原贴</a></p>
</blockquote>
<h2 id="扩展"><a class="header-anchor" href="#扩展">¶</a>扩展</h2>
<blockquote>
<p><code>listener backlog limit</code>并非表示服务器最大能够处理的连接数，服务器最大能够处理的连接数依赖于服务器所配置的最大进程或线程数。而listen backlog是告诉内核在一个socket监听队列外等待的最大连接数的一个socket配置。如果等待队列已潢，那么以后的连接请求都将被拒绝。<br>
根据uwsgi手册，可以通过<code>-l</code>选项指定listen backlog：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-l|--listen &lt;num&gt;</span><br><span class="line">   set  socket  listen queue to &lt;n&gt; (default 100, maximum is system</span><br><span class="line">   dependent)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://stackoverflow.com/questions/12340047/uwsgi-your-server-socket-listen-backlog-is-limited-to-100-connections" target="_blank" rel="noopener">stackoverflow原贴</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>疑难</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Linux</tag>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title>xfce 中 Compiz 无法自动启动时的解决方法</title>
    <url>/2019/08/14/xfce-%E4%B8%AD-Compiz%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1>xfce 中 Compiz无法自动启动时的解决方法</h1>
<ol>
<li>
<p>根据<a href="https://wiki.archlinux.org/index.php/Compiz_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Archlinux Wiki</a>配置好 Compiz 和 Emerald。</p>
</li>
<li>
<p>将 Archlinux Wiki 中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"Client0_Command"</span> <span class="attr">type</span>=<span class="string">"array"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">value</span>=<span class="string">"compiz"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"Client0_Command"</span> <span class="attr">type</span>=<span class="string">"array"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">value</span>=<span class="string">"compiz"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">value</span>=<span class="string">"ccp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>疑难</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SSH config文件</title>
    <url>/2018/10/24/%E4%BD%BF%E7%94%A8SSH-config%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1>使用SSH config文件</h1>
<hr>
<p>[TOC]</p>
<hr>
<p>ssh的介绍及使用参看：<a href="http://daemon369.github.io/ssh/2015/03/16/01-brief-introduction-for-ssh" target="_blank" rel="noopener">SSH简介</a>、<a href="http://daemon369.github.io/ssh/2015/03/08/generating-ssh-keys" target="_blank" rel="noopener">创建SSH密钥对</a>。</p>
<h2 id="配置文件"><a class="header-anchor" href="#配置文件">¶</a>配置文件</h2>
<p><code>ssh</code>程序可以从以下途径获取配置参数：</p>
<ol>
<li>命令行选项</li>
<li>用户配置文件 (~/.ssh/config)</li>
<li>系统配置文件(/etc/ssh/ssh_config)</li>
</ol>
<p>配置文件可分为多个配置区段，每个配置区段使用<code>host</code>来区分。我们可以在命令行中输入不同的<code>host</code>来加载不同的配置段。</p>
<p>对每一个配置项来说，首次获取的参数值将被采用，因此通用的设置应该放到文件的后面，特定<code>host</code>相关的配置项应放到文件的前面。</p>
<hr>
<h2 id="常用配置项"><a class="header-anchor" href="#常用配置项">¶</a>常用配置项</h2>
<p>下面介绍一些常用的<code>SSH</code>配置项：</p>
<h3 id="Host"><a class="header-anchor" href="#Host">¶</a>Host</h3>
<p><code>Host</code>配置项标识了一个配置区段。</p>
<p><code>ssh</code>配置项参数值可以使用通配符：<code>*</code>代表0～n个非空白字符，<code>?</code>代表一个非空白字符，<code>!</code>表示例外通配。</p>
<p>我们可以在系统配置文件中看到一个匹配所有<code>host</code>的默认配置区段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /etc/ssh/ssh_config | grep <span class="string">'^Host'</span></span><br><span class="line">Host *</span><br></pre></td></tr></table></figure>
<p>这里有一些默认配置项，我们可以在用户配置文件中覆盖这些默认配置。</p>
<h3 id="GlobalKnownHostsFile"><a class="header-anchor" href="#GlobalKnownHostsFile">¶</a>GlobalKnownHostsFile</h3>
<p>指定一个或多个全局认证主机缓存文件，用来缓存通过认证的远程主机的密钥，多个文件用空格分隔。默认缓存文件为：/etc/ssh/ssh_known_hosts, /etc/ssh/ssh_known_hosts2.</p>
<h3 id="HostName"><a class="header-anchor" href="#HostName">¶</a>HostName</h3>
<p>指定远程主机名，可以直接使用数字IP地址。如果主机名中包含 ‘%h’ ，则实际使用时会被命令行中的主机名替换。</p>
<h3 id="IdentityFile"><a class="header-anchor" href="#IdentityFile">¶</a>IdentityFile</h3>
<p>指定密钥认证使用的私钥文件路径。默认为 ~/.ssh/id_dsa, ~/.ssh/id_ecdsa, ~/.ssh/id_ed25519 或 ~/.ssh/id_rsa 中的一个。文件名称可以使用以下转义符：</p>
<pre><code>'%d' 本地用户目录
'%u' 本地用户名称
'%l' 本地主机名
'%h' 远程主机名
'%r' 远程用户名
</code></pre>
<p>可以指定多个密钥文件，在连接的过程中会依次尝试这些密钥文件。</p>
<h3 id="Port"><a class="header-anchor" href="#Port">¶</a>Port</h3>
<p>指定远程主机端口号，默认为 22 。</p>
<h3 id="User"><a class="header-anchor" href="#User">¶</a>User</h3>
<p>指定登录用户名。</p>
<p>UserKnownHostsFile<br>
指定一个或多个用户认证主机缓存文件，用来缓存通过认证的远程主机的密钥，多个文件用空格分隔。默认缓存文件为： ~/.ssh/known_hosts, ~/.ssh/known_hosts2.</p>
<p>还有更多参数的介绍，可以参看用户手册：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ man ssh config</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h2>
<p>以下连接为例：</p>
<pre><code>SSH 服务器： ssh.test.com
端口号： 2200
账户： user
密钥文件： ~/.ssh/id_rsa_test
</code></pre>
<p>1. 密码认证登录方式为：</p>
<pre><code>$ ssh -p 2200 -i ~/.ssh/id_rsa_test user@ssh.test.com
user@ssh.test.com's password:
</code></pre>
<p>2. 密钥认证登录方式：</p>
<pre><code>$ ssh-copy-id -i ~/.ssh/id_rsa_test user@ssh.test.com
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
user@ssh.test.com's password:

Number of key(s) added: 1

Now try logging into the machine, with:   &quot;ssh 'user@ssh.test.com'&quot;
and check to make sure that only the key(s) you wanted were added.

$ ssh user@ssh.test.com
</code></pre>
<p>3. 使用配置文件方式</p>
<p>有如下配置文件：</p>
<pre><code>$ vim ~/.ssh/config
Host sshtest
    HostName ssh.test.com
    User user
    Port 2200
    IdentityFile ~/.ssh/id_rsa_test

Host ssttest2
    HostName ssh.test2.com
    User user2
    Port 2345
    IdentityFile ~/.ssh/id_rsa_test2
</code></pre>
<p>使用配置文件登录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh sshtest</span><br></pre></td></tr></table></figure>
<h2 id="环境"><a class="header-anchor" href="#环境">¶</a>环境</h2>
<ul>
<li>Ubuntu</li>
<li>macOs High Sierra(10.13.2)</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>使用管理员权限运行 Windows Terminal 并添加“在此打开 Windows Terminal”至上下文菜单</title>
    <url>/2019/08/14/%E4%BD%BF%E7%94%A8%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E8%BF%90%E8%A1%8C-Windows-Terminal-%E5%B9%B6%E6%B7%BB%E5%8A%A0%E2%80%9C%E5%9C%A8%E6%AD%A4%E6%89%93%E5%BC%80%20-Windows-Terminal%E2%80%9D%E8%87%B3%E4%B8%8A%E4%B8%8B%E6%96%87%E8%8F%9C%E5%8D%95/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h1>使用管理员权限运行 Windows Terminal 并添加“在此打开 Windows Terminal”至上下文菜单</h1>
<h2 id="使用管理员权限运行-Windows-Terminal"><a class="header-anchor" href="#使用管理员权限运行-Windows-Terminal">¶</a>使用管理员权限运行 Windows Terminal</h2>
<ol>
<li>
<p>新建一个快捷方式。</p>
</li>
<li>
<p>在快捷方式的“位置”处填写<code>C:\Windows\system32\cmd.exe /c start /b wt</code>。</p>
<blockquote>
<p>Windows Termianl 的可执行程序的软件连接一般位于 <em>%localappdata%\Microsoft\WindowsApps\wt.exe</em></p>
</blockquote>
</li>
<li>
<p>打开快捷方式的“属性”对话框，选择“高级”，选择“以管理员身份运行”。</p>
</li>
</ol>
<h2 id="添加“在此打开-Windows-Terminal”至上下文菜单"><a class="header-anchor" href="#添加“在此打开-Windows-Terminal”至上下文菜单">¶</a>添加“在此打开 Windows Terminal”至上下文菜单</h2>
<ol>
<li>
<p>设置菜单项的图标：</p>
<ul>
<li>(1) 在注册表_HKEY_CLASSES_ROOT\Directory\Background\shell_ 下新建名为“在此打开 Windows Terminal”的项。</li>
<li>(2) 在 (1) 所建项下新建名为“Icon”的 REG_SZ 值，数值数据为图标文件或带图标的可执行文件完整目录。</li>
</ul>
</li>
<li>
<p>设置 Windows Terminal 的启动脚本：</p>
<ul>
<li>
<p>(1) 任意目录新建一个批处理脚本文件，如 <em>launchwt.bat</em>。</p>
</li>
<li>
<p>(2) 在 (1) 所建文件中输入脚本并保存：</p>
  <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> wt_powershell_dir=<span class="variable">%cd%</span></span><br><span class="line"><span class="built_in">start</span> <span class="variable">%LOCALAPPDATA%</span>\\Microsoft\\WindowsApps\\wt.exe</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>(3) 编辑 Powershell 用户配置文件 <em>~\Documents\WindowsPowershell\Microsoft.PowerShell_profile.ps1</em>：</p>
  <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="operator">-not</span> [<span class="built_in">String</span>]::IsNullOrEmpty(<span class="variable">$env:wt_powershell_dir</span>)) <span class="operator">-and</span> (<span class="built_in">Test-Path</span> <span class="variable">$env:wt_powershell_dir</span>)) &#123;</span><br><span class="line">   cd <span class="variable">$env:wt_powershell_dir</span></span><br><span class="line">   <span class="built_in">Remove-Item</span> Env:\wt_powershell_dir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>(4) 在 1.(1) 中所建项下新建名为“command”的子项，并将其下的“默认”键值的数据数值设置为 (2) 中所建批处理文件的完整路径。</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>疑难</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>关闭GNOME activity页面左边的dock</title>
    <url>/2018/10/22/%E5%85%B3%E9%97%ADGNOME-activity%E9%A1%B5%E9%9D%A2%E5%B7%A6%E8%BE%B9%E7%9A%84dock/</url>
    <content><![CDATA[<h1>关闭GNOME activity页面左边的dock</h1>
<p>************—</p>
<p>[TOC]</p>
<hr>
<ol>
<li>
<p>安装并配置“Dash to Dock”扩展。</p>
</li>
<li>
<p>编辑下面的文件：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /usr/share/gnome-shell/extensions/ubuntu-dock@ubuntu.com/extension.js</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>找到如下代码块，将其中的<code>let to_enable = true;</code>改成<code>let to_enable = false</code>：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">conditionallyenabledock</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> to_enable = <span class="literal">false</span>;</span><br><span class="line">    runningExtensions = ExtensionSystem.extensionOrder;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; runningExtensions.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runningExtensions[i] === <span class="string">"dash-to-dock@micxgx.gmail.com"</span>) &#123;</span><br><span class="line">            to_enable = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enable or disable dock depending on dock status and to_enable state</span></span><br><span class="line">    <span class="keyword">if</span> (to_enable &amp;&amp; !dockManager) &#123;</span><br><span class="line">        dockManager = <span class="keyword">new</span> Docking.DockManager();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!to_enable &amp;&amp; dockManager) &#123;</span><br><span class="line">        dockManager.destroy();</span><br><span class="line">        dockManager = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重启会话或按<code>Alt + F2</code>并键入<code>restart</code>。</p>
</li>
</ol>
<blockquote>
<p><a href="https://askubuntu.com/questions/975387/why-do-i-have-two-docks-in-ubuntu-17-10-desktop" target="_blank" rel="noopener">原贴</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>利用gitlab pages和hexo搭建一个个人博客</title>
    <url>/2018/10/24/%E5%88%A9%E7%94%A8gitlab-pages%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1>利用gitlab pages和hexo搭建一个个人博客</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="1-使用github-pages存在的问题"><a class="header-anchor" href="#1-使用github-pages存在的问题">¶</a>1. 使用github pages存在的问题</h2>
<p>目前网上有很多利用github pages和hexo搭建个人博客的教程，但是github目前拒绝了百度蜘蛛的爬取，因此如果希望自己的博客能够被百度收录，就需要采用一些别的方法托管。之前网上有一些利用coding.net进行托管共百度爬取的方法，但是最近coding.net进行了改版，在打开托管的个人pages时会强行加入一个5s的等待跳转页面，导致百度的蜘蛛无法正确爬取到博客的内容。因此，这篇文章将手把手教你如何用gitlab托管你的博客，实现让百度可以爬取你的博客内容。</p>
<h2 id="2-安装必要环境"><a class="header-anchor" href="#2-安装必要环境">¶</a>2. 安装必要环境</h2>
<p>以下操作均在windows10的环境下进行，其他的环境操作如果有问题请自行进行必要的修改。</p>
<h3 id="2-1-安装nodejs"><a class="header-anchor" href="#2-1-安装nodejs">¶</a>2.1 安装nodejs</h3>
<p>最新版的nodejs可以在这里获取，下载后直接安装即可，安装完后打开cmd，输入npm -v，如果能输出版本号则说明安装成功。</p>
<p>###2.2 安装git</p>
<p>git的安装和配置请自行百度，这里就不详细写了，这是git的<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">下载地址</a></p>
<h3 id="2-3-安装hexo"><a class="header-anchor" href="#2-3-安装hexo">¶</a>2.3 安装hexo</h3>
<p>如果已经完成了以上两步，在一个私人文件夹下打开cmd，运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>如果一切正常，在浏览器中访问http://localhost:4000/就可以看到运行在本地的博客了。</p>
<h2 id="3-将博客部署到gitlab-pages上"><a class="header-anchor" href="#3-将博客部署到gitlab-pages上">¶</a>3. 将博客部署到gitlab pages上</h2>
<h3 id="3-1-添加ssh-key"><a class="header-anchor" href="#3-1-添加ssh-key">¶</a>3.1 添加ssh-key</h3>
<p>在gitlab完成注册后，首先访问这里，向你的帐户添加ssh keys，ssh keys的生成可以参考如下的步骤，打开2.2安装的Git Bash，输入如下命令(自行替换其中的用户名和邮箱信息)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Boyuan"</span></span><br><span class="line">git config --global user.email <span class="string">"work@aiboy.pub"</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"work@aiboy.pub"</span></span><br></pre></td></tr></table></figure>
<p>最终生成的文件一般位于C:\Users\UserName.ssh文件夹下，打开id_rsa.pub，将里面的所有内容添加到这里。</p>
<h3 id="3-2-新建一个项目"><a class="header-anchor" href="#3-2-新建一个项目">¶</a>3.2 新建一个项目</h3>
<p>接着点页面右上角的+号，新建一个项目。项目名为”<a href="http://username.gitlab.io" target="_blank" rel="noopener">username.gitlab.io</a>”，其中username为你的gitlab账号用户名，项目类型选择Private</p>
<h3 id="3-3-添加-gitlab-ci-yml文件"><a class="header-anchor" href="#3-3-添加-gitlab-ci-yml文件">¶</a>3.3 添加.gitlab-ci.yml文件</h3>
<p>利用gitlab部署你的博客和github最大不同在于，在github上部署博客需要先在本地生成各种页面文件，然后再推送到github上就可以直接访问了。而使用gitlab则需要在服务器端完成生成和部署两个阶段，应该需要在项目的根目录下添加一个.gitlab-ci.yml文件用来指导服务器如何处理你提交的源文件。一个完整可用的.gitlab-ci.yml如下，当时node版本为8.11.2，具体查看<a href="https://gitlab.com/pages" target="_blank" rel="noopener">Git Pages Examples</a> 相应示例（本例是<a href="https://gitlab.com/pages/hexo" target="_blank" rel="noopener">hexo</a>）.gitlab-ci.yml文件中的node版本。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apt-get</span> <span class="string">update</span> <span class="string">-qq</span> <span class="string">&amp;&amp;</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">-y</span> <span class="string">-qq</span> <span class="string">pandoc</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">node:8.11.2</span></span><br><span class="line"><span class="attr">pages:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules/</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">  <span class="comment"># 下面这个突然不能用了</span></span><br><span class="line">  <span class="comment">#- hexo deploy</span></span><br><span class="line">  <span class="comment"># 用下面这个</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">public</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-修改站点配置文件-更换主题"><a class="header-anchor" href="#3-4-修改站点配置文件-更换主题">¶</a>3.4 修改站点配置文件&amp;更换主题</h3>
<p>这里推荐大家使用NexT主题，这也是本站目前使用的主题，具体的安装步骤可以参考这里，有一点需要注意的是，将themes\next\目录下的.git文件夹删除。<br>
下面主要还需要对项目根目录下的_config.yml进行修改</p>
<p>接下来，在项目根目录下运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@gitlab.com:feixiang/feixiang.gitlab.io.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"init blog"</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>以上第二句命令请根据自己的项目名称进行调整。<br>
完成推送后，访问你的项目主页，如果看到passed的图标，就表示构建成功了，访问https://username.gitlab.io/ 就可以看到自己刚刚建立的博客了。<br>
如果需要添加新的文章，将文章的md文件保存到source -&gt; _posts文件夹下然后重新执行推送就可以了，服务器端完成构建后，如果没有错误就会出现在你的博客页面上。<br>
到此何如在gitlab上搭建一个博客就说完了，如果想绑定自己的域名实现让百度爬取请继续往下看。</p>
<h2 id="4-绑定个人域名"><a class="header-anchor" href="#4-绑定个人域名">¶</a>4. 绑定个人域名</h2>
<h3 id="4-1-一般绑定"><a class="header-anchor" href="#4-1-一般绑定">¶</a>4.1 一般绑定</h3>
<p>修改_config.yml文件中的url地址为http://你的域名，重新提交，服务器端编译通过后，在项目主页访问Settings-&gt;Pages-&gt;New Domain，输入你的自己的域名就可以了。<a href="http://xn--username-z09lq7i01hwtdbze36ama8c426a63ntn7ctgs4q0a6hfhsvk63auq0l.gitlab.io" target="_blank" rel="noopener">然后去你的域名注册商那添加一条指向username.gitlab.io</a>. 的CNAME记录记录，输入你的域名，看看是不是可以访问了。<br>
利用百度爬虫抓取，可以看到可以成功抓取。图一是使用gatlab托管的抓取状态，图二是利用github抓取的状态。</p>
<p><img src="https://img-blog.csdn.net/20170516224527573?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ludGVyX2V2ZW5pbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="抓取1"></p>
<p><img src="https://img-blog.csdn.net/20170516224547089?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ludGVyX2V2ZW5pbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="抓取2"></p>
<h3 id="4-2-添加SSL证书"><a class="header-anchor" href="#4-2-添加SSL证书">¶</a>4.2 添加SSL证书</h3>
<ul>
<li>在腾讯云（或其它）上申请TrustAsia证书（免费一年），申请成功后下载，使用压缩包中的Nginx中的证书。</li>
<li>将Nginx中的_your.domain.com_bundle.crt的内容复制到4.1中New Pages Domain页面中的Certificate (PEM)中。<br>
将_your.domain.com.key中的内容复制到Key (PEM)中，提交。</li>
</ul>
<h3 id="4-3-验证域名归属"><a class="header-anchor" href="#4-3-验证域名归属">¶</a>4.3 验证域名归属</h3>
<p>根据Gitlab<a href="https://docs.gitlab.com/ee/user/project/pages/getting_started_part_three.html#tl-dr" target="_blank" rel="noopener">官方文档</a>分析：</p>
<ul>
<li>若域名为一级域名（可能会有其它用处，如邮件服务器等），则在域名解析处添加形如（根据Gitlab验证页面修改实际记录值）如下记录：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">From</th>
<th style="text-align:left">DNS Record</th>
<th style="text-align:left">To</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://domain.com" target="_blank" rel="noopener">domain.com</a></td>
<td style="text-align:left">A</td>
<td style="text-align:left">35.185.44.232</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://domain.com" target="_blank" rel="noopener">domain.com</a></td>
<td style="text-align:left">TXT</td>
<td style="text-align:left">gitlab-pages-verification-code=00112233445566778899aabbccddeeff</td>
</tr>
</tbody>
</table>
<ul>
<li>若域名为二级域名（仅用做Gitlab Pages，不运行其它服务），则在域名解析处添加形如（根据Gitlab验证页面修改实际记录值）如下记录：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">From</th>
<th style="text-align:left">DNS Record</th>
<th style="text-align:left">To</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://subdomain.domain.com" target="_blank" rel="noopener">subdomain.domain.com</a></td>
<td style="text-align:left">CNAME</td>
<td style="text-align:left"><a href="http://namespace.gitlab.io" target="_blank" rel="noopener">namespace.gitlab.io</a></td>
</tr>
<tr>
<td style="text-align:left">_gitlab-pages-verification-code.subdomain.domain.com</td>
<td style="text-align:left">TXT</td>
<td style="text-align:left">gitlab-pages-verification-code=00112233445566778899aabbccddeeff</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移Win10的Linux子系统</title>
    <url>/2019/04/24/%E8%BF%81%E7%A7%BBWin10%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1>问题</h1>
<p>Win10 安装的 Linux 子系统默认安装在 C 盘，对于需要在 Linux 系统中使用大文件的用户来说不方便。下面记录一种方法可以将 Linux 文件系统迁移出 C 盘。</p>
<blockquote>
<p>如果要查看 Linux 安装目录， 在文件管理器地址栏输入 <em>%localappdata%\Packages</em>，找到一个文件夹 以 <em>CanonicalGroupLimited.UbuntuonWindows</em> 开头的，就是 Linux 安装目录。Linux 文件在该目录的 <em>LocalState\rootfs</em></p>
</blockquote>
<h1>解决</h1>
<ol>
<li>
<p>查看当前用户名，我的用户名是 <strong>lingl</strong>：</p>
<p><img src="https://img-blog.csdn.net/2018091113394579?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E1NzEyOTMyNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图1"></p>
</li>
<li>
<p>在迁移目标磁盘创建一个文件夹 ，并设置权限。<br>
例如创建 <em>E:\Ubuntu.windows</em> 文件夹后，执行如下命令（lingl 替换成自己的用户名）:</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">icacls E:\Ubuntu.windows /grant <span class="string">"lingl:(OI)(CI)(F)"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下载 LxRunOffline（<a href="https://github.com/DDoSolitary/LxRunOffline/releases" target="_blank" rel="noopener">点此下载</a>）。</p>
</li>
<li>
<p><code>lxrunoffline list</code> 查看已安装的 Linux 发行版本：</p>
<p><img src="https://img-blog.csdn.net/20180911134611768?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E1NzEyOTMyNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图2"></p>
</li>
<li>
<p><code>lxrunoffline move</code> 迁移 Linux 文件：</p>
<p><img src="https://img-blog.csdn.net/20180911134740420?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E1NzEyOTMyNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图3"></p>
</li>
<li>
<p>确认迁移完成，使用 <code>lxrunoffline get-dir -n Ubuntu</code> 查看安装目录。</p>
</li>
<li>
<p>可以删除原 <em>LocalState\rootfs</em> 目录。</p>
</li>
</ol>
<blockquote>
<p>原贴地址：<a href="https://blog.csdn.net/starhosea/article/details/82624629" target="_blank" rel="noopener">https://blog.csdn.net/starhosea/article/details/82624629</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask IIS部署</title>
    <url>/2019/04/24/Flask-IIS%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1>方案一：无 virtual environment (原文链接：<a href="https://segmentfault.com/a/1190000008909201" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008909201</a>)</h1>
<h2 id="安装-IIS，启用-CGI"><a class="header-anchor" href="#安装-IIS，启用-CGI">¶</a>安装 IIS，启用 CGI</h2>
<p>在控制面板中找到打开或者关闭 Windows 功能，安装 IIS 和 CGI，如下图。</p>
<p><img src="https://image-static.segmentfault.com/525/408/525408382-58e616a6eb691_articlex" alt="图1"></p>
<h2 id="安装-URL-重写组件"><a class="header-anchor" href="#安装-URL-重写组件">¶</a>安装 URL 重写组件</h2>
<p>IIS 需要安装 URL 重写组件，这个可以通过<a href="https://www.microsoft.com/web/downloads/platform.aspx" target="_blank" rel="noopener">Microsoft Web Platform Installer</a>搜索 <code>url</code> 来安装。也可以下载<a href="https://www.iis.net/downloads/microsoft/url-rewrite" target="_blank" rel="noopener">离线安装包</a>来安装。</p>
<p><img src="https://image-static.segmentfault.com/314/450/3144503439-58e616a70556a_articlex" alt="Microsoft Web Platform Installer"></p>
<blockquote>
<p><em>注：据说 Windows10 上的 IIS 10 现在不支持 url 重写？待验证</em></p>
</blockquote>
<h2 id="安装-wfastcgi"><a class="header-anchor" href="#安装-wfastcgi">¶</a>安装 wfastcgi</h2>
<p>通过pip就可以安装：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">python <span class="literal">-m</span> pip install wfastcgi</span><br></pre></td></tr></table></figure>
<h2 id="启用-wfastcgi"><a class="header-anchor" href="#启用-wfastcgi">¶</a>启用 wfastcgi</h2>
<p>剩下的事情就只有一些配置了。首先以管理员身份运行 <code>wfastcgi-enable</code> 来在IIS上启用wfastcgi，这个命令位于_c:\python_dir\scripts_，也就是你需要确保此目录在系统的PATH里，或者你需要cd到这个目录后再执行。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd to python_dir\scripts if it is not in PATH</span></span><br><span class="line">wfastcgi<span class="literal">-enable</span></span><br></pre></td></tr></table></figure>
<p>记住命令执行成功后返回的信息：</p>
<blockquote>
<p>C:\Python34\Scripts&gt; wfastcgi-enable<br>
Applied configuration changes to section “system.webServer/fastCgi” for “MACHINE/WEBROOT/APPHOST” at configuration commit path “MACHINE/WEBROOT/APPHOST”<br>
“C:\Python34\python.exe|C:\Python34\lib\site-packages\<a href="http://wfastcgi.py" target="_blank" rel="noopener">wfastcgi.py</a>” can now be used as a FastCGI script processor<br>
“C:\Python34python.exe|C:\<a href="http://Python34libsite-packageswfastcgi.py" target="_blank" rel="noopener">Python34libsite-packageswfastcgi.py</a>” 在下文的配置文件中需要使用。</p>
</blockquote>
<blockquote>
<p>Tips:</p>
<ol>
<li>使用命令 <code>wfastcgi-disable</code> 可以将其移除。</li>
<li>待验证：如果不使用 <code>wfastcgi-enable</code> 命令配置IIS，而用下面的 web.config 配置，并在其中将 <code>C:\\Python34python.exe|C:\\Python34libsite-packageswfastcgi.py</code> 部分换成 virtual environment 的目录，便可使用 virtual environment。</li>
</ol>
</blockquote>
<h2 id="创建-web-config-文件"><a class="header-anchor" href="#创建-web-config-文件">¶</a>创建 web.config 文件</h2>
<p>下面是一个 <em>web.config</em> 文件的例子，你只需要修改对应部分就可以使用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">system.webServer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">handlers</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- scriptProcessor 的值来自命令行工具 wfastcgi-enable --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">"FlaskFastCGI"</span> <span class="attr">path</span>=<span class="string">"*"</span> <span class="attr">verb</span>=<span class="string">"*"</span> <span class="attr">modules</span>=<span class="string">"FastCgiModule"</span> <span class="attr">scriptProcessor</span>=<span class="string">"C:\Python34\python.exe|C:\Python34\lib\site-packages\wfastcgi.py"</span> <span class="attr">resourceType</span>=<span class="string">"Unspecified"</span> <span class="attr">requireAccess</span>=<span class="string">"Script"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">handlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- URL 重写中的特殊字符，比如加号+等等 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">requestFiltering</span> <span class="attr">allowDoubleEscaping</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">requestFiltering</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">security</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">system.webServer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">appSettings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Required settings --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在这里指定Falsk app在模块中的具体位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">"WSGI_HANDLER"</span> <span class="attr">value</span>=<span class="string">"hello.app"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">"PYTHONPATH"</span> <span class="attr">value</span>=<span class="string">"~/"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Optional settings --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 需要先创建日志目录，否则报错 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">"WSGI_LOG"</span> <span class="attr">value</span>=<span class="string">"C:\logs\oboeqa_web.log"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">"WSGI_RESTART_FILE_REGEX"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appSettings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置-IIS-目录及权限"><a class="header-anchor" href="#配置-IIS-目录及权限">¶</a>配置 IIS 目录及权限</h2>
<p>假设你的 Flask 程序将部署在 <em>C:\websitehello</em> 下面，那么你的目录结构大致如此。</p>
<blockquote>
<p>C:\WEBSITE<br>
└───hello<br>
              <a href="http://hello.py" target="_blank" rel="noopener">hello.py</a><br>
              web.config</p>
</blockquote>
<p>现在你需要让IIS用户拥有访问和执行你的网站脚本的权限，进入 <em>C:\website</em> 目录，执行下面两条命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cd C:\website</span><br><span class="line">icacls . /grant <span class="string">"NT AUTHORITY\IUSR:(OI)(CI)(RX)"</span></span><br><span class="line">icacls . /grant <span class="string">"Builtin\IIS_IUSRS:(OI)(CI)(RX)"</span></span><br></pre></td></tr></table></figure>
<h2 id="创建并访问你的网站"><a class="header-anchor" href="#创建并访问你的网站">¶</a>创建并访问你的网站</h2>
<p>现在你离成功只差一步之遥，打开 IIS 管理面板，新建一个网站。</p>
<p><img src="https://image-static.segmentfault.com/219/794/2197942092-58e6163fa0835_articlex" alt="图3"></p>
<p>你只需要填上网站名称，物理地址和相应的端口号，点击确认。</p>
<p><img src="https://image-static.segmentfault.com/199/581/1995815946-58e6163f99194_articlex" alt="图4"></p>
<p>打开浏览器，就可以访问你配置好的网站。如果有错误，可以去检查 <em>web.config</em> 中配置的日志文件。</p>
<p><img src="https://image-static.segmentfault.com/124/003/124003068-58e6163f7048d_articlex" alt="图5"></p>
<h2 id="简单总结"><a class="header-anchor" href="#简单总结">¶</a>简单总结</h2>
<p>写完之后发现其实要完成的步骤并不是特别复杂，但是从摸索到实践的过程确实不易。本文仅讨论了部署的主要步骤，其实真正的生产环境你要考虑的问题可能更多，比如使用 virtualenv 对网站进行隔离，安全问题，静态文件解析等等。</p>
<h2 id="最后的惊喜"><a class="header-anchor" href="#最后的惊喜">¶</a>最后的惊喜</h2>
<p><strong>据说</strong> 部署Python 网站到 IIS 还有更简单的办法，那就是安装宇宙最强的IDE - <a href="https://www.visualstudio.com/" target="_blank" rel="noopener">Visual Studio 2015</a> （VS2017 暂不支持 Python 开发），个人开发者可以免授权使用社区版。在 VS 中你可以使用 <a href="https://microsoft.github.io/PTVS/" target="_blank" rel="noopener">PTVS</a> 来快捷开发并部署Python 程序，真正让你一键无忧。</p>
<p><img src="https://image-static.segmentfault.com/234/190/2341908542-58e61641a5209_articlex" alt="图6"></p>
<p>PTVS 支持了常见的 Python Web 框架，比如 Flask，Django，Bottle，Jade 等等，调试的时候只需要按 F5，部署右键选择 publish，跟着向导一步两步你就可以完成魔鬼的步伐。</p>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接">¶</a>参考链接</h2>
<ul>
<li><a href="http://stackoverflow.com/questions/5072166/how-do-i-deploy-a-flask-application-in-iis" target="_blank" rel="noopener">http://stackoverflow.com/questions/5072166/how-do-i-deploy-a-flask-application-in-iis</a></li>
<li><a href="http://stackoverflow.com/questions/20134329/how-to-deploy-a-flask-application-in-iis-8-windows-server-2012" target="_blank" rel="noopener">http://stackoverflow.com/questions/20134329/how-to-deploy-a-flask-application-in-iis-8-windows-server-2012</a></li>
<li><a href="http://blog.csdn.net/firefox1/article/details/46438769" target="_blank" rel="noopener">http://blog.csdn.net/firefox1/article/details/46438769</a></li>
<li><a href="http://www.cnblogs.com/liulixiang/p/4999608.html" target="_blank" rel="noopener">http://www.cnblogs.com/liulixiang/p/4999608.html</a></li>
<li><a href="http://www.cnblogs.com/xiaolecn/p/5111076.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaolecn/p/5111076.html</a></li>
</ul>
<h1>方案二：有 virtual environment (原文链接：<a href="https://www.cnblogs.com/liluping860122/p/9203908.html" target="_blank" rel="noopener">https://www.cnblogs.com/liluping860122/p/9203908.html</a>)</h1>
<h2 id="一、项目部署"><a class="header-anchor" href="#一、项目部署">¶</a>一、项目部署</h2>
<ol>
<li>
<p>服务器安装 python3.6：根据自己系统位数下载安装： <a href="https://www.python.org/downloads/windows/" target="_blank" rel="noopener">https://www.python.org/downloads/windows/</a></p>
<p><strong>由于 python3.6 已经安装好了 pip，所以剩下的工作就简单了。</strong></p>
</li>
<li>
<p>安装 virtualenv 虚拟环境：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建虚拟环境：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">virtualenv env_36</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置虚拟环境模块：先激活虚拟环境，然后安装项目需要的模块。</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pip install <span class="literal">-r</span> requirements.txt</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>代码迁移，此处省略，然后在虚拟环境检查是否正常：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">python manage.py runserver -<span class="literal">-host</span> <span class="number">0.0</span>.<span class="number">0.0</span> -<span class="literal">-port</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><strong><font color="red">注：如果检查正常说明项目这些都没问题了，下面可以进行IIS相关的配置。</font></strong></p>
</blockquote>
<h2 id="二、IIS-和-wgastcgi-配置"><a class="header-anchor" href="#二、IIS-和-wgastcgi-配置">¶</a>二、IIS 和 wgastcgi 配置</h2>
<ol>
<li>
<p>安装 wfastcgi：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pip install wfastcgi</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color="red">注：这里是全局安装，不是在虚拟环境安装。</font></p>
</blockquote>
</li>
<li>
<p>在 python3.6 的安装目录：  <em>Lib/site-packages</em> 文件夹下，找到：<em><a href="http://wfastcgi.py" target="_blank" rel="noopener">wfastcgi.py</a></em> 这个文件。如图：</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620144521735-971439039.png" alt="图1"></p>
</li>
</ol>
<p>把这个文件拷贝到你的项目根目录。如图：</p>
<pre><code>![图2](/images/Flask-IIS部署/35314-20180620144615996-205738701.png)
</code></pre>
<ol start="3">
<li>
<p>IIS 添加应用：</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620144823448-748090275.png" alt="图3"></p>
</li>
<li>
<p>在你的网站下面找到【处理程序映射】如图：双击打开：</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620144945315-1193833752.png" alt="图4"></p>
</li>
<li>
<p>添加模块映射：<font color="red">大家注意图片中标注的第2条。(<em>D:\Python\ENV\DEV_36\Scripts\python.exe|D:\Python\PRO\cms\<a href="http://wfastcgi.py" target="_blank" rel="noopener">wfastcgi.py</a></em>) 前面部分为虚拟环境路径，<code>|</code> 号后面是项目里的 <em><a href="http://wfastcig.py" target="_blank" rel="noopener">wfastcig.py</a></em> 路径。</font></p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620145449414-1255307354.png" alt="图5"></p>
</li>
<li>
<p>请求限制中把（映射下面的 “√” 去掉）</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620145614871-1826673338.png" alt="图6"></p>
</li>
<li>
<p>确认添加模块</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620145705313-916636073.png" alt="图7"></p>
</li>
<li>
<p>这个时候你应该可以看见你的 FlaskFastCGI 程序了</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620145809096-27445421.png" alt="图8"></p>
</li>
<li>
<p>回到 IIS 控制台，进入【FastCGI设置】如图：</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620145924073-706250573.png" alt="图9"></p>
</li>
<li>
<p>双击打开你应该可以看见刚才添加的 FastCGI:</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620150050654-141759257.png" alt="图10"></p>
</li>
<li>
<p>双击，编辑 —【环境变量】</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620150635034-1010093138.png" alt="图11"></p>
<p>这里添加2个变量：<br>
<code>PYTHONPATH</code>    值为：  项目路径：（如：<em>D:\Python\PRO\cms</em>）<br>
<code>WSGI_HANDLER</code>  值为： 项目启动文件中的 <code>app</code>，如图，因为我是通过 <code>manage</code>启动。</p>
</li>
<li>
<p>回收应用程序池，重启 IIS。</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620150948097-591061574.png" alt="图12"></p>
</li>
<li>
<p>输入地址测试，不出问题应该是可以正常访问了。</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620151138737-242388206.png" alt="图13"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Python</tag>
        <tag>Flask</tag>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 编码规范</title>
    <url>/2019/08/02/Python-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h1>Python 编码规范</h1>
<h2 id="代码书写规范"><a class="header-anchor" href="#代码书写规范">¶</a>代码书写规范</h2>
<h3 id="缩进"><a class="header-anchor" href="#缩进">¶</a>缩进</h3>
<p>统一使用 4 个空格进行缩进，不要混合使用制表符和空格来缩进，也不要单独使用制表符 <code>tab</code>。对于行连接的情况，可以垂直对齐换行的元素。</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/07ad07f65bd548b5932f17533b90dfbf" alt="图1"></p>
<h3 id="行宽"><a class="header-anchor" href="#行宽">¶</a>行宽</h3>
<p>每行代码尽量不超过 80 个字符，在特殊情况下可以略微超过 80 ，如长的导入模块语句或注释里的 URL。<br>
Python 会将圆括号、中括号和花括号中的行隐式的连接起来，可以利用这个特点，在表达式外围增加一对额外的圆括号，不要使用反斜杠连接行。<br>
如果条件语句中条件过多，放在一行显得超长，可以使用圆括号来实现隐式连接，如下：</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/ea37480540e54e2ea17ea3877c8a0c22" alt="图2"></p>
<p>如果一个文本字符串放在一行显得超长，可以使用圆括号来实现隐式行连接，如下：</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/86e79eb962b241efa183bc95418db556" alt="图3"></p>
<h3 id="引号"><a class="header-anchor" href="#引号">¶</a>引号</h3>
<p>自然语言使用双引号，机器标示使用单引号，因此代码里多数应该使用单引号。</p>
<ul>
<li>
<p>自然语言使用双引号</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/8d2d82fc19224c2a994fd2f4ddd0f158" alt="图4"></p>
</li>
<li>
<p>机器标识使用单引号</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/dd7cb92873134526b6d2821bb7b1d303" alt="图5"></p>
</li>
<li>
<p>正则表达式使用双引号</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/9651f26cb26d4986aaaab1af8071142b" alt="图6"></p>
</li>
<li>
<p>文档字符串 (Docstring) 使用三双引号</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/35c333c59b894938b9925a4a555843ea" alt="图7"></p>
</li>
</ul>
<h3 id="空行"><a class="header-anchor" href="#空行">¶</a>空行</h3>
<p>模块中类定义与函数之间空两行，类中各函数之间空一行，函数中可以使用空行分隔各逻辑代码块，使其更加清晰。</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/dd582d744d184c61b416a57c2c440974" alt="图8"></p>
<h3 id="模块导入"><a class="header-anchor" href="#模块导入">¶</a>模块导入</h3>
<p>每个独立模块导入应该独占一行，导入代码应该放在文件顶部，置于模块说明、文档字符串之后，全局变量、常量之前，模块导入建议顺序建议参考以一下顺序，每组之间使用一个空行分隔：</p>
<pre><code>1. 标准库导入
2. 第三方库导入
3. 自定义库导入
</code></pre>
<p><img src="https://p3.pstatp.com/large/pgc-image/7d176cad05ce44de92494779a6f90aac" alt="图9"></p>
<p>同时，导入模块应尽量使用绝对导入。</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/3290579bb9e7438796e24c0cfac61732" alt="图10"></p>
<h3 id="空格"><a class="header-anchor" href="#空格">¶</a>空格</h3>
<p>在二元操作符两边都加上一个空格，如 <code>=, ==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is no，and, or, not</code>。额外注意的是，当 <code>=</code> 用于指示关键字参数或默认参数值时, 不要在其两侧使用空格。</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/cb68241c33c7459b81c454bdfb6b2076" alt="图11"></p>
<p>函数的参数列表中 <code>,</code> 之后要有空格，但左括号之后，右括号之前不要加多余的空格。</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/f56964d2dcae4c08ac34d73207d53bad" alt="图12"></p>
<h2 id="代码注释规范"><a class="header-anchor" href="#代码注释规范">¶</a>代码注释规范</h2>
<h3 id="块注释"><a class="header-anchor" href="#块注释">¶</a>块注释</h3>
<p><code>#</code> 号后空一格，段落间需要用空行分开。</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/cc6ac11b397a456daefe726e205da6f1" alt="图13"></p>
<h3 id="行注释"><a class="header-anchor" href="#行注释">¶</a>行注释</h3>
<p>行注释至少使用两个空格和语句分开。</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/2a8bfadf83894a379d9bfa08a73ce932" alt="图14"></p>
<h3 id="文档注释——文档字符串-Docstring"><a class="header-anchor" href="#文档注释——文档字符串-Docstring">¶</a>文档注释——文档字符串 Docstring</h3>
<p>Python 有一种独一无二的的注释方式：使用文档字符串。文档字符串是包，模块，类或函数里的第一个语句。这些字符串可以通过对象的 doc 成员被自动提取。并且被 pydoc 所用。(你可以在你的模块上运行 pydoc 试一把，看看它长什么样)。我们对文档字符串的惯例是使用三重双引号<code>&quot;&quot;&quot;</code>(PEP-257)。一个文档字符串应该这样组织：首先是一行以句号，问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行)。接着是一个空行。接着是文档字符串剩下的部分，它应该与文档字符串的第一行的第一个引号对齐。下面有更多文档字符串的格式化规范。</p>
<h3 id="模块"><a class="header-anchor" href="#模块">¶</a>模块</h3>
<p>每个文件应该包含一个许可样板。根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板。</p>
<h3 id="函数和方法"><a class="header-anchor" href="#函数和方法">¶</a>函数和方法</h3>
<p>下文所指的函数，包括函数，方法，以及生成器。<br>
一个函数必须要有文档字符串，除非它满足以下条件：</p>
<ul>
<li>外部不可见</li>
<li>非常短小</li>
<li>简单明了</li>
</ul>
<p>文档字符串应该包含函数做什么，以及输入和输出的详细描述。通常，不应该描述“怎么做”， 除非是一些复杂的算法。文档字符串应该提供足够的信息，当别人编写代码调用该函数时，他不需要看一行代码，只要看文档字符串就可以了。对于复杂的代码，在代码旁边加注释会比使用文档字符串更有意义。<br>
关于函数的几个方面应该在特定的小节中进行描述记录，这几个方面如下文所述，每节应该以一个标题行开始。标题行以冒号结尾。除标题行外，节的其他内容应被缩进2个空格。</p>
<h4 id="Args"><a class="header-anchor" href="#Args">¶</a>Args</h4>
<p>列出每个参数的名字，并在名字后使用一个冒号和一个空格，分隔对该参数的描述。如果描述太长超过了单行80字符，使用2或者4个空格的悬挂缩进(与文件其他部分保持一致)。描述应该包括所需的类型和含义。如果一个函数接受foo(可变长度参数列表)或者bar (任意关键字参数)，应该详细列出foo和bar。</p>
<h4 id="Returns-或者-Yields-用于生成器"><a class="header-anchor" href="#Returns-或者-Yields-用于生成器">¶</a>Returns (或者 Yields: 用于生成器)</h4>
<p>描述返回值的类型和语义。如果函数返回 <code>None</code>。这一部分可以省略。</p>
<h4 id="Raises"><a class="header-anchor" href="#Raises">¶</a>Raises</h4>
<p>列出与接口有关的所有异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_bigtable_rows</span><span class="params">(big_table, keys, other_silly_variable=None)</span>:</span></span><br><span class="line">    <span class="string">"""Fetches rows from a Bigtable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Retrieves rows pertaining to the given keys from the Table instance</span></span><br><span class="line"><span class="string">    represented by big_table.  Silly things may happen if</span></span><br><span class="line"><span class="string">    other_silly_variable is not None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        big_table: An open Bigtable Table instance.</span></span><br><span class="line"><span class="string">        keys: A sequence of strings representing the key of each table row</span></span><br><span class="line"><span class="string">            to fetch.</span></span><br><span class="line"><span class="string">        other_silly_variable: Another optional variable, that has a much</span></span><br><span class="line"><span class="string">            longer name than the other args, and which does nothing.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        A dict mapping keys to the corresponding table row data</span></span><br><span class="line"><span class="string">        fetched. Each row is represented as a tuple of strings. For</span></span><br><span class="line"><span class="string">        example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#123;'Serak': ('Rigel VII', 'Preparer'),</span></span><br><span class="line"><span class="string">         'Zim': ('Irk', 'Invader'),</span></span><br><span class="line"><span class="string">         'Lrrr': ('Omicron Persei 8', 'Emperor')&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If a key from the keys argument is missing from the dictionary,</span></span><br><span class="line"><span class="string">        then that row was not found in the table.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        IOError: An error occurred accessing the bigtable.Table object.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="类"><a class="header-anchor" href="#类">¶</a>类</h3>
<p>类应该在其定义下有一个用于描述该类的文档字符串。如果你的类有公共属性(Attributes)，那么文档中应该有一个属性(Attributes)段。并且应该遵守和函数参数相同的格式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Summary of class here.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Longer class information....</span></span><br><span class="line"><span class="string">    Longer class information....</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        likes_spam: A boolean indicating if we like SPAM or not.</span></span><br><span class="line"><span class="string">        eggs: An integer count of the eggs we have laid.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, likes_spam=False)</span>:</span></span><br><span class="line">        <span class="string">"""Inits SampleClass with blah."""</span></span><br><span class="line">        self.likes_spam = likes_spam</span><br><span class="line">        self.eggs = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Performs operation blah."""</span></span><br></pre></td></tr></table></figure>
<h3 id="块注释和行注释"><a class="header-anchor" href="#块注释和行注释">¶</a>块注释和行注释</h3>
<p>最需要写注释的是代码中那些技巧性的部分。如果你在下次代码审查的时候必须解释一下。那么你应该现在就给它写注释。对于复杂的操作，应该在其操作开始前写上若干行注释。对于不是一目了然的代码，应在其行尾添加注释。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># We use a weighted dictionary search to find out where i is in</span></span><br><span class="line"><span class="comment"># the array.  We extrapolate position based on the largest num</span></span><br><span class="line"><span class="comment"># in the array and the array size and then do binary search to</span></span><br><span class="line"><span class="comment"># get the exact number.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &amp; (i<span class="number">-1</span>) == <span class="number">0</span>:        <span class="comment"># true iff i is a power of 2</span></span><br></pre></td></tr></table></figure>
<p>为了提高可读性。注释应该至少离开代码2个空格。<br>
另一方面，绝不要描述代码。假设阅读代码的人比你更懂Python，他只是不知道你的代码要做什么。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BAD COMMENT: Now go through the b array and make sure whenever i occurs</span></span><br><span class="line"><span class="comment"># the next element is i+1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 程序设计语言学习笔记（一）</title>
    <url>/2019/02/23/Rust-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1>Rust 程序设计语言学习笔记（一）</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="1-入门指南"><a class="header-anchor" href="#1-入门指南">¶</a>1. 入门指南</h2>
<h3 id="1-3-Hello-Cargo"><a class="header-anchor" href="#1-3-Hello-Cargo">¶</a>1.3 Hello, Cargo!</h3>
<h4 id="使用Cargo创建项目"><a class="header-anchor" href="#使用Cargo创建项目">¶</a>使用Cargo创建项目</h4>
<p>我们使用 Cargo 创建一个新项目，然后看看与上面的 Hello, world! 项目有什么不同。回到 <em>projects</em> 目录（或者你存放代码的目录）。接着，可在任何操作系统下运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo new hello_cargo</span><br><span class="line">$ <span class="built_in">cd</span> hello_cargo</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：Git 是一个常用的版本控制系统（version control system， VCS）。可以通过 <code>--vcs</code> 参数使 <code>cargo new</code> 切换到其它版本控制系统（VCS），或者不使用 VCS。运行 <code>cargo new --help</code> 参看可用的选项。</p>
</blockquote>
<p>第一行命令新建了名为 <em>hello_cargo</em> 的目录。我们将项目命名为 <em>hello_cargo</em>，同时 Cargo 在一个同名目录中创建项目文件。</p>
<p>进入 <em>hello_cargo</em> 目录并列出文件。将会看到 Cargo 生成了两个文件和一个目录：一个 Cargo.toml 文件，一个 <em>src</em> 目录，以及位于 <em>src</em> 目录中的 <em><a href="http://main.rs" target="_blank" rel="noopener">main.rs</a></em> 文件。它也在 <em>hello_cargo</em> 目录初始化了一个 git 仓库，以及一个 <em>.gitignore</em> 文件。</p>
<p>Cargo.toml 示例：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"hello_cargo"</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.1.0"</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">"Your Name &lt;you@example.com&gt;"</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">"2018"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure>
<p>Cargo 还提供了一个叫 <code>cargo check</code> 的命令。该命令快速检查代码确保其可以编译，但并不产生可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo check</span><br><span class="line">   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.32 secs</span><br></pre></td></tr></table></figure>
<h4 id="发布（release）构建"><a class="header-anchor" href="#发布（release）构建">¶</a>发布（release）构建</h4>
<p>当项目最终准备好发布时，可以使用 <code>cargo build --release</code> 来优化编译项目。这会在 <em>target/release</em> 而不是 <em>target/debug</em> 下生成可执行文件。这些优化可以让 Rust 代码运行的更快，不过启用这些优化也需要消耗更长的编译时间。这也就是为什么会有两种不同的配置：一种是为了开发，你需要经常快速重新构建；另一种是为用户构建最终程序，它们不会经常重新构建，并且希望程序运行得越快越好。如果你在测试代码的运行时间，请确保运行 <code>cargo build --release</code> 并使用 <em>target/release</em> 下的可执行文件进行测试。</p>
<h2 id="2-猜猜看游戏教程"><a class="header-anchor" href="#2-猜猜看游戏教程">¶</a>2. 猜猜看游戏教程</h2>
<h4 id="使用变量储存值"><a class="header-anchor" href="#使用变量储存值">¶</a>使用变量储存值</h4>
<p>关联函数 == 静态方法</p>
<h4 id="生成一个随机数"><a class="header-anchor" href="#生成一个随机数">¶</a>生成一个随机数</h4>
<p>你不可能凭空就知道应该 <code>use</code> 哪个 <code>trait</code> 以及该从 <code>crate</code> 中调用哪个方法。<code>crate</code> 的使用说明位于其文档中。Cargo 有一个很棒的功能是：运行 <code>cargo doc --open</code> 命令来构建所有本地依赖提供的文档，并在浏览器中打开。例如，假设你对 <code>rand</code> crate 中的其他功能感兴趣，你可以运行 <code>cargo doc --open</code> 并点击左侧导航栏中的 <code>rand</code>。</p>
<h2 id="3-通用编程概念"><a class="header-anchor" href="#3-通用编程概念">¶</a>3. 通用编程概念</h2>
<h3 id="3-2-数据类型"><a class="header-anchor" href="#3-2-数据类型">¶</a>3.2 数据类型</h3>
<p>记住，Rust 是 <strong>静态类型</strong>（<em>statically typed</em>）语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时，比如第二章的 “比较猜测的数字和秘密数字” 使用 <code>parse</code> 将 <code>String</code> 转换为数字时，必须增加类型注解，像这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> guess: <span class="built_in">u32</span> = <span class="string">"42"</span>.parse().expect(<span class="string">"Not a number!"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="标量类型"><a class="header-anchor" href="#标量类型">¶</a>标量类型</h4>
<p><strong>标量</strong>（<em>scalar</em>）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。你可能其他语言中见过它们。</p>
<h4 id="复合类型"><a class="header-anchor" href="#复合类型">¶</a>复合类型</h4>
<p><strong>复合类型</strong>（<em>Compound types</em>）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<h5 id="元组类型"><a class="header-anchor" href="#元组类型">¶</a>元组类型</h5>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tup</code> 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值，像这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tup = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value of y is: &#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序首先创建了一个元组并绑定到 <code>tup</code> 变量上。接着使用了 <code>let</code> 和一个模式将 <code>tup</code> 分成了三个不同的变量，<code>x</code>、<code>y</code> 和 <code>z</code>。这叫做 <strong>解构</strong>（<em>destructuring</em>）。</p>
<p>除了使用模式匹配解构外，也可以使用点号（.）后跟值的索引来直接访问它们。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> five_hundred = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> six_point_four = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> one = x.<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数组类型"><a class="header-anchor" href="#数组类型">¶</a>数组类型</h5>
<p>数组的类型比较有趣；它看起来像 [type; number]。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<h3 id="3-3-函数如何工作"><a class="header-anchor" href="#3-3-函数如何工作">¶</a>3.3 函数如何工作</h3>
<h4 id="包含语句和表达式的函数体"><a class="header-anchor" href="#包含语句和表达式的函数体">¶</a>包含语句和表达式的函数体</h4>
<p>我们用来创建新作用域的大括号（代码块），<code>{}</code>，也是一个表达式，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> y = &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value of y is: &#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个表达式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是一个代码块，它的值是 <code>4</code>。这个值作为 <code>let</code> 语句的一部分被绑定到 <code>y</code> 上。注意结尾没有分号的那一行 <code>x+1</code>，与你见过的大部分代码行不同。表达式的结尾没有分号。<strong>如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。在接下来探索具有返回值的函数和表达式时要谨记这一点。</strong></p>
<h3 id="3-5-控制流"><a class="header-anchor" href="#3-5-控制流">¶</a>3.5 控制流</h3>
<h4 id="if-表达式"><a class="header-anchor" href="#if-表达式">¶</a><code>if</code> 表达式</h4>
<p>值得注意的是代码中的条件 <em>必须</em> 是 <code>bool</code> 值。如果条件不是 <code>bool</code> 值，我们将得到一个错误。</p>
<h5 id="在-let-语句中使用-if"><a class="header-anchor" href="#在-let-语句中使用-if">¶</a>在 <code>let</code> 语句中使用 <code>if</code></h5>
<p>因为 <code>if</code> 是一个表达式，我们可以在 <code>let</code> 语句的右侧使用它，例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> condition = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value of number is: &#123;&#125;"</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用循环重复执行"><a class="header-anchor" href="#使用循环重复执行">¶</a>使用循环重复执行</h4>
<h5 id="从循环返回"><a class="header-anchor" href="#从循环返回">¶</a>从循环返回</h5>
<p>如果将返回值加入你用来停止循环的 <code>break</code> 表达式，它会被停止的循环返回：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(result, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-认识所有权"><a class="header-anchor" href="#4-认识所有权">¶</a>4. 认识所有权</h2>
<h3 id="4-1-什么是所有权"><a class="header-anchor" href="#4-1-什么是所有权">¶</a>4.1 什么是所有权</h3>
<h4 id="栈-Stack-与堆-Heap"><a class="header-anchor" href="#栈-Stack-与堆-Heap">¶</a>栈(Stack)与堆(Heap)</h4>
<ul>
<li>栈中的所有数据都必须占用已知且固定的大小。</li>
<li>在编译时大小未知或大小可能变化的数据，要改为存储在堆上。</li>
</ul>
<h4 id="内存与分配"><a class="header-anchor" href="#内存与分配">¶</a>内存与分配</h4>
<h5 id="只在栈上的数据：拷贝"><a class="header-anchor" href="#只在栈上的数据：拷贝">¶</a>只在栈上的数据：拷贝</h5>
<p>那么什么类型是 <code>Copy</code> 的呢？可以查看给定类型的文档来确认，不过作为一个通用的规则，任何简单标量值的组合可以是 <code>Copy</code> 的，不需要分配内存或某种形式资源的类型是 <code>Copy</code> 的。如下是一些 <code>Copy</code> 的类型：</p>
<ul>
<li>所有整数类型，比如 <code>u32</code>。</li>
<li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li>
<li>所有浮点数类型，比如 <code>f64</code>。</li>
<li>字符类型，<code>char</code>。</li>
<li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是。</li>
</ul>
<h3 id="4-2-引用与借用"><a class="header-anchor" href="#4-2-引用与借用">¶</a>4.2 引用与借用</h3>
<p>函数签名使用 <code>&amp;</code> 来表明参数 <code>s</code> 的类型是一个引用。让我们增加一些解释性的注释：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// s 是对 String 的引用</span></span><br><span class="line">    s.len()</span><br><span class="line">&#125; <span class="comment">// 这里，s 离开了</span></span><br></pre></td></tr></table></figure>
<p>正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。</p>
<h5 id="可变引用"><a class="header-anchor" href="#可变引用">¶</a>可变引用</h5>
<p>在特定作用域中的特定数据有且只有一个可变引用。这些代码会失败：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, r1, r2);</span><br></pre></td></tr></table></figure>
<p>错误如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error[E0499]: cannot borrow &#96;s&#96; as mutable more than once at a time</span><br><span class="line"> --&gt; src&#x2F;main.rs:5:10</span><br><span class="line">  |</span><br><span class="line">4 | let r1 &#x3D; &amp;mut s;</span><br><span class="line">  |          ------ first mutable borrow occurs here</span><br><span class="line">5 | let r2 &#x3D; &amp;mut s;</span><br><span class="line">  |          ^^^^^^ second mutable borrow occurs here</span><br><span class="line">6 | println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br><span class="line">  |                    -- borrow later used here</span><br></pre></td></tr></table></figure>
<p>可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 同时 拥有：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure>
<p>类似的规则也存在于同时使用可变与不可变引用中。这些代码会导致一个错误：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">// BIG PROBLEM</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;, and &#123;&#125;"</span>, r1, r2, r3);</span><br></pre></td></tr></table></figure>
<p>错误如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error[E0502]: cannot borrow &#96;s&#96; as mutable because it is also borrowed as immutable</span><br><span class="line"> --&gt; src&#x2F;main.rs:6:10</span><br><span class="line">  |</span><br><span class="line">4 | let r1 &#x3D; &amp;s; &#x2F;&#x2F; no problem</span><br><span class="line">  |          -- immutable borrow occurs here</span><br><span class="line">5 | let r2 &#x3D; &amp;s; &#x2F;&#x2F; no problem</span><br><span class="line">6 | let r3 &#x3D; &amp;mut s; &#x2F;&#x2F; BIG PROBLEM</span><br><span class="line">  |          ^^^^^^ mutable borrow occurs here</span><br><span class="line">7 |</span><br><span class="line">8 | println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3);</span><br><span class="line">  |                            -- borrow later used here</span><br></pre></td></tr></table></figure>
<p>哇哦！我们也 <strong>不能在拥有不可变引用的同时拥有可变引用</strong>。不可变引用的用户可不希望在他们的眼皮底下值就被意外的改变了！然而，<strong>多个不可变引用是可以的</strong>，因为没有哪个只能读取数据的人有能力影响其他人读取到的数据。</p>
<h3 id="4-3-Slices"><a class="header-anchor" href="#4-3-Slices">¶</a>4.3 Slices</h3>
<h4 id="字符串slice"><a class="header-anchor" href="#字符串slice">¶</a>字符串slice</h4>
<p><code>start..end</code> 语法代表一个以 <code>start</code> 开头并一直持续到但不包含 <code>end</code> 的 range。如果需要包含 <code>end</code>，可以使用 <code>..=</code> 而不是 <code>..</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = &amp;s[<span class="number">0</span>..=<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> world = &amp;s[<span class="number">6</span>..=<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p><code>=</code> 意味着包含最后的数字。</p>
<blockquote>
<p>String不能直接取索引，如：</p>
</blockquote>
<blockquote>
   <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"Hello, world!"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s[..]);</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>只能如此形式：</p>
</blockquote>
<blockquote>
   <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"Hello, world!"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, &amp;s[..]);</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>所以字符串字面值是&amp;str类型</p>
</blockquote>
<blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"Hello, world!"</span>; <span class="comment">// s 是&amp;str类型</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="5-使用结构体来组织相关联的数据"><a class="header-anchor" href="#5-使用结构体来组织相关联的数据">¶</a>5. 使用结构体来组织相关联的数据</h2>
<h3 id="5-1-定义并实例化结构体"><a class="header-anchor" href="#5-1-定义并实例化结构体">¶</a>5.1 定义并实例化结构体</h3>
<p>结构体定义示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建结构体实例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"someusername123"</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="变量与字段同名时的字段初始化简写语法"><a class="header-anchor" href="#变量与字段同名时的字段初始化简写语法">¶</a>变量与字段同名时的字段初始化简写语法</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用结构体更新语法从其他实例创建实例"><a class="header-anchor" href="#使用结构体更新语法从其他实例创建实例">¶</a>使用结构体更新语法从其他实例创建实例</h4>
<p>使用结构体更新语法，我们可以通过更少的代码来达到相同的效果。 <code>..</code> 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"another@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"anotherusername567"</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用没有命名字段的元组结构体来创建不同的类型"><a class="header-anchor" href="#使用没有命名字段的元组结构体来创建不同的类型">¶</a>使用没有命名字段的元组结构体来创建不同的类型</h4>
<p>定义元组结构体，以 <code>struct</code> 关键字和结构体名开头并后跟元组中的类型。例如，下面是两个分别叫做 <code>Color</code> 和 <code>Point</code> 元组结构体的定义和用法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>注意 <code>black</code> 和 <code>origin</code> 值的类型 <strong>不同</strong>，因为它们是不同的元组结构体的实例。你定义的每一个结构体有其自己的类型，即使结构体中的字段有着相同的类型。</p>
<h4 id="没有任何字段的类单元结构体"><a class="header-anchor" href="#没有任何字段的类单元结构体">¶</a>没有任何字段的类单元结构体</h4>
<p>我们也可以定义一个没有任何字段的结构体！它们被称为 <strong>类单元结构体</strong>（<em>unit-like structs</em>）因为它们类似于 <code>()</code>，即 <code>unit</code> 类型。类单元结构体常常在你想要在某个类型上实现 <code>trait</code> 但不需要在类型中存储数据的时候发挥作用。</p>
<h4 id="通过派生-trait-增加实用功能"><a class="header-anchor" href="#通过派生-trait-增加实用功能">¶</a>通过派生 trait 增加实用功能</h4>
<p>尝试打印出 <code>Rectangle</code> 实例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"rect1 is &#123;&#125;"</span>, rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们运行这个代码时，会出现带有如下核心信息的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error[E0277]: the trait bound &#96;Rectangle: std::fmt::Display&#96; is not satisfied</span><br><span class="line">&#96;Rectangle&#96; cannot be formatted with the default formatter; try using</span><br><span class="line">&#96;:?&#96; instead if you are using a format string</span><br></pre></td></tr></table></figure>
<p>上述错误说明结构体没实现 <code>std::fmt::Display</code> 方法，按照提示尝试<code>println!(&quot;rect1 is {:?}&quot;, rect1);</code>，但仍能看到另一个错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error[E0277]: the trait bound &#96;Rectangle: std::fmt::Debug&#96; is not satisfied</span><br><span class="line">&#96;Rectangle&#96; cannot be formatted using &#96;:?&#96;; if it is defined in your</span><br><span class="line">crate, add &#96;#[derive(Debug)]&#96; or manually implement it</span><br></pre></td></tr></table></figure>
<p>我们必须为结构体显式选择这个功能。为此，在结构体定义之前加上 #[derive(Debug)] 注解：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"rect1 is &#123;:?&#125;"</span>, rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-方法语法"><a class="header-anchor" href="#5-3-方法语法">¶</a>5.3 方法语法</h3>
<h4 id="关联函数"><a class="header-anchor" href="#关联函数">¶</a>关联函数</h4>
<p><code>impl</code> 块的另一个有用的功能是：允许在 <code>impl</code> 块中定义 不 以 <code>self</code> 作为参数的函数。这被称为 关联函数（<em>associated functions</em>），因为它们与结构体相关联。它们仍是函数而不是方法，因为它们并不作用于一个结构体的实例。你已经使用过 <code>String::from</code> 关联函数了。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>git 学习笔记</title>
    <url>/2018/10/22/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>git学习笔记</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="时光穿梭机"><a class="header-anchor" href="#时光穿梭机">¶</a>时光穿梭机</h2>
<h3 id="版本回退"><a class="header-anchor" href="#版本回退">¶</a>版本回退</h3>
<ol>
<li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。此命令是将工作目录中的修改撤回到与本地版本库一致。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ol>
<h3 id="工作区与暂存区"><a class="header-anchor" href="#工作区与暂存区">¶</a>工作区与暂存区</h3>
<ol>
<li><code>git diff</code> 是你工作区跟仓库（仓库也叫版本库）的比较，这个时候可以看你开发过程中修改了哪些内容</li>
<li><code>git diff --cached</code> 是看你stage区和仓库分支上的比较，你add后但是没有commit， 这个时候只是在stage中，可以确认下修改是否正确，如果正确无误可以commit合并到分支。</li>
<li>在<code>git commit</code>后stage区并不会清空（原贴有错误）。</li>
</ol>
<h3 id="撤消修改"><a class="header-anchor" href="#撤消修改">¶</a>撤消修改</h3>
<ul>
<li>命令<code>git checkout -- readme.txt</code>意思就是，把readme.txt文件在工作区的修改（从版本库）全部撤销，这里有两种情况：</li>
</ul>
<p>1. 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<pre><code>原布局：
    workdir            stage                 master
     test               test                  test

修改后：
    workdir            stage                 master
    test_mod            test                  test

git checkout -- readme.txt后：
    workdir            stage                 master
     test               test                  test
</code></pre>
<p>2. 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<pre><code>原布局：
    workdir            stage                 master
     test               test                  test

修改后并git add后又修改：
    workdir            stage                 master
    test_mod_mod      test_mod                test

git checkout -- readme.txt后：
    workdir            stage                 master
    test_mod          test_mod                  test
</code></pre>
<p>  <strong>总之，就是让这个文件回到最近一次<code>git commit</code>（修改后未<code>git add</code>）或<code>git add</code>（修改后已<code>git add</code>）时的状态。</strong></p>
<ul>
<li>命令<code>git reset HEAD file</code>意思就是，可以把暂存区的修改撤销掉（unstage），重新放回工作区。</li>
<li>小结：
<ul>
<li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li>
<li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，<strong>分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作</strong>。</li>
<li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</li>
</ul>
</li>
</ul>
<p>  笔记：</p>
<ul>
<li><code>git checkout -- file</code>是<strong>撤回</strong>，重点是使<strong>工作区</strong>文件与邻近的且不一致的区的文件一致。</li>
<li><code>git reset HEAD file</code>是<strong>重置</strong>，重点是将<strong>暂存区</strong>文件重置成<code>git add</code>前的状态。</li>
</ul>
<h3 id="删除文件"><a class="header-anchor" href="#删除文件">¶</a>删除文件</h3>
<ol>
<li>如果你用的<code>rm</code>删除文件，那就相当于只删除了工作区的文件，如果想要恢复，直接用<code>git checkout -- &lt;file&gt;</code>就可以。</li>
<li>如果你用的是<code>git rm</code>删除文件，那就相当于不仅删除了文件，而且还添加到了暂存区，需要先<code>git reset HEAD &lt;file&gt;</code>，然后再<code>git checkout -- &lt;file&gt;</code>。</li>
<li>如果你想彻底把版本库的删除掉，先<code>git rm</code>，再<code>git commit</code>就ok了。</li>
</ol>
<h2 id="远程仓库"><a class="header-anchor" href="#远程仓库">¶</a>远程仓库</h2>
<h3 id="添加远程库"><a class="header-anchor" href="#添加远程库">¶</a>添加远程库</h3>
<ol>
<li>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</li>
<li>关联后，使用命令<code>git push -u origin master</code>第一次推送<code>master</code>分支的所有内容；</li>
<li>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</li>
</ol>
<h2 id="分支管理"><a class="header-anchor" href="#分支管理">¶</a>分支管理</h2>
<h3 id="创建与合并分支"><a class="header-anchor" href="#创建与合并分支">¶</a>创建与合并分支</h3>
<ol>
<li>把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure>
<p>2. Git分支常用命令：</p>
<ul>
<li>查看分支：<code>git branch</code></li>
<li>创建分支：<code>git branch &lt;name&gt;</code></li>
<li>切换分支：<code>git checkout &lt;name&gt;</code></li>
<li>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></li>
<li>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></li>
<li>删除分支：<code>git branch -d &lt;name&gt;</code></li>
</ul>
<h3 id="Bug分支"><a class="header-anchor" href="#Bug分支">¶</a>Bug分支</h3>
<ol>
<li>工作区和暂存区是一个公开的工作台，任何分支都会用到，并能看到工作台上最新的内容，只要在工作区、暂存区的改动未能够提交到某一个版本库（分支）中，那么在任何一个分支下都可以看得到这个工作区、暂存区的最新实时改动。</li>
<li>使用<code>git stash</code>就可以将暂存区的修改藏匿起来，使整个工作台看起来都是干净的。所以要清理整个工作台，那么前提是必须先将工作区的内容都<code>git add</code>到暂存区中去。之后在干净的工作台上可以做另外一件紧急事件与藏匿起来的内容是完全独立的。</li>
<li>如果是修改的文件不用<code>git add</code>依然可以<code>git stash</code>，只有新文件才需要<code>git add</code>。</li>
</ol>
<h3 id="Feature分支"><a class="header-anchor" href="#Feature分支">¶</a>Feature分支</h3>
<ul>
<li>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</li>
</ul>
<h3 id="多人协作"><a class="header-anchor" href="#多人协作">¶</a>多人协作</h3>
<ul>
<li>查看远程库信息，使用<code>git remote -v</code>；</li>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>
<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li>
<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>
<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream-to=origin/branch-name branch-name</code>；</li>
<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>
</ul>
<h3 id="Rebase"><a class="header-anchor" href="#Rebase">¶</a>Rebase</h3>
<ul>
<li>只对尚未推送或分享给别人的本地修改执行变基操作清理历史；</li>
<li>从不对已推送至别处的提交执行变基操作。</li>
<li>在重放之前的提交的时候，Git会创建新的提交，也就是说即使你重放的提交与之前的一模一样Git也会将之当做新的独立的提交进行处理。</li>
<li><code>git rebase</code>并不会删除老的提交，也就是说你在对某个分支执行了<code>git rebase</code>操作之后，老的提交仍然会存放在.git文件夹的objects目录下。如果你对于Git是如何存放你的提交不太了解的话可以参考这篇文章：<a href="https://medium.freecodecamp.com/understanding-git-for-real-by-exploring-the-git-directory-1e079c15b807#.6ylqa5e2w" target="_blank" rel="noopener">Understanding git for real by exploring the .git directory</a><br>
<img src="https://image-static.segmentfault.com/206/854/2068544494-5783bdd025d80" alt="rebase"></li>
<li>设你本地有个branch A，服务器上也有branch A，然后你在本地对branch A进行了<code>git rebase</code>，然后出于某种原因必须<code>git push</code>到服务器，那么你必须使用<code>git push --force</code>。
<ol>
<li>如果你能确认branch A没有被其他人<code>git pull</code>过，那么接下来就没什么事了。</li>
<li>如果branch A已经被别人<code>git pull</code>过，那么你必须告诉那些人，在本地将branch A干掉：<code>git branch -D A</code>，然后<code>git fetch</code>，然后重新checkout：<code>git checkout A</code>。</li>
<li>如果branch A已经被别人git pull过，而且那些人在本地对branch A做了几个commit，那么，你必须让他们先<code>git push</code>上去之后，你再<code>git rebase</code>，然后参考步骤2。</li>
</ol>
</li>
</ul>
<h2 id="标签管理"><a class="header-anchor" href="#标签管理">¶</a>标签管理</h2>
<h3 id="创建标签"><a class="header-anchor" href="#创建标签">¶</a>创建标签</h3>
<ul>
<li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</li>
<li><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li>
<li>命令<code>git tag</code>可以查看所有标签。</li>
<li><strong>标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</strong></li>
<li>用GPG签名tag：<code>git tab -s &lt;tagbane&gt; -m &quot;blablabla...&quot;</code>。<a href="http://arondight.me/2016/04/17/%E4%BD%BF%E7%94%A8GPG%E7%AD%BE%E5%90%8DGit%E6%8F%90%E4%BA%A4%E5%92%8C%E6%A0%87%E7%AD%BE/" target="_blank" rel="noopener">GPG详解</a></li>
</ul>
<h3 id="操作标签"><a class="header-anchor" href="#操作标签">¶</a>操作标签</h3>
<ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>《C语言程序设计·现代方法（第二版）》学习笔记 -- 之一</title>
    <url>/2018/10/18/%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%C2%B7%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
    <content><![CDATA[<h1>《C语言程序设计现代方法第二版》学习笔记一</h1>
<hr>
<p>[toc]</p>
<hr>
<h2 id="第二章-C语言基本概念"><a class="header-anchor" href="#第二章-C语言基本概念">¶</a>第二章 C语言基本概念</h2>
<h3 id="2-4-变量和赋值"><a class="header-anchor" href="#2-4-变量和赋值">¶</a>2.4 变量和赋值</h3>
<h4 id="2-4-5-初始化（P15）"><a class="header-anchor" href="#2-4-5-初始化（P15）">¶</a>2.4.5 初始化（P15）</h4>
<p>  当程序开始执行时，某些变量会被自动设置为0，而大多数变量则不会。如果试图访问未初始化的变量，可能会得到不可预知的结果。</p>
<h3 id="2-7-标识符（P19）"><a class="header-anchor" href="#2-7-标识符（P19）">¶</a>2.7 标识符（P19）</h3>
<p>  标准库中函数的名字只能包含小写字母。</p>
<h3 id="第二章FAQ（P22-P23）"><a class="header-anchor" href="#第二章FAQ（P22-P23）">¶</a>第二章FAQ（P22~P23）</h3>
<ol>
<li>（在C99中）如果main函数声明中的返回类型是<code>int</code>，程序会向操作系统返回0;否则程序会返回一个不确定的值。</li>
<li>依据C标准，编译器必须用一个空格字符替换每条注释语句。</li>
<li>传统风格的注释（<code>/*...*/</code>）不允许嵌套;C99注释（以<code>//</code>开头）可以嵌套在传统风格的注释中。</li>
</ol>
<hr>
<h2 id="第三章-格式化输入-输出"><a class="header-anchor" href="#第三章-格式化输入-输出">¶</a>第三章 格式化输入/输出</h2>
<h3 id="3-1-printf函数"><a class="header-anchor" href="#3-1-printf函数">¶</a>3.1 <code>printf</code>函数</h3>
<h4 id="3-1-1-转换说明（P28）"><a class="header-anchor" href="#3-1-1-转换说明（P28）">¶</a>3.1.1 转换说明（P28）</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    </span><br><span class="line">    i = <span class="number">40</span>;</span><br><span class="line">    x = <span class="number">839.21f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"|%d|%5d|%-5d|%5.3d|n"</span>, i, i, i, );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"|%10.3f|%10.3e|%-10g|\n"</span>, x, x, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>|40|   40|40   |  040|</p>
<p>|   839.210| 8.392e+02|839.21    |</p>
<h4 id="3-2-1-scanf的工作方法（P30）"><a class="header-anchor" href="#3-2-1-scanf的工作方法（P30）">¶</a>3.2.1 <code>scanf</code>的工作方法（P30）</h4>
<p>  对于格式串中的第一个转换说明，<code>scanf</code>函数从输入的数据中定位适当类型的项，并在必要时跳过空格。然后，<code>scanf</code>函数诗篇数据项，并且在遇到 <strong>不可能属于此项的字符（笔记：如果不可能属于此项的字符为本次读取的第一个字符，则<code>scanf</code>立即停止。否则将此字符放回原位，在下次读取时作为第一个读取的字符。参考P31例子）</strong> 时停止。如果读入数据项成功，那么<code>scanf</code>函数会继续处理格式串的剩余部分；如果某一项不能成功读入，那么<code>scanf</code>函数将不再查看格式串的剩余部分（或余下的输入数据）而立即返回。</p>
<p>  在寻找数的起始位置时，<code>scanf</code>函数会忽略空白字符。因此，我们可以把数字放在同一行或者分散在几行内输入。</p>
<h4 id="3-2-3易混淆的printf函数和scanf函数（P32）"><a class="header-anchor" href="#3-2-3易混淆的printf函数和scanf函数（P32）">¶</a>3.2.3易混淆的<code>printf</code>函数和<code>scanf</code>函数（P32）</h4>
<p>  <code>printf</code>格式串结党以<code>\n</code>结尾，但是在<code>scanf</code>格式串末尾旋转换行符通常是一个坏主意。对<code>scanf</code>函数来说，格式串中的换行符等价于空格，两者都会引发<code>scanf</code>函数提前进入下一个非空白字符。例如，如果格式串是&quot;<code>%d\n</code>&quot;，那么函数将跳过空白字符，读取一个整数，然后跳到下一个非空白字符处。像这样的格式串可能会导致交互式程序一直“挂起”直到用户输入一个非空白字符为止。</p>
<h3 id="第三章FAQ（P33）"><a class="header-anchor" href="#第三章FAQ（P33）">¶</a>第三章FAQ（P33）</h3>
<p>  <code>%i</code>与<code>%d</code>区别：<code>%i</code>可以为十进制、八进制（0开头）、十六进制（0x或0X开头）的数，<code>%d</code>只识别十进制数。</p>
<hr>
<h2 id="第四章-表达式"><a class="header-anchor" href="#第四章-表达式">¶</a>第四章 表达式</h2>
<h3 id="4-2-赋值运算符"><a class="header-anchor" href="#4-2-赋值运算符">¶</a>4.2 赋值运算符</h3>
<h4 id="4-2-1简单赋值（P40）"><a class="header-anchor" href="#4-2-1简单赋值（P40）">¶</a>4.2.1简单赋值（P40）</h4>
<p>  大多数C语言运算符不会改变操作数的值，但是也有一些会改变。由于这类运算符所做的不再仅仅是计算出值，所以称它们有副作用。如<code>i = 0</code>求值产生的结果为0，并（作为副作用）把0值赋给i。</p>
<h4 id="4-2-3复合赋值（P41）"><a class="header-anchor" href="#4-2-3复合赋值（P41）">¶</a>4.2.3复合赋值（P41）</h4>
<ol>
<li>
<p>在极少数情况下，由于v自身的副作用，<code>v += e</code>不等同于<code>v = v + e</code> <strong>（笔记：<code>v += e</code>中v的值只计算一次，而<code>v = v + e</code>中v的值会计算两次。如：<code>a[i++] += 2</code>中i会自增一次，<code>a[i++] = a[i++] + 2</code>中i会自增两次）</strong>。类似的说明也适用于其它复合赋值运算符。</p>
</li>
<li>
<p>复合赋值运算符有着和=运算符一样的特性。特别是，它们都是右结合的，所以</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i += j += k</span><br></pre></td></tr></table></figure>
<p>意味着</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i += (j += k)</span><br></pre></td></tr></table></figure>
<h3 id="4-5表达式语句（P45）"><a class="header-anchor" href="#4-5表达式语句（P45）">¶</a>4.5表达式语句（P45）</h3>
<p>  任何表达式都可以用作语句。<code>i * j - 1</code>因为i和j没有变化，所以这条语句没有任何作用。</p>
<hr>
<h2 id="第五章-选择语句"><a class="header-anchor" href="#第五章-选择语句">¶</a>第五章 选择语句</h2>
<h3 id="5-2-if语句"><a class="header-anchor" href="#5-2-if语句">¶</a>5.2 <code>if</code>语句</h3>
<h4 id="5-2-4-“悬空else”的问题（P56）"><a class="header-anchor" href="#5-2-4-“悬空else”的问题（P56）">¶</a>5.2.4 “悬空<code>else</code>”的问题（P56）</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (y != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">        result = x / y;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error: y is equal to 0\n"</span>);</span><br></pre></td></tr></table></figure>
<p>  C语言遵循的规则是<code>else</code>子句应该属于离它最近的且还未和其它<code>else</code>匹配的<code>if</code>语句。</p>
<h4 id="5-2-7-C99中的布尔值（P58）"><a class="header-anchor" href="#5-2-7-C99中的布尔值（P58）">¶</a>5.2.7 C99中的布尔值（P58）</h4>
<p>  在C99中提供了<code>_Bool</code>型，<font color=red><strong><code>_Bool</code>是无符号整型，但只能赋值为0或1，一般来说，往<code>_Bool</code>变量中存储非零值会导致变量赋值为1</strong></font>。<br>
  除了<code>_Bool</code>类型的宝座，C99还提供了一个新的头&lt;stdbool.h&gt;。该问提供了<code>bool</code>宏来代表<code>_Bool</code>，<code>true</code>来代表1，<code>false</code>来代表0。</p>
<h3 id="5-3-switch语句"><a class="header-anchor" href="#5-3-switch语句">¶</a>5.3 <code>switch</code>语句</h3>
<ol>
<li><code>switch</code>后边必须跟着由圆括号括起来的<font color=red><strong>整型</strong></font>表达式，不能用浮点数和字符串。</li>
<li><code>case</code>后跟<font color=red><strong>常量表达式</strong></font>，如<code>5 + 10</code>。</li>
</ol>
<h3 id="第五章FAQ（P63-P64）"><a class="header-anchor" href="#第五章FAQ（P63-P64）">¶</a>第五章FAQ（P63~P64）</h3>
<ol>
<li>当<code>int</code>型和<code>float</code>型的值混合在一个条件表达式中时（如<code>i &gt; 0 ? i : f</code>）表达式类型为<code>float</code>型。如果<code>i &gt; 0</code>为真，那么变量i转化为<code>float</code>型后的值就是表达式的值。</li>
<li>C89标准指出，以下划线后跟一个大写字母开头的名字是保留字，程序员不应该使用。</li>
</ol>
<hr>
<h2 id="第六章-循环"><a class="header-anchor" href="#第六章-循环">¶</a>第六章 循环</h2>
<h3 id="6-3-for语句"><a class="header-anchor" href="#6-3-for语句">¶</a>6.3 <code>for</code>语句</h3>
<h4 id="6-3-4-逗号运算符（P76）"><a class="header-anchor" href="#6-3-4-逗号运算符（P76）">¶</a>6.3.4 逗号运算符（P76）</h4>
<ol>
<li>形式：表达式1, 表达式2</li>
<li>实现方式：第一步，计算表达式1并且扔掉计算出的值。第二步，计算表达式2，把这个值作为整个表达式的值。</li>
<li>例如：<code>i = 1</code>, <code>j = 2</code>, <code>k = i + j</code>解释为<code>((i = 1), (j = 2)), (k = (i + j))</code></li>
</ol>
<h3 id="6-4-退出循环"><a class="header-anchor" href="#6-4-退出循环">¶</a>6.4 退出循环</h3>
<h4 id="6-4-3-goto语句（P79）"><a class="header-anchor" href="#6-4-3-goto语句（P79）">¶</a>6.4.3 <code>goto</code>语句（P79）</h4>
<ol>
<li><code>break</code>语句的目标是包含该语句的循环结束之<font color=red><strong>后</strong></font>的那一点，而<code>continue</code>语句的目标是循环结束之<font color=red><strong>前</strong></font>的那一点。</li>
<li><code>goto</code>语句不可以用于绕过变长数组。</li>
</ol>
<h3 id="第六章FAQ（P83-P84）"><a class="header-anchor" href="#第六章FAQ（P83-P84）">¶</a>第六章FAQ（P83~P84）</h3>
<ol>
<li>早期编译器中无限循环<code>for(;;)</code>比<code>while(1)</code>高效；新编译器性能无差别。</li>
<li>空语句可以有如下用途：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">goto</span> end_of_stmt;</span><br><span class="line">    end_of_stmt: ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第七章-基本类型"><a class="header-anchor" href="#第七章-基本类型">¶</a>第七章 基本类型</h2>
<h3 id="7-1整数类型（P89"><a class="header-anchor" href="#7-1整数类型（P89">¶</a>7.1整数类型（P89)</h3>
<p>  <code>short int</code>、<code>int</code>、<code>long int</code>取值范围有可能是一样的。但C标准规定<code>int</code>取值范围不能比<code>short int</code>小，<code>long int</code>取值范围不能比<code>int</code>小。</p>
<h4 id="7-1-4整数溢出（P91）"><a class="header-anchor" href="#7-1-4整数溢出（P91）">¶</a>7.1.4整数溢出（P91）</h4>
<ol>
<li>有符号整数溢出行为未定义。</li>
<li>无符号整数溢出为对<code>2n</code>取模，其中<code>n</code>是用于存储结果的位数。例如，如果对无符号的16位数65535加1，其结果可以保证为0。</li>
</ol>
<h3 id="7-3字符类型"><a class="header-anchor" href="#7-3字符类型">¶</a>7.3字符类型</h3>
<h4 id="7-3-1字符操作（P95）"><a class="header-anchor" href="#7-3-1字符操作（P95）">¶</a>7.3.1字符操作（P95）</h4>
<p>  C语言把字符当作小整数进行处理。</p>
<h4 id="7-3-7用getchar和putchar读-写字符"><a class="header-anchor" href="#7-3-7用getchar和putchar读-写字符">¶</a>7.3.7用<code>getchar</code>和<code>putchar</code>读/写字符</h4>
<p>  在同一个程序中混合使用<code>getchr</code>函数和<code>scanf</code>函数时，要注意<code>scanf</code>函数倾向于遗留下它“扫视”过但未读取的字符（包括换行符）。考虑下面程序段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter an integer: "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter a command: "</span>);</span><br><span class="line"> </span><br><span class="line">command = getchar();</span><br></pre></td></tr></table></figure>
<p>  在读入<code>i</code>的同时，<code>scanf</code>函数调用将会留下没有消耗掉的任意字符，包括（但不限于）换行符。<code>getchar</code>函数随后将取回第一个剩余字符，但这不是我们所希望的结果。</p>
<h3 id="7-4类型转换（P100）"><a class="header-anchor" href="#7-4类型转换（P100）">¶</a>7.4类型转换（P100）</h3>
<p>  当发生下列情况时会进行隐匿转换。</p>
<ul>
<li>当算术表达式或逻辑表达式中操作数的类型不相同时。（C语言执行所谓的常用算术转换）</li>
<li>当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。</li>
<li>当函数调用中的实参类型与其对应的形参类型不匹配时。</li>
<li>当<code>return</code>语句中表达式的类型和函数返回值的类型不匹配时。</li>
</ul>
<h4 id="7-4-1常用算术转换（P101）"><a class="header-anchor" href="#7-4-1常用算术转换（P101）">¶</a>7.4.1常用算术转换（P101）</h4>
<ol>
<li>
<p>任一操作数是浮点类型的情况。</p>
<pre><code>         long double
               ^
               |
            double
               ^
               |
             float
</code></pre>
</li>
<li>
<p>两个操作数的类型都不是浮点类型的情况。</p>
<pre><code>        unsigned long int
                 ^
                 |
              long int
                 ^
                 |
           unsigned int
                 ^
                 |
                int
</code></pre>
</li>
</ol>
<p>  有一种特殊情况，只有在<code>long int</code>类型和<code>unsigned int</code>类型长度（比如32位）相同时才会发生。在这类情况下，如果一个操作数的类型是<code>long int</code>，而另一个的类型是<code>unsiged int</code>，那么两个操作数都会转换成<code>unsigned long int</code>类型。C语言把（类型名）视为一元运算符。一元运算符的优先级高于二元运算符，所以编译器会把表达。</p>
<p>  当把有符号操作数和无符号操作数组合时，把有符号操作数“转换”成无符号的值。转换过程中需要加上或者减去<code>n + 1</code>的倍数，其中<code>n</code>是无符号类型能表示的最大值。这条规则可能会导致某此隐蔽的编程错误。</p>
<p>  假设<code>int</code>类型的变量<code>i</code>的值为-10，而<code>unsigned int</code>类型的变量<code>u</code>的值为10。如果用&lt;运算符比较变量<code>i</code>和变量<code>u</code>，那么期望的结果应该是1（真）。但是，在比较前，变量<code>i</code>转换成为<code>unsigned int</code>类型。因为负数不能被表示成无符号整数，所以转换后的值不再为-10，而是加上4294967296的结果（假定4294967296是最大的无符号整数），即4294967286。因而<code>i &lt; u</code>比较的结果将为0。有些编译器会在程序试图比较有符号与无符号时给出一条类似“comparison between signed and unsigned”的警告消息。</p>
<p>  由于此类陷阱的存在，所以最好尽量避免使用无符号整数，特别是不要把它和有符号整数混合使用。</p>
<h4 id="7-4-2赋值过程中的转换（P102）"><a class="header-anchor" href="#7-4-2赋值过程中的转换（P102）">¶</a>7.4.2赋值过程中的转换（P102）</h4>
<p>  把某种类型的值赋给类型更狭小的变量时，如果该值在变量类型范围之外，那么将会得到无意义的结果（甚至更糟）。<br>
  如果浮点常量被赋值给<code>float</code>型变量时，一个很好的方法是在浮点常量尾部加上后辍<code>f</code>。</p>
<h4 id="7-4-4强制类型转换（P103）"><a class="header-anchor" href="#7-4-4强制类型转换（P103）">¶</a>7.4.4强制类型转换（P103）</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> quotient;</span><br><span class="line"><span class="keyword">int</span> dividend, divisor;</span><br><span class="line"> </span><br><span class="line">quotient = (<span class="keyword">float</span>) dividend / divisor;</span><br></pre></td></tr></table></figure>
<p>  变量<code>divisor</code>不需要进行强制类型转换，因为把变量<code>dividend</code>强制錾成<code>float</code>类型会迫使编译器把<code>divisor</code>也转换成<code>float</code>类型。C语言把（类型名）视为一元运算符。一元运算符的优先级高于二元运算符，所以编译器会把表达式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">float</span>) dividend / divisor</span><br></pre></td></tr></table></figure>
<p>  解释为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((<span class="keyword">float</span>) dividend) / divisor</span><br></pre></td></tr></table></figure>
<h3 id="7-6-sizeof运算符（P106）"><a class="header-anchor" href="#7-6-sizeof运算符（P106）">¶</a>7.6 <code>sizeof</code>运算符（P106）</h3>
<p>  显示<code>sizeof</code>值时要注意，因为<code>sizeof</code>表达式的类型是<code>size_t</code>，这是一种由实现定义的类型。在C89中，最好在显示前把表达式的值转换成一种已知的类型。<code>size_t</code>一定是无符号整型，所以最安全的方法是把<code>sizeof</code>表达式强制转换成<code>unsigned long</code>类型。(C89中最大的无符号类型)，然后使用转换说明答题<code>%lu</code>显示。</p>
<p>  在C99中，<code>size_t</code>类型可以比<code>unsigned long</code>更长。但C99中的<code>printf</code>可以直接显示<code>size_t</code>类型值而不需要强制转换。方法是在转换说明中的一般整数（通常用<code>u</code>）代码前使用字母<code>z</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Size of int: %zu\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">/* C99 only */</span></span><br></pre></td></tr></table></figure>
<h3 id="第七章FAQ（P107）"><a class="header-anchor" href="#第七章FAQ（P107）">¶</a>第七章FAQ（P107）</h3>
<p>  只要有符号整数的值不是负值，就可以用<code>%o</code>和<code>%x</code>显示。这些转换导致<code>printf</code>函数把有符号整数看成无符号的；换句话说，<code>printf</code>函数将假设符号位是数的绝对值部分。只要符号位为0，就没问题。如果符号位为1，那么<code>printf</code>函数将显示出一个走出预期的大数。没有直接的方法可以书写负数的八进制或十六进制形式。幸运的是，需要这样做的情况非常少。当然，我们可以判定这个数是否是负数，然后自己显示一个负号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-%x"</span>, -i);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%x"</span>, i);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>python3 创建带虚拟环境的 Windows 服务程序</title>
    <url>/2020/02/10/python3-%E5%88%9B%E5%BB%BA%E5%B8%A6%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84-Windows-%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1>python3 创建带虚拟环境的 Windows 服务程序</h1>
<ol>
<li>
<p>以 <strong>管理员</strong> 权限<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>打开“命令提示符”或 PowerShell，并 <code>cd</code> 至项目根目录。</p>
</li>
<li>
<p>在项目目录建立虚拟环境<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">python <span class="literal">-m</span> venv .</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>激活虚拟环境：</p>
 <figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="comment">rem 命令提示符</span></span><br><span class="line">.\Scripts\activate.bat</span><br></pre></td></tr></table></figure>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\Scripts\activate.ps1 <span class="comment"># powershell</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装 pywin32。</p>
</li>
<li>
<p>执行 post-install 脚本<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">python .\Scripts\pywin32_postinstall.py <span class="literal">-install</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将 <em>\Lib\site-packages\win32\pythonservice.exe</em> 复制到 <em>myvenv\Scripts\pythonservice.exe</em> 。<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
</li>
<li>
<p>编写服务类及服务管理器：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Service.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QBTransportService</span><span class="params">(win32serviceutil.ServiceFramework)</span>:</span></span><br><span class="line">    _svc_name_ = <span class="string">'服务名称（简称）'</span></span><br><span class="line">    _svc_display_name_ = <span class="string">"服务显示名称"</span></span><br><span class="line">    _svc_description_ = <span class="string">"服务描述"</span></span><br><span class="line">    <span class="comment"># _svc_deps = None # 依赖哪些服务（服务名称）</span></span><br><span class="line">    <span class="comment"># _exe_args = None # 服务参数        </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># VIRTUAL_ENV 环境变量并不是在所有阶段都存在，所以需要判断。</span></span><br><span class="line">    <span class="comment"># StackOverflow 上说是 _exe_path_，经测试无效，多次尝试后确定应是 _exe_name_。</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hasattr(sys, <span class="string">'frozen'</span>) <span class="keyword">and</span> <span class="string">'VIRTUAL_ENV'</span> <span class="keyword">in</span> os.environ:</span><br><span class="line">        _exe_name_ = os.path.join(*[os.environ[<span class="string">'VIRTUAL_ENV'</span>], <span class="string">'Scripts'</span>, <span class="string">'pythonservice.exe'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, args)</span>:</span></span><br><span class="line">        win32serviceutil.ServiceFramework.__init__(self, args)</span><br><span class="line">        self.hWaitStop = win32event.CreateEvent(<span class="literal">None</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">        self.isAlive = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SvcDoRun</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 在此运行主要任务。</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若在上面启动了一个线程，需要进行 join，否则服务立即退出。</span></span><br><span class="line">        <span class="comment"># self._thread.join()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SvcStop</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行一些清理工作。</span></span><br><span class="line"></span><br><span class="line">        win32event.SetEvent(self.hWaitStop)</span><br><span class="line">        self.isAlive = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            servicemanager.Initialize()</span><br><span class="line">            servicemanager.PrepareToHostSingle(QBTransportService)</span><br><span class="line">            servicemanager.StartServiceCtrlDispatcher()</span><br><span class="line">        <span class="keyword">except</span> win32service.error <span class="keyword">as</span> details:</span><br><span class="line">            <span class="keyword">if</span> details == winerror.ERROR_FAILED_SERVICE_CONTROLLER_CONNECT:</span><br><span class="line">                win32serviceutil.usage()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        win32serviceutil.HandleCommandLine(QBTransportService)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装并启动服务：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">python .\Service.py install</span><br><span class="line">python .\Service.py start</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>附：服务管理。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">import</span> win32service</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"><span class="keyword">import</span> time, sys</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">"utf8"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""管理window服务的类"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        name: 服务的名称</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#启动或停止服务时等待操作成功等待时间</span></span><br><span class="line">        self.wait_time = <span class="number">0.5</span></span><br><span class="line">        <span class="comment">#启动或停止服务时最大等待时间，超过时返回超时提示</span></span><br><span class="line">        self.delay_time = <span class="number">10</span></span><br><span class="line">        self.scm = win32service.OpenSCManager(<span class="literal">None</span>, <span class="literal">None</span>, win32service.SC_MANAGER_ALL_ACCESS)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.is_exists():</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.handle = win32service.OpenService(self.scm, self.name, win32service.SC_MANAGER_ALL_ACCESS)</span><br><span class="line">            <span class="keyword">except</span> Exception, e:</span><br><span class="line">                self.log(e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'服务 %s 没有安装'</span>.encode(<span class="string">'gbk'</span>) % self.name</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_stop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""检查服务是否停止"""</span></span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> self.handle:</span><br><span class="line">                ret = win32service.QueryServiceStatus(self.handle)</span><br><span class="line">                flag = ret[<span class="number">1</span>] != win32service.SERVICE_RUNNING</span><br><span class="line">        <span class="keyword">except</span> Exception, e:</span><br><span class="line">            self.log(e)</span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""开启服务"""</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> self.handle:</span><br><span class="line">                win32service.StartService(self.handle, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception, e:</span><br><span class="line">            self.log(e)</span><br><span class="line">        status_info = win32service.QueryServiceStatus(self.handle)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> status_info[<span class="number">1</span>] == win32service.SERVICE_RUNNING:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'启动服务%s成功'</span>.encode(<span class="string">'gbk'</span>) % self.name</span><br><span class="line">        <span class="keyword">elif</span> status_info[<span class="number">1</span>] == win32service.SERVICE_START_PENDING:</span><br><span class="line">            <span class="comment">#如果服务正在启动中则延迟返回启动信息，直到启动成功,或返回启动时间过长信息</span></span><br><span class="line">            start_time = datetime.datetime.now()</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> (datetime.datetime.now() - start_time).seconds &gt; self.delay_time:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'启动服务%s时间太长'</span>.encode(<span class="string">'gbk'</span>) % self.name</span><br><span class="line"></span><br><span class="line">                time.sleep(self.wait_time)</span><br><span class="line">                <span class="keyword">if</span> win32service.QueryServiceStatus(self.handle)[<span class="number">1</span>] == win32service.SERVICE_RUNNING:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'启动服务%s成功'</span>.encode(<span class="string">'gbk'</span>) % self.name</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'启动服务%s失败'</span>.encode(<span class="string">'gbk'</span>) % self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""停止服务"""</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            status_info = win32service.ControlService(self.handle, win32service.SERVICE_CONTROL_STOP)</span><br><span class="line">        <span class="keyword">except</span> Exception, e:</span><br><span class="line">            self.log(e)</span><br><span class="line">        <span class="keyword">if</span> status_info[<span class="number">1</span>] == win32service.SERVICE_STOPPED:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'停止服务%s成功'</span>.encode(<span class="string">'gbk'</span>) % self.name</span><br><span class="line">        <span class="keyword">elif</span> status_info[<span class="number">1</span>] == win32service.SERVICE_STOP_PENDING:</span><br><span class="line">            start_time = datetime.datetime.now()</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> (datetime.datetime.now() - start_time).seconds &gt; self.delay_time:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'停止服务%s时间太长'</span>.encode(<span class="string">'gbk'</span>) % self.name</span><br><span class="line"></span><br><span class="line">                time.sleep(self.wait_time)</span><br><span class="line">                <span class="keyword">if</span> win32service.QueryServiceStatus(self.handle)[<span class="number">1</span>] == win32service.SERVICE_STOPPED:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'停止服务%s成功'</span>.encode(<span class="string">'gbk'</span>) % self.name</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'停止服务%s失败'</span>.encode(<span class="string">'gbk'</span>) % self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restart</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""重启服务"""</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_stop():</span><br><span class="line">            self.stop()</span><br><span class="line">        self.start()</span><br><span class="line">        <span class="keyword">return</span> win32service.QueryServiceStatus(self.handle)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">status</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""获取运行的状态"""</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            status_info = win32service.QueryServiceStatus(self.handle)</span><br><span class="line">            status = status_info[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> status == win32service.SERVICE_STOPPED:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"STOPPED"</span></span><br><span class="line">            <span class="keyword">elif</span> status == win32service.SERVICE_START_PENDING:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"STARTING"</span></span><br><span class="line">            <span class="keyword">elif</span> status == win32service.SERVICE_STOP_PENDING:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"STOPPING"</span></span><br><span class="line">            <span class="keyword">elif</span> status == win32service.SERVICE_RUNNING:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"RUNNING"</span></span><br><span class="line">        <span class="keyword">except</span> Exception, e:</span><br><span class="line">            self.log(e)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""释放资源"""</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> self.scm:</span><br><span class="line">                win32service.CloseServiceHandle(self.handle)</span><br><span class="line">                win32service.CloseServiceHandle(self.scm)</span><br><span class="line">        <span class="keyword">except</span> Exception, e:</span><br><span class="line">            self.log(e)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_exists</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""windows服务是否已安装"""</span></span><br><span class="line">        statuses = win32service.EnumServicesStatus(self.scm, win32service.SERVICE_WIN32, win32service.SERVICE_STATE_ALL)</span><br><span class="line">        <span class="keyword">for</span> (short_name, desc, status) <span class="keyword">in</span> statuses:</span><br><span class="line">            <span class="keyword">if</span> short_name == self.name:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(self, exception)</span>:</span></span><br><span class="line"></span><br><span class="line">        print(exception)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    app= ServiceManager(<span class="string">'AAaservice'</span>)</span><br><span class="line">    msg= app.is_exists()  <span class="comment"># 判断是否安装  （以下操作必须先判断服务是否存在）</span></span><br><span class="line">    <span class="comment">#msg= app.is_stop()  # 判断服务是否停止</span></span><br><span class="line">    <span class="comment">#msg= app.status()  # 查看服务的状态</span></span><br><span class="line">    <span class="comment">#msg= app.start()  # 开启服务</span></span><br><span class="line">    <span class="comment">#msg= app.stop()  # 暂停服务   （服务开启才能停止，else error）</span></span><br><span class="line">    <span class="comment">#msg= app.restart()  # 重启服务</span></span><br><span class="line"></span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>参考：<br>
[StackOverflow]: <a href="https://stackoverflow.com/questions/34696815/using-pythonservice-exe-to-host-python-service-while-using-virtualenv" target="_blank" rel="noopener">https://stackoverflow.com/questions/34696815/using-pythonservice-exe-to-host-python-service-while-using-virtualenv</a><br>
[using pythonservice exe to host python service while using virtualenv（已无法访问，参考 Google 快照）]: <a href="http://xm8z2.icu/questions/34696815/using-pythonservice-exe-to-host-python-service-while-using-virtualenv" target="_blank" rel="noopener">http://xm8z2.icu/questions/34696815/using-pythonservice-exe-to-host-python-service-while-using-virtualenv</a><br>
[Python 写Windows Service服务程序 ]: <a href="https://www.cnblogs.com/dcb3688/p/4496934.html" target="_blank" rel="noopener">https://www.cnblogs.com/dcb3688/p/4496934.html</a></p>
</blockquote>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>pywin32 包需要访问注册表，所以 <strong>所有</strong> 必须使用管理员权限进行。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>必须使用 Python 自带的 venv 模块，不能使用 virtualenv。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>不执行此脚本服务无法启动。卸载脚本为 <code>python .\Scripts\pywin32_postinstall.py -uninstall</code> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>猜测可以跳过此步，<em>pythonservice.exe</em> 应当与服务类中的 _exe_name_ 所指向路径相同即可，未测试。 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Windows</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Hexo 免费搭建属于自己的个人博客</title>
    <url>/2018/10/23/%E4%BD%BF%E7%94%A8-Hexo-%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1>使用 Hexo 免费搭建属于自己的个人博客</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="安装搭建博客必须的环境"><a class="header-anchor" href="#安装搭建博客必须的环境">¶</a>安装搭建博客必须的环境</h2>
<ol>
<li>安装 Git<br>
这里就不说怎么安装了，相信会看这篇文章的一般都已经装了。</li>
<li>申请 GitHub 账号<br>
<code>博客</code> 的 <code>远程创库</code>、<code>域名</code>、<code>服务器</code> 等都和 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 有关，这个必须要。</li>
<li>安装 Node.js<br>
前往 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js 官网</a> 下载最新版本的安装包安装即可。<br>
<img src="https://upload-images.jianshu.io/upload_images/1930874-31fc3087c49f43af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="安装Node.js"></li>
<li>安装 Hexo<br>
打开终端，输入以下命令安装 Hexo ，安装时间可能有点长，要多等一下。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<h2 id="开始搭建博客"><a class="header-anchor" href="#开始搭建博客">¶</a>开始搭建博客</h2>
<p>以上环境必须全部安装完成后，才能开始搭建 <code>博客</code>。</p>
<h3 id="1-创建-GitHub-仓库"><a class="header-anchor" href="#1-创建-GitHub-仓库">¶</a>1. 创建 GitHub 仓库</h3>
<p>打开 GitHub 创建一个仓库，Repository name 为 <a href="http://xxx.github.io" target="_blank" rel="noopener">xxx.github.io</a>，xxx 处就是你 GitHub 的用户名，也就是前面 Owner 处显示的名字，命名必须这样，不能更改，这个仓库的名字也会是 博客 搭建完成后的域名。<br>
<img src="https://upload-images.jianshu.io/upload_images/1930874-6fe8a4a5a643e017.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="创建GitHub仓库"></p>
<h3 id="2-初始化-Hexo-博客"><a class="header-anchor" href="#2-初始化-Hexo-博客">¶</a>2. 初始化 Hexo 博客</h3>
<p>打开终端，执行以下命令初始化 博客，初始化完成后，你的系统根目录中会多一个名为 Blog 的文件夹，Blog 也可以更改成自己喜欢的名字，初始化时间也比较久，耐心等一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init Blog</span><br></pre></td></tr></table></figure>
<h3 id="3-下载博客主题"><a class="header-anchor" href="#3-下载博客主题">¶</a>3. 下载博客主题</h3>
<ul>
<li>
<p><code>博客</code> 初始化完成以后，会有一个自带的 <code>博客主题</code> ，在 <code>Blog / themes </code>文件夹下，但是比较丑，你可以下载一个自己喜欢的 <code>博客主题</code> 。</p>
</li>
<li>
<p>这里是 <code>博客主题</code> 的 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">下载地址</a> ，只需要到主题对应的 <code>GitHub</code> 仓库将主题 <code>clone</code> 下来即可，这是我使用的主题 <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank" rel="noopener">下载地址</a> 。</p>
</li>
<li>
<p><code>clone</code> 完成后，将主题文件夹复制到 <code>Blog</code> 文件夹下的 <code>themes</code> 文件夹中。</p>
</li>
<li>
<p>启用 About 页（限archer主题，其它主题查看相应文档）</p>
<ul>
<li>在<strong>hexo目录</strong>下执行</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">"about"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在hexo目录下<code>source/about/index.md</code>中添加字段<code>layout: about</code>（这个字段必须有且不可更改为其他），<code>title</code>字段修改为about页的标题（自行修改），正文为about页的内容（自行修改），例如：</li>
</ul>
  <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 这是自我介绍的题目</span><br><span class="line">layout: about</span><br><span class="line">---</span><br><span class="line">这是一段自我介绍</span><br></pre></td></tr></table></figure>
<ul>
<li>在<strong>主题配置文件</strong>中添加以下字段，<code>enable</code>字段控制是否开启about，<code>image</code>字段内容为about页的banner图像地址，不填写则默认使用首页banner图像。</li>
</ul>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">about:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">'/intro/about-page.jpg'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-修改博客配置文件"><a class="header-anchor" href="#4-修改博客配置文件">¶</a>4. 修改博客配置文件</h3>
<ul>
<li>
<p>打开 <code>Blog</code> 文件夹下的 <code>_config.yml</code> 文件，修改其中的配置。</p>
</li>
<li>
<p>下面把几个必须修改的配置列出来按需求修改即可，配置的键值之间一定要有空格，否则会报错，想了解更多配置点击 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">这里</a> 。</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Jonzzs</span>  <span class="string">//博客的标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">个人博客</span> <span class="string">//博客的副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">将来的你</span> <span class="string">一定会感激现在拼命的自己</span> <span class="string">//博客的描述</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Jonzzs</span> <span class="string">//博客作者的名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span> <span class="string">//语言中文</span></span><br><span class="line"></span><br><span class="line"><span class="attr">theme:</span> <span class="string">new-vno</span> <span class="string">//刚刚复制到</span> <span class="string">themes</span> <span class="string">文件夹下的主题名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span> <span class="string">//使用</span> <span class="string">Git</span> <span class="string">发布</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">https://github.com/Jonzzs/Jonzzs.github.io.git</span> <span class="string">//刚创建的</span> <span class="string">Github</span> <span class="string">仓库地址</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>关于主题的配置在各自主题文件夹下的 _config.yml 文件中修改。</p>
</li>
</ul>
<h3 id="5-写博客文章"><a class="header-anchor" href="#5-写博客文章">¶</a>5. 写博客文章</h3>
<ul>
<li>
<p>接下来可以开始写你的第一篇 <code>博客</code> 文章了，博客文章保存在 <code>Blog / source / _posts</code> 文件夹下，格式为 <code>MarkDown</code> 格式，也就是 <code>.md</code> 后缀的文件，编码格式为 <code>UTF-8</code> ，否则会显示乱码。<br>
<strong>例如</strong>： 创建一个名为 <code>测试文章.md</code> 的文件，内容为：</p>
  <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 测试文章 //文章的标题</span><br><span class="line">date: 2017-05-03 17:47 //文章的发布时间</span><br><span class="line">categories: 测试分类 //分类名称</span><br><span class="line">tags: 测试标签 //标签名称</span><br><span class="line">photos: http://jonzzs.cn/images/Jonzzs.jpg //需要展示的图片地址</span><br><span class="line">---</span><br><span class="line"><span class="code">    </span></span><br><span class="line"> &gt; 这是一篇测试文章。</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：每一篇文章中，开头都必须有 — 之间的那些参数，参数 : 后面必须有空格，文章的 标题 是必填的，否则文章不会显示在博客中，其他参数看自己的需求填写，categories 、tags 、photos 这三个参数可填写多个，填写多个时用 [ xx, xx ] 格式区分，例如：</p>
  <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 测试文章 //文章的标题</span><br><span class="line">date: 2017-05-03 17:47 //文章的发布时间</span><br><span class="line">categories: [测试分类1, 测试分类2, 测试分类3] //分类名称</span><br><span class="line">tags: [测试标签1, 测试标签2, 测试标签3] //标签名称</span><br><span class="line">photos: [http://jonzzs.cn/images/Jonzzs.jpg, http://jonzzs.cn/images/Jonzzs.jpg, http://jonzzs.cn/images/Jonzzs.jpg] //需要展示的图片地址</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果要在博客的首页显示每篇文章的 <code>摘要</code> ，只要在文章中加入以下 <code>分隔符</code> 即可，该 <code>分隔符</code> 之前的所有内容都会被自动截取为文章的 <code>摘要</code> 。</p>
  <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- more --&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-本地测试博客"><a class="header-anchor" href="#6-本地测试博客">¶</a>6. 本地测试博客</h3>
<ul>
<li>
<p>打开终端 <code>cd</code> 到 <code>Blog</code> 目录下，输入以下命令：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接着浏览器中输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就能够看到 <code>博客</code> 的搭建效果。</p>
</li>
</ul>
<h2 id="发布博客"><a class="header-anchor" href="#发布博客">¶</a>发布博客</h2>
<p>本地显示没问题以后，就可以将 <code>博客</code> 发布到 <code>GitHub</code> 服务器上了。</p>
<h3 id="1-安装自动部署发布插件"><a class="header-anchor" href="#1-安装自动部署发布插件">¶</a>1. 安装自动部署发布插件</h3>
<p>第一次配置时需要安装 <code>hexo-deployer-git</code> 自动部署发布工具，打开终端 <code>cd</code> 到 <code>Blog</code> 目录下，执行以下命令安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h3 id="2-发布博客到服务器"><a class="header-anchor" href="#2-发布博客到服务器">¶</a>2. 发布博客到服务器</h3>
<ul>
<li>打开终端 <code>cd</code> 到 <code>Blog</code> 目录下，输入以下命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<ul>
<li>如果这是你的第一次，终端可能会让你输入 <code>Github</code> 的邮箱和密码，输入完成后，就会把你的 <code>博客</code> 自动上传至 <code>Github</code> 了。</li>
<li>以后在每一次添加新的 <code>博客</code> 文章或者改变配置时，执行一下这个命令就可以直接发布了。<br>
发布完成后，浏览器中输入之前创建的 <code>Github</code> 仓库名，就能访问到你搭建的 博客 了，我的是 <code>carzpurzkey.github.io</code> 。</li>
</ul>
<hr>
<blockquote>
<p>简单的 <code>博客</code> 搭建流程就是这样了，还有很多不错的 <a href="https://hexo.io/plugins/" target="_blank" rel="noopener">插件</a> ，比如 <code>评论</code>、<code>标签</code>、<code>统计</code> 等等，这些自己去研究并慢慢完善自己的博客吧。</p>
</blockquote>
<h2 id="使用-码云-来托管-Hexo-搭建的博客"><a class="header-anchor" href="#使用-码云-来托管-Hexo-搭建的博客">¶</a>使用 码云 来托管 Hexo 搭建的博客</h2>
<ol>
<li>
<p>首先进入 <a href="https://gitee.com" target="_blank" rel="noopener">码云</a> 创建一个仓库，<code>仓库名称</code> 和 <code>仓库路径</code> 都必须和你的 <code>用户名</code> 也就是上面的 <code>归属</code> 一样。<br>
<img src="https://upload-images.jianshu.io/upload_images/1930874-ef54f8b245f993a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="创建仓库"></p>
</li>
<li>
<p>打开本地 <code>博客</code> 下的 <code>_config.yml</code> 文件，将刚才创建的仓库 <code>Git</code> 地址配置进去。<br>
<img src="https://upload-images.jianshu.io/upload_images/1930874-732a1474b74dae5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/772/format/webp" alt="仓库Git地址"></p>
</li>
<li>
<p>添加托管</p>
</li>
</ol>
<ul>
<li>
<p>如果想使用 GitHub 和 码云 同时托管 博客 ，就这样配置：</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span></span><br><span class="line">        <span class="attr">github:</span> <span class="string">https://github.com/Jonzzs/Jonzzs.github.io.git</span></span><br><span class="line">        <span class="attr">oschina:</span> <span class="string">https://git.oschina.net/Jonzzs/Jonzzs.git</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果只想使用 码云 托管 博客 ，就这样配置：</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">https://git.oschina.net/Jonzzs/Jonzzs.git</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="4">
<li>
<p>保存文件后打开终端 <code>cd</code> 到 <code>博客</code> 目录下，使用以下命令重新部署一下博客。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>再次打开刚才 <code>码云</code> 上创建的仓库刷新一下，博客 的 <code>HTML</code> 页面应该已经传到仓库中了，打开 <code>服务</code> 中的 <code>Pages</code>，点击 <code>启动服务</code> 。<br>
<img src="https://upload-images.jianshu.io/upload_images/1930874-4556b0dc9fa60ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="Pages"></p>
</li>
<li>
<p>此时你就可以使用 <code>用户名.gitee.io</code> 来访问你的 <code>博客</code> 了。<br>
<img src="https://upload-images.jianshu.io/upload_images/1930874-be5eeac4cb380f7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="jonzzs.gitee.io"></p>
</li>
</ol>
<blockquote>
<p>大功告成，使用 <code>码云</code> 托管 <code>博客</code> 后访问速度会快很多，大家块试试看吧。</p>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>GPG 使用</title>
    <url>/2018/10/22/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8GPG/</url>
    <content><![CDATA[<h1>GPG使用</h1>
<hr>
<p>Pretty Good Privacy</p>
<h3 id="GPG是什么"><a class="header-anchor" href="#GPG是什么">¶</a>GPG是什么</h3>
<p>提GPG 之前需要提一个软件叫PGP。PGP 是“Pretty Good Privacy” 的缩写，中文直译为“完美隐私”，名字言简意赅，上来就把软件的用途拍用户脸上。然而PGP 不是自由软件，所以自由软件基金会决定开发一个替代PGP 的自由软件，于是有了GPG（GnuPG）。</p>
<p>GPG 可以提供对信息、文件的签名和验证，或者是加密和解密，主要用于不安全网络上的信息传输。为此GPG 需要一个密钥环，GPG 使用私钥和公钥分别完成签名和加密，对应地验证和解密由公钥和私钥完成。</p>
<h3 id="主钥、从钥、公钥、私钥"><a class="header-anchor" href="#主钥、从钥、公钥、私钥">¶</a>主钥、从钥、公钥、私钥</h3>
<p>然而GPG 密钥环并不只有一对公钥和私钥，如果称公钥和其对应的私钥为一个密钥对的话，那么一个GPG 密钥环可以拥有很多个密钥对，每一个密钥对都由一个钥匙号（key ID）标识，被称为钥匙。其中有一个钥匙拥有签名其他钥匙的功能（可以在密钥环中创建钥匙），这个钥匙被称为主钥，其他的钥匙则被称为从钥。<br>
下面列出了我在使用的一个密钥环，首先是公钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --list-keys</span><br><span class="line">/home/&lt;user&gt;/.gnupg/pubring.kbx</span><br><span class="line">---------------------------------</span><br><span class="line">pub   rsa4096/B66CC194 2016-04-15 [SC]</span><br><span class="line">uid         [ 绝对 ] Arondight &lt;shell_way@foxmail.com&gt;</span><br><span class="line">sub   rsa4096/F96E3CB7 2016-04-15 [E]</span><br></pre></td></tr></table></figure>
<p>然后是私钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --list-secret-keys</span><br><span class="line">/home/&lt;user&gt;/.gnupg/pubring.kbx</span><br><span class="line">---------------------------------</span><br><span class="line">sec   rsa4096/B66CC194 2016-04-15 [SC]</span><br><span class="line">uid         [ 绝对 ] Arondight &lt;shell_way@foxmail.com&gt;</span><br></pre></td></tr></table></figure>
<p>GPG 列出的每个密钥环第一行一定是主钥，其余的则为从钥，可以看到上面的密钥环中只有一个主钥和一个从钥。每个密钥后面有许多信息描述它的属性，例如sec rsa4096/B66CC194 2016-04-15 [SC] 代表这是一个主钥的私钥，加密算法为rsa，长度4096 位，主钥的钥匙号为B66CC194，创建于2016 年4 月15 日，功能为SC。</p>
<p>不难看出一个GPG 密钥环一共有四种类型的密钥，如果按照上面指令的样例输出来看的话则如下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">代表</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sec</td>
<td style="text-align:center">SECret key</td>
<td style="text-align:center">主钥的私钥</td>
</tr>
<tr>
<td style="text-align:center">pub</td>
<td style="text-align:center">PUBlic key</td>
<td style="text-align:center">主钥的公钥</td>
</tr>
<tr>
<td style="text-align:center">ssb</td>
<td style="text-align:center">Secret SuBkey</td>
<td style="text-align:center">从钥的私钥</td>
</tr>
<tr>
<td style="text-align:center">sub</td>
<td style="text-align:center">public SUBkey</td>
<td style="text-align:center">从钥的公钥</td>
</tr>
</tbody>
</table>
<p>至于这些钥匙的作用可以查看它们的功能，常用的功能有三种。</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">代表</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">Signing</td>
<td style="text-align:center">签名和验证信息</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">Encryption</td>
<td style="text-align:center">加密和解密信息</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">Certification</td>
<td style="text-align:center">签名和验证钥匙</td>
</tr>
</tbody>
</table>
<p>注意功能是针对一个钥匙而言的，由其中的公钥和私钥共同完成。其中加密和解密分别由钥匙的公钥和私钥完成，签名和验证则分别由私钥和公钥完成。一般地，GPG 密钥环中钥匙的公钥需要公布到网络上，也就意味着：</p>
<ol>
<li>所有人都能用你公布的公钥加密信息，加密后的信息只有持有私钥的你才能够解密。</li>
<li>你可以使用自己持有的私钥签名信息，所有人都能够用你公布的公钥验证签名的合法性。</li>
</ol>
<p>默认地，GPG 生成的密钥环，主钥用于签名和验证，从钥用于加密和解密。</p>
<h2 id="签名"><a class="header-anchor" href="#签名">¶</a>签名</h2>
<h3 id="生成密钥"><a class="header-anchor" href="#生成密钥">¶</a>生成密钥</h3>
<p>首先需要生成一个GPG 密钥环，GPG 在生成密钥的时候会使用一个根据你的操作生成的随机数，所以你可以在GPG 生成密钥的时候多做一些操作，例如点鼠标、敲键盘、复制文件等等。你可以利用dd 指令在生成密钥的期间做一些读写操作以让随机数字发生器获得足够的熵数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dd <span class="keyword">if</span>=/dev/random of=/dev/null bs=4M</span><br></pre></td></tr></table></figure>
<p>然后可以生成GPG 密钥环，推荐使用–full-gen-key 选项来启用所有的功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --full-gen-key</span><br></pre></td></tr></table></figure>
<p>其中需要注意的事情有以下几项：</p>
<ol>
<li>密钥种类：形如<code>method1 and method2</code> 的选项是生成主钥和一个从钥，默认可以用于签名和加密，形如<code>method</code> 的选项只生成主钥，默认只能用于签名。</li>
<li>密钥长度：越长越安全，同时加密解密的时间花费越多，选择一个你认为合理的长度。</li>
<li>有效期限：你需要选择一个你认为合理的有效期限，钥匙到期后，签名将失效，GPG 服务器也会删除其公钥，所以一般来说你需要使用一个永不过期的钥匙。</li>
<li>钥匙密码：一定要为你的钥匙设置一个足够强壮的密码！</li>
</ol>
<h3 id="上传公钥到服务器"><a class="header-anchor" href="#上传公钥到服务器">¶</a>上传公钥到服务器</h3>
<p>现在你可以将你的公钥上传到任意GPG 服务器上了，这可以方便他人导入公钥以验证你的签名。通过服务器的交换机制，全球所有的GPG 服务器都会得到你的公钥。你可以列出你现在所拥有的公钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --list-keys</span><br><span class="line">/home/&lt;user&gt;/.gnupg/pubring.kbx</span><br><span class="line">---------------------------------</span><br><span class="line">pub   rsa4096/B66CC194 2016-04-15 [SC]</span><br><span class="line">uid         [ 绝对 ] Arondight &lt;shell_way@foxmail.com&gt;</span><br><span class="line">sub   rsa4096/F96E3CB7 2016-04-15 [E]</span><br></pre></td></tr></table></figure>
<p>可以看到两个公钥，分别属于主钥<code>B66CC194</code> 和从钥<code>F96E3CB7</code>。上传时指定主钥的钥匙号（key ID）即可，GPG 会将密钥环中的公钥上传到指定的服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --keyserver keys.gnupg.net --send-keys &lt;key ID&gt;</span><br></pre></td></tr></table></figure>
<h3 id="上传公钥到GitHub"><a class="header-anchor" href="#上传公钥到GitHub">¶</a>上传公钥到GitHub</h3>
<p>GitHub 刚刚发布了支持GPG 签名的消息，所以你可以选择使用GitHub 托管你的仓库。首先你需要以文本形式导出你主钥的公钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg -a -o gnupg.pub --<span class="built_in">export</span> &lt;key ID&gt;</span><br></pre></td></tr></table></figure>
<p>然后打开你的GitHub 密钥管理界面，根据文件<code>gnupg.pub</code> 为你的GitHub 账户配置用于验证签名的公钥。</p>
<blockquote>
<p>注意：这一步不是必须的，你不一定要使用GitHub，或许你更喜欢使用其他的商业产品，或者自己搭建一个Git 服务器。Git 本身就是支持GPG 签名的，GitHub 对GPG 的支持仅是把验证结果在网页上显示出来（使用你上传的公钥）。</p>
</blockquote>
<h3 id="导出指纹"><a class="header-anchor" href="#导出指纹">¶</a>导出指纹</h3>
<p>然而不幸的是，任何人都可以冒充你的名义上传公钥到GPG 服务器，所以对方搜到以你的名义发布的公钥，不一定真的是你发布的。为了避免这个问题，你需要公布主钥的指纹。GPG 导入公钥后需要手动设置信任度。这时候对方就可以通过对比计算得到的主钥指纹和你提供的主钥指纹，来确定导入的主钥的合法性。</p>
<p>你可以像下面一样导出指纹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --fingerprint &lt;key ID&gt; | perl -nE <span class="string">'$.-2 or s/^\h+// and print'</span> | tee fingerprint</span><br></pre></td></tr></table></figure>
<p>然后将<code>fingerprint</code> 文件提交到你的项目仓库中，或者公布在网络的其他位置。</p>
<ol>
<li>你只需（只能）导出主钥的指纹，对方也只需要验证主钥的指纹，因为主钥的公钥可以验证从钥。</li>
<li>你可以通过<code>--export-ownertrust</code> 和<code>--import-ownertrust</code> 来直接导出和导入信任度，但是不推荐这样做。</li>
</ol>
<h3 id="签名提交和标签"><a class="header-anchor" href="#签名提交和标签">¶</a>签名提交和标签</h3>
<p>首先你需要为Git 设置一个用于签名的私钥，通常来说所有的个人项目都用一个私钥进行签名，所以建议设置为全局配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.signingkey &lt;key ID&gt;</span><br></pre></td></tr></table></figure>
<p>然后就可以使用这个私钥来签名提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -S</span><br></pre></td></tr></table></figure>
<p>或者签名标签了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -s &lt;tag&gt;</span><br></pre></td></tr></table></figure>
<p>如果你想全局默认使用GPG 签名提交，可以全局将<code>commit.gpgsign</code> 设置为<code>true</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global commit.gpgsign <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="关于私钥"><a class="header-anchor" href="#关于私钥">¶</a>关于私钥</h3>
<p>任何情况向下都不要把私钥泄露给除了你之外的任何人。如果需要向对方发送加密信息，请让对方提供指纹，导入对方的公钥进行加密，而不要用自己的公钥加密后再把自己的私钥发送过去。</p>
<h2 id="验证"><a class="header-anchor" href="#验证">¶</a>验证</h2>
<h3 id="获得公钥"><a class="header-anchor" href="#获得公钥">¶</a>获得公钥</h3>
<p>你可以根据你得到的信息在任何GPG 服务器上查找对应的公钥，典型的例如查看指纹（后8 位数字为钥匙号），然后根据得到的钥匙号到服务器上查找钥匙。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --keyserver keys.gnupg.net --search-keys &lt;key ID&gt;</span><br></pre></td></tr></table></figure>
<p>选择对应的编号，会自动下载并导入该公钥。你也可以根据用户名和邮箱进行查找。</p>
<h3 id="设置信任"><a class="header-anchor" href="#设置信任">¶</a>设置信任</h3>
<p>导入后的公钥需要设置信任度才能使用该公钥进行验证，你可以通过类似下面的指令编辑该公钥的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --edit-key &lt;key ID&gt;</span><br></pre></td></tr></table></figure>
<p>你所看到的应该是一个文本交互界面，下面是一个样例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg (GnuPG) 2.1.11; Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">pub  rsa4096/B66CC194</span><br><span class="line">     创建于：2016-04-15  有效至：永不过期  可用于：SC</span><br><span class="line">     信任度：未知        有效性：未知</span><br><span class="line">sub  rsa4096/F96E3CB7</span><br><span class="line">     创建于：2016-04-15  有效至：永不过期  可用于：E</span><br><span class="line">[ 未知 ] (1). Arondight &lt;shell_way@foxmail.com&gt;</span><br><span class="line">gpg&gt;</span><br></pre></td></tr></table></figure>
<p>你可以键入<code>fpr</code> 来打印这个主钥的指纹，和你得到的主钥指纹进行对比，如果一致则键入<code>trust</code> 来设置主钥的信任度。如果主钥被设置为绝对可信的（ultimately），GPG 会根据主钥的公钥验证从钥的签名，最终完成信任建立。最后键入<code>quit</code>退出。</p>
<h3 id="验证签名"><a class="header-anchor" href="#验证签名">¶</a>验证签名</h3>
<p>现在你可以用导入的公钥来验证你<code>git clone</code> 下来的仓库的提交和标签了，同样你需要首先告诉Git 应该使用哪个公钥对这个仓库进行验证。一般来说不同作者的项目公钥都不同，建议不要将用于验证的公钥设置为全局。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config user.signingkey &lt;key ID&gt;</span><br><span class="line">然后可以像下面这样验证一个提交。</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git verify-commit &lt;commit ID&gt;</span><br></pre></td></tr></table></figure>
<p>或者验证一个标签。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -v &lt;tag&gt;</span><br></pre></td></tr></table></figure>
<h2 id="扩展阅读"><a class="header-anchor" href="#扩展阅读">¶</a>扩展阅读</h2>
<h3 id="签名和验证"><a class="header-anchor" href="#签名和验证">¶</a>签名和验证</h3>
<table>
<thead>
<tr>
<th style="text-align:center">动作</th>
<th style="text-align:center">指令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">二进制方式签名文件</td>
<td style="text-align:center"><code>gpg -u &lt;key ID&gt; -s &lt;file&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">纯文本方式签名文件</td>
<td style="text-align:center"><code>gpg -u &lt;key ID&gt; --clearsign &lt;file&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">签名文件并独立存放签名</td>
<td style="text-align:center"><code>gpg -u &lt;key ID&gt; --detach-sign &lt;file&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">验证文件</td>
<td style="text-align:center"><code>gpg --verify-files &lt;file&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">通过独立的签名文件验证文件</td>
<td style="text-align:center"><code>gpg --verify-files &lt;file_sig&gt; &lt;file&gt;</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果不指定<code>-u</code> 选项，会使用第一个密钥环中主钥的私钥进行签名。</p>
</blockquote>
<h3 id="加密和解密"><a class="header-anchor" href="#加密和解密">¶</a>加密和解密</h3>
<table>
<thead>
<tr>
<th style="text-align:center">动作</th>
<th style="text-align:center">指令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">二进制方式加密文件</td>
<td style="text-align:center"><code>gpg -r &lt;key ID&gt; -e &lt;file&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">纯文本方式加密文件</td>
<td style="text-align:center"><code>gpg -r &lt;key ID&gt; -a -e &lt;file&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">解密文件</td>
<td style="text-align:center"><code>gpg &lt;file&gt;</code></td>
</tr>
</tbody>
</table>
<ul>
<li>这里你需要指定从钥的钥匙号，如果<code>-r</code> 选项被省略，GPG 会交互式的请求一个钥匙号。</li>
<li>如果你想在加密的同时签名文件，在加密指令中额外指定一个<code>-s</code>选项。</li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Linux</tag>
        <tag>GPG</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法手册</title>
    <url>/2018/10/18/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1>Markdown 语法手册</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="1-斜体和粗体"><a class="header-anchor" href="#1-斜体和粗体">¶</a>1. 斜体和粗体</h2>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span>或<span class="emphasis">_斜体_</span></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line"><span class="strong">***加粗斜体**</span>*</span><br><span class="line">~~ 删除线 ~~</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<ul>
<li><em>这是一段斜体</em></li>
<li><strong>这是一段粗体</strong></li>
<li><em><strong>这是一段加粗斜体</strong></em></li>
<li><s>这是一段删除线</s></li>
</ul>
<hr>
<h2 id="2-分级标题"><a class="header-anchor" href="#2-分级标题">¶</a>2. 分级标题</h2>
<p>第一种写法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一个一级标题</span><br><span class="line">================</span><br><span class="line">这是一个二级标题</span><br><span class="line">----------------</span><br></pre></td></tr></table></figure>
<p>第二种写法：</p>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
</code></pre>
<p>由于用了<code>[TOC]</code>标记编辑器会把所有标题写到目录大纲中，在这里写的演示标题也会列进去，所以就不演示了。同学们自己在编辑器中观察，很简单，一级标题字号最大，依级递减。</p>
<hr>
<h2 id="3-超链接"><a class="header-anchor" href="#3-超链接">¶</a>3.超链接</h2>
<p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。</p>
<h3 id="3-1-行内式"><a class="header-anchor" href="#3-1-行内式">¶</a>3.1. 行内式</h3>
<p>语法说明：</p>
<ul>
<li>[]里写链接文字，()里写链接地址, ()中的&quot;&quot;中可以为链接指定 <code>title</code> 属性，<code>title</code>属性可加可不加。<code>title</code> 属性的效果是鼠标悬停在链接上会出现指定的 <code>title</code> 文字。[链接文字](链接地址 “链接标题”) 这样的形式。链接地址与链接标题前有一个空格。</li>
</ul>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">欢迎来到[<span class="string">梵居闹市</span>](<span class="link">http://blog.leanote.com/freewalk</span>)</span><br><span class="line">欢迎来到[<span class="string">梵居闹市</span>](<span class="link">http://blog.leanote.com/freewalk "梵居闹市"</span>)</span><br></pre></td></tr></table></figure>
<p>显示效果：<br>
欢迎来到<a href="http://blog.leanote.com/freewalk" target="_blank" rel="noopener">梵居闹市</a><br>
欢迎来到<a href="http://blog.leanote.com/freewalk" target="_blank" rel="noopener" title="梵居闹市">梵居闹市</a></p>
<h3 id="3-2-参考式"><a class="header-anchor" href="#3-2-参考式">¶</a>3.2. 参考式</h3>
<p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p>
<p>语法说明： <br>
参考式链接分为两部分，文中的写法[链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。<br>
如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>
[链接文字]：链接地址的形式，见代码的最后一行。<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">我经常去的几个网站[<span class="string">Google</span>][<span class="symbol">1</span>]、[<span class="string">Leanote</span>][<span class="symbol">2</span>]以及[<span class="string">自己的博客</span>][<span class="symbol">3</span>]</span><br><span class="line">[<span class="string">Leanote 笔记</span>][<span class="symbol">2</span>]是一个不错的[<span class="string">网站</span>][<span class="symbol"></span>]。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">1</span>]:<span class="link">http://www.google.com "Google"</span></span><br><span class="line">[<span class="symbol">2</span>]:<span class="link">http://www.leanote.com "Leanote"</span></span><br><span class="line">[<span class="symbol">3</span>]:<span class="link">http://http://blog.leanote.com/freewalk "梵居闹市"</span></span><br><span class="line">[<span class="symbol">网站</span>]:<span class="link">http://http://blog.leanote.com/freewalk</span></span><br></pre></td></tr></table></figure>
<p>显示效果：<br>
我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]<br>
[Leanote 笔记][2]是一个不错的[网站][]。<br>
[1]:<a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a> “Google”<br>
[2]:<a href="http://www.leanote.com" target="_blank" rel="noopener">http://www.leanote.com</a> “Leanote”<br>
[3]:<a href="http://http" target="_blank" rel="noopener">http://http</a>://blog.leanote.com/freewalk “梵居闹市”<br>
[网站]:<a href="http://http" target="_blank" rel="noopener">http://http</a>://blog.leanote.com/freewalk</p>
<h3 id="3-3-自动链接"><a class="header-anchor" href="#3-3-自动链接">¶</a>3.3. 自动链接</h3>
<p>语法说明： <br>
Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">http:</span>//<span class="attr">example.com</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">address@example.com</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<p><a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a><br>
<a href="mailto:address@example.com">address@example.com</a></p>
<hr>
<h2 id="4-锚点"><a class="header-anchor" href="#4-锚点">¶</a>4.锚点</h2>
<p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。</p>
<p>注意：</p>
<ol>
<li>Markdown Extra 只支持在标题后插入锚点，其它地方无效。</li>
<li>Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。</li>
</ol>
<p>语法描述：<br>
可把鼠标放到 Github 的标题上进行观察，如下图</p>
<p><img src="https://static.oschina.net/uploads/img/201707/19103223_ugM1.png" alt="anchor"></p>
<ul>
<li>任意 1-6 个 # 标注的标题都会被添加上同名的锚点链接</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">标题1</span>](<span class="link">#标题1</span>) </span><br><span class="line">[<span class="string">标题2</span>](<span class="link">#标题2</span>) </span><br><span class="line">[<span class="string">标题3</span>](<span class="link">#标题3</span>) </span><br><span class="line"></span><br><span class="line"><span class="section"># 标题1</span></span><br><span class="line"><span class="section">## 标题2</span></span><br><span class="line"><span class="section">### 标题3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>锚点跳转的标识名称，可使用任意字符，大写字母要转换成小写</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Github标题1</span>](<span class="link">#github标题1</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### Github标题1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>多单词锚点的空格用 - 代替</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Github 标题2 Test</span>](<span class="link">#github-标题2-test</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### Github 标题2 Test</span></span><br></pre></td></tr></table></figure>
<ul>
<li>多级序号需要去除 .</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">2.3. Github 标题</span>](<span class="link">#23-github-标题</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### 2.3. Github 标题</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: 非英文的锚点字符，在单击跳转时，在浏览器的 url 中会按照规则进行 encode 和 decode</p>
</blockquote>
<hr>
<h2 id="5-列表"><a class="header-anchor" href="#5-列表">¶</a>5. 列表</h2>
<h3 id="5-1-无序列表"><a class="header-anchor" href="#5-1-无序列表">¶</a>5.1. 无序列表</h3>
<p>使用 *，+，- 表示无序列表。<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>无序列表项 一</span><br><span class="line"><span class="bullet">- </span>无序列表项 二</span><br><span class="line"><span class="bullet">- </span>无序列表项 三</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<ul>
<li>无序列表项 一</li>
<li>无序列表项 二</li>
<li>无序列表项 三</li>
</ul>
<h3 id="5-2-有序列表"><a class="header-anchor" href="#5-2-有序列表">¶</a>5.2. 有序列表</h3>
<p>有序列表则使用数字接着一个英文句点。<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>有序列表项 一</span><br><span class="line"><span class="bullet">2. </span>有序列表项 二</span><br><span class="line"><span class="bullet">3. </span>有序列表项 三</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<h3 id="5-3-定义型列表"><a class="header-anchor" href="#5-3-定义型列表">¶</a>5.3. 定义型列表</h3>
<p>语法说明：</p>
<p>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)</p>
<p>代码：</p>
<pre><code>Markdown
:    轻量级文本标记语言，可以转换成 html，pdf 等格式（左侧有一个可见的冒号和四个不可见的空格）
代码块 2
:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）
    代码块（左侧有八个不可见的空格）
</code></pre>
<p>显示效果：</p>
<p>Markdown<br>
:    轻量级文本标记语言，可以转换成 html，pdf 等格式（左侧有一个可见的冒号和四个不可见的空格）</p>
<p>代码块 2<br>
:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</p>
<pre><code>    代码块（左侧有八个不可见的空格）
</code></pre>
<h3 id="5-4-列表缩进"><a class="header-anchor" href="#5-4-列表缩进">¶</a>5.4. 列表缩进</h3>
<p>语法说明：<br>
列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。<br>
要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：</p>
<ul>
<li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 <br>
那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 <br>
软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</li>
<li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 <br>
寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 <br>
但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ <br>
悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li>
</ul>
<p>但是如果你懒，那也行： <br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*   </span>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。</span><br><span class="line">那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 </span><br><span class="line">软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ </span><br><span class="line"><span class="bullet">*   </span>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 </span><br><span class="line">寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。</span><br><span class="line">但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ </span><br><span class="line">悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<ul>
<li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 <br>
那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 <br>
软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</li>
<li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 <br>
寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 <br>
但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ <br>
悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li>
</ul>
<h3 id="5-5-包含段落的列表"><a class="header-anchor" href="#5-5-包含段落的列表">¶</a>5.5. 包含段落的列表</h3>
<p>语法说明：<br>
列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：</p>
<ul>
<li>
<p>轻轻的我走了， 正如我轻轻的来；<br>
我轻轻的招手， 作别西天的云彩。 <br>
那河畔的金柳， 是夕阳中的新娘；<br>
波光里的艳影， 在我的心头荡漾。 <br>
软泥上的青荇， 油油的在水底招摇；<br>
在康河的柔波里， 我甘心做一条水草！</p>
<p>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 <br>
寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 <br>
但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</p>
</li>
<li>
<p>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</p>
</li>
</ul>
<p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*   </span>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。</span><br><span class="line">那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。    </span><br><span class="line">软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</span><br><span class="line">那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 </span><br><span class="line">寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 </span><br><span class="line">但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ </span><br><span class="line"><span class="bullet">*    </span>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<ul>
<li>
<p>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 <br>
那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 <br>
软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</p>
<p>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 <br>
寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 <br>
但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</p>
</li>
<li>
<p>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</p>
</li>
</ul>
<h3 id="5-6-包含引用的列表"><a class="header-anchor" href="#5-6-包含引用的列表">¶</a>5.6. 包含引用的列表</h3>
<p>语法说明：<br>
如果要在列表项目内放进引用，那 &gt; 就需要缩进：<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*   </span>阅读的方法:</span><br><span class="line"><span class="code">    &gt; 打开书本。</span></span><br><span class="line"><span class="code">    &gt; 打开电灯。</span></span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<ul>
<li>阅读的方法:
<blockquote>
<p>打开书本。<br>
打开电灯</p>
</blockquote>
</li>
</ul>
<h3 id="5-7-包含代码区块的引用"><a class="header-anchor" href="#5-7-包含代码区块的引用">¶</a>5.7. 包含代码区块的引用</h3>
<p>语法说明： <br>
如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</p>
<ul>
<li>
<p>列表项包含一个列表区块：</p>
<pre><code>  &lt;代码写在这&gt;
</code></pre>
</li>
</ul>
<h3 id="5-8-一个特殊情况"><a class="header-anchor" href="#5-8-一个特殊情况">¶</a>5.8. 一个特殊情况</h3>
<p>在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法：</p>
<pre><code>1986. What a great season.
</code></pre>
<p>会显示成：</p>
<ul>
<li>
<ol start="1986">
<li>What a great season</li>
</ol>
</li>
</ul>
<p>What a great season.<br>
换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠：</p>
<pre><code>1986\. What a great season.
</code></pre>
<p>会显示成：</p>
<p>1986. What a great season.</p>
<hr>
<h2 id="6-引用"><a class="header-anchor" href="#6-引用">¶</a>6. 引用</h2>
<p>语法说明：<br>
引用需要在被引用的文本前加上&gt;符号。<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一个有两段文字的引用,</span></span><br><span class="line"><span class="quote">&gt; 无意义的占行文字1.</span></span><br><span class="line"><span class="quote">&gt; 无意义的占行文字2.</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; 无意义的占行文字3.</span></span><br><span class="line"><span class="quote">&gt; 无意义的占行文字4.</span></span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<blockquote>
<p>这是一个有两段文字的引用, <br>
无意义的占行文字1. <br>
无意义的占行文字2.</p>
</blockquote>
<blockquote>
<p>无意义的占行文字3. <br>
无意义的占行文字4.</p>
</blockquote>
<p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ：</p>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一个有两段文字的引用,</span></span><br><span class="line">无意义的占行文字1.</span><br><span class="line">无意义的占行文字2.</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 无意义的占行文字3.</span></span><br><span class="line">无意义的占行文字4.</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<blockquote>
<p>这是一个有两段文字的引用, <br>
无意义的占行文字1. <br>
无意义的占行文字2.</p>
</blockquote>
<blockquote>
<p>无意义的占行文字3. <br>
无意义的占行文字4.</p>
</blockquote>
<h3 id="6-1-引用的多层嵌套"><a class="header-anchor" href="#6-1-引用的多层嵌套">¶</a>6.1. 引用的多层嵌套</h3>
<p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白</span><br><span class="line"></span><br><span class="line">&gt;&gt; 自己看教程！ - 愤青</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 教程在哪？ - 小白</span></span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<blockquote>
<blockquote>
<blockquote>
<p>请问 Markdwon 怎么用？ - 小白</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>自己看教程！ - 愤青</p>
</blockquote>
</blockquote>
<blockquote>
<p>教程在哪？ - 小白</p>
</blockquote>
<h3 id="6-2-引用其它要素"><a class="header-anchor" href="#6-2-引用其它要素">¶</a>6.2. 引用其它要素</h3>
<p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 1.   这是第一行列表项。</span></span><br><span class="line"><span class="quote">&gt; 2.   这是第二行列表项。</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; 给出一些例子代码：</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt;     return shell_exec("echo $input | $markdown_script");</span></span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<blockquote>
<ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>
<p>给出一些例子代码：</p>
<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre>
</blockquote>
<hr>
<h2 id="7-插入图像"><a class="header-anchor" href="#7-插入图像">¶</a>7. 插入图像</h2>
<p>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。</p>
<p>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p>
<h3 id="7-1-行内式"><a class="header-anchor" href="#7-1-行内式">¶</a>7.1. 行内式</h3>
<p>语法说明：![图片Alt](图片地址 “图片Title”)<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">美丽花儿： </span><br><span class="line">![<span class="string">美丽花儿</span>](<span class="link">http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg "美丽花儿"</span>)</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<p>美丽花儿：<br>
<img src="http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg" alt="美丽花儿" title="美丽花儿"></p>
<h3 id="7-2-参考式"><a class="header-anchor" href="#7-2-参考式">¶</a>7.2. 参考式</h3>
<p>语法说明：<br>
在文档要插入图片的地方写![图片Alt][标记]</p>
<p>在文档的最后写上[标记]:图片地址 “Title”</p>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">美丽花儿：</span><br><span class="line">![<span class="string">美丽花儿</span>][<span class="symbol">flower</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">flower</span>]:<span class="link">http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg  "美丽花儿"</span></span><br></pre></td></tr></table></figure>
<p>显示效果：<br>
美丽花儿：<br>
<img src="http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg" alt="美丽花儿" title="美丽花儿"></p>
<hr>
<h2 id="8-内容目录"><a class="header-anchor" href="#8-内容目录">¶</a>8. 内容目录</h2>
<p>在段落中填写 [TOC] 以显示全文内容的目录结构。<br>
效果参见最上方的目录</p>
<hr>
<h2 id="9-注脚"><a class="header-anchor" href="#9-注脚">¶</a>9. 注脚</h2>
<p>语法说明：</p>
<p>在需要添加注脚的文字后加上脚注名字 [^注脚名字] ,称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p>
<p>注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经 Markdown 转换后，也会自动归类到文章的最后。<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">使用 Markdown[^1]可以效率的书写文档,直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]:<span class="link">Markdown是一种纯文本标记语言</span></span><br><span class="line"></span><br><span class="line">[<span class="symbol">^2</span>]:<span class="link">HyperText Markup Language 超文本标记语言</span></span><br><span class="line"></span><br><span class="line">[<span class="symbol">^Le</span>]:<span class="link">开源笔记平台，支持Markdown和笔记直接发为博文`</span></span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<p>使用 Markdown<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>可以效率的书写文档,直接转换成 HTML<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>, 你可以使用Leanote<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 编辑器进行书写。</p>
<p>注：脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。</p>
<hr>
<h2 id="10-LaTeX-公式"><a class="header-anchor" href="#10-LaTeX-公式">¶</a>10. LaTeX 公式</h2>
<h3 id="10-1-表示行内公式："><a class="header-anchor" href="#10-1-表示行内公式：">¶</a>10.1. <code>$</code> 表示行内公式：</h3>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">质能守恒方程可以用一个很简洁的方程式 $E&#x3D;mc^2$ 来表达。</span><br></pre></td></tr></table></figure>
<p>显示效果：<br>
质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>
<h3 id="10-2-表示整行公式："><a class="header-anchor" href="#10-2-表示整行公式：">¶</a>10.2 <code>$$</code> 表示整行公式：</h3>
<p>代码：</p>
<pre><code>$$\sum_{i=1}^n a_i=0$$
$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$
$$\sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}$$
</code></pre>
<p>显示效果：</p>
<p>$$\sum_{i=1}^n a_i=0$$<br>
$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$<br>
$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p>
<p>访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p>
<hr>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: Start:&gt;https:&#x2F;&#x2F;www.zybuluo.com</span><br><span class="line">io&#x3D;&gt;inputoutput: verification</span><br><span class="line">op&#x3D;&gt;operation: Your Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">sub&#x3D;&gt;subroutine: Your Subroutine</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line">st-&gt;io-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;sub-&gt;io</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<div id="flowchart-0" class="flow-chart"></div>
<p>更多语法参考：<a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">流程图语法参考</a></p>
<hr>
<h2 id="12-表格"><a class="header-anchor" href="#12-表格">¶</a>12. 表格</h2>
<p>语法说明：</p>
<ul>
<li>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。</li>
<li>列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。</li>
<li>第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。</li>
</ul>
<p>代码：<br>
简单方式写表格：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">学号|姓名|分数</span><br><span class="line">-|-|-</span><br><span class="line">小明|男|75</span><br><span class="line">小红|女|79</span><br><span class="line">小陆|男|92</span><br></pre></td></tr></table></figure>
<p>原生方式写表格：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|学号|姓名|分数|</span><br><span class="line">|-|-|-|</span><br><span class="line">|小明|男|75|</span><br><span class="line">|小红|女|79|</span><br><span class="line">|小陆|男|92|</span><br></pre></td></tr></table></figure>
<p>为表格第二列指定方向：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">产品|价格</span><br><span class="line">-|-:</span><br><span class="line">Leanote 高级账号|60元/年</span><br><span class="line">Leanote 超级账号|120元/年</span><br></pre></td></tr></table></figure>
<p>显示效果：<br>
简单方式写表格：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>小明</td>
<td>男</td>
<td>75</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>79</td>
</tr>
<tr>
<td>小陆</td>
<td>男</td>
<td>92</td>
</tr>
</tbody>
</table>
<p>原生方式写表格：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>小明</td>
<td>男</td>
<td>75</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>79</td>
</tr>
<tr>
<td>小陆</td>
<td>男</td>
<td>92</td>
</tr>
</tbody>
</table>
<p>为表格第二列指定方向：</p>
<table>
<thead>
<tr>
<th>产品</th>
<th style="text-align:right">价格</th>
</tr>
</thead>
<tbody>
<tr>
<td>Leanote 高级账号</td>
<td style="text-align:right">60元/年</td>
</tr>
<tr>
<td>Leanote 超级账号</td>
<td style="text-align:right">120元/年</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="13-分隔线"><a class="header-anchor" href="#13-分隔线">¶</a>13. 分隔线</h2>
<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span><span class="emphasis">* *</span></span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="strong">*****</span></span><br><span class="line"><span class="bullet">- </span>- -</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure>
<p>显示效果都一样：</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<h2 id="14-代码"><a class="header-anchor" href="#14-代码">¶</a>14 代码</h2>
<p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。<br>
语法说明：</p>
<ol>
<li>插入行内代码，即插入一个单词或者一句代码的情况，使用`code`这样的形式插入。</li>
<li>插入多行代码，可以使用缩进或者“` code “`,具体看示例。<br>
注意： 缩进式插入前方必须有空行</li>
</ol>
<h3 id="14-1-行内式"><a class="header-anchor" href="#14-1-行内式">¶</a>14.1. 行内式</h3>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">C语言里的函数 <span class="code">`scanf()`</span> 怎么使用？</span><br></pre></td></tr></table></figure>
<p>显示效果：<br>
C语言里的函数 <code>scanf()</code> 怎么使用？</p>
<h3 id="14-2-缩进式多行代码"><a class="header-anchor" href="#14-2-缩进式多行代码">¶</a>14.2. 缩进式多行代码</h3>
<p>缩进 4 个空格或是 1 个制表符<br>
一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。<br>
代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello world\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    printf(&quot;Hello world\n&quot;);
}
</code></pre>
<h3 id="14-3-用六个-包裹多行代码"><a class="header-anchor" href="#14-3-用六个-包裹多行代码">¶</a>14.3. 用六个 ` 包裹多行代码</h3>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="code">int main(void)</span></span><br><span class="line"><span class="code">&#123;</span></span><br><span class="line"><span class="code">    printf("Hello world\n");</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello world\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-4-HTML-原始码"><a class="header-anchor" href="#14-4-HTML-原始码">¶</a>14.4. HTML 原始码</h2>
<p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：<br>
代码：<br>
第一个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">    © 2004 Foo Corporation</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>值班人员<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>星期一<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>星期二<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>星期三<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>李强<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>张明<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>王平<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>显示效果：<br>
第一个例子：</p>
<div class="footer">
   © 2004 Foo Corporation
</div>
<p>第二个例子：</p>
<table>
    <tr>
        <th rowspan="2">值班人员</th>
        <th>星期一</th>
        <th>星期二</th>
        <th>星期三</th>
    </tr>
    <tr>
        <td>李强</td>
        <td>张明</td>
        <td>王平</td>
    </tr>
</table>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start:>https://www.zybuluo.com
io=>inputoutput: verification
op=>operation: Your Operation
cond=>condition: Yes or No?
sub=>subroutine: Your Subroutine
e=>end
st->io->op->cond
cond(yes)->e
cond(no)->sub->io</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Markdown是一种纯文本标记语言 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>HyperText Markup Language 超文本标记语言 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>开源笔记平台，支持Markdown和笔记直接发为博文 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP 学习笔记</title>
    <url>/2020/12/04/Spring-AOP-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>Spring AOP 学习笔记</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="一、概述"><a class="header-anchor" href="#一、概述">¶</a>一、概述</h2>
<ul>
<li>设计模式：代理模式。</li>
<li>基本概念：
<ul>
<li><strong>Aspect（切面）</strong>：即一个横跨多个核心逻辑的功能，或者称之为 <strong>系统关注点</strong>。<span style="border-width: 0 0 3px 0; border-style: double">（对哪些方法进行拦截，拦截后怎么处理）</span>；</li>
<li><strong>Joinpoint（连接点）</strong>：即定义在应用程序流程的何处插入切面的执行。<span style="border-width: 0 0 3px 0; border-style: double">（被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring 中连接点指的就是被拦截到的 <strong>方法</strong>，实际上连接点还可以是字段或者构造器）</span>；</li>
<li><strong>Pointcut（切入点）</strong>：即一组连接点的集合。<span style="border-width: 0 0 3px 0; border-style: double">（对连接点进行拦截的定义，即 Pointcut 表达式）</span>；</li>
<li><strong>Advice（增强）</strong>：指特定连接点上执行的动作；</li>
<li><strong>Introduction（引介、引入）</strong>：指为一个已有的 Java 对象动态地增加新的接口。<span style="border-width: 0 0 3px 0; border-style: double">（在不修改代码的前提下，引入可以在 <strong>运行期</strong> 为类 <strong>动态</strong> 地添加一些方法或字段）</span>；</li>
<li><strong>Weaving（织入）</strong>：指将切面整合到程序的执行流程中。<span style="border-width: 0 0 3px 0; border-style: double">（将切面应用到目标对象并导致代理对象创建的 <strong>过程</strong>）</span>；</li>
<li><strong>Interceptor（拦截器）</strong>：是一种实现增强的方式；</li>
<li><strong>Target Object（目标对象）</strong>：即真正执行业务的核心逻辑对象。<span style="border-width: 0 0 3px 0; border-style: double">（代理的目标对象）</span>；</li>
<li><strong>AOP Proxy（AOP 代理）</strong>：是客户端持有的增强后的对象引用。</li>
</ul>
</li>
<li>在 Java 平台上，对于 AOP 的织入，有 3 种方式：
<ol>
<li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ 就扩展了 Java 编译器，使用关键字 aspect 来实现织入；</li>
<li>类加载器：在目标类被装载到 JVM 时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li>
<li>运行期：目标对象和切面都是普通 Java 类，通过 JVM 的动态代理功能或者第三方库实现运行期动态织入。</li>
</ol>
</li>
</ul>
<h2 id="二、装配-AOP"><a class="header-anchor" href="#二、装配-AOP">¶</a>二、装配 AOP</h2>
<p>首先，我们通过 Maven 引入 Spring 对 AOP 的支持：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-切面定义"><a class="header-anchor" href="#1-切面定义">¶</a>1. 切面定义</h3>
<p>首先，我们定义一个 <code>LoggingAspect</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在执行UserService的每个方法前执行:</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(public * com.itranswarp.learnjava.service.UserService.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"[Before] do access check..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行MailService的每个方法前后执行:</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(public * com.itranswarp.learnjava.service.MailService.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doLogging</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"[Around] start "</span> + pjp.getSignature());</span><br><span class="line">        Object retVal = pjp.proceed();</span><br><span class="line">        System.err.println(<span class="string">"[Around] done "</span> + pjp.getSignature());</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>观察 <code>doAccessCheck()</code> 方法，我们定义了一个 <code>@Before</code> 注解，后面的字符串是告诉 AspectJ 应该在何处执行该方法，这里写的意思是：执行 <code>UserService</code> 的每个 <code>public</code> 方法前执行 <code>doAccessCheck()</code> 代码。</p>
</li>
<li>
<p>再观察 <code>doLogging()</code> 方法，我们定义了一个 <code>@Around</code> 注解，它和 <code>@Before</code> 不同，<code>@Around</code> 可以决定是否执行目标方法，因此，我们在 <code>doLogging()</code> 内部先打印日志，再调用方法，最后打印日志后返回结果。</p>
</li>
</ul>
<p>在 <code>LoggingAspect</code> 类的声明处，除了用 <code>@Component</code> 表示它本身也是一个 Bean 外，我们再加上 <code>@Aspect</code> 注解，表示它的 <code>@Before</code> 标注的方法需要注入到 <code>UserService</code> 的每个 <code>public</code> 方法执行前，<code>@Around</code> 标注的方法需要注入到 <code>MailService</code> 的每个 <code>public</code> 方法执行前后。</p>
<h3 id="2-装配-AOP"><a class="header-anchor" href="#2-装配-AOP">¶</a>2. 装配 AOP</h3>
<p>紧接着，我们需要给 <code>@Configuration</code> 类加上一个 <code>@EnableAspectJAutoProxy</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 的 IoC 容器看到这个注解，就会自动查找带有 <code>@Aspect</code> 的 Bean，然后根据每个方法的 <code>@Before</code>、<code>@Around</code> 等注解把 AOP 注入到特定的 Bean 中。执行代码，我们可以看到以下输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Before] do access check...</span><br><span class="line">[Around] start void com.itranswarp.learnjava.service.MailService.sendRegistrationMail(User)</span><br><span class="line">Welcome, test!</span><br><span class="line">[Around] done void com.itranswarp.learnjava.service.MailService.sendRegistrationMail(User)</span><br><span class="line">[Before] do access check...</span><br><span class="line">[Around] start void com.itranswarp.learnjava.service.MailService.sendLoginMail(User)</span><br><span class="line">Hi, Bob! You are logged in at 2020-02-14T23:13:52.167996+08:00[Asia&#x2F;Shanghai]</span><br><span class="line">[Around] done void com.itranswarp.learnjava.service.MailService.sendLoginMail(User)</span><br></pre></td></tr></table></figure>
<h4 id="拦截器类型"><a class="header-anchor" href="#拦截器类型">¶</a>拦截器类型</h4>
<p>顾名思义，拦截器有以下类型：</p>
<ul>
<li>
<p><code>@Before</code>：这种拦截器先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；</p>
</li>
<li>
<p><code>@After</code>：这种拦截器先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；</p>
</li>
<li>
<p><code>@AfterReturning</code>：和 <code>@After</code> 不同的是，只有当目标代码正常返回时，才执行拦截器代码；</p>
</li>
<li>
<p><code>@AfterThrowing</code>：和 <code>@After</code> 不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；</p>
</li>
<li>
<p><code>@Around</code>：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能。</p>
</li>
</ul>
<h2 id="三、Pointcut-表达式"><a class="header-anchor" href="#三、Pointcut-表达式">¶</a>三、Pointcut 表达式</h2>
<h3 id="1-表达式类型"><a class="header-anchor" href="#1-表达式类型">¶</a>1. 表达式类型</h3>
<p>标准的 AspectJ AOP 的 Pointcut 的表达式类型是很丰富的，但是 Spring AOP 只支持其中的 9 种，外加 Spring AOP 自己扩充的一种一共是 10 种类型的表达式，分别如下：</p>
<ul>
<li><strong><code>execution</code></strong>：一般用于指定方法的执行，用的最多。</li>
<li><strong><code>within</code></strong>：指定某些类型的全部方法执行，也可用来指定一个包。</li>
<li><strong><code>this</code></strong>：Spring AOP 是基于代理的，生成的 Bean 也是一个代理对象，<code>this</code> 就是这个代理对象，当这个对象可以转换为指定的类型时，对应的切入点就是它了，Spring AOP 将生效。</li>
<li><strong><code>target</code></strong>：当被代理的对象可以转换为指定的类型时，对应的切入点就是它了，Spring AOP 将生效。</li>
<li><strong><code>args</code></strong>：当执行的方法的参数是指定类型时生效。</li>
<li><strong><code>@target</code></strong>：当代理的目标对象上拥有指定的注解时生效。</li>
<li><strong><code>@args</code></strong>：当执行的方法参数类型上拥有指定的注解时生效。</li>
<li><strong><code>@within</code></strong>：与 <code>@target</code> 类似，看官方文档和网上的说法都是 <code>@within</code> 只需要目标对象的类或者父类上有指定的注解，则 <code>@within</code> 会生效，而 <code>@target</code> 则是必须是目标对象的类上有指定的注解。而根据笔者的测试这两者都是只要目标类或父类上有指定的注解即可。</li>
<li><strong><code>@annotation</code></strong>：当执行的方法上拥有指定的注解时生效。</li>
<li><strong><code>bean</code></strong>：当调用的方法是指定的 Bean 的方法时生效。</li>
</ul>
<h3 id="2-使用示例"><a class="header-anchor" href="#2-使用示例">¶</a>2. 使用示例</h3>
<h4 id="execution"><a class="header-anchor" href="#execution">¶</a><code>execution</code></h4>
<p><code>execution</code> 是使用的最多的一种 Pointcut 表达式，表示某个方法的执行，其标准语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>modifiers-pattern</code> 表示方法的访问类型，<code>public</code> 等；</li>
<li><code>ret-type-pattern</code> 表示方法的返回值类型，如 <code>String</code> 表示返回类型是<code>String</code>，“<code>*</code>” 表示所有的返回类型；</li>
<li><code>declaring-type-pattern</code> 表示方法的声明类，如 “<code>com.elim..*</code>” 表示<code>com.elim</code> 包及其子包下面的所有类型；</li>
<li><code>name-pattern</code> 表示方法的名称，如 “<code>add*</code>” 表示所有以 <code>add</code> 开头的方法名；</li>
<li><code>param-pattern</code>表示方法参数的类型，<code>name-pattern(param-pattern)</code> 其实是一起的表示的方法集对应的参数类型，如 “<code>add()</code>” 表示不带参数的 <code>add</code> 方法，“<code>add(*)</code>” 表示带一个任意类型的参数的 <code>add</code> 方法，“<code>add(*,String)</code>” 则表示带两个参数，且第二个参数是 <code>String</code> 类型的 <code>add</code> 方法；</li>
<li><code>throws-pattern</code> 表示异常类型；其中以问号结束的部分都是可以省略的。</li>
</ul>
<p>例如：</p>
<ul>
<li>“<code>execution(* add())</code>” 匹配所有的不带参数的 <code>add()</code> 方法。</li>
<li>“<code>execution(public * com.elim..*.add*(..))</code>” 匹配所有 <code>com.elim</code> 包及其子包下所有类的以 <code>add</code> 开头的所有 <code>public</code> 方法。</li>
<li>“<code>execution(* *(..) throws Exception)</code>” 匹配所有抛出 <code>Exception</code> 的方法。</li>
</ul>
<h4 id="within"><a class="header-anchor" href="#within">¶</a><code>within</code></h4>
<p><code>within</code> 是用来指定类型的，指定类型中的所有方法将被拦截。如：</p>
<ul>
<li>“<code>within(com.elim.spring.aop.service.UserServiceImpl)</code>” 匹配<code>UserServiceImpl</code> 类对应对象的所有方法外部调用，而且这个对象只能是 <code>UserServiceImpl</code> 类型，不能是其子类型。</li>
<li>“<code>within(com.elim..*)</code>” 匹配 <code>com.elim</code> 包及其子包下面所有的类的所有方法的外部调用。</li>
</ul>
<h4 id="this"><a class="header-anchor" href="#this">¶</a><code>this</code></h4>
<p>Spring AOP 是基于代理的，<code>this</code> 就表示代理对象。<code>this</code> 类型的 Pointcut 表达式的语法是 <code>this(type)</code>，当生成的代理对象可以转换为 <code>type</code> 指定的类型时则表示匹配。基于 JDK 接口的代理和基于 CGLIB 的代理生成的代理对象是不一样的。如</p>
<ul>
<li>“<code>this(com.elim.spring.aop.service.IUserService)</code>” 匹配生成的代理对象是 <code>IUserService</code> 类型的所有方法的外部调用。</li>
</ul>
<h4 id="target"><a class="header-anchor" href="#target">¶</a><code>target</code></h4>
<p>Spring AOP 是基于代理的，<code>target</code> 则表示被代理的目标对象。当被代理的目标对象可以被转换为指定的类型时则表示匹配。如：</p>
<ul>
<li>“<code>target(com.elim.spring.aop.service.IUserService)</code>” 则匹配所有被代理的目标对象能够转换为 <code>IUserService</code> 类型的所有方法的外部调用。</li>
</ul>
<h4 id="args"><a class="header-anchor" href="#args">¶</a><code>args</code></h4>
<p><code>args</code> 用来匹配方法参数的。如：</p>
<ul>
<li>“<code>args()</code>” 匹配任何不带参数的方法。</li>
<li>“<code>args(java.lang.String)</code>” 匹配任何只带一个参数，而且这个参数的类型是 <code>String</code> 的方法。</li>
<li>“<code>args(..)</code>” 带任意参数的方法。</li>
<li>“<code>args(java.lang.String,..)</code>” 匹配带任意个参数，但是第一个参数的类型是 <code>String</code> 的方法。</li>
<li>“<code>args(..,java.lang.String)</code>” 匹配带任意个参数，但是最后一个参数的类型是 <code>String</code> 的方法。</li>
</ul>
<h4 id="target-v2"><a class="header-anchor" href="#target-v2">¶</a><code>@target</code></h4>
<p><code>@target</code> 匹配当被代理的目标对象对应的类型及其父类型上拥有指定的注解时。如：</p>
<ul>
<li>“<code>@target(com.elim.spring.support.MyAnnotation)</code>” 匹配被代理的目标对象对应的类型上拥有 <code>MyAnnotation</code> 注解时。</li>
</ul>
<h4 id="args-v2"><a class="header-anchor" href="#args-v2">¶</a><code>@args</code></h4>
<p><code>@args</code> 匹配被调用的方法上含有参数，且对应的参数类型上拥有指定的注解的情况。如：</p>
<ul>
<li>“<code>@args(com.elim.spring.support.MyAnnotation)</code>” 匹配方法参数类型上拥有 <code>MyAnnotation</code> 注解的方法调用。如我们有一个方法 <code>add(MyParam  param)</code> 接收一个 <code>MyParam</code> 类型的参数，而 <code>MyParam</code> 这个类是拥有注解 <code>MyAnnotation</code> 的，则它可以被 Pointcut 表达式 “<code>@args(com.elim.spring.support.MyAnnotation)</code>” 匹配上。</li>
</ul>
<h4 id="within-v2"><a class="header-anchor" href="#within-v2">¶</a><code>@within</code></h4>
<p><code>@within</code> 用于匹配被代理的目标对象对应的类型或其父类型拥有指定的注解的情况，但只有在调用拥有指定注解的类上的方法时才匹配。如：</p>
<ul>
<li>“<code>@within(com.elim.spring.support.MyAnnotation)</code>” 匹配被调用的方法声明的类上拥有 <code>MyAnnotation</code> 注解的情况。比如有一个 <code>ClassA</code> 上使用了注解 <code>MyAnnotation</code> 标注，并且定义了一个方法 <code>a()</code>，那么在调用 <code>ClassA.a()</code> 方法时将匹配该 Pointcut；如果有一个 <code>ClassB</code> 上没有 <code>MyAnnotation</code> 注解，但是它继承自 <code>ClassA</code>，同时它上面定义了一个方法 <code>b()</code>，那么在调用 <code>ClassB().b()</code> 方法时不会匹配该 Pointcut，但是在调用 <code>ClassB().a()</code> 时将匹配该方法调用，因为 <code>a()</code> 是定义在父类型 <code>ClassA</code> 上的，且 <code>ClassA</code> 上使用了 <code>MyAnnotation</code> 注解。但是如果子类 <code>ClassB</code> 覆写了父类 <code>ClassA</code> 的 <code>a()</code> 方法，则调用 <code>ClassB.a()</code> 方法时也不匹配该 Pointcut。</li>
</ul>
<h4 id="annotation"><a class="header-anchor" href="#annotation">¶</a><code>@annotation</code></h4>
<p><code>@annotation</code> 用于匹配方法上拥有指定注解的情况。如：</p>
<ul>
<li>“<code>@annotation(com.elim.spring.support.MyAnnotation)</code>” 匹配所有的方法上拥有 <code>MyAnnotation</code> 注解的方法外部调用。</li>
</ul>
<h4 id="bean"><a class="header-anchor" href="#bean">¶</a><code>bean</code></h4>
<p><code>bean</code> 用于匹配当调用的是指定的 Spring 的某个 Bean 的方法时。</p>
<ul>
<li>1、“<code>bean(abc)</code>” 匹配 Spring Bean 容器中 id 或 name 为 <code>abc</code> 的 Bean 的方法调用。</li>
<li>2、“<code>bean(user*)</code>” 匹配所有 id 或 name 为以 <code>user</code> 开头的 Bean 的方法调用。</li>
</ul>
<h3 id="3-表达式组合"><a class="header-anchor" href="#3-表达式组合">¶</a>3. 表达式组合</h3>
<p>表达式的组合其实就是对应的表达式的逻辑运算，与、或、非。可以通过它们把多个表达式组合在一起。</p>
<ul>
<li>“<code>bean(userService) &amp;&amp; args()</code>” 匹配 id 或 name 为 <code>userService</code> 的 Bean 的所有无参方法。</li>
<li>“<code>bean(userService) || @annotation(MyAnnotation)</code>” 匹配 id 或 name 为 <code>userService</code> 的 Bean 的方法调用，或者是方法上使用了 <code>MyAnnotation</code> 注解的方法调用。</li>
<li>“<code>bean(userService) &amp;&amp; !args()</code>” 匹配 id 或 name 为 <code>userService</code> 的 Bean 的所有有参方法调用。</li>
</ul>
<h3 id="基于-AspectJ-注解的-Pointcut-表达式应用"><a class="header-anchor" href="#基于-AspectJ-注解的-Pointcut-表达式应用">¶</a>基于 AspectJ 注解的 Pointcut 表达式应用</h3>
<p>在使用基于 AspectJ 注解的 Spring AOP 时，我们可以把通过 <code>@Pointcut</code> 注解定义 Pointcut，指定其表达式，然后在需要使用 Pointcut 表达式的时候直接指定 Pointcut。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Pointcut</span>(<span class="string">"execution(* add(..))"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeAdd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Before</span>(<span class="string">"beforeAdd()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"-----------before-----------"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中我们就是在 <code>@Before()</code> 中直接指定使用当前类定义的 <code>beforeAdd()</code> 方法对应的 Pointcut 的表达式，如果我们需要指定的 Pointcut 定义不是在当前类中的，我们需要加上类名称，如下面这个示例中引用的就是定义在 <code>MyService</code> 中的 <code>add()</code> 方法上的 Pointcut 的表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"com.elim.spring.aop.service.MyService.add()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"-----------before2-----------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，除了通过引用 Pointcut 定义间接的引用其对应的 Pointcut 表达式外，我们也可以直接使用 Pointcut 表达式的，如下面这个示例就直接在 <code>@Before</code> 中使用了 Pointcut 表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有的add方法的外部执行时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(* add())"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeExecution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"-------------before execution---------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、Spring-AOP-原理"><a class="header-anchor" href="#四、Spring-AOP-原理">¶</a>四、Spring AOP 原理</h2>
<p>其实 AOP 的原理非常简单。我们以 <code>LoggingAspect.doAccessCheck()</code> 为例，要把它注入到 <code>UserService</code> 的每个 <code>public</code> 方法中，最简单的方法是编写一个子类，并持有原始实例的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> UserServiceAopProxy extends UserService &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line">    <span class="keyword">private</span> LoggingAspect aspect;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceAopProxy</span><span class="params">(UserService target, LoggingAspect aspect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.aspect = aspect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先执行Aspect的代码:</span></span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        <span class="comment">// 再执行UserService的逻辑:</span></span><br><span class="line">        <span class="keyword">return</span> target.login(email, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">register</span><span class="params">(String email, String password, String name)</span> </span>&#123;</span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        <span class="keyword">return</span> target.register(email, password, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些都是 Spring 容器启动时为我们自动创建的注入了 Aspect 的子类，它取代了原始的 <code>UserService</code>（原始的 <code>UserService</code> 实例作为内部变量隐藏在 <code>UserServiceAopProxy</code> 中）。如果我们打印从 Spring 容器获取的 <code>UserService</code> 实例类型，它类似 <code>UserService$$EnhancerBySpringCGLIB$$1f44e01c</code>，实际上是 Spring 使用 CGLIB 动态创建的子类，但对于调用方来说，感觉不到任何区别。</p>
<p>Spring 对接口类型使用 JDK 动态代理，对普通类使用 CGLIB 创建子类。如果一个Bean 的 class 是 <code>final</code>，Spring 将无法为其创建子类。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Web</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>《Learn Emacs in 21 days》学习笔记</title>
    <url>/2019/10/06/%E3%80%8ALearn-Emacs-in-21-days%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h1>《Learn Emacs in 21 days》学习笔记</h1>
<h2 id="第一天"><a class="header-anchor" href="#第一天">¶</a>第一天</h2>
<h3 id="配置文件-init-el"><a class="header-anchor" href="#配置文件-init-el">¶</a>配置文件(init.el)</h3>
<ul>
<li>配置文件默认位置为 <em>$HOME/.emacs.d/init.el</em>
<blockquote>
<p>Windows 下需要设置环境变量<code>HOME</code>，若不设置，默认为 <em>%USERPROFILE%\.emacs.d\init.el</em> 或 <em>%APPDATA%\.emacs.d\init.el</em>。</p>
</blockquote>
</li>
<li>手动指定配置文件位置<br>
编辑 <em>$HOME/.emacs.d/init.el</em> (Windows 下为 <em>%USERPROFILE%\.emacs.d\init.el</em> 或 <em>%APPDATA%\.emacs.d\init.el</em>)：</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"><span class="comment">;; This file is only for windows 7/8/8.1</span></span><br><span class="line"><span class="comment">;; The only thing it does is to set the HOME directories for emacs,</span></span><br><span class="line"><span class="comment">;; then trigger the init.el in the directory specified by HOME to</span></span><br><span class="line"><span class="comment">;; accomplish the true initialization</span></span><br><span class="line"><span class="comment">;; You should put this file in the default HOME directory right after</span></span><br><span class="line"><span class="comment">;; emacs is installed</span></span><br><span class="line">(<span class="name">setenv</span> <span class="string">"HOME"</span> <span class="string">"C:/Users/Carzpurzkey"</span>) <span class="comment">;; you can change this dir to the place you like</span></span><br><span class="line">(<span class="name">load</span> <span class="string">"~/.emacs.d/init.el"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>基础配置</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 关闭工具栏</span></span><br><span class="line">(<span class="name">tool-bar-mode</span> <span class="number">-1</span>)</span><br><span class="line"><span class="comment">; 关闭滚动条</span></span><br><span class="line">(<span class="name">scroll-bar-mode</span> <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">electric-indent-mode</span> <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">; 关闭欢迎画面</span></span><br><span class="line">(<span class="name">setq</span> inhibit-splash-screen <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">; 启用全局行号</span></span><br><span class="line">(<span class="name">global-linum-mode</span> <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">; 启用全局company-mode</span></span><br><span class="line">(<span class="name">global-company-mode</span> <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">; 启用全局条状光标</span></span><br><span class="line">(<span class="name">setq-default</span> cursor-type 'bar)</span><br><span class="line"></span><br><span class="line"><span class="comment">; 禁用自动文件备份</span></span><br><span class="line">(<span class="name">setq</span> make-backup-files <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<h3 id="前缀键-Leading-Key"><a class="header-anchor" href="#前缀键-Leading-Key">¶</a>前缀键 (Leading Key)</h3>
<ul>
<li>
<p><code>C-x</code> 执行快捷键命令</p>
<ol>
<li><code>C-x C-e</code>
<ul>
<li>立即执行光标所在位置 elisp 脚本（光标必须在 sexp 尾部）。</li>
<li>运行上一个 sexp（即执行 <code>eval-last-sexp</code> 命令）。</li>
</ul>
</li>
<li><code>C-x C-f</code> 打开文件。</li>
<li><code>C-x C-s</code> 保存文件。</li>
<li><code>C-x 2</code> 在下方新建窗口。</li>
<li><code>C-x 3</code> 在右侧新建窗口。</li>
<li><code>C-x 1</code> 关闭当前窗口之外的所有窗口。</li>
<li><code>C-x b</code> 切换 buffers。</li>
<li><code>C-x k</code> 删除当前buffer。</li>
<li><code>C-x o</code> 切换窗口。</li>
</ol>
</li>
<li>
<p><code>C-h</code> 帮助</p>
<ol>
<li><code>C-h v</code> 查询变量信息。</li>
<li><code>C-h f</code> 查询函数信息。</li>
<li><code>C-h k</code> 查询键绑定信息。</li>
</ol>
</li>
<li>
<p><code>C-c</code> 自定义快捷键</p>
<ul>
<li>
<p>org-mode：</p>
<ul>
<li>
<p><code>C-c t</code> 切换 TODO 状态。</p>
</li>
<li>
<p><code>C-c '</code> 当光标处于块</p>
<pre><code>  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">#+BEGIN_SRC language</span><br><span class="line">#+END_SRC</span><br></pre></td></tr></table></figure>
</code></pre>
<p>中间时，按 <code>C-c '</code> 则会在新 <em>buffer</em> 中以 <code>language</code> minar mode 编辑块中内容。</p>
</li>
<li>
<p><code>C-c C-s</code> 制定计划，指定开始时间。</p>
</li>
<li>
<p><code>C-c C-d</code> 制定计划，指定 dead line。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>M-x</code> 在 <em>minibuffer</em> 执行文字命令。</p>
</li>
<li>
<p>其它</p>
<ol>
<li><code>C-a</code> 定位至行首。</li>
<li><code>C-e</code> 定位至行尾。</li>
<li><code>C-f</code> 光标前移一个字符。</li>
<li><code>C-p</code> 光标上移一行。</li>
<li><code>C-n</code> 光标下移一行。</li>
<li><code>C-s</code> 搜索。</li>
<li><code>C-g</code> 终止一切未完成的操作。</li>
<li><code>M-Enter</code> 自动修正序号。</li>
</ol>
</li>
</ul>
<h2 id="第二天"><a class="header-anchor" href="#第二天">¶</a>第二天</h2>
<h3 id="继续定制配置文件"><a class="header-anchor" href="#继续定制配置文件">¶</a>继续定制配置文件</h3>
<ol>
<li>
<p>org-mode：</p>
<ul>
<li>
<p>启用：</p>
<pre><code>  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">require</span> 'org)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li>
<p>使块 <code>#+BEGIN_SRC</code> <code>#+END_SRC</code> 之间的代码有语法高亮：</p>
<pre><code>  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">require</span> 'org)</span><br><span class="line">(<span class="name">setq</span> org-src-fontify-natively <span class="literal">t</span>)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li>
<p><code>&lt;s</code> + <code>tab键</code> 自动插入 <code>#+BEGIN_SRC language</code> <code>#+END_SRC</code> 块。</p>
</li>
<li>
<p>Agenda</p>
<ul>
<li>
<p>启用及配置</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> org-agenda-files '(<span class="string">"~/org-agenda"</span>))</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-c a"</span>) 'org-agenda)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>开启“最近打开的文件”功能：</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">require</span> 'recentf)</span><br><span class="line">(<span class="name">recentf-mode</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">setq</span> recentf-max-menu-items <span class="number">25</span>)</span><br><span class="line">(<span class="name">global-set-key</span> <span class="string">"\C-x\ \C-r"</span> 'recentf-open-files)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使选中区域切换为替换模式：</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">delete-selection-mode</span> <span class="literal">t</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>打开 Emacs 时自动全屏显示：</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> initial-frame-alist (<span class="name">quote</span> ((fullscreen . maximized))))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>高亮括号匹配：</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">add-hook</span> 'emacs-lisp-mode-hook 'show-parent-mode)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>高亮当前行：</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">global-hl-line-mode</span> <span class="literal">t</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>加载主题：</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">load-theme</span> 'dracula <span class="literal">t</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>hungry delete：</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">require</span> 'hungry-delete)</span><br><span class="line">(<span class="name">global-hungry-delete-mode</span> <span class="literal">t</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>smex：<br>
smex 是 <code>M-x</code> 的扩展</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">require</span> 'smex)</span><br><span class="line">(<span class="name">smex-initialize</span>)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"M-x"</span>) 'smex)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"M-x"</span>) 'smex-major-mode-commands)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-c C-c M-x"</span>) 'execute-extended-command)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>swiper：<br>
swiper 是 <code>C-s</code> 的扩展：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">ivy-mode</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">setq</span> ivy-use-virtual-buffers <span class="literal">t</span>)</span><br><span class="line">(<span class="name">global-set-key</span> <span class="string">"\C-s"</span> 'swiper)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-c C-r"</span>) 'ivy-resume)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"&lt;f6&gt;"</span>) 'ivy-resume)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"M-x"</span>) 'counsel-M-x)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-x C-f"</span>) 'counsel-find-file)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"&lt;f1&gt; f"</span>) 'counsel-describe-function)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"&lt;f1&gt; v"</span>) 'counsel-describe-variable)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-c g"</span>) 'counsel-git)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>smartparens：<br>
smartparens 可以自动补全括号及各种引号：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">smartparens-global-mode</span> <span class="literal">t</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>find-function</code> 和 <code>find-variable</code> 函数</p>
</li>
</ol>
<ul>
<li>
<p><code>find-function</code> 函数查看函数定义。</p>
</li>
<li>
<p><code>find-variable</code> 函数查看变量定义。</p>
</li>
<li>
<p><code>find-function-on-key</code> 函数查看指定的快捷键绑定在了哪个函数上。</p>
<p>定义以上函数快捷键：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-h C-f"</span>) 'find-function)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-h C-v"</span>) 'find-variable)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-h C-k"</span>) 'find-function-on-key)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="require-命令"><a class="header-anchor" href="#require-命令">¶</a><code>require</code> 命令</h3>
<ul>
<li><code>require</code> 命令会从一个文件加载一个特性(feature)。如果未提供文件名，那么 <code>require</code> 命令会将第一个参数同时作为特性名和文件名。</li>
<li><code>require</code> 命令内部调用的是 <code>load</code> 命令。</li>
</ul>
<h3 id="eval-buffer-命令"><a class="header-anchor" href="#eval-buffer-命令">¶</a><code>eval-buffer</code> 命令</h3>
<p><code>eval-buffer</code> 命令会执行当前整个 <em>buffer</em> 中的所有命令。</p>
<h3 id="hook"><a class="header-anchor" href="#hook">¶</a>hook</h3>
<p><code>add-hook</code> 函数：</p>
<p>使用：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">add-hook</span> 'hook-name 'hook-function-or-mode)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>hook-name</code> 代表将在哪个 mode 中添加 hook。例如 <code>emacs-lisp-mode-hook</code>。</p>
</blockquote>
<h3 id="改进-package-系统"><a class="header-anchor" href="#改进-package-系统">¶</a>改进 package 系统</h3>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">when</span> (<span class="name">&gt;=</span> emacs-major-version <span class="number">24</span>)</span><br><span class="line">    (<span class="name">require</span> 'package)</span><br><span class="line">    (<span class="name">package-initialize</span>)</span><br><span class="line">    (<span class="name">setq</span> package-archives '((<span class="string">"gnu"</span>   . <span class="string">"http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/"</span>)</span><br><span class="line">                             (<span class="string">"melpa"</span> . <span class="string">"http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/"</span>))))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; cl - Common Lisp Extension</span></span><br><span class="line">(<span class="name">require</span> 'cl)</span><br><span class="line"><span class="comment">;; Add Packages</span></span><br><span class="line">(<span class="name">defvar</span> my/packages '(</span><br><span class="line">    ;; --- Auto-completion ---</span><br><span class="line">    company</span><br><span class="line"></span><br><span class="line">    ;; --- Better Editor ---</span><br><span class="line">    hungry-delete</span><br><span class="line">    swiper</span><br><span class="line">    counsel</span><br><span class="line">    smartparens</span><br><span class="line">	smex</span><br><span class="line"></span><br><span class="line">    ;; --- Major Mode ---</span><br><span class="line">    js2-mode</span><br><span class="line"></span><br><span class="line">	;; --- Minor Mode ---</span><br><span class="line">	nodejs-repl</span><br><span class="line">	exec-path-from-shell</span><br><span class="line"></span><br><span class="line">	;; --- Themes ---</span><br><span class="line">	;; monokai-theme</span><br><span class="line">	;; solarized-theme</span><br><span class="line">    dracula-theme</span><br><span class="line"></span><br><span class="line">	) <span class="string">"Default packages"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 添加此行防止 package-autoremove 命令自动删除第三方 package</span></span><br><span class="line">(<span class="name">setq</span> package-selected-packages my/packages)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> my/packages-installed-p ()</span><br><span class="line">    (<span class="name">loop</span> for pkg in my/packages</span><br><span class="line">        when (<span class="name">not</span> (<span class="name">package-installed-p</span> pkg)) do (<span class="name">return</span> <span class="literal">nil</span>)</span><br><span class="line">        finally (<span class="name">return</span> <span class="literal">t</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">unless</span> (<span class="name">my/packages-installed-p</span>)</span><br><span class="line">    (<span class="name">message</span> <span class="string">"%s"</span> <span class="string">"Refreshing package database..."</span>)</span><br><span class="line">    (<span class="name">package-refresh-contents</span>)</span><br><span class="line">    (<span class="name">dolist</span> (<span class="name">pkg</span> my/packages)</span><br><span class="line">        (<span class="name">when</span> (<span class="name">not</span> (<span class="name">package-installed-p</span> pkg))</span><br><span class="line">            (<span class="name">package-install</span> pkg))))</span><br></pre></td></tr></table></figure>
<h3 id="package-list-packages-命令"><a class="header-anchor" href="#package-list-packages-命令">¶</a><code>package-list-packages</code> 命令</h3>
<p>执行 <code>M-x package-list-packages</code> 命令后，会打开一个新的名为 <em>*Packages*</em> 的 <em>buffer</em> 。</p>
<ul>
<li>在 <em>*Packages*</em> <em>buffer</em> 中，按 <code>I</code> 标记将要被安装的包；按 <code>U</code> 取消被标记为将被安装的包；</li>
<li>在 <em>*Packages*</em> <em>buffer</em> 中，按 <code>D</code> 标记将要卸载的包。</li>
<li>在 <em>*Packages*</em> <em>buffer</em> 中，按 <code>U</code> 标记将要更新的包。</li>
<li>在 <em>*Packages*</em> <em>buffer</em> 中，按 <code>X</code> 执行上述标记。</li>
</ul>
<h3 id="customize-group-命令"><a class="header-anchor" href="#customize-group-命令">¶</a><code>customize-group</code> 命令</h3>
<p><code>customize-group</code> 命令用来以更直观的方式配置插件参数并保存至 emacs 配置文件。</p>
<h3 id="更改默认-mode"><a class="header-anchor" href="#更改默认-mode">¶</a>更改默认 mode</h3>
<p>通过更改 <code>auto-mode-alist</code> 变量可以改变自动加载的 mode：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"><span class="comment">;; 将 Javascript 文件默认的 Javascript Major Mode 更改为 js2-mode</span></span><br><span class="line">(<span class="name">setq</span> auto-mode-alist</span><br><span class="line">    (<span class="name">append</span></span><br><span class="line">        '((<span class="string">"\\.js\\'"</span> . js2-mode))</span><br><span class="line">        auto-mode-alist))</span><br></pre></td></tr></table></figure>
<h2 id="第三天"><a class="header-anchor" href="#第三天">¶</a>第三天</h2>
<h3 id="继续定制配置文件-v2"><a class="header-anchor" href="#继续定制配置文件-v2">¶</a>继续定制配置文件</h3>
<ol>
<li>
<p>自动重新加载外部修改文件：</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">global-auto-revert-mode</span> <span class="literal">t</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>禁用文件自动保存</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> auto-save-default <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>popwin：</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">require</span> 'popwin)</span><br><span class="line">(<span class="name">popwin-mode</span> <span class="literal">t</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>abbrev-mode</p>
<p>abbrev-mode 可以定义一个用以简化自动补全的缩写。</p>
<ul>
<li>
<p>启用：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">abbrev-mode</span> <span class="literal">t</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义缩写列表：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">define-abbrev-table</span> 'global-abbrev-table '(</span><br><span class="line">	(<span class="string">"8zl"</span> <span class="string">"zilongshanren"</span>)))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>关闭触底/顶声音提示</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> ring-bell-function 'ignore)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="autoload-魔法注释"><a class="header-anchor" href="#autoload-魔法注释">¶</a><code>;;;###autoload</code> 魔法注释</h3>
<p>当我们调用 <code>(package-initialize)</code> 时，其会遍历 <em>elpa</em> 目录中的 packages、读取该 package 目录下的 <em>*.el</em> 文件。根据 <code>;;;###autoload</code> 注释，<code>(package-initialize)</code> 会生成一个包含所有自动加载项的 el 文件。<br>
通过添加 <code>;;;###autoload</code> 魔法注释，emacs 便可以不调用 <code>(require 'mode-name)</code> 而是直接使用 <code>(global-mode-name t)</code> 来启用 package。</p>
<h3 id="load-命令"><a class="header-anchor" href="#load-命令">¶</a><code>load</code> 命令</h3>
<p><code>load package-name</code> 命令使用如下顺序在 <code>load-path</code> 变量指定的目录中查找一个包并加载：</p>
<blockquote>
<p>package-name.elc -&gt; package-name.el -&gt; package-name.gz</p>
</blockquote>
<p>找不到则报错。</p>
<h3 id="load-file-命令"><a class="header-anchor" href="#load-file-命令">¶</a><code>load-file</code> 命令</h3>
<p>在指定的目录查找并加载 package。</p>
<h3 id="features-变量"><a class="header-anchor" href="#features-变量">¶</a><code>features</code> 变量</h3>
<p>一个 package 可以通过 <code>provide</code> 向 <code>features</code> 变量添加自己的包名来“导出”自己，然后 emacs 便可以通过 <code>require</code> 命令读取 <code>features</code> 变量“导入”这个 package。</p>
<h3 id="多文件存储配置"><a class="header-anchor" href="#多文件存储配置">¶</a>多文件存储配置</h3>
<h4 id="load-path-变量"><a class="header-anchor" href="#load-path-变量">¶</a><code>load-path</code> 变量</h4>
<ul>
<li><code>load-path</code> 是一个 <code>list</code> 型变量且默认不包含 <em>~/.emacs.d</em>。</li>
<li>可以通过 <code>(add-to-list 'load-path &quot;custom-configuration-file-path&quot;)</code> 将自定义配置文件所在目录添加到 <code>load-path</code> 中。</li>
</ul>
<h4 id="指定由-customize-group-生成的配置项存储文件"><a class="header-anchor" href="#指定由-customize-group-生成的配置项存储文件">¶</a>指定由 <code>customize-group</code> 生成的配置项存储文件</h4>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> custom-file (<span class="name">expand-file-name</span> <span class="string">"configuration-file-path-relative-to-init.el-path"</span> user-emacs-directory))</span><br><span class="line">(<span class="name">load-file</span> custom-file)</span><br></pre></td></tr></table></figure>
<h3 id="major-mode-和-minar-mode"><a class="header-anchor" href="#major-mode-和-minar-mode">¶</a>major mode 和 minar mode</h3>
<p>major mode 分为以下三类：</p>
<ul>
<li>text-mode：普通文本模式。</li>
<li>special-mode：特殊模式。用的较少。</li>
<li>prog-mode：编程语言模式。如上述 js2-mode 便从 prog-mode 继承。</li>
</ul>
<h2 id="第四天"><a class="header-anchor" href="#第四天">¶</a>第四天</h2>
<h3 id="indent-region-命令"><a class="header-anchor" href="#indent-region-命令">¶</a><code>indent-region</code> 命令</h3>
<ul>
<li>
<p>签名：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">indent-region</span> START END <span class="symbol">&amp;optional</span> COLUMN)</span><br></pre></td></tr></table></figure>
<p>当我们选中部分文本后，<code>START</code> 和 <code>END</code> 既为选中区域的开头和结尾。</p>
</li>
<li>
<p>使用示例</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> indent-buffer()</span><br><span class="line">	(<span class="name">interactive</span>)</span><br><span class="line">	(<span class="name">indent-region</span> (<span class="name">point-min</span>) (<span class="name">point-max</span>)))</span><br><span class="line">	</span><br><span class="line">(<span class="name">defun</span> indent-region-or-buffer()</span><br><span class="line">   (<span class="name">interactive</span>)</span><br><span class="line">   (<span class="name">save-excursion</span>    <span class="comment">;; save-excursion：保存光标位置，执行子语句后恢复光标位置。</span></span><br><span class="line">       (<span class="name">if</span> (<span class="name">region-active-p</span>)    <span class="comment">;; *-p：断言。</span></span><br><span class="line">           (<span class="name">progn</span></span><br><span class="line">               (<span class="name">indent-region</span> (<span class="name">region-beginning</span>) (<span class="name">region-end</span>))</span><br><span class="line">               (<span class="name">message</span> <span class="string">"Indent selected region."</span>))</span><br><span class="line">       (<span class="name">progn</span>    <span class="comment">;; 等价于 else。</span></span><br><span class="line">           (<span class="name">indent-buffer</span>)</span><br><span class="line">           (<span class="name">message</span> <span class="string">"Indent buffer."</span>)))))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Dired-Mode"><a class="header-anchor" href="#Dired-Mode">¶</a>Dired Mode</h3>
<ul>
<li>
<p>Dired Mode 是一个强大的模式它能让我们完成和文件管理相关的所有操作。<br>
使用 <code>C-x d</code> 就可以进入 Dired Mode。<br>
常用操作：</p>
<ul>
<li><code>+</code> 创建目录</li>
<li><code>g</code> 刷新目录</li>
<li><code>C</code> 拷贝</li>
<li><code>D</code> 删除</li>
<li><code>R</code> 重命名</li>
<li><code>d</code> 标记删除</li>
<li><code>u</code> 取消标记</li>
<li><code>x</code> 执行所有的标记</li>
</ul>
</li>
<li>
<p>优化</p>
<ul>
<li>
<p>删除目录的时候 Emacs 会询问是否递归删除或拷贝， 这也有些麻烦我们可以用下面的配置将其设定为默认递归删除目录。</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> dired-recursive-deletes 'always)</span><br><span class="line">(<span class="name">setq</span> dired-recursive-copies 'always)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>每一次你进入一个回车进入一个新的目录中是，一个新的缓冲区就会被建立。这使 得我们的缓冲区列表中充满了大量没有实际意义的记录。我们可以使用下面的代码，让 Emacs 重用唯一的一个缓冲区作为 Dired Mode 显示专用缓冲区。</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">put</span> 'dired-find-alternate-file 'disabled <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 主动加载 Dired Mode</span></span><br><span class="line"><span class="comment">;; (require 'dired)</span></span><br><span class="line"><span class="comment">;; (defined-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 延迟加载</span></span><br><span class="line">(<span class="name">with-eval-after-load</span> 'dired</span><br><span class="line">    (<span class="name">define-key</span> dired-mode-map (<span class="name">kbd</span> <span class="string">"RET"</span>) 'dired-find-alternate-file))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <code>(setq dired-dwin-target 1)</code> 则可以使当一个窗口（frame）中存在两个分屏 （window）时，将另一个分屏自动设置成拷贝地址的目标。</p>
</li>
</ul>
</li>
</ul>
<h3 id="org-mode-管理-Emacs-配置"><a class="header-anchor" href="#org-mode-管理-Emacs-配置">¶</a>org-mode 管理 Emacs 配置</h3>
<p>我们也可以使用 org 来管理 Emacs 的配置文件（笔者和他的师傅其实更倾向于模块管理配置文件）。</p>
<p>你需要将下面的代码放入配置入口文件 <em>init.el</em> 中，</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">package-initialize</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">require</span> 'org-install)</span><br><span class="line">(<span class="name">require</span> 'ob-tangle)</span><br><span class="line">(<span class="name">org-babel-load-file</span> (<span class="name">expand-file-name</span> <span class="string">"org-file-name.org"</span> user-emacs-directory))</span><br></pre></td></tr></table></figure>
<p>之后我们需要做的仅仅只是将所有的配置文件放入 Org 模式中的代码块即可，并使用目录 结构来表述你的配置文件再把它保存在与入口文件相同的目录中即可(文件名为 <em><a href="http://org-file-name.org" target="_blank" rel="noopener">org-file-name.org</a></em>)。Emacs 会提取其中的配置并使其生效。这样做的好处是可以使自 己和他人更直观的，理解你的配置文件或者代码。</p>
<h2 id="第五天"><a class="header-anchor" href="#第五天">¶</a>第五天</h2>
<h3 id="继续定制配置文件-v3"><a class="header-anchor" href="#继续定制配置文件-v3">¶</a>继续定制配置文件</h3>
<ol>
<li>
<p>取消引号自动配对：</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">sp-local-pair</span> 'emacs-lisp-mode <span class="string">"'"</span> <span class="literal">nil</span> <span class="symbol">:actions</span> <span class="literal">nil</span>)</span><br><span class="line">(<span class="name">sp-local-pair</span> 'lisp-interaction-mode <span class="string">"'"</span> <span class="literal">nil</span> <span class="symbol">:actions</span> <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 也可以把上面两句合起来</span></span><br><span class="line">(<span class="name">sp-local-pair</span> '(emacs-lisp-mode lisp-interaction-mode) <span class="string">"'"</span> <span class="literal">nil</span> <span class="symbol">:actions</span> <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>show-paren-mode 可以使鼠标在括号上是高亮其所匹配的另一半括号，然而我们想要光标在括号内时就高亮包含内容的两个括号，使用下面的代码就可以做到这一点：</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"><span class="comment">;; define-advice宏：扩展一个函数，使其在执行过程中 (:around) 执行另外一些操作。</span></span><br><span class="line">(<span class="name">define-advice</span> show-paren-function (<span class="symbol">:around</span> (<span class="name">fn</span>) fix-show-paren-function)</span><br><span class="line">  <span class="string">"Highlight enclosing parens."</span></span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">looking-at-p</span> <span class="string">"\\s("</span>) (<span class="name">funcall</span> fn))</span><br><span class="line">		(<span class="name">t</span> (<span class="name">save-excursion</span></span><br><span class="line">	     (<span class="name">ignore-errors</span> (<span class="name">backward-up-list</span>))</span><br><span class="line">	     (<span class="name">funcall</span> fn)))))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>解决在不同系统中的换行符，例如在 DOS 系统下的 <code>\r(^M)</code> 换行符， 这让我们有时候在 Unix 系统中很是头疼，因为它的存在会使版本控制误以为整行的代码都 被修改过而造成不必要的麻烦。（你可以在这里找到更多关于 <a href="http://unix.stackexchange.com/questions/32001/what-is-m-and-how-do-i-get-rid-of-it" target="_blank" rel="noopener">\r(^M)</a> 的信息）。</p>
<ul>
<li>
<p>方法一：隐藏</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> hidden-dos-eol ()</span><br><span class="line">  <span class="string">"Do not show ^M in files containing mixed UNIX and DOS line endings."</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">unless</span> buffer-display-table</span><br><span class="line">    (<span class="name">setq</span> buffer-display-table (<span class="name">make-display-table</span>)))</span><br><span class="line">  (<span class="name">aset</span> buffer-display-table ?\^M []))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法二：删除</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> remove-dos-eol ()</span><br><span class="line">  <span class="string">"Replace DOS eolns CR LF with Unix eolns CR"</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">goto-char</span> (<span class="name">point-min</span>))</span><br><span class="line">  (<span class="name">while</span> (<span class="name">search-forward</span> <span class="string">"\r"</span> <span class="literal">nil</span> <span class="literal">t</span>) (<span class="name">replace-match</span> <span class="string">""</span>)))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="web-mode"><a class="header-anchor" href="#web-mode">¶</a>web-mode</h3>
<ul>
<li>
<p>安装</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defvar</span> xinyang/packages '(</span><br><span class="line">			   ;; 你其他的插件在这里</span><br><span class="line">			   web-mode</span><br><span class="line">			   ) <span class="string">"Default packages"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置</p>
<ol>
<li>
<p>我们需要做的是将所有的 <em>*.html</em> 文件都使用 web-mode 来打开。</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> auto-mode-alist</span><br><span class="line">      (<span class="name">append</span></span><br><span class="line">       '((<span class="string">"\\.js\\'"</span> . js2-mode))</span><br><span class="line">       '((<span class="string">"\\.html\\'"</span> . web-mode))</span><br><span class="line">       auto-mode-alist))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样所有的 HTML 代码在 Emacs 中就会之间启用 web-mode 而非默认的 HTML Mode 了。你可以阅读它的<a href="http://web-mode.org/" target="_blank" rel="noopener">文档</a>来学习更多 web-mode 详细的使用方法。</p>
<ol start="2">
<li>
<p>缩进的大小的设置。我们可以对不同的语言的缩减做出设置：</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> my-web-mode-indent-setup ()</span><br><span class="line">  (<span class="name">setq</span> web-mode-markup-indent-offset <span class="number">4</span>) <span class="comment">; web-mode, html tag in html file</span></span><br><span class="line">  (<span class="name">setq</span> web-mode-css-indent-offset <span class="number">4</span>)    <span class="comment">; web-mode, css in html file</span></span><br><span class="line">  (<span class="name">setq</span> web-mode-code-indent-offset <span class="number">4</span>)   <span class="comment">; web-mode, js code in html file</span></span><br><span class="line">  )</span><br><span class="line">(<span class="name">add-hook</span> 'web-mode-hook 'my-web-mode-indent-setup)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 下面的函数可以用于在两个空格和四个空格之间进行切换</span></span><br><span class="line">(<span class="name">defun</span> my-toggle-web-indent ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  <span class="comment">;; web development</span></span><br><span class="line">  (<span class="name">if</span> (<span class="name">or</span> (<span class="name">eq</span> major-mode 'js-mode) (<span class="name">eq</span> major-mode 'js2-mode))</span><br><span class="line">      (<span class="name">progn</span></span><br><span class="line">		(<span class="name">setq</span> js-indent-level (<span class="name">if</span> (<span class="name">=</span> js-indent-level <span class="number">2</span>) <span class="number">4</span> <span class="number">2</span>))</span><br><span class="line">		(<span class="name">setq</span> js2-basic-offset (<span class="name">if</span> (<span class="name">=</span> js2-basic-offset <span class="number">2</span>) <span class="number">4</span> <span class="number">2</span>))))</span><br><span class="line"></span><br><span class="line">  (<span class="name">if</span> (<span class="name">eq</span> major-mode 'web-mode)</span><br><span class="line">      (<span class="name">progn</span> (<span class="name">setq</span> web-mode-markup-indent-offset (<span class="name">if</span> (<span class="name">=</span> web-mode-markup-indent-offset <span class="number">2</span>) <span class="number">4</span> <span class="number">2</span>))</span><br><span class="line">		     (<span class="name">setq</span> web-mode-css-indent-offset (<span class="name">if</span> (<span class="name">=</span> web-mode-css-indent-offset <span class="number">2</span>) <span class="number">4</span> <span class="number">2</span>))</span><br><span class="line">		     (<span class="name">setq</span> web-mode-code-indent-offset (<span class="name">if</span> (<span class="name">=</span> web-mode-code-indent-offset <span class="number">2</span>) <span class="number">4</span> <span class="number">2</span>))))</span><br><span class="line">  (<span class="name">if</span> (<span class="name">eq</span> major-mode 'css-mode)</span><br><span class="line">      (<span class="name">setq</span> css-indent-offset (<span class="name">if</span> (<span class="name">=</span> css-indent-offset <span class="number">2</span>) <span class="number">4</span> <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">  (<span class="name">setq</span> indent-tabs-mode <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-c t i"</span>) 'my-toggle-web-indent)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="js2-refactor"><a class="header-anchor" href="#js2-refactor">¶</a>js2-refactor</h3>
<ol>
<li>
<p>安装</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defvar</span> xinyang/packages '(</span><br><span class="line">			   ;; 你其他的插件在这里</span><br><span class="line">			   js2-refactor</span><br><span class="line">			   ) <span class="string">"Default packages"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">add-hook</span> 'js2-mode-hook #'js2-refactor-mode)</span><br><span class="line">(<span class="name">js2r-add-keybindings-with-prefix</span> <span class="string">"C-c C-m"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="occur-mode"><a class="header-anchor" href="#occur-mode">¶</a>occur-mode</h3>
<p>occur 可以用于显示变量或函数的定义。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> occur-dwim ()</span><br><span class="line">  <span class="string">"Call `occur' with a sane default."</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">push</span> (<span class="name">if</span> (<span class="name">region-active-p</span>)</span><br><span class="line">	  (<span class="name">buffer-substring-no-properties</span></span><br><span class="line">		  (<span class="name">region-beginning</span>)</span><br><span class="line">	      (<span class="name">region-end</span>))</span><br><span class="line">		(<span class="name">let</span> ((<span class="name">sym</span> (<span class="name">thing-at-point</span> 'symbol)))</span><br><span class="line">		    (<span class="name">when</span> (<span class="name">stringp</span> sym)</span><br><span class="line">		      (<span class="name">regexp-quote</span> sym))))</span><br><span class="line">		regexp-history)</span><br><span class="line">  (<span class="name">call-interactively</span> 'occur))</span><br><span class="line">	(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-c C-s o"</span>) 'occur-dwim)</span><br></pre></td></tr></table></figure>
<p>occur 与普通的搜索模式不同的是，它可以使用 Occur-Edit Mode (在弹出的窗口中按 <code>e</code> 进入编辑模式) 对搜索到的结果进行之间的编辑。</p>
<h3 id="imenu"><a class="header-anchor" href="#imenu">¶</a>imenu</h3>
<p>imenu 可以显示当前缓冲区所有符号的列表，下面的配置可以让其拥有更精确的跳转：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> js2-imenu-make-index ()</span><br><span class="line">	(<span class="name">interactive</span>)</span><br><span class="line">    (<span class="name">save-excursion</span></span><br><span class="line">	<span class="comment">;; (setq imenu-generic-expression '((nil "describe\\(\"\\(.+\\)\"" 1)))</span></span><br><span class="line">	(<span class="name">imenu--generic-function</span> '((<span class="string">"describe"</span> <span class="string">"\\s-*describe\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*"</span> <span class="number">1</span>)</span><br><span class="line">				   (<span class="string">"it"</span> <span class="string">"\\s-*it\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*"</span> <span class="number">1</span>)</span><br><span class="line">				   (<span class="string">"test"</span> <span class="string">"\\s-*test\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*"</span> <span class="number">1</span>)</span><br><span class="line">				   (<span class="string">"before"</span> <span class="string">"\\s-*before\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*"</span> <span class="number">1</span>)</span><br><span class="line">				   (<span class="string">"after"</span> <span class="string">"\\s-*after\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*"</span> <span class="number">1</span>)</span><br><span class="line">				   (<span class="string">"Function"</span> <span class="string">"function[ \t]+\\([a-zA-Z0-9_$.]+\\)[ \t]*("</span> <span class="number">1</span>)</span><br><span class="line">				   (<span class="string">"Function"</span> <span class="string">"^[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*=[ \t]*function[ \t]*("</span> <span class="number">1</span>)</span><br><span class="line">				   (<span class="string">"Function"</span> <span class="string">"^var[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*=[ \t]*function[ \t]*("</span> <span class="number">1</span>)</span><br><span class="line">				   (<span class="string">"Function"</span> <span class="string">"^[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*()[ \t]*&#123;"</span> <span class="number">1</span>)</span><br><span class="line">				   (<span class="string">"Function"</span> <span class="string">"^[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*:[ \t]*function[ \t]*("</span> <span class="number">1</span>)</span><br><span class="line">				   (<span class="string">"Task"</span> <span class="string">"[. \t]task([ \t]*['\"]\\([^'\"]+\\)"</span> <span class="number">1</span>)))))</span><br><span class="line">(<span class="name">add-hook</span> 'js2-mode-hook</span><br><span class="line">	    (<span class="name">lambda</span> ()</span><br><span class="line">			(<span class="name">setq</span> imenu-create-index-function 'js2-imenu-make-index)))</span><br><span class="line"></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-c C-s i"</span>) 'counsel-imenu)</span><br></pre></td></tr></table></figure>
<h3 id="expand-region"><a class="header-anchor" href="#expand-region">¶</a>expand-region</h3>
<p>使用这个插件可以使我们更方便的选中一个区域。（更多使用方法和文档可以在<a href="https://github.com/magnars/expand-region.el" target="_blank" rel="noopener">这里</a>找到）。<br>
为其绑定一个快捷键：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-="</span>) 'er/expand-region)</span><br></pre></td></tr></table></figure>
<h3 id="iedit"><a class="header-anchor" href="#iedit">¶</a>iedit</h3>
<p>iedit 是一个可以同时编辑多个区域的插件，它类似 Sublime Text 中的多光标编辑。<br>
我们将其绑定快捷键以便更快捷的使用这个模式（ <code>C-;</code> 为默认快捷键），</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-c C-s e"</span>) 'iedit-mode)</span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>customized-group</code> 来更改其高亮的背景色，将 <code>highlight</code> 改为 <code>region</code>。</p>
<h3 id="org-导出"><a class="header-anchor" href="#org-导出">¶</a>org 导出</h3>
<p>使用 <code>C-c C-e</code> 可以将 org-mode 文档导出为你需要的格式，例如 HTML 或者 PDF 文件。</p>
<h2 id="第六天"><a class="header-anchor" href="#第六天">¶</a>第六天</h2>
<h3 id="org-mode-进阶"><a class="header-anchor" href="#org-mode-进阶">¶</a>org-mode 进阶</h3>
<ol>
<li>
<p>使用 <code>org-capture</code> 命令记笔记。</p>
<p>我们用下面的配置代码来设置一个模板（其中设置了待办事项的优先级还有触发键）：</p>
<pre><code> <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> org-capture-templates</span><br><span class="line">    '((<span class="string">"t"</span> <span class="string">"Todo"</span> entry (file+headline <span class="string">"~/.emacs.d/gtd.org"</span> <span class="string">"工作安排"</span>)</span><br><span class="line">		 <span class="string">"* TODO [#B] %?\n  %i\n"</span></span><br><span class="line">	 :empty-lines <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
</code></pre>
<p>我们也可以为其绑定一个快捷键：</p>
<pre><code> <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-c r"</span>) 'org-capture)</span><br></pre></td></tr></table></figure>
</code></pre>
<p>更多有关 <code>org-capture</code> 的内容可以在<a href="http://orgmode.org/manual/Capture.html" target="_blank" rel="noopener">这里</a>找到。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
        <tag>笔记</tag>
        <tag>GNU</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Hexo Ocean 主题博客搭建</title>
    <url>/2020/02/04/%E5%9F%BA%E4%BA%8E-Hexo-Ocean-%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1>基于 Hexo Ocean 主题博客搭建</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="hexo-的基本命令"><a class="header-anchor" href="#hexo-的基本命令">¶</a>hexo 的基本命令</h2>
<ul>
<li><code>hexo init [folder]</code> ：创建一个存放网站源码的文件夹。</li>
<li><code>hexo new [layout] &lt;title&gt;</code>：新建一篇文章。<br>
<code>layout</code>：默认 <code>post</code>，可以是 <code>page</code>、<code>draft</code>。<br>
<code>title</code>：文章标题，标题包含空格的话，请使用引号括起来。</li>
<li><code>hexo clean</code>：清除缓存文件 <em>db.json</em> 和已生成的静态文件 <em>public</em>,尤其是更换主题后</li>
<li><code>hexo g</code>：生成静态 html 文件</li>
<li><code>hexo s</code>：启动服务器</li>
<li><code>hexo d</code>：部署网站</li>
</ul>
<h2 id="下载主题源码"><a class="header-anchor" href="#下载主题源码">¶</a>下载主题源码</h2>
<p>在 <code>hexo init [folder]</code> 的 <em>folder</em> 目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zhwangart/hexo-theme-ocean.git themes/ocean</span><br></pre></td></tr></table></figure>
<h2 id="参照主题文档进行配置"><a class="header-anchor" href="#参照主题文档进行配置">¶</a>参照主题文档进行配置</h2>
<ul>
<li><a href="https://zhwangart.github.io/2018/11/30/Ocean/" target="_blank" rel="noopener">Ocean 中文文档</a></li>
<li><a href="https://zhwangart.github.io/2019/07/02/Ocean-Issues/" target="_blank" rel="noopener">关于 Ocean 使用中的问题</a></li>
</ul>
<h2 id="个性化主题配置"><a class="header-anchor" href="#个性化主题配置">¶</a>个性化主题配置</h2>
<h3 id="文章自动添加-Read-More"><a class="header-anchor" href="#文章自动添加-Read-More">¶</a>文章自动添加 Read More</h3>
<p>将 _\themes\ocean\layout\<em>partial\article.ejs</em> 文中的 <code>&lt;% if (post.excerpt &amp;&amp; index){ %&gt; </code>的 else 部分替换为如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% var br &#x3D; post.content.indexOf(&#39;&lt;br&gt;&#39;) %&gt;</span><br><span class="line">&lt;% if(br &lt; 0 || !index) &#123; %&gt;</span><br><span class="line">  &lt;%- post.more %&gt;</span><br><span class="line">&lt;% &#125; else &#123; %&gt;</span><br><span class="line">  &lt;%- post.content.substring(0, br) %&gt;&lt;br&#x2F;&gt;</span><br><span class="line">  &lt;% if (theme.excerpt_link) &#123; %&gt;</span><br><span class="line">	&lt;a class&#x3D;&quot;article-more-link&quot; href&#x3D;&quot;&lt;%- url_for(post.path) %&gt;&quot;&gt;&lt;%&#x3D; theme.excerpt_link %&gt;&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<h3 id="搜索功能不起作用或除开首页不能正常搜索"><a class="header-anchor" href="#搜索功能不起作用或除开首页不能正常搜索">¶</a>搜索功能不起作用或除开首页不能正常搜索</h3>
<p>本地检索需要安装插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>另外一个问题：插件搜索函数返回的 url 有问题 ，作者说是因为 “中文字符被URL encode了 ” 。后来我找到一个解决办法：<br>
将 <em>[folder]/node_modules/hexo-generator-searchdb/templates/xml.ejs</em> 文件中的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;url&gt;&lt;%- encodeURIComponent(config.root + post.path) %&gt;&lt;&#x2F;url&gt;</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;url&gt;&lt;%- encodeURI(config.root + post.path) %&gt;&lt;&#x2F;url&gt;</span><br></pre></td></tr></table></figure>
<h3 id="修改导航栏"><a class="header-anchor" href="#修改导航栏">¶</a>修改导航栏</h3>
<p>修改 <em>themes/ocean/source/css/_partial/navbar.styl</em> 文件</p>
<h3 id="文章添加封面图片"><a class="header-anchor" href="#文章添加封面图片">¶</a>文章添加封面图片</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Post name</span><br><span class="line">date: 2019-07-24 22:01:03</span><br><span class="line">photos: [</span><br><span class="line"><span class="code">        ["/images/相机.jpg"], // themes/ocean/source/images目录下</span></span><br><span class="line"><span class="code">        ["https://tuchong.pstatp.com/2716763/f/531173888.jpg"]</span></span><br><span class="line"> ]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>在首页只会显示第一张，详情页会按顺序显示这两张。</p>
<h3 id="为文章添加Gitalk评论"><a class="header-anchor" href="#为文章添加Gitalk评论">¶</a>为文章添加Gitalk评论</h3>
<p>参考：<a href="https://zhwangart.github.io/2018/12/06/Gitalk/" target="_blank" rel="noopener">https://zhwangart.github.io/2018/12/06/Gitalk/</a></p>
<h3 id="在右上角或者左上角实现-fork-me-on-github"><a class="header-anchor" href="#在右上角或者左上角实现-fork-me-on-github">¶</a>在右上角或者左上角实现 fork me on github</h3>
<p>选样式：</p>
<ul>
<li><a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">GitHub Corners-1</a></li>
<li><a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">GitHub Corners-2</a></li>
</ul>
<p>然后粘贴刚才复制的代码到 <em>themes/ocean/layout/index.ejs</em> 文件中，放在 <code>&lt;div id=&quot;landingpage&quot;&gt;&lt;/div&gt;</code> 的第一行，并把 <code>href</code> 改为你的 github 地址。<br>
对样式做出修改：</p>
<p><code>&lt;div id=&quot;landingpage&quot;&gt;</code> 修改为 <code>&lt;div id=&quot;landingpage&quot; style=&quot;position:relative;&quot;&gt;</code></p>
<p>复制的 <code>&lt;a&gt;</code> 标签添加如下样式：<code>style=”position:absolute;left:0;top:100;z-index=1000;”</code></p>
<h3 id="实现点击出现特效"><a class="header-anchor" href="#实现点击出现特效">¶</a>实现点击出现特效</h3>
<ul>
<li>
<p>点击桃心</p>
<p>下载：<a href="https://github.com/andus-top/andus-top.github.io/blob/master/js/love.js" target="_blank" rel="noopener">桃心Js</a><br>
然后将里面的代码 copy 一下，新建 <em>love.js</em> 文件并且将代码复制进去，然后保存。<br>
在 <em>themes/ocean/_config.yml</em> 最后一行写入：</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">lovejs:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>将 <em>love.js</em> 文件放到路径 <em>/themes/ocean/source/js/src</em> 里面，然后打开 <em>\themes\ocean\layout\_partial\after-footer.ejs</em> 文件, 在最后一行写入：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (theme.lovejs)&#123; %&gt;</span><br><span class="line">	&lt;%- js(&#39;&#x2F;js&#x2F;love.js&#39;) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>爆炸效果</p>
<p>下载：</p>
<ul>
<li><a href="https://github.com/andus-top/andus-top.github.io/blob/master/js/fireworks.js" target="_blank" rel="noopener">fireworks.js</a></li>
<li><a href="https://github.com/andus-top/andus-top.github.io/blob/master/js/anime.min.js" target="_blank" rel="noopener">anime.min.js</a></li>
</ul>
<p>步骤与上面类似保存 js 到 <em>/themes/ocean/source/js/src</em>，最后在 <em>\themes\ocean\layout\_partial\after-footer.ejs</em> 文件内容未写入：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (theme.fireworks)&#123; %&gt;</span><br><span class="line">   &lt;canvas class&#x3D;&quot;fireworks&quot; style&#x3D;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;&#x2F;canvas&gt;</span><br><span class="line">   &lt;%- js(&#39;&#x2F;js&#x2F;anime.min.js&#39;) %&gt;</span><br><span class="line">   &lt;%- js(&#39;&#x2F;js&#x2F;fireworks.js&#39;) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="头像旋转效果"><a class="header-anchor" href="#头像旋转效果">¶</a>头像旋转效果</h3>
<p>打开 <em>\themes\ocean\layout\_partial\sidebar.ejs</em>，给 <code>&lt;div class=logo&gt;</code> 下的 <code>img</code> 加上一个 <code>id</code>。然后参考：<a href="https://blog.csdn.net/u011295864/article/details/84773123" target="_blank" rel="noopener">css + js实现图片不停旋转 鼠标悬停停止旋转</a></p>
<p>然后将里面的 js 代码 copy 到一个 <em>my.js</em> 文件中（注意替换 <code>img</code> 的 <code>id</code>），保存到 <em>/themes/ocean/source/js/src</em> 目录。<br>
然后在 <em>\themes\ocean\layout\_partial\after-footer.ejs</em> 中最后一行写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%- js(&#39;&#x2F;js&#x2F;my.js&#39;) %&gt;</span><br></pre></td></tr></table></figure>
<h3 id="网站底部加上访问量"><a class="header-anchor" href="#网站底部加上访问量">¶</a>网站底部加上访问量</h3>
<p><em>\themes\ocean\layout\_partial\after-footer.ejs</em> 中默认是导入了统计脚本的(busuanzi-2.3.pure.min.js )</p>
<p>修改访问量统计的样式：<br>
将 _\themes\ocean\layout\<em>partial\post\busuanzi.ejs</em><br>
修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;powered-by&quot;&gt;</span><br><span class="line">  &lt;% if (is_home()) &#123; %&gt;</span><br><span class="line">    &lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt;访问量:&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;%&#125; %&gt;</span><br><span class="line">	&amp;emsp;&lt;i class&#x3D;&quot;fa fa-user-md&quot;&gt;&lt;&#x2F;i&gt;&lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot;&gt;访客数:&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&amp;emsp;</span><br><span class="line">  &lt;% if (is_post()) &#123; %&gt;</span><br><span class="line">    &lt;i class&#x3D;&quot;fe fe-bookmark&quot;&gt;&lt;&#x2F;i&gt;文章访问量:&lt;span id&#x3D;&quot;busuanzi_value_page_pv&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;%&#125; %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="添加网站字数，阅读时间统计"><a class="header-anchor" href="#添加网站字数，阅读时间统计">¶</a>添加网站字数，阅读时间统计</h3>
<p>在根目录下运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount –save</span><br></pre></td></tr></table></figure>
<p>在 <em>\themes\ocean\_config.yml</em> 主题配置文件中加入：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">totalcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>在 <em>\themes\ocean\layout\_partial\footer.ejs</em> 文件中，在 <code>&lt;ul class=&quot;list-inline&quot;&gt;</code> 标签后加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul class&#x3D;&quot;list-inline&quot;&gt;</span><br><span class="line">	&lt;li&gt;全站共&lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; totalcount(site) %&gt;&lt;&#x2F;span&gt;字&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
<p>在 <em>\themes\ocean\layout\_partial\article.ejs</em> 文件中，在标签中加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;emsp;&lt;i class&#x3D;&quot;fe fe-bar-chart&quot;&gt;&lt;&#x2F;i&gt; &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%- wordcount(post.content) %&gt;&lt;&#x2F;span&gt;字</span><br><span class="line">&amp;emsp;&lt;i class&#x3D;&quot;fe fe-clock&quot;&gt;&lt;&#x2F;i&gt; &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%- min2read(post.content) %&gt;&lt;&#x2F;span&gt;分钟</span><br></pre></td></tr></table></figure>
<h3 id="Ocean主题的图标"><a class="header-anchor" href="#Ocean主题的图标">¶</a>Ocean主题的图标</h3>
<p>图标在 <em>\themes\ocean\source\css\_feathericon.styl</em> 中查找<br>
官网：<a href="https://feathericons.com/" target="_blank" rel="noopener">feathericons</a></p>
<h3 id="为博客加上萌萌的宠物"><a class="header-anchor" href="#为博客加上萌萌的宠物">¶</a>为博客加上萌萌的宠物</h3>
<p>在网站根目录下执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -save hexo-helper-live2d</span><br><span class="line">npm install live2d-widget-model-haruto(自己选择的萌宠模型)</span><br></pre></td></tr></table></figure>
<p>在 hexo 的配置文件中添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 萌宠</span></span><br><span class="line"> <span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-haruto</span></span><br><span class="line">    <span class="attr">scale:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">hHeadPos:</span> <span class="number">0.5</span></span><br><span class="line">    <span class="attr">vHeadPos:</span> <span class="number">0.618</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">superSample:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">    <span class="attr">hOffset:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">vOffset:</span> <span class="number">-20</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">opacityDefault:</span> <span class="number">0.5</span></span><br><span class="line">    <span class="attr">opacityOnHover:</span> <span class="number">0.2</span></span><br></pre></td></tr></table></figure>
<p>重启服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>
<h3 id="添加网站运行时间"><a class="header-anchor" href="#添加网站运行时间">¶</a>添加网站运行时间</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"timeDate"</span>&gt;</span>载入天数...<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"times"</span>&gt;</span>载入时分秒...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">createtime</span><span class="params">()</span> </span>&#123; </span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> grt= <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"04/26/2019 15:49:00"</span>);<span class="comment">//此处修改你的建站时间或者网站上线时间 </span></span></span><br><span class="line">        now.setTime(now.getTime()+250); </span><br><span class="line"><span class="javascript">        days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = <span class="built_in">Math</span>.floor(days); </span></span><br><span class="line"><span class="javascript">        hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = <span class="built_in">Math</span>.floor(hours); </span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="built_in">String</span>(hnum).length ==<span class="number">1</span> )&#123;hnum = <span class="string">"0"</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum); </span></span><br><span class="line"><span class="javascript">        mnum = <span class="built_in">Math</span>.floor(minutes); <span class="keyword">if</span>(<span class="built_in">String</span>(mnum).length ==<span class="number">1</span> )&#123;mnum = <span class="string">"0"</span> + mnum;&#125; </span></span><br><span class="line">        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); </span><br><span class="line"><span class="javascript">        snum = <span class="built_in">Math</span>.round(seconds); <span class="keyword">if</span>(<span class="built_in">String</span>(snum).length ==<span class="number">1</span> )&#123;snum = <span class="string">"0"</span> + snum;&#125; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"timeDate"</span>).innerHTML = <span class="string">"本站已安全运行 "</span>+dnum+<span class="string">" 天 "</span>; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"times"</span>).innerHTML = hnum + <span class="string">" 小时 "</span> + mnum + <span class="string">" 分 "</span> + snum + <span class="string">" 秒"</span>; </span></span><br><span class="line">    &#125; </span><br><span class="line"><span class="actionscript">	setInterval(<span class="string">"createtime()"</span>,<span class="number">250</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将以上代码保存到 <em>\themes\ocean\layout\_partial\post\runtime.ejs</em></p>
<p>在 <em>\themes\ocean\layout\_partial\footer.ejs</em> 文件中，第一个 <code>&lt;ul class=&quot;list-inline&quot;&gt;&lt;/ul&gt;</code> 标签后加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;float-right&quot;&gt;</span><br><span class="line">      &lt;%- partial(&#39;post&#x2F;runtime&#39;) %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="添加DaoVoice-在线联系"><a class="header-anchor" href="#添加DaoVoice-在线联系">¶</a>添加DaoVoice 在线联系</h3>
<p>首先在 <a href="https://account.daocloud.io/signin" target="_blank" rel="noopener">https://account.daocloud.io/signin</a>  注册账号<br>
然后点击下方链接<br>
<a href="http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f" target="_blank" rel="noopener">http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f</a><br>
之后会得到一个app_id</p>
<p>在主题配置文件写入：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Online contact </span></span><br><span class="line"><span class="attr">daovoice:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">daovoice_app_id:</span> <span class="string">这里填你的刚才获得的</span> <span class="string">app_id</span></span><br></pre></td></tr></table></figure>
<p>在 <em>\themes\ocean\layout\_partial\head.ejs</em> 的未尾中写入（<strong>注：原文是“在 <em>\themes\ocean\layout\_partial\footer.ejs</em> 中，<code>&lt;/head&gt;</code> 前写入”，但实际并未在 <em>footer.ejs</em> 中找到 <code>&lt;/head&gt;</code>，所以改为在 <em>head.ejs</em> 未尾写入达到了同样效果。</strong>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (theme.daovoice)&#123; %&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]&#x3D;r;i[r]&#x3D;i[r]||function()&#123;(i[r].q&#x3D;i[r].q||[]).push(arguments)&#125;,i[r].l&#x3D;1*new Date();a&#x3D;s.createElement(o),m&#x3D;s.getElementsByTagName(o)[0];a.async&#x3D;1;a.src&#x3D;g;a.charset&#x3D;&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&#39;https:&#39; &#x3D;&#x3D; document.location.protocol ? &#39;https:&#39; : &#39;http:&#39;) + &quot;&#x2F;&#x2F;widget.daovoice.io&#x2F;widget&#x2F;0f81ff2f.js&quot;,&quot;daovoice&quot;)</span><br><span class="line">  daovoice(&#39;init&#39;, &#123;</span><br><span class="line">      app_id: &quot;&lt;%- theme.daovoice_app_id %&gt;&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">  daovoice(&#39;update&#39;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<h3 id="取消文章下面的分享连接，添加本文结束"><a class="header-anchor" href="#取消文章下面的分享连接，添加本文结束">¶</a>取消文章下面的分享连接，添加本文结束</h3>
<p>去掉 <em>\themes\ocean\layout\_partial\article.ejs</em> 中的以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a data-url&#x3D;&quot;&lt;%- post.permalink %&gt;&quot; data-id&#x3D;&quot;&lt;%&#x3D; post._id %&gt;&quot; class&#x3D;&quot;article-share-link&quot;&gt;&lt;%- theme.share_text %&gt;&lt;&#x2F;a&gt;</span><br><span class="line">同时还可以添加本文结束 感谢阅读等说明:</span><br><span class="line">如在&lt;%- partial(‘post&#x2F;tag’) %&gt;下面一行添加：</span><br><span class="line"></span><br><span class="line">&lt;% if (!index &amp;&amp; is_post()) &#123; %&gt;</span><br><span class="line">	&lt;div style&#x3D;&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;------------- 本文结束&amp;nbsp;&lt;i class&#x3D;&quot;fe fe-smile&quot;&gt;&lt;&#x2F;i&gt;&amp;nbsp;感谢您的阅读 -------------&lt;&#x2F;div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<h3 id="博文压缩"><a class="header-anchor" href="#博文压缩">¶</a>博文压缩</h3>
<p>在根目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install gulp -g</span><br><span class="line">npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp –save</span><br></pre></td></tr></table></figure>
<p>在根目录下新建 <em>gulpfile.js</em>，写入以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="comment">//Plugins模块获取</span></span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="comment">//压缩css</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>,</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>).pipe(minifycss()).pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//压缩html</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>,</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>).pipe(htmlclean()).pipe(htmlmin(&#123;</span><br><span class="line">        removeComments: <span class="literal">true</span>,</span><br><span class="line">        minifyJS: <span class="literal">true</span>,</span><br><span class="line">        minifyCSS: <span class="literal">true</span>,</span><br><span class="line">        minifyURLs: <span class="literal">true</span>,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//压缩js 不压缩min.js</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>,</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src([<span class="string">'./public/**/*.js'</span>, <span class="string">'!./public/**/*.min.js'</span>]).pipe(uglify()).pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.0以前的写法 </span></span><br><span class="line"><span class="comment">//gulp.task('default', [</span></span><br><span class="line"><span class="comment">//  'minify-html', 'minify-css', 'minify-js'</span></span><br><span class="line"><span class="comment">//]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.0以后的写法</span></span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line"><span class="comment">//gulp.task('default', gulp.parallel('minify-html', 'minify-css', 'minify-js',</span></span><br><span class="line"><span class="comment">//function() &#123;</span></span><br><span class="line">    <span class="comment">// Do something after a, b, and c are finished.</span></span><br><span class="line"><span class="comment">//	console.log('success')</span></span><br><span class="line"><span class="comment">//&#125;));</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>,gulp.series(gulp.parallel(<span class="string">'minify-html'</span>,<span class="string">'minify-css'</span>,<span class="string">'minify-js'</span>)));</span><br></pre></td></tr></table></figure>
<p>生成博文时执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>就会根据 <em>gulpfile.js</em> 中的配置，对 <em>public</em> 目录中的静态资源文件进行压缩。</p>
<h3 id="修改文章封面图片的引入方式，同时支持相对地址与-http-的图片"><a class="header-anchor" href="#修改文章封面图片的引入方式，同时支持相对地址与-http-的图片">¶</a>修改文章封面图片的引入方式，同时支持相对地址与 http 的图片</h3>
<p>将 <em>\themes\ocean\layout\_partial\post\gallery.ejs</em> 中的 <code>&lt;% if (index){ %&gt;</code> 的上一行写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% var idx &#x3D; url_for(photo).indexOf(&#39;http&#39;) %&gt;</span><br></pre></td></tr></table></figure>
<p>将文中两处的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;&lt;%- url_for(photo) %&gt;&quot; itemprop&#x3D;&quot;image&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if(idx &lt; 0) &#123; %&gt;</span><br><span class="line">	&lt;img src&#x3D;&quot;&lt;%- url_for(post.path)+url_for(photo).substring(1) %&gt;&quot; itemprop&#x3D;&quot;image&quot;&gt;</span><br><span class="line">&lt;% &#125; else &#123; %&gt;</span><br><span class="line">	&lt;img src&#x3D;&quot;&lt;%- url_for(photo) %&gt;&quot; itemprop&#x3D;&quot;image&quot;&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<h3 id="设置封面图片不在内容详情页展示"><a class="header-anchor" href="#设置封面图片不在内容详情页展示">¶</a>设置封面图片不在内容详情页展示</h3>
<p>将 <em>\themes\ocean\layout\_partial\article.ejs</em> 中的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%- partial(&#39;post&#x2F;gallery&#39;) %&gt;</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (index)&#123; %&gt;</span><br><span class="line">	&lt;%- partial(&#39;post&#x2F;gallery&#39;) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<h3 id="去掉-rss-订阅"><a class="header-anchor" href="#去掉-rss-订阅">¶</a>去掉 rss 订阅</h3>
<p>根目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-feed –save</span><br></pre></td></tr></table></figure>
<p>将 <em>\themes\ocean\_config.yml</em> 文件中修改为：<code>rss: false</code></p>
<h3 id="导航栏图表改为在文字左侧"><a class="header-anchor" href="#导航栏图表改为在文字左侧">¶</a>导航栏图表改为在文字左侧</h3>
<p>修改 <em>\themes\ocean\source\css\_partial\navbar.styl</em></p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line">&amp;.nav-main</span><br><span class="line">      .nav-item-link</span><br><span class="line">        &amp;::before, <span class="selector-tag">i</span>.fe</span><br><span class="line">          <span class="attribute">display</span> block</span><br><span class="line">          <span class="attribute">line-height</span> <span class="number">1</span></span><br><span class="line">        &amp;::before</span><br><span class="line">          <span class="attribute">font-family</span> <span class="string">'feathericon'</span></span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line">&amp;.nav-main</span><br><span class="line">      .nav-item-link</span><br><span class="line">        &amp;::before, <span class="selector-tag">i</span>.fe</span><br><span class="line">          <span class="comment">// display block</span></span><br><span class="line">          <span class="attribute">line-height</span> <span class="number">1</span></span><br><span class="line">		   <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">        &amp;::before</span><br><span class="line">          <span class="attribute">font-family</span> <span class="string">'feathericon'</span></span><br></pre></td></tr></table></figure>
<h3 id="添加-readme-md-不被渲染"><a class="header-anchor" href="#添加-readme-md-不被渲染">¶</a>添加 <em><a href="http://readme.md" target="_blank" rel="noopener">readme.md</a></em> 不被渲染</h3>
<p>在 Hexo 目录下的 <em>source</em> 根目录下添加一个 <em><a href="http://README.md" target="_blank" rel="noopener">README.md</a></em> 。修改 Hexo 目录下的 <em>config.yml</em> 。将 <code>skip_render</code> 参数的值设置为： <code>skip_render: README.md</code>。保存退出即可。</p>
<h3 id="首页视屏换成图片"><a class="header-anchor" href="#首页视屏换成图片">¶</a>首页视屏换成图片</h3>
<p>将 <em>\themes\ocean\layout\_partial\ocean.ejs</em> 中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;video playsinline&#x3D;&quot;&quot; autoplay&#x3D;&quot;&quot; loop&#x3D;&quot;&quot; muted&#x3D;&quot;&quot; data-autoplay&#x3D;&quot;&quot;</span><br><span class="line">   poster&#x3D;&quot;&lt;%- theme.ocean.path %&gt;ocean.png&quot; x5-video-player-type&#x3D;&quot;h5&quot;&gt;</span><br><span class="line">  &lt;source src&#x3D;&quot;&lt;%- theme.ocean.path %&gt;ocean.mp4&quot; type&#x3D;&quot;video&#x2F;mp4&quot;&gt;</span><br><span class="line">  &lt;source src&#x3D;&quot;&lt;%- theme.ocean.path %&gt;ocean.ogv&quot; type&#x3D;&quot;video&#x2F;ogg&quot;&gt;</span><br><span class="line">  &lt;source src&#x3D;&quot;&lt;%- theme.ocean.path %&gt;ocean.webm&quot; type&#x3D;&quot;video&#x2F;webm&quot;&gt;</span><br><span class="line">  &lt;p&gt;Your user agent does not support the HTML5 Video element.&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;video&gt;</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;&lt;%- theme.ocean.path %&gt;ocean.png&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="去掉首页视频或图片"><a class="header-anchor" href="#去掉首页视频或图片">¶</a>去掉首页视频或图片</h3>
<p>去掉 <em>themes/ocean/layout/index.ejs</em> 中的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%- partial(&#39;_partial&#x2F;ocean&#39;) %&gt;</span><br></pre></td></tr></table></figure>
<h3 id="is-home-、is-post-函数判断不正确"><a class="header-anchor" href="#is-home-、is-post-函数判断不正确">¶</a><code>is_home()</code>、<code>is_post()</code> 函数判断不正确</h3>
<p>将 <em>\themes\ocean\layout\layout.ejs</em> 中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%- partial(&#39;_partial&#x2F;footer&#39;, null, &#123;cache: !config.relative_link&#125;) %&gt;</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%- partial(&#39;_partial&#x2F;footer&#39;, null, &#123;cache: config.relative_link&#125;) %&gt;</span><br></pre></td></tr></table></figure>
<p>就是将 <code>partial</code> 中的 <code>cache</code> 设置为 <code>false</code>。参考：<a href="https://github.com/zhwangart/hexo-theme-ocean/issues/18" target="_blank" rel="noopener"><code>is_home()</code>、<code>is_post()</code> 函数判断不正确</a>。</p>
<h3 id="视频-or-图片只在pc端显示，不在移动端显示"><a class="header-anchor" href="#视频-or-图片只在pc端显示，不在移动端显示">¶</a>视频 or 图片只在pc端显示，不在移动端显示</h3>
<p>修改 <em>themes\ocean\source\css\_partial\layou.styl</em> 文件</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Media Query</span></span><br><span class="line">@media (<span class="attribute">min-width</span>: <span class="number">768px</span>)</span><br><span class="line">  .jumbotron</span><br><span class="line">    <span class="attribute">margin-bottom</span> <span class="number">6rem</span></span><br><span class="line">    <span class="attribute">display</span> block   //此处为新增。设备宽度大于等于<span class="number">768</span>像素时显示视频or图片</span><br></pre></td></tr></table></figure>
<p>在文件末尾新增</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line">@media (<span class="attribute">max-width</span>: <span class="number">768px</span>)</span><br><span class="line">  .jumbotron</span><br><span class="line">    <span class="attribute">display</span> none  // 设备宽度小于等于<span class="number">768</span>像素时不显示视频or图片</span><br></pre></td></tr></table></figure>
<p>此时会发现移动端左上角有点空旷，则进行如下修改：</p>
<ul>
<li>
<p>修改 <em>themes\ocean\layout_partial\archive.ejs</em> 文件’</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var title &#x3D; &#39;&#39;;</span><br><span class="line">var mobile_title &#x3D; &quot;松林羊 Blog&quot;;  &#x2F;&#x2F; 此处为新增</span><br><span class="line">...</span><br><span class="line">&lt;h1 class&#x3D;&quot;page-type-title pc&quot;&gt;&lt;%- title %&gt;&lt;&#x2F;h1&gt; &#x2F;&#x2F; 新增类名为pc的样式</span><br><span class="line">&lt;h1 class&#x3D;&quot;page-type-title mobile&quot;&gt;&lt;%- mobile_title %&gt;&lt;&#x2F;h1&gt; &#x2F;&#x2F; 此处为新增</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改 <em>themes\ocean\source\css_partial\archive.styl</em> 文件</p>
  <figure class="highlight styl"><table><tr><td class="code"><pre><span class="line">.page-type-title</span><br><span class="line">  <span class="attribute">margin</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">padding</span> <span class="number">3rem</span> <span class="number">0</span></span><br><span class="line"> <span class="comment">// 以下内容为新增</span></span><br><span class="line">  &amp;.pc</span><br><span class="line">	@media screen and (<span class="attribute">max-width</span>: <span class="number">768px</span>)</span><br><span class="line">	  <span class="attribute">display</span> none</span><br><span class="line">	@media screen and (<span class="attribute">min-width</span>: <span class="number">768px</span>)</span><br><span class="line">	  <span class="attribute">display</span> block</span><br><span class="line">  &amp;.mobile</span><br><span class="line">	@media screen and (<span class="attribute">max-width</span>: <span class="number">768px</span>)</span><br><span class="line">	  <span class="attribute">display</span> block</span><br><span class="line">	  <span class="attribute">font-family</span> <span class="string">'STXingkai'</span></span><br><span class="line">	@media screen and (<span class="attribute">min-width</span>: <span class="number">768px</span>)</span><br><span class="line">	  <span class="attribute">display</span> none</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="配置-fancybox-展示文章图集"><a class="header-anchor" href="#配置-fancybox-展示文章图集">¶</a>配置 fancybox 展示文章图集</h3>
<p>在 <em>themes\ocean\layout\_partial\after-footer.ejs</em> 文件末尾加入如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (is_post())&#123; %&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; 使用fancybox来显示post图片集(#andus-head-img为头像id)</span><br><span class="line">$(&#39;img:not(#andus-head-img)&#39;).each(function() &#123;</span><br><span class="line">  $(this).wrap(&#39;&lt;a class&#x3D;&quot;fancybox&quot; data-fancybox&#x3D;&quot;gallery&quot; href&#x3D;&quot;&#39; + $(this).prop(&quot;src&quot;) + &#39;&quot;&gt;&lt;&#x2F;a&gt;&#39;); </span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<h3 id="更换评论系统，由gitalk跟换为valine-并增加邮件通知功能"><a class="header-anchor" href="#更换评论系统，由gitalk跟换为valine-并增加邮件通知功能">¶</a>更换评论系统，由gitalk跟换为valine, 并增加邮件通知功能</h3>
<p>依次参考</p>
<ul>
<li><a href="https://ioliu.cn/2017/add-valine-comments-to-your-blog/" target="_blank" rel="noopener">Valine–一款极简的评论系统</a></li>
<li><a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a></li>
<li><a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a></li>
</ul>
<p>在 <em>themes/ocean/_config.yml</em> 文件中新增以下内容，同时确保 <code>gitalk.enable</code> 为 <code>false</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine 不能与gitalk同时开启</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">app_id:</span>  <span class="comment"># 这里填写得到的APP ID</span></span><br><span class="line">  <span class="attr">app_key:</span>  <span class="comment"># 这里填写得到的APP KEY</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">记得留下你的昵称和邮箱...可以快速收到回复ヾﾉ≧∀≦)o</span> <span class="comment"># [v1.0.7 new]留言框占位提示文字</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">true</span> <span class="comment"># 评论回复邮件提醒 。 第三方支持：https://github.com/zhaojun1998/Valine-Admin</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># 验证码 。 开启邮件提醒会默认开启验证码选项</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">monsterid</span> <span class="comment"># Gravatar头像。可选项：[identicon monsterid  wavatar retro robohash mp ''] ，见 https://valine.js.org/avatar.html</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">true</span> <span class="comment"># 是否记录评论者ip</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span>  <span class="comment"># 阅读量统计 https://valine.js.org/visitor.html</span></span><br></pre></td></tr></table></figure>
<p>拷贝 <em>themes\ocean\layout\_partial\post\gitalk.ejs</em> 重命名为 <em>valine.ejs</em>。<br>
全部内容修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (theme.valine.enable) &#123; %&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;comment_headling&quot;  style&#x3D;&quot;margin-top:5rem;&quot;&gt;</span><br><span class="line">	&lt;font size&#x3D;&quot;5&quot;&gt;&lt;i class&#x3D;&quot;fe fe-comments&quot;&gt;&lt;&#x2F;i&gt; 评论&lt;&#x2F;font&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;comment&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;%- js(&#39;https:&#x2F;&#x2F;cdn1.lncld.net&#x2F;static&#x2F;js&#x2F;3.0.4&#x2F;av-min.js&#39;) %&gt;</span><br><span class="line">  &lt;%- js(&#39;js&#x2F;Valine.min.js&#39;) %&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  &#x2F;&#x2F; https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;valine&#x2F;1.3.10&#x2F;Valine.min.js</span><br><span class="line">  GUEST_INFO &#x3D; [&quot;nick&quot;, &quot;mail&quot;, &quot;link&quot;],</span><br><span class="line">  guest_info &#x3D; &quot;nick,mail,link&quot;.split(&quot;,&quot;).filter(function(i) &#123;</span><br><span class="line">		return - 1 &lt; GUEST_INFO.indexOf(i)</span><br><span class="line">  &#125;);</span><br><span class="line">  guest_info &#x3D; 0 &#x3D;&#x3D; guest_info.length ? GUEST_INFO: guest_info,</span><br><span class="line">  new Valine(&#123;</span><br><span class="line">	 &#x2F;&#x2F; AV 对象来自上面引入av-min.js</span><br><span class="line">	 av: AV, </span><br><span class="line">	 el: &#39;.comment&#39;,</span><br><span class="line">	 app_id: &#39;&lt;%- theme.valine.app_id %&gt;&#39;, </span><br><span class="line">	 app_key: &#39;&lt;%- theme.valine.app_key %&gt;&#39;, </span><br><span class="line">	 placeholder: &#39;&lt;%- theme.valine.placeholder %&gt;&#39;,</span><br><span class="line">	 meta: guest_info,</span><br><span class="line">	 notify: &lt;%- theme.valine.notify %&gt;,</span><br><span class="line">	 verify: &lt;%- theme.valine.verify %&gt;,</span><br><span class="line">	 avatar: &#39;&lt;%- theme.valine.avatar %&gt;&#39;,</span><br><span class="line">	 recordIP: &lt;%- theme.valine.recordIP %&gt;,</span><br><span class="line">	 visitor: &lt;%- theme.valine.visitor %&gt;,</span><br><span class="line">	 lang: &#39;zh-cn&#39;</span><br><span class="line">  &#125;);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>修改 <em>themes\ocean\layout\_partial\article.ejs</em> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (is_post()) &#123; %&gt;</span><br><span class="line">	&lt;%- partial(&#39;post&#x2F;gitalk&#39;) %&gt;</span><br><span class="line">	&lt;%# 下面为新增内容 %&gt;</span><br><span class="line">	&lt;%- partial(&#39;post&#x2F;valine&#39;) %&gt;</span><br><span class="line">&lt;%&#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>关闭评论时的验证码，将 <em>Valine.min.js</em> 保存到  <em>themes\ocean\source\js</em> 目录下，将其中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">u.attr(Q, <span class="string">"style"</span>, <span class="string">"display:block;"</span>), t &amp;&amp; t.type) &#123;</span><br><span class="line">	<span class="keyword">var</span> o = u.find(Q, <span class="string">".vsure"</span>);</span><br><span class="line">	u.on(<span class="string">"click"</span>, o,</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">		e.alert.hide(),</span><br><span class="line">		t.cb &amp;&amp; t.cb()</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">u.attr(Q, <span class="string">"style"</span>, <span class="string">"display:none;"</span>), t &amp;&amp; t.type) &#123;</span><br><span class="line">	e.alert.hide(),</span><br><span class="line">	t.cb &amp;&amp; t.cb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记录(自用)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%- page.content.substring(0,tips) %&gt; 显示html的样式结果</span><br><span class="line">&lt;%&#x3D; page.content.substring(0,tips) %&gt; 显示html源代码</span><br></pre></td></tr></table></figure>
<h2 id="笔记"><a class="header-anchor" href="#笔记">¶</a>笔记</h2>
<ul>
<li>
<p><em>hexo根目录\source</em> 对应发布后 <em>public</em> 目录，故 <em>source\images</em> 对应 <em>public\images</em> 。</p>
</li>
<li>
<p>在 Hexo 配置文件 <em>_config.yaml</em> 中设置 <code>language</code> 为 <code>zh-CN</code> 可设置为中文（前题是主题支持）。</p>
</li>
<li>
<p>实现侧边栏进入文章时半透明：</p>
<ol>
<li>
<p>在 <em>themes\ocean\source\css\_partial\layou.styl</em> 中添加：</p>
 <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">.sidebar-spector</span><br><span class="line">  <span class="attribute">opacity</span> <span class="number">0.2</span></span><br><span class="line">  &amp;:hover</span><br><span class="line">    <span class="attribute">opacity</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 <em>\themes\ocean\source\js</em> 下建立 <em>fade-sidebar.js</em> 文件，内容为：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">document</span>.querySelector(<span class="string">'main.content &gt; section.jumbotron'</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> my_sidebar = <span class="built_in">document</span>.querySelector(<span class="string">'aside.sidebar'</span>);</span><br><span class="line">        <span class="keyword">if</span>(my_sidebar) &#123;</span><br><span class="line">            <span class="keyword">const</span> my_content = <span class="built_in">document</span>.querySelector(<span class="string">'main.content'</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 收窄侧边栏</span></span><br><span class="line">            my_content.style.marginRight = <span class="string">'6rem'</span>;</span><br><span class="line">            my_sidebar.style.width = <span class="string">'6rem'</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">const</span> sidebar_class = my_sidebar.getAttribute(<span class="string">'class'</span>);</span><br><span class="line">            <span class="keyword">if</span>(sidebar_class.indexOf(<span class="string">'sidebar-spector'</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                my_sidebar.setAttribute(<span class="string">'class'</span>, sidebar_class + <span class="string">' sidebar-spector'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 <em>themes\ocean\layout\_partial\after-footer.ejs</em> 未尾添加：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%- js(&#39;js&#x2F;fade-sidebar.js&#39;) %&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>如果不需要去掉 Valine 的验证码，可将 <em>\themes\ocean\layout\_partial\post\valine.ejs</em> 中的 <code>&lt;%- js('js/Valine.min.js') %&gt;</code> 改为 CDN 地址，如： <code>&lt;%- js('https://unpkg.com/valine@1.03.10/dist/Valine.min.js') %&gt;</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer （第五版）》学习笔记 -- 之一</title>
    <url>/2020/02/18/C++-Primer-%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1>C++ Primer 第五版学习笔记（一）</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="第一章-开始"><a class="header-anchor" href="#第一章-开始">¶</a>第一章 开始</h2>
<p>在本章中，我们将编写一个程序来解决简单的书店问题。<br>
我们的书店保存所有销售记录的档案，每条记录保存了某本书的一次销售的信息（一册或多册）。每条记录包含三个数据项：</p>
<ul>
<li>书的 ISBN 号（唯一标识）。如： 0-201-70353-X</li>
<li>售出册数。如：4</li>
<li>单价。如： 24.99</li>
</ul>
<h3 id="1-1-缩写一个简单的-C-程序"><a class="header-anchor" href="#1-1-缩写一个简单的-C-程序">¶</a>1.1 缩写一个简单的 C++ 程序</h3>
<p>每个 C++ 程序都包含一个或多个函数，其中一个必须命名为 <code>main</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在大多数系统中，<code>main</code> 的返回值被用来指示状态。返回 <code>0</code> 表明成功，<strong>非 <code>0</code> 的返回值的含义由系统定义</strong>，通常用来指出错误类型。</p>
<h4 id="1-1-1-编译、运行程序"><a class="header-anchor" href="#1-1-1-编译、运行程序">¶</a>1.1.1 编译、运行程序</h4>
<h5 id="程序源文件命名约定"><a class="header-anchor" href="#程序源文件命名约定">¶</a>程序源文件命名约定</h5>
<p>略，见 P3。</p>
<h5 id="从命令行运行编译器"><a class="header-anchor" href="#从命令行运行编译器">¶</a>从命令行运行编译器</h5>
<ul>
<li>
<p>GNU 编译器的命令是：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$g</span>++ -o prog1 prog1.cc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据使用的 GNU 编译器版本，你可能需要指定 <code>-std=c++0x</code> 参数来打开对 C++11 的支持。</p>
</blockquote>
</li>
<li>
<p>Visual Studio 2010 编译器命令为 cl：</p>
  <figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">me</span>\<span class="title">Programs</span>&gt; <span class="title">cl</span> /<span class="title">EHsc</span> <span class="title">prog1.cpp</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>/EHsc</code> 选项用来打开标准异常处理。</p>
</blockquote>
</li>
<li>
<p>编译器通常包含一些选项，能对有问题的程序结构发出警告。我们习惯在 GNU 编译器中使用 <code>-Wall</code> 选项，在微软编译器中则使用 <code>/W</code> 打开警告。</p>
</li>
</ul>
<h4 id="1-1-节习题"><a class="header-anchor" href="#1-1-节习题">¶</a>1.1 节习题</h4>
<ul>
<li>
<p>练习 1.1：查阅你使用的编译器的文档，确定它所使用的文件命名约定。编译并运行第 2 页的 <code>main</code> 程序。</p>
<p>解：</p>
<p><img src="images/C++Primer/practice1.1.PNG" alt="习题1.1.1"></p>
</li>
<li>
<p>练习 1.2：改写程序，让它返回 <code>-1</code>。返回 <code>-1</code> 通常被当作程序错误的标识。重新编译并运行你的程序，观察你的系统如何处理 main 返回的错误标识。</p>
<p>解：</p>
<p><img src="images/C++Primer/practice1.1.PNG" alt="习题1.1.1"></p>
</li>
</ul>
<h3 id="1-2-初识输入输出"><a class="header-anchor" href="#1-2-初识输入输出">¶</a>1.2 初识输入输出</h3>
<p><code>iostream</code> 库包含两个基础类型 <code>istream</code> 和 <code>ostream</code>，分别表示 <strong>输入流</strong> 和 <strong>输出流</strong> 。一个 <strong>流</strong> 就是一个字符序列，是从 IO 设备读出或输入 IO 设备的。</p>
<blockquote>
<p>术语“流”(stream)想要表达的是，随着时间的失衡，字符是顺序生成或消耗的。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：<code>iostream</code> 是 <strong>库</strong>，<code>istream</code> 和 <code>ostream</code> 是 <code>iostream</code> 库中的对象。若 <strong>仅</strong>  <code>#include &lt;istream&gt;</code> 或 <code>#include &lt;ostream&gt;</code> 将不会报错，但对于命名空间 <code>std</code> 的引用将会出现类似 <code>“cout”: 不是“std”的成员</code> 的错误。</p>
</blockquote>
<h4 id="标准输入输出对象"><a class="header-anchor" href="#标准输入输出对象">¶</a>标准输入输出对象</h4>
<p>标准库定义了 4 个 IO 对象：</p>
<ol>
<li><code>cin</code>： 为了处理输入，我们使用一个名为 <code>cin</code> (发音为 see-in)的 <code>istream</code> 类型的对象。这个对象也被称为 <strong>标准输入</strong> (standard input)。</li>
<li><code>cout</code>：对于输出，我们使用一个名为 <code>cout</code> (发音为 see-out)的 <code>ostream</code> 类型对象。此对象也被称为 <strong>标准输出</strong> (standard output)。</li>
<li><code>cerr</code>：我们通常用 <code>ostream</code> 对象 <code>cerr</code> (发音为 see-err) 来输出警告和错误消息，因此它也被称为 <strong>标准错误</strong> (standard error)。</li>
<li><code>clog</code>：<code>ostream</code> 对象 <code>clog</code> (发音为 see-log) 用来输出程序运行时一般性信息。</li>
</ol>
<p>系统通常将程序所运行的窗口与这些对象关联起来。因此当我们读取 <code>cin</code>，数据将从程序正在运行的窗口读入，当我们向 <code>cout</code>、<code>cerr</code> 和 <code>clog</code> 写入数据时，将会写到同一个窗口。</p>
<h4 id="一个使用-IO-库的程序"><a class="header-anchor" href="#一个使用-IO-库的程序">¶</a>一个使用 IO 库的程序</h4>
<p>在书店程序中，我们需要将多条记录合并成单一的汇总记录：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::out &lt;&lt; <span class="string">"Enter two numbers: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> vl = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">    <span class="built_in">std</span>::out &lt;&lt; <span class="string">"The sum of "</span> &lt;&lt; v1 &lt;&lt; <span class="string">" and "</span> &lt;&lt; v2 &lt;&lt; <span class="string">" is "</span> &lt;&lt; v1 + v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>#include</code> 指令和头文件的名字必须写在同一行中。</li>
<li>通常情况下，<code>#include</code> 指令必须出现在所有函数之外。</li>
<li>我们一般将一个程序的所有 <code>#include</code> 指令都放在源文件的开始位置。</li>
</ul>
<h4 id="向流写入数据"><a class="header-anchor" href="#向流写入数据">¶</a>向流写入数据</h4>
<ul>
<li><code>main</code> 的函数体第一条语句执行了一个表达式 (expression)。在 C++ 中，一个表达式产生一个计算结果，它由一个或多个运算对象和(通常是)一个运算符组成。</li>
<li>第一个输出运算符给用户打印一条消息。这个消息是一个 <strong>字符串字面值常量</strong> (string literal)，是用一对双引号包围的字符序列。</li>
<li>第二个运算符打印 <code>endl</code>，这是一个被称为 <strong>操纵符</strong> (manipulator) 的特殊值。写入 <code>endl</code> 的效果是结束当前行，<strong>并将与设备关联的 <em>缓冲区</em> (buffer) 中的内容刷到设备中</strong>。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：程序员常常在调度时添加打印语句。这类语句应该保证“一直”刷新流。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。</p>
</blockquote>
<h4 id="使用标准库中的名字"><a class="header-anchor" href="#使用标准库中的名字">¶</a>使用标准库中的名字</h4>
<p>前缀 <code>std::</code> 指出名字 <code>cout</code> 和 <code>endl</code> 是定义在名为 <code>std</code> 的 <strong>命名空间</strong> (namespace)中的。</p>
<p>命名空间可以：</p>
<ul>
<li>帮助我们避免不经意的名字定义冲突。</li>
<li>使用库中相同名字导致的冲突。</li>
</ul>
<blockquote>
<p>标准库定义的所有名字都在命名空间 <code>std</code> 中。</p>
</blockquote>
<h4 id="从流读取数据"><a class="header-anchor" href="#从流读取数据">¶</a>从流读取数据</h4>
<p>略，见 P7。</p>
<h4 id="完成程序"><a class="header-anchor" href="#完成程序">¶</a>完成程序</h4>
<p>略，见 P7。</p>
<h4 id="1-2-节练习"><a class="header-anchor" href="#1-2-节练习">¶</a>1.2 节练习</h4>
<ul>
<li>
<p>练习 1.3：编写程序，在标准输出上打印 Hello, World</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hellow, World"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="images/C++Primer/practice1.3.PNG" alt="习题1.1.1"></p>
</li>
<li>
<p>练习 1.4：我们的程序使用加法运算符 <code>+</code> 来将两个数相加。编写程序使用乘法运算符 <code>*</code>，来打印两个数的积。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1 = <span class="number">1</span>, v2 = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 + v2 = "</span> &lt;&lt; v1 + v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"v1 * v2 = "</span> &lt;&lt; v1 * v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="images/C++Primer/practice1.4.PNG" alt="习题1.1.1"></p>
</li>
<li>
<p>练习 1.5：我们将所有输出操作放在一条很长的语句中。重写程序，将每个运算对象的打印操作放在一条独立的语句中。</p>
<p>解：见习题 1.4。</p>
</li>
<li>
<p>练习 1.6：解释下面程序片段是否合法。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of "</span> &lt;&lt; v1;</span><br><span class="line">          &lt;&lt; <span class="string">" and "</span> &lt;&lt; v2;</span><br><span class="line">          &lt;&lt; <span class="string">" is "</span> &lt;&lt; v1 + v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>解：不合法。因为：</p>
<ul>
<li>根据 P3：<em>大多数 C++ 语句表示结束。</em> 所以片段第一行语句已结束，第二行和第三行都已是新语句。</li>
<li>又根据 P6：<em><code>&lt;&lt;</code> 运算符接受两个运算对象：左侧是运算对象必须是一个 <code>ostream</code> 对象，右侧对象是要打印的值。</em> 所以第二、三行缺少 <code>ostream</code> 对象。</li>
</ul>
<p>修正：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of "</span> &lt;&lt; v1</span><br><span class="line">          &lt;&lt; <span class="string">" and "</span> &lt;&lt; v2</span><br><span class="line">          &lt;&lt; <span class="string">" is "</span> &lt;&lt; v1 + v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>或</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of "</span> &lt;&lt; v1;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" and "</span> &lt;&lt; v2;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" is "</span> &lt;&lt; v1 + v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-3-注释简介"><a class="header-anchor" href="#1-3-注释简介">¶</a>1.3 注释简介</h3>
<h4 id="C-中注释的种类"><a class="header-anchor" href="#C-中注释的种类">¶</a>C++ 中注释的种类</h4>
<p>略，见 P8。</p>
<h4 id="注释界定符不能嵌套"><a class="header-anchor" href="#注释界定符不能嵌套">¶</a>注释界定符不能嵌套</h4>
<p>界定符对形式的注释是以 <code>/*</code> 开始，以 <code>*/</code> 结束的。因此，一个注释不能嵌套在另一个注释之内。例如，在你的系统中编译如下程序，就会产生错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注释对 /* */</span> 不能嵌套。</span><br><span class="line"> * “不能嵌套” 几个字会被认为是源码，</span><br><span class="line"> * 像剩余程序一样处理</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们通常需要在调度期间注释掉一些代码。由于这些代码可能包含界定符形式的注释，因此可能导致注释嵌套错误，因此最好的方式是用 <strong>单行注释</strong> 方式注释掉代码段的每一行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /*</span></span><br><span class="line"><span class="comment">//  * 单行注释中的任何内容都会被忽略</span></span><br><span class="line"><span class="comment">//  * 包括嵌套的注释对也一样会被忽略</span></span><br><span class="line"><span class="comment">//  */</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-节练习"><a class="header-anchor" href="#1-3-节练习">¶</a>1.3 节练习</h4>
<ul>
<li>
<p>练习 1.7：编译一个包含不正确的嵌套注释的程序，观察编译器返回的错误信息。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注释对 /* */</span> 不能嵌套。</span><br><span class="line"> * “不能嵌套” 几个字会被认为是源码，</span><br><span class="line"> * 像剩余程序一样处理</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="images/C++Primer/practice1.7.PNG" alt="习题1.1.1"></p>
</li>
<li>
<p>练习 1.8：指出下列哪些输出语句是合法的（如果有的话）：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"/*"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*/"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="comment">/* "*/</span><span class="string">" */;</span></span><br><span class="line"><span class="string">std::cout &lt;&lt; /* "</span>*/<span class="string">" /* "</span><span class="comment">/*" */</span>;</span><br></pre></td></tr></table></figure>
<p>预测编译这些语句会产生什么样的结果，实际编译这些语句来验证你的答案（编写一个小程序，每次将上述一条语句作为其主体），改正每个编译错误。</p>
<p>解：</p>
<p>预测：语句一、二和语句四编译通过，语句三编译错误。</p>
<p>验证：</p>
<ol>
<li>
<p>语句一：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"/*"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语句二：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*/"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语句三：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="comment">/* "*/</span><span class="string">" */;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用于 x86 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.24.28316 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">prog1.cc</span><br><span class="line">.\prog1.cc(4): error C2001: 常量中有换行符</span><br><span class="line">.\prog1.cc(5): error C2143: 语法错误: 缺少“;”(在“return”的前面)</span><br></pre></td></tr></table></figure>
<p>改正：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*/"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>语句四：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="comment">/* "*/</span><span class="string">" /* "</span><span class="comment">/*" */</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="1-4-控制流"><a class="header-anchor" href="#1-4-控制流">¶</a>1.4 控制流</h3>
<h4 id="1-4-1-while-语句"><a class="header-anchor" href="#1-4-1-while-语句">¶</a>1.4.1 <code>while</code> 语句</h4>
<p>略，见 P10~P11。</p>
<h5 id="1-4-1-节练习"><a class="header-anchor" href="#1-4-1-节练习">¶</a>1.4.1 节练习</h5>
<ul>
<li>
<p>练习 1.9：编写程序，使用 <code>while</code> 循环将 <code>50</code> 到 <code>100</code> 的整数相加。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">49</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(v &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        sum += (++v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 50 ~ 100 is "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The sum of 50 ~ 100 is 3825</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 1.10：除了 <code>++</code> 运算符将运算对象增加 <code>1</code> 之外，还有一个递减运算符 (<code>--</code>) 实现将值减少 <code>1</code>。编写程序，使用递减运算符在循环中顺序打印 <code>10</code> 到 <code>0</code> 之间的整数。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">while</span>(v &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; --v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 1.11：编写程序，提示用户输入两个整数，打印出这两个整数所指定的范围内的所有整数。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v_start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> v_end = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter start number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v_start;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter end number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v_end;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="string">"The integers between "</span></span><br><span class="line">              &lt;&lt; v_start &lt;&lt; <span class="string">" and "</span> &lt;&lt; v_end &lt;&lt; <span class="string">" are: "</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(v_end &gt;= v_start) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v_start &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        ++v_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter start number: 1</span><br><span class="line"></span><br><span class="line">Please enter end number: 5</span><br><span class="line"></span><br><span class="line">The integers between 1 and 5 are: 1 2 3 4 5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-4-2-for-语句"><a class="header-anchor" href="#1-4-2-for-语句">¶</a>1.4.2 <code>for</code> 语句</h4>
<p>用 <code>for</code> 语句重写从 <code>1</code> 加到 <code>10</code> 的程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从 1 加到 10</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= <span class="number">10</span>; ++val)</span><br><span class="line">        sum += val; <span class="comment">// 等价于 sum = sum + val</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum of 1 to 10 inclusive is "</span></span><br><span class="line">              &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简要重述一下 <code>for</code> 循环的总体执行流程：</p>
<ol>
<li>创建变量 <code>val</code>，将其初始化为 <code>1</code>。</li>
<li>检测 <code>val</code> 是否小于等于 <code>10</code>。若检测成功，执行 <code>for</code> 循环体。若失败，退出循环，继续执行<code>for</code> 循环体之后的第一条语句。</li>
<li>将 <code>val</code> 的值增加 <code>1</code>。</li>
<li>重复第 2 步中的条件检测，只要条件为真就继续执行剩余步骤。</li>
</ol>
<h5 id="1-4-2-节练习"><a class="header-anchor" href="#1-4-2-节练习">¶</a>1.4.2 节练习</h5>
<ul>
<li>
<p>练习 1.12：下面的 <code>for</code> 循环完成了什么功能？<code>sum</code> 的终值是多少？</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-100</span>; i &lt;= <span class="number">100</span>; ++i)</span><br><span class="line">    sum += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>解：</p>
<p>完成了从 <code>0</code> 到 <code>201</code> 之间的整数遍历。<code>sum</code> 的终值为 <code>201</code>。</p>
</li>
<li>
<p>练习 1.13：使用 <code>for</code> 循环重做 1.4.1 节中的所有练习(第 11 页)。</p>
<p>解：</p>
<ol>
<li></li>
</ol>
<pre><code>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">50</span>; i &lt; <span class="number">101</span>; ++i) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 50 ~ 100 is "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="2">
<li></li>
</ol>
<pre><code>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">10</span>; v &gt;= <span class="number">0</span>; --v)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="3">
<li></li>
</ol>
<pre><code>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v_start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> v_end = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter start number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v_start;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter end number: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v_end;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="string">"The integers between "</span></span><br><span class="line">              &lt;&lt; v_start &lt;&lt; <span class="string">" and "</span> &lt;&lt; v_end &lt;&lt; <span class="string">" are: "</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = v_start; i &lt;= v_end; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li>
<p>练习 1.14：对比 <code>for</code> 循环 <code>while</code> 循环，两种形式的优缺点各是什么？</p>
<p>解：</p>
<p>在 <code>for</code> 循环中，循环控制变量的初始化和修改都放在语句头部分，形式较简洁，且特别适用于循环次数已知的情况。在 <code>while</code> 循环中，循环控制变量的初始化一般放在 <code>while</code> 语句之前，循环控制变量的修改一般放在循环体中，形式上不如 <code>for</code> 语句简洁，但它比较适用于循环次数不易预知的情况（用某一条件控制循环）。两种形式各有优点，但它们在功能上是等价的，可以相互转换。</p>
</li>
<li>
<p>练习 1.15：编写程序，包含第 14 页“再探编译”中讨论的常见错误。熟悉编译器生成的错误信息。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      .\prog1.cc(4): error C2143: 语法错误: 缺少“;”(在“:”的前面)</span></span><br><span class="line"><span class="comment">      .\prog1.cc(4): error C2059: 语法错误:“:”</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Read each file."</span> &lt;&lt; <span class="built_in">endl</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     .\prog1.cc(4): error C2065: “Update”: 未声明的标识符</span></span><br><span class="line"><span class="comment">     .\prog1.cc(4): error C2146: 语法错误: 缺少“;”(在标识符“master”的前面)</span></span><br><span class="line"><span class="comment">     .\prog1.cc(4): error C2065: “master”: 未声明的标识符</span></span><br><span class="line"><span class="comment">     .\prog1.cc(4): error C2059: 语法错误:“&lt;&lt;”</span></span><br><span class="line"><span class="comment">     .\prog1.cc(4): error C2228: “.endl”的左边必须有类/结构/联合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Update master. &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     .\prog1.cc(4): error C2143: 语法错误: 缺少“;”(在“std::endl”的前面)</span></span><br><span class="line"><span class="comment">     .\prog1.cc(4): error C2143: 语法错误: 缺少“;”(在“:”的前面)</span></span><br><span class="line"><span class="comment">     .\prog1.cc(4): warning C4551: 缺少参数列表的函数调用</span></span><br><span class="line"><span class="comment">     .\prog1.cc(4): error C2059: 语法错误:“:”</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Write new master."</span> <span class="built_in">std</span>::<span class="built_in">endl</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     .\prog1.cc(4): error C2440: “初始化”: 无法从“const char [6]”转换为“int”</span></span><br><span class="line"><span class="comment">     .\prog1.cc(4): note: 没有使该转换得以执行的上下文</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> v0 = <span class="string">"hello"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     .\prog1.cc(5): error C2065: “v”: 未声明的标识符</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; v &gt;&gt; v2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     .\prog1.cc(5): error C2065: “cout”: 未声明的标识符</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1 + v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-4-3-读取数量不定的输入数据"><a class="header-anchor" href="#1-4-3-读取数量不定的输入数据">¶</a>1.4.3 读取数量不定的输入数据</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)</span><br><span class="line">        sum += value; <span class="comment">// 等价于 sum = sum + value</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum is: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 5 6</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sum is: 18</span><br></pre></td></tr></table></figure>
<p><strong>当我们使用一个 <code>istream</code> 对象作为条件时，其效果是检测流的状态。如果是流是有效的，即流未遇到错误，那么检测成功。当遇到 <em>文件结束符</em>(end-of-file)，或遇到一个无效输入时 (例如读入的值不是一个整数)，<code>istream</code> 对象的状态会变为无效。处于无效状态的 <code>istream</code> 对象会使条件变为假。</strong></p>
<h5 id="1-4-3-节练习"><a class="header-anchor" href="#1-4-3-节练习">¶</a>1.4.3 节练习</h5>
<ul>
<li>
<p>练习 1.16：编写程序，从 <code>cin</code> 读取一组数，输出其和。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; sum)</span><br><span class="line">        result += sum;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-4-4-if-语句"><a class="header-anchor" href="#1-4-4-if-语句">¶</a>1.4.4 <code>if</code> 语句</h4>
<p>略，见 P15~P16。</p>
<h5 id="1-4-4-节练习"><a class="header-anchor" href="#1-4-4-节练习">¶</a>1.4.4 节练习</h5>
<ul>
<li>
<p>练习 1.17：如果输入的所有值都是相等的，本节的程序会输出什么？如果没有重复值，输出又会是怎样的？</p>
<p>解：</p>
<p>输入：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">42 42 42 42 42 42 42 42 42 42 42</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">42 occurs 11 times</span><br></pre></td></tr></table></figure>
<p>输入：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">42 43 44 45 46 47 48 49 50 51 52</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">42 occurs 1 times</span><br><span class="line">43 occurs 1 times</span><br><span class="line">44 occurs 1 times</span><br><span class="line">45 occurs 1 times</span><br><span class="line">46 occurs 1 times</span><br><span class="line">47 occurs 1 times</span><br><span class="line">48 occurs 1 times</span><br><span class="line">49 occurs 1 times</span><br><span class="line">50 occurs 1 times</span><br><span class="line">51 occurs 1 times</span><br><span class="line">52 occurs 1 times</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 1.18：编译并运行本节的程序，给它输入全都相等的值。再次运行程序，输入没有重复的值。</p>
<p>解：</p>
<p>见练习 1.17。</p>
</li>
<li>
<p>练习 1.19：修改你为 1.4.1 节练习 1.10 (第11页) 所编写的程序 (打印一个范围内的数)，使其能处理用户输入的第一个数比第二个数小的情况。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>, second = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter two numbers:"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; first &gt;&gt; second;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(first &lt; second) &#123;</span><br><span class="line">        tmp = first;</span><br><span class="line">        first = second;</span><br><span class="line">        second = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(first &gt; second) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; --v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter two numbers:10 22</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22</span><br><span class="line">21</span><br><span class="line">20</span><br><span class="line">19</span><br><span class="line">18</span><br><span class="line">17</span><br><span class="line">16</span><br><span class="line">15</span><br><span class="line">14</span><br><span class="line">13</span><br><span class="line">12</span><br><span class="line">11</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-5-类简介"><a class="header-anchor" href="#1-5-类简介">¶</a>1.5 类简介</h3>
<p>C++ 最初的一个设计焦点就是能定义使用上像内置类型一样自然的 <strong>类类型</strong> (class type)。</p>
<p>对于书店程序来说，我们假定类名为 <code>Sales_item</code>，头文件 <em>Sales_item.h</em> 中已经定义了这个类。</p>
<p><strong>为了使用标准库设施，我们必须包含相关的头文件。习惯上，头文件根据其中定义的类的名字来命名。</strong></p>
<p><strong>我们通常使用 <em>.h</em> 作为头文件的后缀，但也有一些程序员习惯 <em>.H</em> 、 <em>.hpp</em> 或 <em>.hxx</em> 。标准库头文件通常不带后缀。</strong></p>
<h4 id="1-5-1-Sales-item-类"><a class="header-anchor" href="#1-5-1-Sales-item-类">¶</a>1.5.1 <code>Sales_item</code> 类</h4>
<p>定义类类型的变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_item item;</span><br></pre></td></tr></table></figure>
<p>除了可以定义 <code>Sales_item</code> 类型的变量之外，我们还可以：</p>
<ul>
<li>调用一个名为 <code>isbn</code> 的函数从一个 <code>Sales_item</code> 对象中提取 ISBN 书号。</li>
<li>用输入运算符 (<code>&gt;&gt;</code>) 和输出运算符 (<code>&lt;&lt;</code>) 读、写 <code>Sales_item</code> 类型对象。</li>
<li>用赋值运算符 (<code>=</code>) 将一个 <code>Sales_item</code> 对旬的值赋予另一个 <code>Sales_item</code> 对象。</li>
<li>用加法运算符 (<code>+</code>) 将两个 <code>Sales_item</code> 对象相加。两个对象必须表示同一本书 (相同的 ISBN)。加法结果是一个新的 <code>Sales_item</code> 对象，基 ISBN 与两个运算对象相同，而其总销售额和售出册数则是两个运算对象的对应值之和。</li>
<li>使用复合赋值运算符 (<code>+=</code>) 将一个 <code>Sales_item</code> 对象加到另一个对象上。</li>
</ul>
<h5 id="读写-Sales-item"><a class="header-anchor" href="#读写-Sales-item">¶</a>读写 <code>Sales_item</code></h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sales_item.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sales_item book;</span><br><span class="line">    <span class="comment">// 读入 ISBN 号、售出的册数以及销售价格</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; book;</span><br><span class="line">    <span class="comment">// 写入 ISBN、售出的册数、总销售额和平均价格</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; book &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-201-70353-X 4 24.99</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-201-70353-X 4 99.96 24.99</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此程序以两个 <code>#include</code> 指令开始，其中一个使用了新的形式。包含来自标准库的头文件，也应该用尖括号 (<code>&lt;</code> <code>&gt;</code>) 包围头文件名。对于不属于标准库的头文件，则用双引号 (<code>&quot;</code> <code>&quot;</code>) 包围。</p>
</blockquote>
<h5 id="Sales-item-对象的加法"><a class="header-anchor" href="#Sales-item-对象的加法">¶</a><code>Sales_item</code> 对象的加法</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sales_item.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sales_item item1, item2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2;               <span class="comment">// 读取一对交易记录</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; item1 + item2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 打印它们的和</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-201-78345-X 3 20.00</span><br><span class="line">0-201-78345-X 2 25.00</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-201-78345-X 5 110 22</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>使用文件重定向</strong></p>
<hr>
<p>当你测试程序时，反复从键盘调入这些销售记录作为程序输入，是非常乏味的（<strong>笔记</strong>：用文件作为输入可以避免终端输入的数据和输出的数据混杂在一起引起混淆。）。这种机制允许我们将标准输入和标准输出与命名文件关联起来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ addItems &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure>
<p>假定 <code>$</code> 是操作系统提示符，我们的加法程序已经编译命名为  <em>addItems.exe</em> 的可执行文件 (在 Unix 中是 <em>addItems</em> )，则上述命令会从一个名为 <em>infile</em> 的文件读取销售记录，并将输出结果写入到一个名为 <em>output</em> 的文件中，两个文件都位于当前目录中。</p>
</blockquote>
<h5 id="1-5-1-节练习"><a class="header-anchor" href="#1-5-1-节练习">¶</a>1.5.1 节练习</h5>
<ul>
<li>
<p>练习 1.20：在网站 <a href="http://www.informit.com/title/0321714113" target="_blank" rel="noopener">http://www.informit.com/title/0321714113</a> 上，第 1 章的代码目录中包含了头文件 <em>Sales_item.h</em> 。将它拷贝到你自己的工作目录中。用它编写一个程序，读取一组书籍销售记录，将每条记录打印到标准输出上。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sales_item.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sales_item book;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; book) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; book &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-201-78345-X 3 20.00 0-201-78345-X 2 20.00 0-201-78345-X 5 20.00</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-201-78345-X 3 60 20</span><br><span class="line">0-201-78345-X 2 40 20</span><br><span class="line">0-201-78345-X 5 100 20</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 1.21：编写程序，读取两个 ISBN 相同的 <code>Sales_item</code> 对象，输出它们的和。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sales_item.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sales_item item1, item2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter two Sales_item:"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; item1 + item2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter two Sales_item:0-201-78345-X 3 20.00 0-201-78345-X 2 25.00</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-201-78345-X 5 110 22</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 1.22：编写程序，读取多个具有相同 ISBN 的销售记录，输出所有记录的和。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sales_item.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sales_item book, sum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; book)</span><br><span class="line">        sum += book;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-201-78345-X 3 20.00</span><br><span class="line">0-201-78345-X 2 20.00</span><br><span class="line">0-201-78345-X 5 20.00</span><br><span class="line">^Z</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 200 20</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-5-2-初识成员函数"><a class="header-anchor" href="#1-5-2-初识成员函数">¶</a>1.5.2 初识成员函数</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sales_item.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sales_item item1, item2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2;</span><br><span class="line">    <span class="comment">// 首先检查 item1 和 item2 是否表示相同的书</span></span><br><span class="line">    <span class="keyword">if</span>(item1.isbn() == item2.isbn()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; item1 + item2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0l</span>;                <span class="comment">// 表示成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Data must refer to same ISBN"</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// 表示失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="什么是成员函数"><a class="header-anchor" href="#什么是成员函数">¶</a>什么是成员函数</h5>
<p>当用 <code>.</code> 运算符访问一个成员函数时，通常我们是想 (效果也确实是) 调用该函数。我们使用 <strong>调用运算符</strong> (<code>(</code> <code>)</code>) 来调用一个函数。调用运算符是一对圆括号，里面放置 <strong>实参</strong> (argument) 列表 (<strong>可能为空</strong>)。</p>
<h5 id="1-5-2-节练习"><a class="header-anchor" href="#1-5-2-节练习">¶</a>1.5.2 节练习</h5>
<ul>
<li>
<p>练习 1.23：编写程序，读取多条销售记录，并统计每个 ISBN (每本书) 有几条销售记录。</p>
<p>解：</p>
<blockquote>
<p>提示：使用文件重定向。</p>
</blockquote>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sales_item.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sales_item currItem, item;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; currItem) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; item) &#123;</span><br><span class="line">            <span class="keyword">if</span>(item.isbn() == currItem.isbn())</span><br><span class="line">                currItem += item;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Sale amount of "</span> &lt;&lt; currItem.isbn() &lt;&lt; <span class="string">" is:"</span> &lt;&lt; currItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                currItem = item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Sale amount of "</span> &lt;&lt; currItem.isbn() &lt;&lt; <span class="string">" is:"</span> &lt;&lt; currItem &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-201-78345-X 4 25.0</span><br><span class="line">0-201-78345-X 1 25.0</span><br><span class="line">0-201-78345-X 2 25.0</span><br><span class="line">0-201-78345-X 9 25.0</span><br><span class="line">0-207-78345-X 9 31.0</span><br><span class="line">0-207-78345-X 3 31.0</span><br><span class="line">0-202-78345-X 3 20.0</span><br><span class="line">0-202-78345-X 3 20.0</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sale amount of 0-201-78345-X is:0-201-78345-X 16 400 25</span><br><span class="line">Sale amount of 0-207-78345-X is:0-207-78345-X 12 372 31</span><br><span class="line">Sale amount of 0-202-78345-X is:0-202-78345-X 6 120 20</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 1.24：输入表示多个 ISBN 的多条销售记录来测试上一个程序，每个 ISBN 的记录应该聚在一起。</p>
<p>解：</p>
<p>见练习 1.23。</p>
</li>
</ul>
<h3 id="1-6-书店程序"><a class="header-anchor" href="#1-6-书店程序">¶</a>1.6 书店程序</h3>
<p>我们的程序会将每个 ISBN 的所有数据合并起来，存入名为 <code>total</code> 变量中。我们使用另一个名为 <code>trans</code> 的变量保存读取的每条销售记录。如果 <code>trans</code> 和 <code>total</code> 指向相同的 ISBN，我们会更新 <code>total</code> 的值。否则，我们会打印 <code>total</code> 的值，并将其重置为刚读取的数据 (<code>tran</code>)：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sales_item.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sales_item total;  <span class="comment">// 保存下一条交易记录的变量</span></span><br><span class="line">    <span class="comment">// 读入第一条交易记录，并确保有数据可以处理</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; total) &#123;</span><br><span class="line">        Sales_item trans;  <span class="comment">// 保存和的变量</span></span><br><span class="line">        <span class="comment">// 读入并处理剩余交易记录</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; trans) &#123;</span><br><span class="line">            <span class="comment">// 如果我们仍在处理相同的书</span></span><br><span class="line">            <span class="keyword">if</span>(total.isbn() == trans.isbn())</span><br><span class="line">                total += trans;  <span class="comment">//更新总销售额</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 打印前一本书的结果</span></span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                total = trans;  <span class="comment">// total 现在表示下一本书的销售额</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有输入！警告读者</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"No data?!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-节练习"><a class="header-anchor" href="#1-6-节练习">¶</a>1.6 节练习</h4>
<ul>
<li>
<p>练习 1.25：借助网站上的 <em>Sales_item.h</em> 头文件，编译并运行本节给出的书店程序。</p>
<p>解：</p>
<p>输入：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-201-78345-X 4 25.0</span><br><span class="line">0-201-78345-X 1 25.0</span><br><span class="line">0-201-78345-X 2 25.0</span><br><span class="line">0-201-78345-X 9 25.0</span><br><span class="line">0-207-78345-X 9 31.0</span><br><span class="line">0-207-78345-X 3 31.0</span><br><span class="line">0-202-78345-X 3 20.0</span><br><span class="line">0-202-78345-X 3 20.0</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-201-78345-X 16 400 25</span><br><span class="line">0-207-78345-X 12 372 31</span><br><span class="line">0-202-78345-X 6 120 20</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables文档</title>
    <url>/2018/11/22/iptables%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1>iptables文档</h1>
<hr>
<p>[TOC]</p>
<hr>
<p>iptabels是与Linux内核集成的包过滤防火墙系统，几乎所有的linux发行版本都会包含iptables的功能。如果 Linux 系统连接到因特网或 LAN、服务器或连接 LAN 和因特网的代理服务器， 则iptables有利于在 Linux 系统上更好地控制 IP 信息包过滤和防火墙配置。</p>
<p>netfilter/iptables过滤防火墙系统是一种功能强大的工具，可用于添加、编辑和除去规则，这些规则是在做信息包过滤决定时，防火墙所遵循和组成的规则。这些规则存储在专用的信 息包过滤表中，而这些表集成在 Linux 内核中。在信息包过滤表中，规则被分组放在我们所谓的链（chain）中。</p>
<p>虽然netfilter/iptables包过滤系统被称为单个实体，但它实际上由两个组件netfilter 和 iptables 组成。</p>
<p>netfilter 组件也称为内核空间（kernelspace），是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。</p>
<p>iptables 组件是一种工具，也称为用户空间（userspace），它使插入、修改和除去信息包过滤表中的规则变得容易。</p>
<h2 id="优点"><a class="header-anchor" href="#优点">¶</a>优点</h2>
<p>netfilter/iptables的最大优点是它可以配置有状态的防火墙。有状态的防火墙能够指定并记住为发送或接收信息包所建立的连接的状态。防火墙可以从信息包的连接跟踪状态获得该信 息。在决定新的信息包过滤时，防火墙所使用的这些状态信息可以增加其效率和速度。这里有四种有效状态，名称分别为 <code>ESTABLISHED</code>、 <code>INVALID</code>、 <code>NEW</code> 和 <code>RELATED</code>。</p>
<p>状态 <code>ESTABLISHED</code> 指出该信息包属于已建立的连接，该连接一直用于发送和接收信息包并且完全有效。<code>INVALID</code> 状态指出该信息包与任何已知的流或连接都不相关联，它可能包含错误的数据或头。状态 <code>NEW</code> 意味着该信息包已经或将启动新的连接，或者它与尚未用于发送和接收信息包的连接相关联。最后， <code>RELATED</code> 表示该信息包正在启动新连接，以及它与已建立的连接相关联。</p>
<p>netfilter/iptables的另一个重要优点是，它使用户可以完全控制防火墙配置和信息包过滤。您可以定制自己的规则来满足您的特定需求，从而只允许您想要的网络流量进入系统。</p>
<p>另外，netfilter/iptables是免费的，这对于那些想要节省费用的人来说十分理想，它可以代替昂贵的防火墙解决方案。</p>
<h2 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h2>
<p>iptables的原理主要是对数据包的控制，看下图：</p>
<p><img src="http://img.blog.csdn.net/20131023184402031" alt="图1"></p>
<ol>
<li>一个数据包进入网卡时，它首先进入<code>PREROUTING</code>链，内核根据数据包目的IP判断是否需要转发出去。</li>
<li>如果数据包就是进入本机的，它就会沿着图向下移动，到达<code>INPUT</code>链。数据包到了<code>INPUT</code>链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经 过<code>OUTPUT</code>链，然后到达<code>POSTROUTING</code>链输出。</li>
<li>如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过 <code>FORWARD</code>链，然后到达<code>POSTROUTING</code>链输出。</li>
</ol>
<h2 id="规则、表和链"><a class="header-anchor" href="#规则、表和链">¶</a>规则、表和链</h2>
<h3 id="1-规则（rules）"><a class="header-anchor" href="#1-规则（rules）">¶</a>1. 规则（rules）</h3>
<p>规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如<code>TCP</code>、<code>UDP</code>、<code>ICMP</code>）和服务类型（如<code>HTTP</code>、<code>FTP</code>和<code>SMTP</code>）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（<code>ACCEPT</code>）、拒绝（<code>REJECT</code>）和丢弃（<code>DROP</code>）等。配置防火墙的主要工作就是添加、修改和删除这些规则。</p>
<h3 id="2-链（chains）"><a class="header-anchor" href="#2-链（chains）">¶</a>2. 链（chains）</h3>
<p>链（chains）是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定义的默认策略来处理数据包。</p>
<h3 id="3-表（tables）"><a class="header-anchor" href="#3-表（tables）">¶</a>3. 表（tables）</h3>
<p>表（tables）提供特定的功能，iptables内置了4个表，即<code>RAW</code>表、<code>FILTER</code>表、<code>NAT</code>表和<code>MANGLE</code>表，分别用于实现包过滤，网络地址转换和包重构的功能。</p>
<p><img src="http://img.blog.csdn.net/20131023184415343" alt="图2"></p>
<ol>
<li><code>raw</code>表<br>
只使用在<code>PREROUTING</code>链和<code>OUTPUT</code>链上,因为优先级最高，从而可以对收到的数据包在连接跟踪前进行处理。一但用户使用了<code>RAW</code>表,在 某个链上,<code>RAW</code>表处理完后,将跳过<code>NAT</code>表和 ip_conntrack处理,即不再做地址转换和数据包的链接跟踪处理了。</li>
<li><code>FILTER</code>表<br>
主要用于过滤数据包，该表根据系统管理员预定义的一组规则过滤符合条件的数据包。对于防火墙而言，主要利用在<code>FILTER</code>表中指定的规则来实现对数据包的过滤。<code>FILTER</code>表是默认的表，如果没有指定哪个表，iptables 就默认使用<code>FILTER</code>表来执行所有命令，<code>FILTER</code>表包含了<code>INPUT</code>链（处理进入的数据包），<code>FORWARD</code>链（处理转发的数据包），<code>OUTPUT</code>链（处理本地生成的数据包）在<code>FILTER</code>表中只能允许对数据包进行接受，丢弃的操作，而无法对数据包进行更改。</li>
<li><code>NAT</code>表<br>
主要用于网络地址转换<code>NAT</code>，该表可以实现一对一，一对多，多对多等<code>NAT</code> 工作，iptables就是使用该表实现共享上网的，<code>NAT</code>表包含了<code>PREROUTING</code>链（修改即将到来的数据包），<code>POSTROUTING</code>链（修改即将出去的数据包），<code>OUTPUT</code>链（修改路由之前本地生成的数据包）。</li>
<li><code>MANGLE</code>表<br>
主要用于对指定数据包进行更改，在内核版本2.4.18 后的linux版本中该表包含的链为：<code>INPUT</code>链（处理进入的数据包），<code>FORWARD</code>链（处理转发的数据包），<code>OUTPUT</code>链（处理本地生成的数据包）<code>POSTROUTING</code>链（修改即将出去的数据包），<code>PREROUTING</code>链（修改即将到来的数据包）。</li>
</ol>
<h3 id="4-规则表之间的优先顺序"><a class="header-anchor" href="#4-规则表之间的优先顺序">¶</a>4. 规则表之间的优先顺序</h3>
<p>RAW —&gt; MANGE —&gt; NAT ——&gt; FILTER</p>
<p>规则链之间的优先顺序（分三种情况）：</p>
<h4 id="第一种情况：入站数据流向"><a class="header-anchor" href="#第一种情况：入站数据流向">¶</a>第一种情况：入站数据流向</h4>
<p>从外界到达防火墙的数据包，先被<code>PREROUTING</code>规则链处理（是否修改数据包地址等），之后会进行路由选择（判断该数据包应该发往何处），如果数据包 的目标主机是防火墙本机（比如说Internet用户访问防火墙主机中的web服务器的数据包），那么内核将其传给<code>INPUT</code>链进行处理（决定是否允许通 过等），通过以后再交给系统上层的应用程序（比如Apache服务器）进行响应。</p>
<h4 id="第二冲情况：转发数据流向"><a class="header-anchor" href="#第二冲情况：转发数据流向">¶</a>第二冲情况：转发数据流向</h4>
<p>来自外界的数据包到达防火墙后，首先被<code>PREROUTING</code>规则链处理，之后会进行路由选择，如果数据包的目标地址是其它外部地址（比如局域网用户通过网 关访问QQ站点的数据包），则内核将其传递给<code>FORWARD</code>链进行处理（是否转发或拦截），然后再交给<code>POSTROUTING</code>规则链（是否修改数据包的地 址等）进行处理。</p>
<h4 id="第三种情况：出站数据流向"><a class="header-anchor" href="#第三种情况：出站数据流向">¶</a>第三种情况：出站数据流向</h4>
<p>防火墙本机向外部地址发送的数据包（比如在防火墙主机中测试公网DNS服务器时），首先被<code>OUTPUT</code>规则链处理，之后进行路由选择，然后传递给<code>POSTROUTING</code>规则链（是否修改数据包的地址等）进行处理。</p>
<p>iptables是采用规则堆栈的方式来进行过滤，当一个封包进入网卡，会先检查 <code>PREROUTING</code>，然后检查目的IP判断是否需要转送出去，接着就会跳到<code>INPUT</code>或<code>FORWORD</code> 进行过滤，如果封包需转送处理则检查 <code>POSTROUTING</code>，如果是来自本机封包，则检查 <code>OUTPUT</code>以及<code>POSTROUTING</code>。过程中如果符合某条规则将会进行处理，处理动作除了 <code>ACCEPT</code>、<code>REJECT</code>、<code>DROP</code>、<code>REDIRECT</code> 和<code>MASQUERADE</code>以外，还多出 <code>LOG</code>、<code>ULOG</code>、<code>DNAT</code>、<code>SNAT</code>、<code>MIRROR</code>、<code>QUEUE</code>、<code>RETURN</code>、<code>TOS</code>、<code>TTL</code>、<code>MARK</code>等，其中某些处理动作不会中断过滤程序，某些处理动作则会中断同一规则链的过滤，并依照前述流程继续进行下一个规则链的过滤（注意：这一点与ipchains不同），一直到堆栈中的规则检查完毕为止。透过这种机制所带来的好处是，我们可以进行复杂、多重的封包过滤，简单的说，iptables可以进行纵横交错式的过滤（tables）而非链状过滤（chains）。<code>ACCEPT</code>将封包放行，进行完此处理动作后，将不再比对其它规则，直接跳往下一个规则链（<code>NAT</code>:<code>POSTROUTING</code>）。</p>
<p>那么如何使用iptables在以上流程中控制对数据包的处理行为呢？当然是使用iptables与其相关的参数了。</p>
<h2 id="iptables命令格式"><a class="header-anchor" href="#iptables命令格式">¶</a>iptables命令格式</h2>
<p>iptables的命令格式较为复杂，一般的格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables [-t 表] -命令 匹配   操作</span><br></pre></td></tr></table></figure>
<p>说明</p>
<ol>
<li>
<p>-t 表<br>
表选项用于指定命令应用于哪个iptables内置表。</p>
</li>
<li>
<p>命令<br>
命令选项用于指定iptables的执行方式，包括插入规则，删除规则和添加规则，如下表所示：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-P  --policy &lt;链名&gt;</td>
<td style="text-align:left">定义默认策略</td>
</tr>
<tr>
<td style="text-align:left">-L  --list &lt;链名&gt;</td>
<td style="text-align:left">查看iptables规则列表</td>
</tr>
<tr>
<td style="text-align:left">-A  --append &lt;链名&gt;</td>
<td style="text-align:left">在规则列表的最后增加1条规则</td>
</tr>
<tr>
<td style="text-align:left">-I  --insert &lt;链名&gt;</td>
<td style="text-align:left">在指定的位置插入1条规则</td>
</tr>
<tr>
<td style="text-align:left">-D  --delete &lt;链名&gt;</td>
<td style="text-align:left">从规则列表中删除1条规则</td>
</tr>
<tr>
<td style="text-align:left">-R  --replace &lt;链名&gt;</td>
<td style="text-align:left">替换规则列表中的某条规则</td>
</tr>
<tr>
<td style="text-align:left">-F  --flush &lt;链名&gt;</td>
<td style="text-align:left">删除表中所有规则</td>
</tr>
<tr>
<td style="text-align:left">-Z  --zero &lt;链名&gt;</td>
<td style="text-align:left">将表中数据包计数器和流量计数器归零</td>
</tr>
<tr>
<td style="text-align:left">-X  --delete-chain &lt;链名&gt;</td>
<td style="text-align:left">删除自定义链</td>
</tr>
<tr>
<td style="text-align:left">-v  --verbose &lt;链名&gt;</td>
<td style="text-align:left">与<code>-L</code>他命令一起使用显示更多更详细的信息</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>匹配规则<br>
匹配选项指定数据包与规则匹配所具有的特征，包括源地址，目的地址，传输协议和端口号，如下表所示：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">匹配</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-i --in-interface &lt;网络接口名&gt;</td>
<td style="text-align:left">指定数据包从哪个网络接口进入</td>
</tr>
<tr>
<td style="text-align:left">-o --out-interface   &lt;网络接口名&gt;</td>
<td style="text-align:left">指定数据包从哪个网络接口输出</td>
</tr>
<tr>
<td style="text-align:left">-p —proto 协议类型</td>
<td style="text-align:left">指定数据包匹配的协议，如<code>TCP</code>、<code>UDP</code>和<code>ICMP</code>等</td>
</tr>
<tr>
<td style="text-align:left">-s --source &lt;源地址或子网&gt;</td>
<td style="text-align:left">指定数据包匹配的源地址</td>
</tr>
<tr>
<td style="text-align:left">–sport &lt;源端口号&gt;</td>
<td style="text-align:left">指定数据包匹配的源端口号</td>
</tr>
<tr>
<td style="text-align:left">–dport &lt;目的端口号&gt;</td>
<td style="text-align:left">指定数据包匹配的目的端口号</td>
</tr>
<tr>
<td style="text-align:left">-m --match 匹配的模块</td>
<td style="text-align:left">指定数据包规则所使用的过滤模块</td>
</tr>
</tbody>
</table>
<p>iptables执行规则时，是从规则表中从上至下顺序执行的，如果没遇到匹配的规则，就一条一条往下执行，如果遇到匹配的规则后，那么就执行本规则，执行后根据本规则的动作(<code>ACCEPT</code>，<code>REJECT</code>，<code>LOG</code>，<code>DROP</code>等)，决定下一步执行的情况，后续执行一般有三种情况。</p>
<ul>
<li>一种是继续执行当前规则队列内的下一条规则。比如执行过<code>FILTER</code>队列内的<code>LOG</code>后，还会执行<code>FILTER</code>队列内的下一条规则。</li>
<li>一种是中止当前规则队列的执行，转到下一条规则队列。比如从执行过<code>ACCEPT</code>后就中断<code>FILTER</code>队列内其它规则，跳到<code>NAT</code>队列规则去执行</li>
<li>一种是中止所有规则队列的执行。</li>
</ul>
<h2 id="iptables规则的动作"><a class="header-anchor" href="#iptables规则的动作">¶</a>iptables规则的动作</h2>
<p>前面我们说过iptables处理动作除了 <code>ACCEPT</code>、<code>REJECT</code>、<code>DROP</code>、<code>REDIRECT</code> 、<code>MASQUERADE</code> 以外，还多出 <code>LOG</code>、<code>ULOG</code>、<code>DNAT</code>、<code>RETURN</code>、<code>TOS</code>、<code>SNAT</code>、<code>MIRROR</code>、<code>QUEUE</code>、<code>TTL</code>、<code>MARK</code>等。我们只说明其中最常用的动作：</p>
<p><strong>REJECT</strong> 拦阻该数据包，并返回数据包通知对方，可以返回的数据包有几个选择：<code>ICMP port-unreachable</code>、<code>ICMP echo-reply</code> 或是<code>tcp-reset</code>（这个数据包包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。 范例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A  INPUT -p TCP --dport 22 -j REJECT --reject-with ICMP <span class="built_in">echo</span>-reply</span><br></pre></td></tr></table></figure>
<p><strong>DROP</strong> 丢弃数据包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</p>
<p><strong>REDIRECT</strong> 将封包重新导向到另一个端口（<code>PNAT</code>），进行完此处理动作后，将会继续比对其它规则。这个功能可以用来实作透明代理 或用来保护web 服务器。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT--to-ports 8081</span><br></pre></td></tr></table></figure>
<p><strong>MASQUERADE</strong> 改写封包来源IP为防火墙的IP，可以指定<code>port</code> 对应的范围，进行完此处理动作后，直接跳往下一个规则链（<code>MANGLE</code>:<code>POSTROUTING</code>）。这个功能与 <code>SNAT</code> 略有不同，当进行IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读取，当使用拨接连线时，IP 通常是由 ISP 公司的 DHCP服务器指派的，这个时候 <code>MASQUERADE</code> 特别有用。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE --to-ports 21000-31000</span><br></pre></td></tr></table></figure>
<p><strong>LOG</strong> 将数据包相关信息纪录在 <code>/var/lo</code>g 中，详细位置请查阅 <code>/etc/syslog.conf</code> 配置文件，进行完此处理动作后，将会继续比对其它规则。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -j LOG --<span class="built_in">log</span>-prefix <span class="string">"input packet"</span></span><br></pre></td></tr></table></figure>
<p><strong>SNAT</strong> 改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 <code>port</code> 对应的范围，进行完此处理动作后，将直接跳往下一个规则链（<code>MANGLE</code>:<code>POSTROUTING</code>）。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT --to-source 192.168.10.15-192.168.10.160:2100-3200</span><br></pre></td></tr></table></figure>
<p><strong>DNAT</strong> 改写数据包包目的地 IP 为某特定 IP 或 IP 范围，可以指定 <code>port</code> 对应的范围，进行完此处理动作后，将会直接跳往下一个规则链（<code>FILTER</code>:<code>INPUT</code> 或 <code>FILTER</code>:<code>FORWORD</code>）。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 --dport 80 -j DNAT --to-destination 192.168.10.1-192.168.10.10:80-100</span><br></pre></td></tr></table></figure>
<p><strong>MIRROR</strong> 镜像数据包，也就是将来源 IP与目的地IP对调后，将数据包返回，进行完此处理动作后，将会中断过滤程序。</p>
<p><strong>QUEUE</strong> 中断过滤程序，将封包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，例如：计算联机费用…等。</p>
<p><strong>RETURN</strong> 结束在目前规则链中的过滤程序，返回主规则链继续过滤，如果把自订规则炼看成是一个子程序，那么这个动作，就相当于提早结束子程序并返回到主程序中。</p>
<p><strong>MARK</strong> 将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --<span class="built_in">set</span>-mark 22</span><br></pre></td></tr></table></figure>
<p>看了本文是不是对iptables参数有所了解了，下文我会使用实例来更详细的说明iptables的参数的用法。</p>
<h3 id="保存规则"><a class="header-anchor" href="#保存规则">¶</a>保存规则</h3>
<p>使用iptables程序建立的规则只会保存在内存中，通常我们在修改了iptables的规则重启 iptables 后，之前修改的规则又消失了。那么如何保存新建立的规则呢？</p>
<ol>
<li>
<p>对于RHEL和ceontos系统可以使用<code>service iptables save</code>将当前内存中的规则保存到<code>/etc/sysconfig/iptables</code>文件中</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@lampbo ~]# service iptables save</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改<code>/etc/sysconfig/iptables-config</code> 将里面的<code>IPTABLES_SAVE_ON_STOP=&quot;no&quot;</code>, 这一句的<code>no</code>改为<code>yes</code>这样每次服务在停止之前会自动将现有的规则保存在 <code>/etc/sysconfig/iptables</code>这个文件中去。</p>
</li>
</ol>
<h2 id="规则示例"><a class="header-anchor" href="#规则示例">¶</a>规则示例</h2>
<p>先回顾下iptables的格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables [-t table] <span class="built_in">command</span> [match] [-j target/jump]</span><br></pre></td></tr></table></figure>
<p>-t 参数用来指定规则表，内建的规则表有三个，分别是：<code>NAT</code>、<code>MANGLE</code> 和 <code>FILTER</code>，当未指定规则表时，则一律视为是 <code>FILTER</code>。</p>
<p>各个规则表的功能如下：</p>
<p><strong>NAT</strong> 此规则表拥有 <code>PREROUTING</code> 和 <code>POSTROUTING</code> 两个规则链，主要功能为进行一对一、一对多、多对多等网址转换工作（<code>SNAT</code>，<code>DNAT</code>），由于转换的特性，需进行目的地网址转换的数据包，就不需要进行来源网址转换，反之亦然，因此为了提升改写封包的效率，在防火墙运作时，每个封包只会经过这个规则表一次。如果我们把数据包过滤的规则定义在这个数据表里，将会造成无法对同一包进行多次比对，因此这个规则表除了作网址转换外，请不要做其它用途。mangle 此规则表拥有 <code>PREROUTING</code>、<code>FORWARD</code> 和 <code>POSTROUTING</code> 三个规则链。</p>
<p>除了进行网址转译工作会改写封包外，在某些特殊应用可能也必须去改写数据包（<code>TTL</code>、<code>TOS</code>）或者是设定 <code>MARK</code>（将数据包作记号，以进行后续的过滤），这时就必须将这些工作定义在 <code>MANGLE</code> 规则表中。</p>
<p><strong>MANGLE</strong> 表主要用于对指定数据包进行更改，在内核版本2.4.18 后的linux版本中该表包含的链为：<code>INPUT</code>链（处理进入的数据包），<code>FORWARD</code>链（处理转发的数据包），<code>OUTPUT</code>链（处理本地生成的数据包）<code>POSTROUTING</code>链（修改即将出去的数据包），<code>PREROUTING</code>链（修改即将到来的数据包）。</p>
<p><strong>FILTER</strong> 这个规则表是预设规则表，拥有 <code>INPUT</code>、<code>FORWARD</code> 和 <code>OUTPUT</code> 三个规则链，这个规则表顾名思义是用来进行封包过滤的动作（例如：DROP、 LOG、 ACCEPT<code>或</code>REJECT`），我们会将基本规则都建立在此规则表中。</p>
<h3 id="常用命令示例"><a class="header-anchor" href="#常用命令示例">¶</a>常用命令示例</h3>
<ol>
<li>
<p>命令 -A, --append<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明 ：新增规则到<code>INPUT</code>规则链中，规则时接到所有目的端口为80的数据包的流入连接，该规则将会成为规则链中的最后一条规则。</p>
</blockquote>
</li>
<li>
<p>命令 -D, --delete<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -D INPUT -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>或：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -D INPUT 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：从<code>INPUT</code>规则链中删除上面建立的规则，可输入完整规则，或直接指定规则编号加以删除。</p>
</blockquote>
</li>
<li>
<p>命令 -R, --replace<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -R INPUT 1 -s 192.168.0.1 -j DROP</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：取代现行第一条规则，规则被取代后并不会改变顺序。</p>
</blockquote>
</li>
<li>
<p>命令 -I, --insert<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT 1 -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：在第一条规则前插入一条规则，原本该位置上的规则将会往后移动一个顺位。</p>
</blockquote>
</li>
<li>
<p>命令 -L, --list<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -L INPUT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：列出<code>INPUT</code>规则链中的所有规则。</p>
</blockquote>
</li>
<li>
<p>命令 -F, --flush<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -F INPUT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明： 删除<code>INPUT</code>规则链中的所有规则。</p>
</blockquote>
</li>
<li>
<p>命令 -Z, --zero<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -Z INPUT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：将<code>INPUT</code>链中的数据包计数器归零。它是计算同一数据包出现次数，过滤阻断式攻击不可少的工具。</p>
</blockquote>
</li>
<li>
<p>命令 -N, --new-chain<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -N denied</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：定义新的规则链。</p>
</blockquote>
</li>
<li>
<p>命令 -X, --delete-chain<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -X denied</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：删除某个规则链。</p>
</blockquote>
</li>
<li>
<p>命令 -P, --policy<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT DROP</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：定义默认的过滤策略。 数据包没有找到符合的策略，则根据此预设方式处理。</p>
</blockquote>
</li>
<li>
<p>命令 -E, --rename-chain<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -E denied disallowed</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：修改某自订规则链的名称。</p>
</blockquote>
</li>
</ol>
<h3 id="常用封包比对参数"><a class="header-anchor" href="#常用封包比对参数">¶</a>常用封包比对参数</h3>
<ol>
<li>
<p>参数 -p, --protocol<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：比对通讯协议类型是否相符，可以使用 <code>!</code> 运算子进行反向比对，例如：<code>-p ! tcp</code> ，意思是指除 tcp 以外的其它类型，包含udp、icmp …等。如果要比对所有类型，则可以使用 <code>all</code> 关键词，例如：<code>-p all</code>。</p>
</blockquote>
</li>
<li>
<p>参数 -s, --src, --source<br>
范例:</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -s 192.168.1.100</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对数据包的来源IP，可以比对单机或网络，比对网络时请用数字来表示屏蔽，例如：<code>-s 192.168.0.0/24</code>，比对 IP 时可以使用<code>!</code>运算子进行反向比对，例如：<code>-s ! 192.168.0.0/24</code>。</p>
</blockquote>
</li>
<li>
<p>参数 -d, --dst, --destination<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -d 192.168.1.100</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对封包的目的地 IP，设定方式同上。</p>
</blockquote>
</li>
<li>
<p>参数 -i, --in-interface<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -i  lo</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明:用来比对数据包是从哪个网卡进入，可以使用通配字符 <code>+</code> 来做大范围比对，如：<code>-i eth+</code> 表示所有的 ethernet 网卡，也可以使用 <code>!</code> 运算子进行反向比对，如：<code>-i ! eth0</code>。这里<code>lo</code>指本地换回接口。</p>
</blockquote>
</li>
<li>
<p>参数 -o, --out-interface<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A FORWARD -o eth0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对数据包要从哪个网卡流出，设定方式同上。</p>
</blockquote>
</li>
<li>
<p>参数 --sport, --source-port<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --sport 22</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对数据的包的来源端口号，可以比对单一端口，或是一个范围，例如：<code>--sport 22:80</code>，表示从 22 到 80 端口之间都算是符合件，如果要比对不连续的多个端口，则必须使用 <code>--multiport</code> 参数，详见后文。比对端口号时，可以使用 <code>!</code> 运算子进行反向比对。</p>
</blockquote>
</li>
<li>
<p>参数 --dport, --destination-port<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 22</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对封包的目的地端口号，设定方式同上。</p>
</blockquote>
</li>
<li>
<p>参数 --tcp-flags<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -p tcp --tcp-flags SYN,FIN,ACK SYN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：比对 TCP 封包的状态标志号，参数分为两个部分，第一个部分列举出想比对的标志号，第二部分则列举前述标志号中哪些有被设，未被列举的标志号必须是空的。TCP 状态标志号包括：<code>SYN</code>（同步）、<code>ACK</code>（应答）、<code>FIN</code>（结束）、<code>RST</code>（重设）、<code>URG</code>（紧急）、<code>PSH</code>（强迫推送） 等均可使用于参数中，除此之外还可以使用关键词 <code>ALL</code> 和 <code>NONE</code> 进行比对。比对标志号时，可以使用 <code>!</code> 运算子行反向比对。</p>
</blockquote>
</li>
<li>
<p>参数 --syn<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -p tcp --syn</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对是否为要求联机之TCP 封包，与 <code>iptables -p tcp --tcp-flags SYN,FIN,ACK SYN</code> 的作用完全相同，如果使用 <code>!</code>运算子，可用来比对非要求联机封包。</p>
</blockquote>
</li>
<li>
<p>参数 -m multiport --source-port<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m multiport --<span class="built_in">source</span>-port 22,53,80,110 -j ACCEPT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对不连续的多个来源端口号，一次最多可以比对 15 个端口，可以使用 <code>!</code> 运算子进行反向比对。</p>
</blockquote>
</li>
<li>
<p>参数 -m multiport --destination-port<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m multiport --destination-port 22,53,80,110 -j ACCEPT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对不连续的多个目的地端口号，设定方式同上。</p>
</blockquote>
</li>
<li>
<p>参数 -m multiport --port<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m multiport --port 22,53,80,110 -j ACCEPT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：这个参数比较特殊，用来比对来源端口号和目的端口号相同的数据包，设定方式同上。注意：在本范例中，如果来源端口号为 80，目的地端口号为 110，这种数据包并不算符合条件。</p>
</blockquote>
</li>
<li>
<p>参数 --icmp-type<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p icmp --icmp-type 8 -j DROP</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对 ICMP 的类型编号，可以使用代码或数字编号来进行比对。请打 <code>iptables -p icmp --help</code> 来查看有哪些代码可用。这里是指禁止ping如，但是可以从该主机ping出。</p>
</blockquote>
</li>
<li>
<p>参数 -m limit --limit<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 3/hour</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对某段时间内数据包的平均流量，上面的例子是用来比对：每小时平均流量是否超过一次3个数据包。 除了每小时平均次外，也可以每秒钟、每分钟或每天平均一次，默认值为每小时平均一次，参数如后： <code>/second</code>、 <code>/minute</code>、<code>/day</code>。 除了进行数据包数量的比对外，设定这个参数也会在条件达成时，暂停数据包的比对动作，以避免因洪水攻击法，导致服务被阻断。</p>
</blockquote>
</li>
<li>
<p>参数 --limit-burst<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -m <span class="built_in">limit</span> --<span class="built_in">limit</span>-burst 5</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对瞬间大量封包的数量，上面的例子是用来比对一次同时涌入的封包是否超过 5 个（这是默认值），超过此上限的封将被直接丢弃。使用效果同上。</p>
</blockquote>
</li>
<li>
<p>参数 -m mac --mac-source<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -m mac --mac-source 00:00:00:00:00:01 -j ACCEPT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对数据包来源网络接口的硬件地址，这个参数不能用在 <code>OUTPUT</code> 和 <code>POSTROUTING</code> 规则链上，这是因为封包要送出到网后，才能由网卡驱动程序透过 ARP 通讯协议查出目的地的 MAC 地址，所以 iptables 在进行封包比对时，并不知道封包会送到个网络接口去。</p>
</blockquote>
</li>
<li>
<p>参数 --mark<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t mangle -A INPUT -m mark --mark 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对封包是否被表示某个号码，当封包被比对成功时，我们可以透过 <code>MARK</code> 处理动作，将该封包标示一个号码，号码最不可以超过 4294967296。</p>
</blockquote>
</li>
<li>
<p>参数 -m owner --uid-owner<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -m owner --uid-owner 500</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对来自本机的封包，是否为某特定使用者所产生的，这样可以避免服务器使用 root 或其它身分将敏感数据传送出，可以降低系统被骇的损失。可惜这个功能无法比对出来自其它主机的封包。</p>
</blockquote>
</li>
<li>
<p>参数 -m owner --gid-owner<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -m owner --gid-owner 0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对来自本机的数据包，是否为某特定使用者群组所产生的，使用时机同上。</p>
</blockquote>
</li>
<li>
<p>参数 -m owner --pid-owner<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -m owner --pid-owner 78</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：用来比对来自本机的数据包，是否为某特定行程所产生的，使用时机同上。</p>
</blockquote>
</li>
<li>
<p>参数 -m owner --sid-owner<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -m owner --sid-owner 100</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明： 用来比对来自本机的数据包，是否为某特定联机（Session ID）的响应封包，使用时机同上。</p>
</blockquote>
</li>
<li>
<p>参数 -m state --state<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明： 用来比对联机状态，联机状态共有四种：<code>INVALID</code>、<code>ESTABLISHED</code>、<code>NEW</code> 和 <code>RELATED</code>。</p>
</blockquote>
</li>
<li>
<p><code>iptables -L -n -v</code>  可以查看计数器<br>
<code>INVALID</code> 表示该数据包的联机编号（Session ID）无法辨识或编号不正确。<code>ESTABLISHED</code> 表示该数据包属于某个已经建立的联机。<code>NEW</code> 表示该数据包想要起始一个联机（重设联机或将联机重导向）。<code>RELATED</code> 表示该数据包是属于某个已经建立的联机，所建立的新联机。例如：<code>FTP-DATA</code> 联机必定是源自某个 FTP 联机。</p>
</li>
</ol>
<h3 id="常用的处理动作"><a class="header-anchor" href="#常用的处理动作">¶</a>常用的处理动作</h3>
<p>-j 参数用来指定要进行的处理动作，常用的处理动作包括：<code>ACCEPT</code>、<code>REJECT</code>、<code>DROP</code>、<code>REDIRECT</code>、<code>MASQUERADE</code>、<code>LOG</code>、<code>DNAT</code>、<code>SNAT</code>、<code>MIRROR</code>、<code>QUEUE</code>、<code>RETURN</code>、<code>MARK</code>。</p>
<p>分别说明如下：</p>
<p><strong>ACCEPT</strong> 将数据包放行，进行完此处理动作后，将不再比对其它规则，直接跳往下一个规则链（<code>NAT</code>:<code>POSTROUTING</code>）。</p>
<p><strong>REJECT</strong> 拦阻该数据包，并传送数据包通知对方，可以传送的数据包有几个选择：<code>ICMP port-unreachable</code>、<code>ICMP echo-reply</code> 或是<code>tcp-reset</code>（这个数据包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接 中断过滤程序。 范例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A FORWARD -p TCP --dport 22 -j REJECT --reject-with tcp-reset</span><br></pre></td></tr></table></figure>
<p><strong>DROP</strong> 丢弃包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</p>
<p><strong>REDIRECT</strong> 将包重新导向到另一个端口（PNAT），进行完此处理动作后，将会继续比对其它规则。 这个功能可以用来实作通透式porxy 或用来保护 web 服务器。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080</span><br></pre></td></tr></table></figure>
<p><strong>MASQUERADE</strong> 改写数据包来源 IP为防火墙 NIC IP，可以指定 port 对应的范围，进行完此处理动作后，直接跳往下一个规则（<code>MANGLE</code>:<code>POSTROUTING</code>）。这个功能与 <code>SNAT</code> 略有不同，当进行 IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读取，当使用拨号连接时，IP 通常是由 ISP 公司的 DHCP 服务器指派的，这个时候 <code>MASQUERADE</code> 特别有用。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE --to-ports 1024-31000</span><br></pre></td></tr></table></figure>
<p><strong>LOG</strong> 将封包相关讯息纪录在 <code>/var/log</code> 中，详细位置请查阅 <code>/etc/syslog.conf</code> 配置文件，进行完此处理动作后，将会继续比对其规则。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -j LOG --<span class="built_in">log</span>-prefix <span class="string">"INPUT packets"</span></span><br></pre></td></tr></table></figure>
<p><strong>SNAT</strong> 改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将直接跳往下一个规则（<code>MANGLE</code>:<code>POSTROUTING</code>）。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT --to-source 194.236.50.155-194.236.50.160:1024-32000</span><br></pre></td></tr></table></figure>
<p><strong>DNAT</strong> 改写封包目的地 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将会直接跳往下一个规炼（<code>FILTER</code>:<code>INPUT</code> 或 <code>FILTER</code>:<code>FORWARD</code>）。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 --dport 80 -j DNAT --to-destination</span><br><span class="line">192.168.1.1-192.168.1.10:80-100</span><br></pre></td></tr></table></figure>
<p><strong>MIRROR</strong> 镜像数据包，也就是将来源 IP 与目的地 IP 对调后，将数据包送回，进行完此处理动作后，将会中断过滤程序。</p>
<p><strong>QUEUE</strong> 中断过滤程序，将数据包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，例如：计算联机费…等。</p>
<p><strong>RETURN</strong> 结束在目前规则链中的过滤程序，返回主规则链继续过滤，如果把自订规则链看成是一个子程序，那么这个动作，就相当提早结束子程序并返回到主程序中。</p>
<p><strong>MARK</strong> 将数据包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --<span class="built_in">set</span>-mark 2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>《C语言程序设计·现代方法（第二版）》学习笔记 -- 之二</title>
    <url>/2018/10/18/%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%C2%B7%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
    <content><![CDATA[<h1>《C语言程序设计现代方法第二版》学习笔记二</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="第八章"><a class="header-anchor" href="#第八章">¶</a>第八章</h2>
<h3 id="8-1-一维数组"><a class="header-anchor" href="#8-1-一维数组">¶</a>8.1 一维数组</h3>
<h4 id="8-1-1-数组下标（P114）"><a class="header-anchor" href="#8-1-1-数组下标（P114）">¶</a>8.1.1 数组下标（P114）</h4>
<ol>
<li>C语言不要求检查下标的范围。当下标超出范围时，程序可能执行不可预知的行为。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], i; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) </span><br><span class="line">    a[i] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p> 对于某些编译器来说，这个表面上正确的<code>for</code>语句却产生了一个无限循环！当变量<code>i</code>的值变为10时，程序将数值0存储在<code>a[10]</code>中。但是<code>a[10]</code>这个元素并不存在，所以在元素<code>a[9]</code>后数值0立刻进入内存。如果内存中变量<code>i</code>旋转在<code>a[9]</code>的后边（这是有可能的），那么变量<code>i</code>将会被重置为0，进而导致循环重新开始。</p>
<ol start="2">
<li>当数组下标有副作用时一定要注意：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; N)</span><br><span class="line">    a[i] = b[i++];</span><br></pre></td></tr></table></figure>
<p> 表达式<code>a[i] = b[i++]</code>访问并修改i的值，如4.4节所述，这样会导致未定义的行为。</p>
<h4 id="8-1-2数组初始化（P115）"><a class="header-anchor" href="#8-1-2数组初始化（P115）">¶</a>8.1.2数组初始化（P115）</h4>
<ol>
<li>如果初始化式比数组短，好么数组中剩余元素赋值为0。利用这一特性，可以很容易地把数组初始化为全0：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>初始化式完全为空是非法的，初始化式比要初始化的数组长也是非法的。</li>
<li>如果给定了初始化式，可以活力掉数组的长度。</li>
</ol>
<h4 id="8-1-3指定初始化式（P116）"><a class="header-anchor" href="#8-1-3指定初始化式（P116）">¶</a>8.1.3指定初始化式（P116）</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">15</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">29</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">48</span>&#125;;</span><br></pre></td></tr></table></figure>
<p> 可以使用指定初始化式写为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">15</span>] = &#123;[<span class="number">14</span>] = <span class="number">48</span>, [<span class="number">9</span>] = <span class="number">7</span>, [<span class="number">2</span>] = <span class="number">29</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-多维数组"><a class="header-anchor" href="#8-2-多维数组">¶</a>8.2 多维数组</h3>
<h4 id="8-2-1多维数组初始化（P120）"><a class="header-anchor" href="#8-2-1多维数组初始化（P120）">¶</a>8.2.1多维数组初始化（P120）</h4>
<ol>
<li>在多维数组中省略掉内层花括号可能是很危险的，因为额外的元素（更糟的情况是丢失的元素）将会影响剩下的初始化式。省略花括号会引起某些编译器产生类似“missing braces around initialiezer”这样的警告消息。</li>
<li>C99指定初始化式对多维数组也有效。例如，可以这样创建2x2的单位矩阵：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> ident[<span class="number">2</span>][<span class="number">2</span>] = &#123;[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0</span>, [<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="第八章FAQ（P123）"><a class="header-anchor" href="#第八章FAQ（P123）">¶</a>第八章FAQ（P123）</h3>
<ol>
<li>编译器在处理初始化式列表时，会记录下一个待初始化的数组元素的位置。正常情况下，下一个元素是刚被初始化的元素后面的那个。但是，当列表中出现初始化式时，下一个元素会被强制为指示符对应的元素，即使该元素已经被初始化了：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a [] = &#123;<span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, [<span class="number">0</span>] = <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>  下面逐步分析编译器处理数组a的初始化式的操作：</p>
<ul>
<li>用4初始化元素0，下一个待初始化的是元素1；</li>
<li>用9初始化元素1，下一个待初始化的是元素2；</li>
<li>用1初始化元素2，下一个待初始化的是元素3；</li>
<li>用8初始化元素3，下一个待初始化的是元素4；</li>
<li>[0]指示符导致下一个元素是元素0，所以用5初始化元素0（替换先前存储的4）.下一个待初始化的是元素1；</li>
<li>用7初始化元素1（替换先前存储的9）.下一个待初始化的是元素2（跟本例不相关，因为已经到达列表末尾）。<br>
  最终效果跟下面的声明一样：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>
<p> <font color: red><strong>因此，数组的长度为4。</strong></font></p>
<p>2. 在程序执行过程中，遇到变长数组声明时通常就为该变长数组分配内存空间了。用<code>goto</code>语句绕过变长数组的声明可能会导致程序对未分配空间的数组中的元素进行访问。</p>
<hr>
<h2 id="第九章-函数"><a class="header-anchor" href="#第九章-函数">¶</a>第九章 函数</h2>
<h3 id="9-1-函数的定义和调用"><a class="header-anchor" href="#9-1-函数的定义和调用">¶</a>9.1 函数的定义和调用</h3>
<h4 id="9-1-1函数定义（P132）"><a class="header-anchor" href="#9-1-1函数定义（P132）">¶</a>9.1.1函数定义（P132）</h4>
<ol>
<li>下列规则用来管理返回类型：</li>
</ol>
<ul>
<li><font color=red><strong>函数不能返回数组，但关于返回类型没有其它限制。</strong></font></li>
<li>指定返回类型是<code>void</code>类型说明函数没有返回值。</li>
<li><font color=red><strong>如果省略返回类型，C89会假定函数返回值的类型是<code>int</code>类型，但在C99中这是不合法的。</strong></font></li>
</ul>
<ol start="2">
<li><font color=red><strong>如果函数没有形式参数，那么在圆括号内应该出现<code>void</code>。</strong></font></li>
<li>对于返回类型为<code>void</code>的函数，其函数体可以为空。</li>
</ol>
<h4 id="9-1-2函数调用（P133）"><a class="header-anchor" href="#9-1-2函数调用（P133）">¶</a>9.1.2函数调用（P133）</h4>
<ol>
<li>如果丢失圆括号，那么将无法进行函数调用：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_pun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_pun; <span class="comment">/* WRONG */</span></span><br></pre></td></tr></table></figure>
<p>  这样的结果是合法的（虽然没有意义）表达式语句，而且看上去这语句是正确的，但是这条语句不起任何作用。一些编译器会发出一条类似“statement with no effect”的警告。</p>
<p>2. 在C语言中，“强制转换成<code>void</code>”是对“抛弃”的一种客气的说法。使用<code>(void)</code>可以使别人清楚编写者是故意抛弃返回值的，而不是忘记了。</p>
<h3 id="9-2函数声明（P135）"><a class="header-anchor" href="#9-2函数声明（P135）">¶</a>9.2函数声明（P135）</h3>
<p>  C99遵循这样的规则：在调用一个函数之前，必须先对其进行声明或定义。调用函数时，如果此前编译器未见到该函数的声明或定义，会导致出错。</p>
<h4 id="9-3-2数组型实际参数（P138）"><a class="header-anchor" href="#9-3-2数组型实际参数（P138）">¶</a>9.3.2数组型实际参数（P138）</h4>
<ol>
<li>当形式参数是一维数组时，可以（而且是通常情况下）不说明数组的长度：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a [])</span> </span>&#123; <span class="comment">/* no length specified*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2. C语言没有为函数提供任务简便的方法来确定传递给它的数组的长度；如果函数需要，我们必须把长度作为额外的参数提供出来。</p>
<p>3. 虽然可以用运算符<code>sizeof</code>计算出数组变量的长度，但是它无法给出关于数组型形式参数的正确答案。</p>
<p>4. 如果形式参数是多维数组，声明参数时<font color=red><strong>只能省略第一维长度</strong></font>。</p>
<h3 id="9-3-实际参数"><a class="header-anchor" href="#9-3-实际参数">¶</a>9.3 实际参数</h3>
<h4 id="9-3-3变长数组形式参数（P140）"><a class="header-anchor" href="#9-3-3变长数组形式参数（P140）">¶</a>9.3.3变长数组形式参数（P140）</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a[n])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-3-4在数组参数声明中使用static（P141）"><a class="header-anchor" href="#9-3-4在数组参数声明中使用static（P141）">¶</a>9.3.4在数组参数声明中使用<code>static</code>（P141）</h4>
<p>  在下面这个例子中，将<code>static</code>放在数字3之前表明数组a的长度至少可以保证是3：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> a[<span class="keyword">static</span> <span class="number">3</span>], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这样使用<code>static</code>不会对程序的行为有任何影响。<code>static</code>的存在只不过是一个“提示”，C编译器可以据此生成更快的指令来访问数组。<font color=red><strong>如果数组参数是多维的，<code>static</code>仅可用于第一维（例如，指定二维数组的行数）</strong></font>。</p>
<h4 id="9-3-5复合字面量（P141）"><a class="header-anchor" href="#9-3-5复合字面量（P141）">¶</a>9.3.5复合字面量（P141）</h4>
<ol>
<li>复合字面量是通过其包含的元素而创建的没有名字的数组：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">total = sum_array((<span class="keyword">int</span> [])&#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>&#125;, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>2. 可以指明数组长度，如<code>(int[4]){1, 9, 2, 1}</code>，这种方式等同于<code>(int[]){1, 9, 2,1}</code>。</p>
<p>3. 如果要求复合字面量为“只读”，可以在类型前加上const，如(const int []){5, 4}。</p>
<h3 id="9-5程序终止（P143）"><a class="header-anchor" href="#9-5程序终止（P143）">¶</a>9.5程序终止（P143）</h3>
<p>  <code>exit</code>函数、<code>EXIT_SUCCESS</code>、<code>EXIT_FAILURE</code>位于<code>&lt;stdlib.h&gt;</code>中。</p>
<h3 id="第九章FAQ（P149）"><a class="header-anchor" href="#第九章FAQ（P149）">¶</a>第九章FAQ（P149）</h3>
<p>  如果几个函数具有相同的返回类型，那么可以把它们的声明合并，事实上，C语言甚至允许把函数声明和变量声明合并在一起：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x, y, average(<span class="keyword">double</span> a, <span class="keyword">double</span> b);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第十章-程序结构"><a class="header-anchor" href="#第十章-程序结构">¶</a>第十章 程序结构</h2>
<h3 id="10-1-局部变量"><a class="header-anchor" href="#10-1-局部变量">¶</a>10.1 局部变量</h3>
<h4 id="10-1-1静态局部变量（P156）"><a class="header-anchor" href="#10-1-1静态局部变量（P156）">¶</a>10.1.1静态局部变量（P156）</h4>
<ol>
<li>在局部变量声明中旋转单词<code>static</code>可以使变量具有静态存储期限而不再是自动存储期限。因为具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。</li>
<li>静态局部变量始终有块作用域，所以它对其他函数是不可见的。概括来说，静态变量是对其它函数隐藏数据的地方，但是它会为将来同一个函数的再调用保留这些数据。</li>
</ol>
<h3 id="10-2外部变量（P156）"><a class="header-anchor" href="#10-2外部变量（P156）">¶</a>10.2外部变量（P156）</h3>
<ul>
<li>外部变量（有时称为全局变量）的性质不同于局部变量的性质：</li>
</ul>
<blockquote>
<ul>
<li>静态存储期限。就如同声明为static的局部变量一样，外部变量拥有静态存储期限。存储在外部变量中的值将永久保留下来。</li>
<li>文件作用域。外部变量拥有文件作用域：从变量被声明的点开始一直到所在文件的末尾。因此，跟随在外部变量声明之后的所有函数都可以访问（并修改）它。</li>
</ul>
</blockquote>
<hr>
<h2 id="第十二章-指针和数组"><a class="header-anchor" href="#第十二章-指针和数组">¶</a>第十二章 指针和数组</h2>
<h3 id="12-2-指针用于数组处理（P186）"><a class="header-anchor" href="#12-2-指针用于数组处理（P186）">¶</a>12.2 指针用于数组处理（P186）</h3>
<p>  后缀<code>++</code>的优先级高于<code>*</code>，所以编译器把<code>*p++ = j</code>看成是<code>*(p++) = j</code>。<code>p++</code>的值是<code>p</code>。（因为使用后缀<code>++</code>，所以<code>p</code>只有在表达式计算出来后才可能自增。）因此，<code>*(p++)</code>的值将是<code>*p</code>，即<code>p</code>当前指向的对象。</p>
<h3 id="12-3用数组名作为指针（P188）"><a class="header-anchor" href="#12-3用数组名作为指针（P188）">¶</a>12.3用数组名作为指针（P188）</h3>
<p> 虽然可以把数组名用作指针，但是不能给数组名赋新的值。试图使数组名指向其它地方是错误的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (*a != <span class="number">0</span>)</span><br><span class="line">    a++; <span class="comment">/* WRONG */</span></span><br></pre></td></tr></table></figure>
<h3 id="第十二章FAQ"><a class="header-anchor" href="#第十二章FAQ">¶</a>第十二章FAQ</h3>
<p>  <code>i[a]</code>和<code>a[i]</code>是一样的。对于编译器而言<code>i[a]</code>等同于<code>*(i + a)</code>，也就是<code>*(a + i)</code>。而<code>*(a + i)</code>也就是<code>a[i]</code>。</p>
<hr>
<h2 id="第十四章-预处理器"><a class="header-anchor" href="#第十四章-预处理器">¶</a>第十四章 预处理器</h2>
<h3 id="14-3-宏定义"><a class="header-anchor" href="#14-3-宏定义">¶</a>14.3 宏定义</h3>
<h4 id="14-3-1简单的宏（P228）"><a class="header-anchor" href="#14-3-1简单的宏（P228）">¶</a>14.3.1简单的宏（P228）</h4>
<p>  不要在宏定义中放置任何额外的符号，否则它们会被作为替换列表的一部分。一种常见的错误是在宏定义中使用<code>=</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N = 100 <span class="comment">/* WRONG */</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> a[N]; <span class="comment">/*becomes int a[= 100] */</span></span><br></pre></td></tr></table></figure>
<h4 id="14-3-2带参数的宏（P229）"><a class="header-anchor" href="#14-3-2带参数的宏（P229）">¶</a>14.3.2带参数的宏（P229）</h4>
<ol>
<li>带参数的宏（也称为函数式宏）的定义有如下格式：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 标识符(x1, x2, ..., xn) 替换列表</span></span><br></pre></td></tr></table></figure>
<p>  在宏的名字和左括号之间必须没有空格。如果有空格，预处理器会认为是在定义一个简单的宏，其中<code>(x1, x2, ..., xn)</code>是替换列表的一部分。</p>
<p>2. 使用带参数的宏替代真正的函数有两个优点：</p>
<ul>
<li>
<p>程序可能会稍微快些。程序执行时调用函数通常会有些额外的开销——存储上下文信息、复制参数的值等，而调用宏则没有这些运行开销。（注意，C99的内联函数为我们提供了一种不使用宏而避免这一开销的办法。）</p>
</li>
<li>
<p>宏更“通用”。与函数的参数不同，宏的参数没有类型。因此，只要预处理后的程序依然是合法的，宏可以接受任何类型的参数。例如，我们可以使用<code>MAX</code>宏从两个数中选出较大的一个，数的类型可以是<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>等。<br>
3. 但是带参数的宏也有一些缺点：</p>
</li>
<li>
<p>编译后的代码通常会变大。</p>
</li>
<li>
<p>宏参数没有类型检查。</p>
</li>
<li>
<p>无法用一个指针来指向一个宏。</p>
</li>
<li>
<p>宏可能会不止一次地计算它的参数。考虑下面的例子，其中<code>MAX</code>的一个参数有副作用：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = MAX(i++, j);</span><br></pre></td></tr></table></figure>
<p>  下面是这条语句在预处理之后的结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = ((i++)&gt;(j)?(i++):(j));</span><br></pre></td></tr></table></figure>
<p>  如果<code>i</code>大于<code>j</code>，那么<code>i</code>可能会被（错误地）增加两次，同时<code>n</code>可能被赋予错误的值。</p>
<h4 id="14-3-3-运算符（P231）"><a class="header-anchor" href="#14-3-3-运算符（P231）">¶</a>14.3.3 <code>#</code>运算符（P231）</h4>
<p>  <code>#</code>运算符将宏的一个参数转换为字符串字面量。它仅允许出现在带参数的宏的替换列表中。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_INT(n) printf(#n <span class="meta-string">" = %d\n"</span>, n)</span></span><br></pre></td></tr></table></figure>
<p>  调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PRINT_INT(i/j);</span><br></pre></td></tr></table></figure>
<p>  会变为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"i/j"</span> <span class="string">" = %d\n"</span>, i/j);</span><br></pre></td></tr></table></figure>
<h4 id="14-3-4-运算符（P231）"><a class="header-anchor" href="#14-3-4-运算符（P231）">¶</a>14.3.4 ##运算符（P231）</h4>
<ol>
<li><code>##</code>运算符被称为“记号粘合”。</li>
<li><code>##</code>运算符可以将两个记号（如标识符）“粘合”在一起，成为一个记号。如果其中一个操作数是宏参数，“粘合”会在形式参数被相应的实际参数替换后发生。考虑下面的宏：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MK_ID(n) i##n</span></span><br></pre></td></tr></table></figure>
<p>  当<code>MK_ID</code>被调用时（比如<code>MK_ID(1)</code>），预处理器首先使用实际参数（这个例子中是1）替换形式参数<code>n</code>。接着，预处理器将i和1合并成为一个记号（i1）。下面的声明使用<code>MK_ID</code>创建了3个标识符：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">int MK_ID(1), MK_ID(2), MK_ID(3);</span><br></pre></td></tr></table></figure>
<p>  预处理后这一声明变为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i1, i2, i3;</span><br></pre></td></tr></table></figure>
<p>3. 使用宏实现泛型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERIC_MAX(type) \</span></span><br><span class="line"> </span><br><span class="line">type type##_max(type x , type y) \</span><br><span class="line">&#123; \</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4. C11标准泛型（使用<code>_Generic</code>宏）：<br>
  <code>_Generic(表达式,类型匹配列表,default: 默认表达式)</code>，如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERAL_ABS(x) _Generic((x), int:abs, float:fabsf, double:fabs)(x)</span></span><br><span class="line"> </span><br><span class="line">GENERAL_ABS(<span class="number">-12</span>); <span class="comment">//将被展开为abs(-12)</span></span><br><span class="line"> </span><br><span class="line">GENERAL_ABS(<span class="number">-12.04</span>); <span class="comment">//将被展开为fabsf(-12.04)</span></span><br><span class="line"> </span><br><span class="line">GENERAL_ABS(<span class="number">-13.09876</span>); <span class="comment">//将被展开为fabs(-13.09876)</span></span><br></pre></td></tr></table></figure>
<h4 id="14-3-5宏的通用属性（P232）"><a class="header-anchor" href="#14-3-5宏的通用属性（P232）">¶</a>14.3.5宏的通用属性（P232）</h4>
<p>  宏定义的作用范围通常到出现这个宏的文件末尾。由于宏是由预处理器处理的，<font color=red><strong>它们不遵从通常的作用域规则。定义在函数中的宏并不是仅在函数内起作用，而是作用到文件末尾</strong></font>。</p>
<h4 id="14-3-6宏定义中的圆括号（P233）"><a class="header-anchor" href="#14-3-6宏定义中的圆括号（P233）">¶</a>14.3.6宏定义中的圆括号（P233）</h4>
<p>  一个宏定义中加圆括号的规则：</p>
<blockquote>
<p><font color=red><strong>如果宏的替换列表中有运算符，那么将替换列表放在圆括号中。</strong></font></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWO_PI (2 * 3.14159)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color=red><strong>如果宏有参数，每个参数每次在替换列表中出现时都要放在圆括号中。</strong></font></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCALE(x) ((x) * 10)</span></span><br></pre></td></tr></table></figure>
<h4 id="14-3-10空的宏参数（P236）"><a class="header-anchor" href="#14-3-10空的宏参数（P236）">¶</a>14.3.10空的宏参数（P236）</h4>
<ol>
<li>C99允许宏调用中的任意或所有参数为空。当然这样的调用需要有和一般调用一样的多逗号（这样容易看出哪些参数被省略了）。如</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x, y) (x + y)</span></span><br></pre></td></tr></table></figure>
<p>  经过预处理之后，语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = ADD(j, k);</span><br></pre></td></tr></table></figure>
<p>  变成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = (j + k);</span><br></pre></td></tr></table></figure>
<p>  而赋值语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = ADD(,k);</span><br></pre></td></tr></table></figure>
<p>  则变为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = (+k);</span><br></pre></td></tr></table></figure>
<p>2. 当空参数是<code>#</code>或<code>##</code>运算符的操作数时，用法有特殊规定。</p>
<ul>
<li>如果空的实际参数被#运算符“字符串化”，则结果为<code>&quot;&quot;</code>（空字符串）。</li>
<li>如果<code>##</code>运算符之后的一个实际参数为空，它将会被不可见的“位置标记”记号代替。把原始的记号与位置标记记号相连接，得到的还是原始的记号（位置记号消失了）。如果连接两个位置标记记号，得到的是一个位置标记记号。宏扩展完成后，位置标记记号从程序中消失。</li>
</ul>
<h4 id="14-3-11参数个数可变的宏（P237）"><a class="header-anchor" href="#14-3-11参数个数可变的宏（P237）">¶</a>14.3.11参数个数可变的宏（P237）</h4>
<p>  例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(condition, ...) ((condition)?\</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Passed test:%s\n"</span>, #condition): \</span><br><span class="line">    <span class="built_in">printf</span>(__VA_ARGS__))</span><br><span class="line"></span><br><span class="line">TEST(voltage &lt;= max_voltage,</span><br><span class="line">        <span class="string">"Voltage %d exceeds %d\n"</span>, voltage, max_voltage);</span><br></pre></td></tr></table></figure>
<h4 id="14-3-12-func-标识符（P237）"><a class="header-anchor" href="#14-3-12-func-标识符（P237）">¶</a>14.3.12 <code>__func__</code>标识符（P237）</h4>
<p>  其作用相当于在函数体的一开始包含如下声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> __func__[] = <span class="string">"function_name"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="14-5-宏定义"><a class="header-anchor" href="#14-5-宏定义">¶</a>14.5 宏定义</h3>
<h4 id="14-5-1-error指令（P241）"><a class="header-anchor" href="#14-5-1-error指令（P241）">¶</a>14.5.1 <code>#error</code>指令（P241）</h4>
<p>  遇到<code>#error</code>指令预示着程序中出现了严重的错误，有些编译器会立即终止编译而不再检查其它错误。使用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INT_MAX &lt; 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> int type is too small</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="第十四章FAQ（P243）"><a class="header-anchor" href="#第十四章FAQ（P243）">¶</a>第十四章FAQ（P243）</h3>
<ol>
<li><code>#</code>单独占一行为空指令，它没有任何作用。一些程序员用空指令作为条件编译模块之间的间隔：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> INT_MAX &lt; 100000</span></span><br><span class="line">#</span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> int type is too small</span></span><br><span class="line">#</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>2. 建议在下面的条件下使用宏来替代字符或字符串字面量：</p>
<ul>
<li>常量不止一次地使用。</li>
<li>以后可能需要修改常量。</li>
</ul>
<p>3. 如果要被“字符串化”的参数包含&quot;或\字符，#运算符会将&quot;转换为\&quot;，\转换为\\。<br>
4. <font color=red><strong>替换列表中依赖##的宏通常不能嵌套调用</strong></font>。<br>
5. 在执行预处理指令前，先处理注释，并把源代码分为多个预处理记号。因此，<code>#if</code>和<code>#endif</code>之间的未终止的注释引起错误消息。此外，不成对的单引号或双引号字符也可能导致未定义的行为。</p>
<hr>
<h2 id="第十五章-编写大型程序"><a class="header-anchor" href="#第十五章-编写大型程序">¶</a>第十五章 编写大型程序</h2>
<h3 id="15-2-头文件"><a class="header-anchor" href="#15-2-头文件">¶</a>15.2 头文件</h3>
<h4 id="15-2-6-保护头文件（P253）"><a class="header-anchor" href="#15-2-6-保护头文件（P253）">¶</a>15.2.6 保护头文件（P253）</h4>
<p>  如果文件只包含宏定义、函数原型和/或变量声明，那么不会有任何困难。然而，<font color=red><strong>如果文件包含类型定义，则会带来编译错误</strong></font>。为防止头文件多次包含，用<code>#ifndef</code>和<code>#endif</code>指令来封闭文件的内容。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BOOLEAN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOLEAN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="第十五章FAQ（P265）"><a class="header-anchor" href="#第十五章FAQ（P265）">¶</a>第十五章FAQ（P265）</h3>
<p>  共享数组应该按照下列方式声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a[];</span><br></pre></td></tr></table></figure>
<p>  <font color=red><strong>但用下列写法代替是不合法的</strong></font>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> *a;</span><br></pre></td></tr></table></figure>
<p>  虽然<font color=red><strong>在用于表达式时，数组“衰退”成指针</strong></font>。但在变量声明中，数组和指针是截然不同的两种类型。</p>
<hr>
<h2 id="第十六章-结构、联合和枚举"><a class="header-anchor" href="#第十六章-结构、联合和枚举">¶</a>第十六章 结构、联合和枚举</h2>
<h3 id="16-1-结构变量"><a class="header-anchor" href="#16-1-结构变量">¶</a>16.1 结构变量</h3>
<h4 id="16-1-1结构变量的声明（P267）"><a class="header-anchor" href="#16-1-1结构变量的声明（P267）">¶</a>16.1.1结构变量的声明（P267）</h4>
<p>  结构的成员在内存中是按照声明的顺序存储的。</p>
<h4 id="16-1-3指定初始化（P269）"><a class="header-anchor" href="#16-1-3指定初始化（P269）">¶</a>16.1.3指定初始化（P269）</h4>
<p>  示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;.number = <span class="number">528</span>, <span class="string">"Disk drive"</span>, .on_hand = <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure>
<p>  值<code>&quot;Disk drive&quot;</code>的前面并没有指示符，<font color=red><strong>所以编译器会认为它用于初始化结构中位于<code>number</code>之后的成员。初始化式中没有涉及的成员都设为0</strong></font>。</p>
<h4 id="16-1-4对结构的操作（P270）"><a class="header-anchor" href="#16-1-4对结构的操作（P270）">¶</a>16.1.4对结构的操作（P270）</h4>
<ol>
<li>结构可以用<code>=</code>运算符复制。<font color=red><strong>对结构进行复制时，嵌在结构内的数组也得到了复制</strong></font>。一些程序员利用这种性质来产生“空”结构，以封装稍候将进行复制的数组：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">int</span> a[<span class="number">10</span>]; &#125; a1, a2;</span><br><span class="line"> </span><br><span class="line">a1 = a2; <span class="comment">/* legal, since a1 and a2 are structures */</span></span><br></pre></td></tr></table></figure>
<p>2. <font color=red><strong>不能使用运算符<code>==</code>和<code>!=</code>来判定两个结构相等还是不等</strong></font>。</p>
<h3 id="16-3-嵌套的数组和结构"><a class="header-anchor" href="#16-3-嵌套的数组和结构">¶</a>16.3 嵌套的数组和结构</h3>
<h4 id="16-3-3结构数组的初始化（P275）"><a class="header-anchor" href="#16-3-3结构数组的初始化（P275）">¶</a>16.3.3结构数组的初始化（P275）</h4>
<p>  可以有如下初始方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">part</span> <span class="title">inventory</span>[100] = &#123;</span>[<span class="number">0</span>].number = <span class="number">528</span>, [<span class="number">0</span>].on_hand = <span class="number">10</span>, [<span class="number">0</span>].name[<span class="number">0</span>] = <span class="string">'\0'</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="第十六章FAQ（P288）"><a class="header-anchor" href="#第十六章FAQ（P288）">¶</a>第十六章FAQ（P288）</h3>
<ol>
<li>对于在不同文件中定义的结构来说，如果<font color=red><strong>它们的成员具有同样的名字并且顺序一样，且标记相同</strong></font>，那么它们是兼容的，相应的成员类型也是兼容的。<font color=red><strong>具有兼容类型的变量可以互相赋值</strong></font>。</li>
<li>枚举常量的值可以用作下标。</li>
</ol>
<h2 id="第十七章-指针的高级应用"><a class="header-anchor" href="#第十七章-指针的高级应用">¶</a>第十七章 指针的高级应用</h2>
<h3 id="17-3-动态分配数组"><a class="header-anchor" href="#17-3-动态分配数组">¶</a>17.3 动态分配数组</h3>
<h4 id="17-3-2-calloc函数（P300）"><a class="header-anchor" href="#17-3-2-calloc函数（P300）">¶</a>17.3.2 <code>calloc</code>函数（P300）</h4>
<p>  <code>calloc</code>函数会将内存初始化为0，<code>malloc</code>、<code>realloc</code>函数不会。</p>
<h3 id="17-4-释放存储空间"><a class="header-anchor" href="#17-4-释放存储空间">¶</a>17.4 释放存储空间</h3>
<h4 id="17-4-1-free函数（P301）"><a class="header-anchor" href="#17-4-1-free函数（P301）">¶</a>17.4.1 <code>free</code>函数（P301）</h4>
<p>  <font color=red><strong><code>free</code>函数参数可以是空指针，此时<code>free</code>调用不起作用</strong></font>。</p>
<h3 id="17-7-指向函数的指针"><a class="header-anchor" href="#17-7-指向函数的指针">¶</a>17.7 指向函数的指针</h3>
<h4 id="17-7-1函数指针作为参数（P314）"><a class="header-anchor" href="#17-7-1函数指针作为参数（P314）">¶</a>17.7.1函数指针作为参数（P314）</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">integrate</span><span class="params">(<span class="keyword">double</span> (*f)(<span class="keyword">double</span>), <span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>  等同于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">integrate</span><span class="params">(<span class="keyword">double</span> f(<span class="keyword">double</span>), <span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="17-8受限指针（P318）"><a class="header-anchor" href="#17-8受限指针（P318）">¶</a>17.8受限指针（P318）</h3>
<p>  如果指针<code>p</code>指向的对象在之后需要修改，那么该对象不会允许通过除指针<code>p</code>之外的任何方式访问（其它访问对象的方式包括让另一个指针指向同一个对象，或者让指针<code>p</code>指向命名变量）。</p>
<h3 id="第十七章FAQ（P322）"><a class="header-anchor" href="#第十七章FAQ（P322）">¶</a>第十七章FAQ（P322）</h3>
<ol>
<li>两个结构都含有指向对方的指针成员的情况：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span>;</span> <span class="comment">/* incomplete declaration of s1 */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s2</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s1</span> *<span class="title">p</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s2</span> *<span class="title">p</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  <code>s1</code>的第一处声明创建了一个不完整的结构类型，因为我们没有指明s1的成员。`s1的第二处声明通过描述结构的成员“完善”了该类型。</p>
<p>2. 存在惯用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(*p));</span><br></pre></td></tr></table></figure>
<p>  可以避免用错误的参数调用<code>malloc</code>函数（导致分配的内存过大或过小）。因为<code>sizeof</code>并不对<code>*p</code>求值，所以此用法合法。</p>
<h2 id="第十八章-声明"><a class="header-anchor" href="#第十八章-声明">¶</a>第十八章 声明</h2>
<h3 id="18-2-存储类型"><a class="header-anchor" href="#18-2-存储类型">¶</a>18.2 存储类型</h3>
<h4 id="18-2-1变量的性质（P329）"><a class="header-anchor" href="#18-2-1变量的性质（P329）">¶</a>18.2.1变量的性质（P329）</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">       <span class="comment">//|----静态存储期限</span></span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">//+----文件作用域</span></span><br><span class="line">       <span class="comment">//|----外部链接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">           <span class="comment">//|-----自动存储期限</span></span><br><span class="line">    <span class="keyword">int</span> j; <span class="comment">//+-----块作用域</span></span><br><span class="line">           <span class="comment">//|------无链接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="18-2-2-auto存储类型（P329）"><a class="header-anchor" href="#18-2-2-auto存储类型（P329）">¶</a>18.2.2 auto存储类型（P329）</h4>
<p>  <code>auto</code>存储类型只对属于块的变量有效。<code>auto</code>存储类型几乎从来不用明确地指明，因为对于在块内部声明的变量，它是默认的。</p>
<h4 id="18-2-3-static存储类型（P329）"><a class="header-anchor" href="#18-2-3-static存储类型（P329）">¶</a>18.2.3 <code>static</code>存储类型（P329）</h4>
<p>1.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">              <span class="comment">//|----静态存储期限</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i; <span class="comment">//+----文件作用域</span></span><br><span class="line">              <span class="comment">//|----**内部**链接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                  <span class="comment">//|-----**静态**存储期限</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> j; <span class="comment">//+-----块作用域</span></span><br><span class="line">                  <span class="comment">//|------无链接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>`static`的此种用法可以用来实现一种称为信息隐藏的技术。
</code></pre>
<p>2. <code>static</code>变量具有以下一些有趣的性质：</p>
<ul>
<li>块内的<code>static</code>变量只在程序执行前进行一次初始化，而<code>auto</code>变量则会在每次出现时进行初始化（当然，需假设它有初始化式）。</li>
<li><font color=red><strong>每次函数被递归调用时，它都会获得一组新的<code>auto</code>变量。但是，如果函数含有<code>static</code>变量，那么此函数的全部调用都可以共享这个<code>static</code>变量</strong></font>。</li>
<li><font color=red><strong>虽然函数不应该返回指向<code>auto</code>变量的指针，但是函数返回指向<code>static</code>变量的指针是没有错误的</strong></font>。</li>
</ul>
<h4 id="18-2-4-extern存储类型（P330）"><a class="header-anchor" href="#18-2-4-extern存储类型（P330）">¶</a>18.2.4 <code>extern</code>存储类型（P330）</h4>
<p>1. 变量是<code>extern</code>声明不是定义这一规则有一个例外：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>  这条规则可以防止多个<code>extern</code>声明用不同方法对变量进行初始化。<br>
2.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">              <span class="comment">//|----静态存储期限</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">//+----文件作用域</span></span><br><span class="line">              <span class="comment">//|     |----在文件较早的位置（任何函数定义的外部）声明为static，那么它具有内部链接</span></span><br><span class="line">              <span class="comment">//|-----+</span></span><br><span class="line">              <span class="comment">//      |----通常情况下为外部链接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                  <span class="comment">//|-----静态存储期限</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> j; <span class="comment">//+-----块作用域</span></span><br><span class="line">                  <span class="comment">//|-----通常情况下为外部链接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="18-2-5-register存储类型（P331）"><a class="header-anchor" href="#18-2-5-register存储类型（P331）">¶</a>18.2.5 <code>register</code>存储类型（P331）</h4>
<ol>
<li>指明变量的存储类型是<code>register</code>是一种请求，而不是命令。编译器可以选择把<code>register</code>型变量存储在内存中。</li>
<li>由于寄存器没有地址，所以对<code>register</code>变量使用取地址运算符<code>&amp;</code>是非法的。即使编译器选择把变量存储在内存中，这一限制仍适用。</li>
<li><code>register</code>存储类型最好用于需要频繁进行访问或更新的变量。例如，在<code>for</code>语句中的循环控制变量就比较适合声明为<code>register</code>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        sum += a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-4-声明符"><a class="header-anchor" href="#18-4-声明符">¶</a>18.4 声明符</h3>
<h4 id="18-4-1解释复杂声明（P335）"><a class="header-anchor" href="#18-4-1解释复杂声明（P335）">¶</a>18.4.1解释复杂声明（P335）</h4>
<p>  下面两条简单的规则可以用来理解任何声明：</p>
<ul>
<li>始终从内往外读声明符。</li>
<li>在作选择时，始终使<code>[]</code>和<code>()</code>优先于<code>*</code>。</li>
</ul>
<h3 id="18-5初始化式（P337）"><a class="header-anchor" href="#18-5初始化式（P337）">¶</a>18.5初始化式（P337）</h3>
<ol>
<li>控制初始化式的额外规则：</li>
</ol>
<ul>
<li>具有静态存储期限的变量的初始化式必须是常量。</li>
<li>自动存储期限的变量的初始化式不需要是常量。</li>
<li>仅当变量具有静态存储期限时，包含在花括号中的数组、结构或联合的初始化式必须只包含常量表达式，不允许有变量或函数调用。</li>
</ul>
<p>2. 变量的初始化值依赖于变量的存储期限：</p>
<ul>
<li><font color=red><strong>具有自动存储期限的变量没有默认的初始值。不能预测自动变量的初始值，而且每次变量变为有效时值可能不同</strong></font>。</li>
<li>具有静态存储期限的变量默认情况下值为零。用<code>calloc</code>分配的内存是简单的给字节位置零，而静态变量不同于此，它是基于类型的正确初始化，即整型变量初始化为0，浮点变量初始化为0.0，而指针则初始化为空指针。</li>
</ul>
<h3 id="18-6内联函数（P339，本节内容来自C语言inline详细讲解）"><a class="header-anchor" href="#18-6内联函数（P339，本节内容来自C语言inline详细讲解）">¶</a>18.6内联函数（P339，本节内容来自<a href="http://www.cnblogs.com/cnmaizi/archive/2011/01/19/1939686.html" target="_blank" rel="noopener">C语言<code>inline</code>详细讲解</a>）</h3>
<ol>
<li><code>static inline</code>（GCC和C99标准一致）：这个函数大部分表现和普通的<code>static</code>函数一样，只不过在调用这种函数的时候，gcc会在其调用处将其汇编码展开编译而不为这个函数生成独立的汇编码。除了以下几种情况外：</li>
</ol>
<ul>
<li>函数的地址被使用的时候。如通过函数指针对函数进行了间接调用。这种情况下就不得不为<code>static inline</code>函数生成独立的汇编码，否则它没有自己的地址。</li>
<li>其他一些无法展开的情况，比如函数本身有递归调用自身的行为等。</li>
</ul>
<p>2. <code>inline</code>（GCC）：相对于C99的<code>inline</code>来说，GCC的<code>inline</code>更容易理解：可以认为它是一个普通全局函数加上了<code>inline</code>的属性。即在其定义所在文件内，它的表现和<code>static inline</code>一致：在能展开的时候会被内联展开编译。但是为了能够在文件外调用它，gcc一定会为它生成一份独立的汇编码，以便在外部进行调用。即从文件外部看来，它和一个普通的<code>extern</code>的函数无异。<br>
3. <code>extern inline</code>（GCC）：gcc的<code>extern inline</code>十分古怪：一个<code>extern inline</code>的函数只会被内联进去，而绝对不会生成独立的汇编码！即使是通过指针应用或者是递归调用也不会让编译器为它生成汇编码，在这种时候对此函数的调用会被处理成一个外部引用。另外，<code>extern inline</code>的函数允许和外部函数重名，即在存在一个外部定义的全局库函数的情况下，再定义一个同名的<code>extern inline</code>函数也是合法的。以下用例子具体说明一下<code>extern inline</code>的特点：</p>
<p>foo.c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    a = foo(a);   <span class="comment">/* ① */</span></span><br><span class="line">    p_foo = foo;  <span class="comment">/* ② */</span></span><br><span class="line">    b = p_foo(b); <span class="comment">/* ③ */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在这个文件内，gcc不会生成<code>foo</code>函数的汇编码。在<code>func1</code>中的调用点①，编译器会将上面定义的<code>foo</code>函数数在这里内联展开编译，其表现类似于普通<code>inline</code>函数。因为这样的调用是能够进行内联处理的。而在②处，引用了<code>foo</code>函数的地址。但是注意：编译器是绝对不会为<code>extern inline</code>函数生成独立汇编码的！所以在这种非要个函数地址不可的情况下，编译器不得不将其处理为外部引用，在链接的时候链接到外部的<code>foo</code>函数去（填写外部函数的地址）。这时如果外部没有再定义全局的<code>foo</code>函数的话就会在链接时产生<code>foo</code>函数未定义的错误。<br>
假设在另一个文件里面也定义了一个全局函数<code>foo</code>：</p>
<p>foo2.c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  那么在上面那个例子里面，后面一个对<code>foo</code>函数地址的引用就会在链接时被指到这个foo2.c中定义的<code>foo</code>函数去。也就是说：①调用<code>foo</code>函数的结果是<code>a = -a</code>，因为其内联了foo.c内的<code>foo</code>函数；而③调用的结果则是<code>b = b</code>，因为其实际上调用的是foo2.c里面的<code>foo</code>函数！<br>
  gcc的<code>extern inline</code>函数的用法相当奇怪，使用的范围也非常狭窄：几乎没有什么情况会需要用它。 C99中，也没有关于<code>extern inline</code>这样的描述，所以不建议大家使用<code>extern inline</code>，除非你明确理解了这种用法的意义并且有充足的理由使用它！</p>
<p>4. <code>inline</code>（C99标准）：如果一个inline函数在文件范围内没有被声明为<code>extern</code>的话，这个函数在文件内的表现就和gcc的<code>extern inline</code>相似：在本文件内调用时允许编译器使用本文件内定义的这个内联版本，但同时也允许外部存在同名的全局函数。只是比较奇怪的是C99居然没有指定编译器是否必须在本文件内使用这个<code>inline</code>的版本而是让编译器厂家自己来决定，相当模糊的定义。<br>
  <font color=red><strong>如果在文件内把这个<code>inline</code>函数声明为<code>extern</code>，则这个<code>inline</code>函数的表现就和gcc的<code>inline</code>一致了：这个函数即成为一个“external definition”（可以简单理解为全局函数）：可以在外部被调用，并且在程序内仅能存在一个这样名字的定义。</strong></font></p>
<p>5. <code>extern inline</code>（C99标准）：C99标准没有见到<code>extern inline</code>的用法。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>bash 教程</title>
    <url>/2018/10/30/Shell%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1>Shell教程</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="Shell-变量"><a class="header-anchor" href="#Shell-变量">¶</a>Shell 变量</h2>
<ul>
<li><font color=red><strong>变量名和等号之间不能有空格。</strong></font></li>
<li>定义变量时，变量名不加美元符号（$，PHP语言中变量需要）。</li>
<li>使用一个定义过的变量，只要在变量名前面加美元符号即可。</li>
<li>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> skill <span class="keyword">in</span> Ada Coffe Action Java; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"I am good at <span class="variable">$&#123;skill&#125;</span>Script"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="只读变量"><a class="header-anchor" href="#只读变量">¶</a>只读变量</h3>
<p>使用<code>readonly</code>命令可以将变量 定义为只读变量，只读变量的值不能被改变。<br>
下面的例子尝试更改只读变量，结果报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">myUrl=<span class="string">"http://www.google.com"</span></span><br><span class="line"><span class="built_in">readonly</span> myUrl</span><br><span class="line">myUrl=<span class="string">"http://www.runoob.com"</span></span><br></pre></td></tr></table></figure>
<p>运行脚本，结果如下：</p>
<blockquote>
<p>/bin/sh: NAME: This variable is read only.</p>
</blockquote>
<h3 id="删除变量"><a class="header-anchor" href="#删除变量">¶</a>删除变量</h3>
<p>使用<code>unset</code>命令可以删除变量。语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> variable_name</span><br></pre></td></tr></table></figure>
<p><strong><code>unset</code>命令不能删除只读变量。</strong></p>
<h3 id="变量类型"><a class="header-anchor" href="#变量类型">¶</a>变量类型</h3>
<p>运行shell时，会同时存在三种变量：</p>
<ol>
<li><strong>局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell中有效，其它shell启动的程序不能访问局部变量。</li>
<li><strong>环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
<li><strong>shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。</li>
</ol>
<hr>
<h2 id="Shell字符串"><a class="header-anchor" href="#Shell字符串">¶</a>Shell字符串</h2>
<ul>
<li>
<p>字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
</li>
<li>
<p><font color=red><strong>单引号把内容当成纯文本，不会经过翻译。而双引号则与此相反。里面的内容会经过处理。</strong></font>举个简单的例子：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$foo</span>=<span class="string">"data"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$foo'</span>    <span class="comment">#单引号输出$foo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$foo</span>"</span>    <span class="comment">#双引号输出data</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>单引号不能处理变量和黑底字符<font color=red><strong>（除了\\和\'这两个）</strong></font></p>
</li>
</ul>
<h3 id="单引号"><a class="header-anchor" href="#单引号">¶</a>单引号</h3>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li><font color=red><strong>单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</strong></font></li>
</ul>
<h3 id="双引号"><a class="header-anchor" href="#双引号">¶</a>双引号</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">'runoob'</span></span><br><span class="line">str=<span class="string">"Hello, I know you are \"<span class="variable">$your_name</span>\"! \n"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<blockquote>
<p>Hello, I know you are “runoob”!</p>
</blockquote>
<p>双绰号的优点：</p>
<ul>
<li>双引号里可以有变量。</li>
<li>双引号里可以出现转义字符。</li>
</ul>
<h3 id="拼接字符串"><a class="header-anchor" href="#拼接字符串">¶</a>拼接字符串</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">your_name=<span class="string">"runoob"</span></span><br><span class="line"><span class="comment">#使用双引号</span></span><br><span class="line">greeting=<span class="string">"hello, "</span><span class="variable">$your_name</span><span class="string">" !"</span></span><br><span class="line">greeting_1=<span class="string">"hello, <span class="variable">$&#123;your_name&#125;</span> !"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting</span> <span class="variable">$greeting_1</span></span><br><span class="line"><span class="comment">#使用单引号拼接</span></span><br><span class="line">greeting_2=<span class="string">'hello, '</span><span class="variable">$your_name</span><span class="string">' !'</span></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<blockquote>
<p>hello, runoob ! hello, runob !<br>
hello, runoob ! hello, ${your_name} !</p>
</blockquote>
<h3 id="获取字符串长度"><a class="header-anchor" href="#获取字符串长度">¶</a>获取字符串长度</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">string=<span class="string">"abcd"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span> <span class="comment">#输出4</span></span><br></pre></td></tr></table></figure>
<h3 id="提取子字符串"><a class="header-anchor" href="#提取子字符串">¶</a>提取子字符串</h3>
<p>以下实例从字符串第2个字符开始截取4个字符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">string=<span class="string">"runoob is a great site"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:1:4&#125;</span> <span class="comment">#输出unoo</span></span><br></pre></td></tr></table></figure>
<h3 id="查找子字符串"><a class="header-anchor" href="#查找子字符串">¶</a>查找子字符串</h3>
<p>查找字符i或o的位置（哪个字母先出现就计算哪个）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">string=<span class="string">"runoob is a great site"</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">"<span class="variable">$string</span>"</span> io`</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Shell数组"><a class="header-anchor" href="#Shell数组">¶</a>Shell数组</h2>
<p>bash不支持多维数组。</p>
<h3 id="定义数组"><a class="header-anchor" href="#定义数组">¶</a>定义数组</h3>
<p>在shell中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">数组名=(值1 值2 ... 值n)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>还可以单独定义数组的各个分量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br></pre></td></tr></table></figure>
<p>可以不使用连续的下标，而且下标的范围没有限制。</p>
<h3 id="读取数组"><a class="header-anchor" href="#读取数组">¶</a>读取数组</h3>
<p>读取数组元素值的一般格式是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;数组名[下标]&#125;</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">valuen=<span class="variable">$&#123;array_name[n]&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以使用<code>@</code>符号可以获取数组中的所有元素，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_name[@]&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="获取数组的长度"><a class="header-anchor" href="#获取数组的长度">¶</a>获取数组的长度</h3>
<p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#取得数组元素的个数</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[@]&#125;</span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[*]&#125;</span></span><br><span class="line"><span class="comment">#取得数组单个元素的长度</span></span><br><span class="line">lengthn=<span class="variable">$&#123;#array_name[n]&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Shell注释"><a class="header-anchor" href="#Shell注释">¶</a>Shell注释</h2>
<h3 id="多行注释"><a class="header-anchor" href="#多行注释">¶</a>多行注释</h3>
<ul>
<li>
<p>用一对花括号括起来。</p>
</li>
<li>
<p>定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p>
</li>
<li>
<p>还可以使用以下格式：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>EOF也可以使用其它符号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;<span class="string">'</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line"></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容</span><br><span class="line">!</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Shell传递参数"><a class="header-anchor" href="#Shell传递参数">¶</a>Shell传递参数</h2>
<p>脚本内获取参数的格式为：<code>$n</code>。n代表一个数字，1为执行脚本的第一个参数，2为执行脚本的第二个参数，以此类推……</p>
<h3 id="实例"><a class="header-anchor" href="#实例">¶</a>实例</h3>
<p>以下实例我们向脚本传递三个参数，并分别输出，其中$0为执行的文件名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#author: 菜鸟教程</span></span><br><span class="line"><span class="comment">#url: www.runoob.com</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Shell 传递参数实例！"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"执行的文件名：<span class="variable">$0</span>"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第一个参数为：<span class="variable">$1</span>"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第二个参数为：<span class="variable">$2</span>"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第三个参数为：<span class="variable">$3</span>"</span>;</span><br></pre></td></tr></table></figure>
<p>为脚本设置可以执行权限，并执行脚本，输出结果如下所示：</p>
<blockquote>
<p>$ chmod +x <a href="http://test.sh" target="_blank" rel="noopener">test.sh</a><br>
$ ./test.sh 1 2 3<br>
Shell传递参数实例！<br>
执行的文件名：./test.sh<br>
第一个参数为：1<br>
第二个参数为：2<br>
第三个参数为：3</p>
</blockquote>
<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数处理</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$#</td>
<td style="text-align:left">传递到脚本的参数个数</td>
</tr>
<tr>
<td style="text-align:left">$^</td>
<td style="text-align:left">以一个单字符串显示所有向脚本传递的参数。<br>如&quot;$*“用「”」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。</td>
</tr>
<tr>
<td style="text-align:left">$$</td>
<td style="text-align:left">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td style="text-align:left">$!</td>
<td style="text-align:left">后台运行的最后一个进程ID号</td>
</tr>
<tr>
<td style="text-align:left">$@</td>
<td style="text-align:left">与$*相同，但是使用时加引号，并在引号中返回每个参数。<br>如&quot;$@“用「”」括起来的情况、以&quot;$1&quot; “$2” … &quot;$n&quot;的形式输出所有参数。</td>
</tr>
<tr>
<td style="text-align:left">$-</td>
<td style="text-align:left">显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td style="text-align:left">$?</td>
<td style="text-align:left">显示最后命令的退出状态。0表示没有错误，其它任何值表明有错误。</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#author: 菜鸟教程</span></span><br><span class="line"><span class="comment">#url: www.runoob.com</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Shell传递参数实例！"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第一个参数为：<span class="variable">$1</span>"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"参数个数为：<span class="variable">$#</span>"</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"传递的参数作为一个字符串显示：$*"</span>;</span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>$ chmod +x <a href="http://test.sh" target="_blank" rel="noopener">test.sh</a><br>
./test/sh 1 2 3<br>
Shell传递参数实例！<br>
第一个参数为：1<br>
参数个数为：3<br>
传递参数作为一个字符串显示：1 2 3</p>
</blockquote>
<p><code>$*</code>与<code>$@</code>区别：</p>
<ul>
<li>相同点：都是引用所有参数。</li>
<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数1、2、3,则<code>$*</code>等价于“1 2 3”（传递了一个参数），而<code>$@</code>等价于&quot;1&quot; “2” “3”（传递了三个参数）。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#author: 菜鸟教程</span></span><br><span class="line"><span class="comment">#url: www.runoob.com</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"-- \$* 演示 ---"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"$*"</span>; <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"-- \$@ 演示 ---"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Shell数组-v2"><a class="header-anchor" href="#Shell数组-v2">¶</a>Shell数组</h2>
<p>数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。<br>
与大部分编程语言类似，数组元素的下标由0开始。<br>
Shell 数组用括号来表示，元素用&quot;空格&quot;符号分割开，语法格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array_name=(value1 ... valuen)</span><br></pre></td></tr></table></figure>
<h4 id="实例-v2"><a class="header-anchor" href="#实例-v2">¶</a>实例</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line">my_array=(A B <span class="string">"C"</span> D)</span><br></pre></td></tr></table></figure>
<p>我们也可以使用下标来定义数组:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br></pre></td></tr></table></figure>
<h3 id="读取数组-v2"><a class="header-anchor" href="#读取数组-v2">¶</a>读取数组</h3>
<p>读取数组元素值的一般格式是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;array_name[index]&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="实例-v3"><a class="header-anchor" href="#实例-v3">¶</a>实例</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line">my_array=(A B <span class="string">"C"</span> D)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第一个元素为: <span class="variable">$&#123;my_array[0]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第二个元素为: <span class="variable">$&#123;my_array[1]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第三个元素为: <span class="variable">$&#123;my_array[2]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"第四个元素为: <span class="variable">$&#123;my_array[3]&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>$ chmod +x <a href="http://test.sh" target="_blank" rel="noopener">test.sh</a><br>
$ ./test.sh<br>
第一个元素为: A<br>
第二个元素为: B<br>
第三个元素为: C<br>
第四个元素为: D</p>
</blockquote>
<h3 id="获取数组中的所有元素"><a class="header-anchor" href="#获取数组中的所有元素">¶</a>获取数组中的所有元素</h3>
<p>使用<code>@</code> 或 <code>*</code> 可以获取数组中的所有元素，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line">my_array[0]=A</span><br><span class="line">my_array[1]=B</span><br><span class="line">my_array[2]=C</span><br><span class="line">my_array[3]=D</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"数组的元素为: <span class="variable">$&#123;my_array[*]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"数组的元素为: <span class="variable">$&#123;my_array[@]&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>$ chmod +x <a href="http://test.sh" target="_blank" rel="noopener">test.sh</a><br>
$ ./test.sh<br>
数组的元素为: A B C D<br>
数组的元素为: A B C D</p>
</blockquote>
<h3 id="获取数组的长度-v2"><a class="header-anchor" href="#获取数组的长度-v2">¶</a>获取数组的长度</h3>
<p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line">my_array[0]=A</span><br><span class="line">my_array[1]=B</span><br><span class="line">my_array[2]=C</span><br><span class="line">my_array[3]=D</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"数组元素个数为: <span class="variable">$&#123;#my_array[*]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"数组元素个数为: <span class="variable">$&#123;#my_array[@]&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>$ chmod +x <a href="http://test.sh" target="_blank" rel="noopener">test.sh</a><br>
$ ./test.sh<br>
数组元素个数为: 4<br>
数组元素个数为: 4</p>
</blockquote>
<hr>
<h2 id="Shell-基本运算符"><a class="header-anchor" href="#Shell-基本运算符">¶</a>Shell 基本运算符</h2>
<p>Shell 和其他编程语言一样，支持多种运算符，包括：</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符</li>
</ul>
<p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 <code>awk</code> 和 <code>expr</code>，<code>expr</code> 最常用。<br>
<code>expr</code> 是一款表达式计算工具，使用它能完成表达式的求值操作。<br>
例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ')：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">val=`expr 2 + 2`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"两数之和为 : <span class="variable">$val</span>"</span></span><br></pre></td></tr></table></figure>
<p><a href="http://www.runoob.com/try/runcode.php?filename=add2data&amp;type=bash" target="_blank" rel="noopener">运行实例 »</a></p>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>两数之和为 : 4</p>
</blockquote>
<p>两点注意：</p>
<ul>
<li><font color=red><strong>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</strong></font></li>
<li>完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li>
</ul>
<h3 id="算术运算符"><a class="header-anchor" href="#算术运算符">¶</a>算术运算符</h3>
<p>下表列出了常用的算术运算符，假定变量 <code>a</code> 为 10，变量 <code>b</code> 为 20：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">加法</td>
<td style="text-align:left">`expr $a + $b` 结果为 30。</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">减法</td>
<td style="text-align:left">`expr $a - $b` 结果为 -10。</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">乘法</td>
<td style="text-align:left">`expr $a * $b` 结果为  200。</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:left">除法</td>
<td style="text-align:left">`expr $b / $a` 结果为 2。</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">取余</td>
<td style="text-align:left">`expr $b % $a` 结果为 0。</td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">赋值</td>
<td style="text-align:left">a=$b 将把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">相等。用于比较两个数字，相同则返回 <code>true。</code></td>
<td style="text-align:left">[ $a == $b ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">不相等。用于比较两个数字，不相同则返回 <code>true</code>。</td>
<td style="text-align:left">[ $a != $b ] 返回 <code>true</code>。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：<strong>条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成<font color=red></strong>[ $a == $b ]</strong></font>。</p>
</blockquote>
<h4 id="实例-v4"><a class="header-anchor" href="#实例-v4">¶</a>实例</h4>
<p>算术运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$a</span> + <span class="variable">$b</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a + b : <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$a</span> - <span class="variable">$b</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a - b : <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$a</span> \* <span class="variable">$b</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a * b : <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$b</span> / <span class="variable">$a</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"b / a : <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line">val=`expr <span class="variable">$b</span> % <span class="variable">$a</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"b % a : <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a 等于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a 不等于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>a + b : 30<br>
a - b : -10<br>
a * b : 200<br>
b / a : 2<br>
b % a : 0<br>
a 不等于 b</p>
</blockquote>
<hr>
<blockquote>
<p>注意：</p>
<ul>
<li><font color=red><strong>乘号(*)前边必须加反斜杠(\)才能实现乘法运算</strong></font>；</li>
<li><code>if</code>…<code>then.</code>…<code>fi</code> 是条件语句，后续将会讲解。</li>
<li>在 MAC 中 shell 的 <code>expr</code> 语法是：<code>$((表达式))</code>，此处表达式中的 “*” 不需要转义符号 “” 。</li>
</ul>
</blockquote>
<h3 id="关系运算符"><a class="header-anchor" href="#关系运算符">¶</a>关系运算符</h3>
<p><font color=red><strong>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</strong></font></p>
<p>下表列出了常用的关系运算符，假定变量 <code>a</code> 为 10，变量 <code>b</code> 为 20：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-eq</td>
<td style="text-align:left">检测两个数是否相等，相等返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -eq $b ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-ne</td>
<td style="text-align:left">检测两个数是否不相等，不相等返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -ne $b ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-gt</td>
<td style="text-align:left">检测左边的数是否大于右边的，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -gt $b ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-lt</td>
<td style="text-align:left">检测左边的数是否小于右边的，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -lt $b ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-ge</td>
<td style="text-align:left">检测左边的数是否大于等于右边的，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -ge $b ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-le</td>
<td style="text-align:left">检测左边的数是否小于等于右边的，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -le $b ] 返回 <code>true</code>。</td>
</tr>
</tbody>
</table>
<h4 id="实例-v5"><a class="header-anchor" href="#实例-v5">¶</a>实例</h4>
<p>关系运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -eq <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -eq <span class="variable">$b</span> : a 等于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -eq <span class="variable">$b</span>: a 不等于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -ne <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -ne <span class="variable">$b</span>: a 不等于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -ne <span class="variable">$b</span> : a 等于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -gt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -gt <span class="variable">$b</span>: a 大于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -gt <span class="variable">$b</span>: a 不大于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -lt <span class="variable">$b</span>: a 小于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -lt <span class="variable">$b</span>: a 不小于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -ge <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -ge <span class="variable">$b</span>: a 大于或等于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -ge <span class="variable">$b</span>: a 小于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -le <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -le <span class="variable">$b</span>: a 小于或等于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -le <span class="variable">$b</span>: a 大于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>10 -eq 20: a 不等于 b<br>
10 -ne 20: a 不等于 b<br>
10 -gt 20: a 不大于 b<br>
10 -lt 20: a 小于 b<br>
10 -ge 20: a 小于 b<br>
10 -le 20: a 小于或等于 b</p>
</blockquote>
<h3 id="布尔运算符"><a class="header-anchor" href="#布尔运算符">¶</a>布尔运算符</h3>
<p>下表列出了常用的布尔运算符，假定变量 <code>a</code> 为 10，变量 <code>b</code> 为 20：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">!</td>
<td style="text-align:left">非运算，表达式为 <code>true</code> 则返回 <code>false</code>，否则返回 <code>true</code>。</td>
<td style="text-align:left">[ ! false ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-o</td>
<td style="text-align:left">或运算，有一个表达式为 <code>true</code> 则返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -lt 20 -o $b -gt 100 ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-a</td>
<td style="text-align:left">与运算，两个表达式都为 <code>true</code> 才返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -lt 20 -a $b -gt 100 ] 返回 <code>false</code>。</td>
</tr>
</tbody>
</table>
<h4 id="实例-v6"><a class="header-anchor" href="#实例-v6">¶</a>实例</h4>
<p>布尔运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span> : a 不等于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span>: a 等于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 100 -a <span class="variable">$b</span> -gt 15 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 100 且 <span class="variable">$b</span> 大于 15 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 100 且 <span class="variable">$b</span> 大于 15 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 100 -o <span class="variable">$b</span> -gt 100 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 100 或 <span class="variable">$b</span> 大于 100 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 100 或 <span class="variable">$b</span> 大于 100 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 5 -o <span class="variable">$b</span> -gt 100 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 5 或 <span class="variable">$b</span> 大于 100 : 返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 5 或 <span class="variable">$b</span> 大于 100 : 返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>10 != 20 : a 不等于 b<br>
10 小于 100 且 20 大于 15 : 返回 true<br>
10 小于 100 或 20 大于 100 : 返回 true<br>
10 小于 5 或 20 大于 100 : 返回 false</p>
</blockquote>
<h3 id="逻辑运算符"><a class="header-anchor" href="#逻辑运算符">¶</a>逻辑运算符</h3>
<p>以下介绍 Shell 的逻辑运算符，假定变量 <code>a</code> 为 10，变量 <code>b</code> 为 20:</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&amp;&amp;</td>
<td style="text-align:left">逻辑的 AND</td>
<td style="text-align:left">[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 <code>false</code></td>
</tr>
<tr>
<td style="text-align:left">||</td>
<td style="text-align:left">逻辑的 OR</td>
<td style="text-align:left">[[ $a -lt 100 || $b -gt 100 ]] 返回 <code>true</code></td>
</tr>
</tbody>
</table>
<h4 id="实例-v7"><a class="header-anchor" href="#实例-v7">¶</a>实例</h4>
<p>逻辑运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> -lt 100 &amp;&amp; <span class="variable">$b</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> -lt 100 || <span class="variable">$b</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"返回 true"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"返回 false"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>返回 false<br>
返回 true</p>
</blockquote>
<h3 id="字符串运算符"><a class="header-anchor" href="#字符串运算符">¶</a>字符串运算符</h3>
<p>下表列出了常用的字符串运算符，假定变量 <code>a</code> 为 “abc”，变量 <code>b</code> 为 “efg”：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">检测两个字符串是否相等，相等返回 <code>true</code>。</td>
<td style="text-align:left">[ $a = $b ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">检测两个字符串是否相等，不相等返回 <code>true</code>。</td>
<td style="text-align:left">[ $a != $b ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-z</td>
<td style="text-align:left">检测字符串长度是否为0，为0返回 <code>true</code>。</td>
<td style="text-align:left">[ -z $a ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-n</td>
<td style="text-align:left">检测字符串长度是否为0，不为0返回 <code>true</code>。</td>
<td style="text-align:left">[ -n “$a” ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">str</td>
<td style="text-align:left">检测字符串是否为空，不为空返回 <code>true</code>。</td>
<td style="text-align:left">[ $a ] 返回 <code>true</code>。</td>
</tr>
</tbody>
</table>
<h4 id="实例-v8"><a class="header-anchor" href="#实例-v8">¶</a>实例</h4>
<p>字符串运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">"abc"</span></span><br><span class="line">b=<span class="string">"efg"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> = <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> = <span class="variable">$b</span> : a 等于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> = <span class="variable">$b</span>: a 不等于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span> : a 不等于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> != <span class="variable">$b</span>: a 等于 b"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$a</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$a</span> : 字符串长度为 0"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-z <span class="variable">$a</span> : 字符串长度不为 0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$a</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$a</span> : 字符串长度不为 0"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"-n <span class="variable">$a</span> : 字符串长度为 0"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> : 字符串不为空"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> : 字符串为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>abc = efg: a 不等于 b<br>
abc != efg : a 不等于 b<br>
-z abc : 字符串长度不为 0<br>
-n abc : 字符串长度不为 0<br>
abc : 字符串不为空</p>
</blockquote>
<h3 id="文件测试运算符"><a class="header-anchor" href="#文件测试运算符">¶</a>文件测试运算符</h3>
<p>文件测试运算符用于检测 Unix 文件的各种属性。<br>
属性检测描述如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-b file</td>
<td style="text-align:left">检测文件是否是块设备文件，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -b $file ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-c file</td>
<td style="text-align:left">检测文件是否是字符设备文件，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -c $file ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-d file</td>
<td style="text-align:left">检测文件是否是目录，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -d $file ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-f file</td>
<td style="text-align:left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -f $file ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-g file</td>
<td style="text-align:left">检测文件是否设置了 <code>SGID</code> 位，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -g $file ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-k file</td>
<td style="text-align:left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -k $file ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-p file</td>
<td style="text-align:left">检测文件是否是有名管道，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -p $file ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-u file</td>
<td style="text-align:left">检测文件是否设置了 <code>SUID</code> 位，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -u $file ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-r file</td>
<td style="text-align:left">检测文件是否可读，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -r $file ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-w file</td>
<td style="text-align:left">检测文件是否可写，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -w $file ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-x file</td>
<td style="text-align:left">检测文件是否可执行，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -x $file ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-s file</td>
<td style="text-align:left">检测文件是否为空（文件大小是否大于0），不为空返回 <code>true</code>。</td>
<td style="text-align:left">[ -s $file ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-e file</td>
<td style="text-align:left">检测文件（包括目录）是否存在，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -e $file ] 返回 <code>true</code>。</td>
</tr>
</tbody>
</table>
<h4 id="实例-v9"><a class="header-anchor" href="#实例-v9">¶</a>实例</h4>
<p>变量 file 表示文件&quot;/var/www/runoob/test.sh&quot;，它的大小为100字节，具有 <code>rwx</code> 权限。下面的代码，将检测该文件的各种属性：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line">file=<span class="string">"/var/www/runoob/test.sh"</span></span><br><span class="line"><span class="keyword">if</span> [ -r <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件可读"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件不可读"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -w <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件可写"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件不可写"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -x <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件可执行"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件不可执行"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件为普通文件"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件为特殊文件"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件是个目录"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件不是个目录"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -s <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件不为空"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件为空"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$file</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件存在"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"文件不存在"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>文件可读<br>
文件可写<br>
文件可执行<br>
文件为普通文件<br>
文件不是个目录<br>
文件不为空<br>
文件存在</p>
</blockquote>
<hr>
<h2 id="Shell-echo命令"><a class="header-anchor" href="#Shell-echo命令">¶</a>Shell echo命令</h2>
<p>Shell 的 <code>echo</code> 指令与 PHP 的 <code>echo</code> 指令类似，都是用于字符串的输出。命令格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> string</span><br></pre></td></tr></table></figure>
<p>您可以使用<code>echo</code>实现更复杂的输出格式控制。</p>
<h3 id="1-显示普通字符串"><a class="header-anchor" href="#1-显示普通字符串">¶</a>1. 显示普通字符串:</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"It is a test"</span></span><br></pre></td></tr></table></figure>
<p>这里的双引号完全可以省略，以下命令与上面实例效果一致：</p>
<blockquote>
<p>echo It is a test</p>
</blockquote>
<h3 id="2-显示转义字符"><a class="header-anchor" href="#2-显示转义字符">¶</a>2. 显示转义字符</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"\"It is a test\""</span></span><br></pre></td></tr></table></figure>
<p>结果将是:</p>
<blockquote>
<p>“It is a test”</p>
</blockquote>
<p>同样，双引号也可以省略</p>
<h3 id="3-显示变量"><a class="header-anchor" href="#3-显示变量">¶</a>3. 显示变量</h3>
<p><code>read</code> 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">read</span> name </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$name</span> It is a test"</span></span><br></pre></td></tr></table></figure>
<p>以上代码保存为 <a href="http://test.sh" target="_blank" rel="noopener">test.sh</a>，<code>name</code> 接收标准输入的变量，结果将是:</p>
<blockquote>
<p>[root@www ~]# sh <a href="http://test.sh" target="_blank" rel="noopener">test.sh</a><br>
OK                     #标准输入<br>
OK It is a test        #输出</p>
</blockquote>
<h3 id="4-显示换行"><a class="header-anchor" href="#4-显示换行">¶</a>4. 显示换行</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"OK! \n"</span> <span class="comment"># -e 开启转义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"It is a test"</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>OK!</p>
</blockquote>
<blockquote>
<p>It is a test</p>
</blockquote>
<h3 id="5-显示不换行"><a class="header-anchor" href="#5-显示不换行">¶</a>5. 显示不换行</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"OK! \c"</span> <span class="comment"># -e 开启转义 \c 不换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"It is a test"</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>OK! It is a test</p>
</blockquote>
<h3 id="6-显示结果定向至文件"><a class="header-anchor" href="#6-显示结果定向至文件">¶</a>6. 显示结果定向至文件</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"It is a test"</span> &gt; myfile</span><br></pre></td></tr></table></figure>
<h3 id="7-原样输出字符串，不进行转义或取变量-用单引号"><a class="header-anchor" href="#7-原样输出字符串，不进行转义或取变量-用单引号">¶</a>7. 原样输出字符串，不进行转义或取变量(用单引号)</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'$name\"'</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>$name&quot;</p>
</blockquote>
<h3 id="8-显示命令执行结果"><a class="header-anchor" href="#8-显示命令执行结果">¶</a>8. 显示命令执行结果</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> `date`</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 这里使用的是反引号 `, 而不是单引号 '。</p>
<p>结果将显示当前日期</p>
<blockquote>
<p>Thu Jul 24 10:08:46 CST 2014</p>
</blockquote>
<hr>
<h2 id="Shell-printf-命令"><a class="header-anchor" href="#Shell-printf-命令">¶</a>Shell printf 命令</h2>
<p>上一章节我们学习了 Shell 的 <code>echo</code> 命令，本章节我们来学习 Shell 的另一个输出命令 <code>printf</code>。<br>
<code>printf</code> 命令模仿 C 程序库（library）里的 <code>printf()</code> 程序。<br>
<code>printf</code> 由 POSIX 标准所定义，因此使用 <code>printf</code> 的脚本比使用 <code>echo</code> 移植性好。<br>
<code>printf</code> 使用引用文本或空格分隔的参数，外面可以在 <code>printf</code> 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 <code>printf</code> 不会像 <code>echo</code> 自动添加换行符，我们可以手动添加 <code>\n</code>。<br>
<code>printf</code> 命令的语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>  format-string  [arguments...]</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>format-string: 为格式控制字符串</li>
<li>arguments: 为参数列表。</li>
</ul>
<p>实例如下：</p>
<blockquote>
<p>$ echo “Hello, Shell”<br>
Hello, Shell<br>
$ printf “Hello, Shell\n”<br>
Hello, Shell<br>
$</p>
</blockquote>
<p>接下来,我来用一个脚本来体现printf的强大功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4s\n"</span> 姓名 性别 体重kg  </span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 郭靖 男 66.1234 </span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 杨过 男 48.6543 </span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span> 郭芙 女 47.9876</span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>姓名     性别   体重kg<br>
郭靖     男      66.12<br>
杨过     男      48.65<br>
郭芙     女      47.99</p>
</blockquote>
<p><code>%s</code> <code>%c</code> <code>%d</code> <code>%f</code>都是格式替代符<br>
<code>%-10s</code> 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。<br>
<code>%-4.2f</code> 指格式化为小数，其中.2指保留2位小数。</p>
<p>更多实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># format-string为双引号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%d %s\n"</span> 1 <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单引号与双引号效果一样 </span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'%d %s\n'</span> 1 <span class="string">"abc"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有引号也可以输出</span></span><br><span class="line"><span class="built_in">printf</span> %s abcdef</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用</span></span><br><span class="line"><span class="built_in">printf</span> %s abc def</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s\n"</span> abc def</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s %s %s\n"</span> a b c d e f g h i j</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%s and %d \n"</span></span><br></pre></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>1 abc<br>
1 abc<br>
abcdefabcdefabc<br>
def<br>
a b c<br>
d e f<br>
g h i<br>
j<br>
and 0</p>
</blockquote>
<h3 id="printf的转义序列"><a class="header-anchor" href="#printf的转义序列">¶</a><code>printf</code>的转义序列</h3>
<table>
<thead>
<tr>
<th style="text-align:left">序列</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\a</td>
<td style="text-align:left">警告字符，通常为ASCII的BEL字符</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">后退</td>
</tr>
<tr>
<td style="text-align:left">\c</td>
<td style="text-align:left">抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td>
</tr>
<tr>
<td style="text-align:left">\f</td>
<td style="text-align:left">换页（formfeed）</td>
</tr>
<tr>
<td style="text-align:left">\n</td>
<td style="text-align:left">换行</td>
</tr>
<tr>
<td style="text-align:left">\r</td>
<td style="text-align:left">回车（Carriage return）</td>
</tr>
<tr>
<td style="text-align:left">\t</td>
<td style="text-align:left">水平制表符</td>
</tr>
<tr>
<td style="text-align:left">\v</td>
<td style="text-align:left">垂直制表符</td>
</tr>
<tr>
<td style="text-align:left">\\</td>
<td style="text-align:left">一个字面上的反斜杠字符</td>
</tr>
<tr>
<td style="text-align:left">\ddd</td>
<td style="text-align:left">表示1到3位数八进制值的字符。仅在格式字符串中有效</td>
</tr>
<tr>
<td style="text-align:left">\0ddd</td>
<td style="text-align:left">表示1到3位的八进制值字符</td>
</tr>
</tbody>
</table>
<p>实例</p>
<blockquote>
<p>$ printf “a string, no processing:&lt;%s&gt;\n” “A\nB”<br>
a string, no processing:&lt;A\nB&gt;</p>
</blockquote>
<blockquote>
<p>$ printf “a string, no processing:&lt;%b&gt;\n” “A\nB”<br>
a string, no processing:<A
B></p>
</blockquote>
<blockquote>
<p>$ printf “<a href="http://www.runoob.com" target="_blank" rel="noopener">www.runoob.com</a> \a”<br>
<a href="http://www.runoob.com" target="_blank" rel="noopener">www.runoob.com</a> $                  #不换行</p>
</blockquote>
<hr>
<h2 id="Shell-test-命令"><a class="header-anchor" href="#Shell-test-命令">¶</a>Shell <code>test</code> 命令</h2>
<p>Shell中的 <code>test</code> 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>
<h3 id="数值测试"><a class="header-anchor" href="#数值测试">¶</a>数值测试</h3>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-eq</td>
<td style="text-align:left">等于则为真</td>
</tr>
<tr>
<td style="text-align:left">-ne</td>
<td style="text-align:left">不等于则为真</td>
</tr>
<tr>
<td style="text-align:left">-gt</td>
<td style="text-align:left">大于则为真</td>
</tr>
<tr>
<td style="text-align:left">-ge</td>
<td style="text-align:left">大于等于则为真</td>
</tr>
<tr>
<td style="text-align:left">-lt</td>
<td style="text-align:left">小于则为真</td>
</tr>
<tr>
<td style="text-align:left">-le</td>
<td style="text-align:left">小于等于则为真</td>
</tr>
</tbody>
</table>
<h4 id="实例演示："><a class="header-anchor" href="#实例演示：">¶</a>实例演示：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> $[num1] -eq $[num2]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个数相等！'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个数不相等！'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>两个数相等！</p>
</blockquote>
<p>代码中的 [] 执行基本的算数运算，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=5</span><br><span class="line">b=6</span><br><span class="line"></span><br><span class="line">result=$[a+b] <span class="comment"># 注意等号两边不能有空格</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"result 为： <span class="variable">$result</span>"</span></span><br></pre></td></tr></table></figure>
<p>结果为:</p>
<blockquote>
<p>result 为： 11</p>
</blockquote>
<h3 id="字符串测试"><a class="header-anchor" href="#字符串测试">¶</a>字符串测试</h3>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">等于则为真</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">不相等则为真</td>
</tr>
<tr>
<td style="text-align:left">-z 字符串</td>
<td style="text-align:left">字符串的长度为零则为真</td>
</tr>
<tr>
<td style="text-align:left">-n 字符串</td>
<td style="text-align:left">字符串的长度不为零则为真</td>
</tr>
</tbody>
</table>
<p>实例演示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">num1=<span class="string">"ru1noob"</span></span><br><span class="line">num2=<span class="string">"runoob"</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$num1</span> = <span class="variable">$num2</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个字符串相等!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个字符串不相等!'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>两个字符串不相等!</p>
</blockquote>
<h3 id="文件测试"><a class="header-anchor" href="#文件测试">¶</a>文件测试</h3>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-e 文件名</td>
<td style="text-align:left">如果文件存在则为真</td>
</tr>
<tr>
<td style="text-align:left">-r 文件名</td>
<td style="text-align:left">如果文件存在且可读则为真</td>
</tr>
<tr>
<td style="text-align:left">-w 文件名</td>
<td style="text-align:left">如果文件存在且可写则为真</td>
</tr>
<tr>
<td style="text-align:left">-x 文件名</td>
<td style="text-align:left">如果文件存在且可执行则为真</td>
</tr>
<tr>
<td style="text-align:left">-s 文件名</td>
<td style="text-align:left">如果文件存在且至少有一个字符则为真</td>
</tr>
<tr>
<td style="text-align:left">-d 文件名</td>
<td style="text-align:left">如果文件存在且为目录则为真</td>
</tr>
<tr>
<td style="text-align:left">-f 文件名</td>
<td style="text-align:left">如果文件存在且为普通文件则为真</td>
</tr>
<tr>
<td style="text-align:left">-c 文件名</td>
<td style="text-align:left">如果文件存在且为字符型特殊文件则为真</td>
</tr>
<tr>
<td style="text-align:left">-b 文件名</td>
<td style="text-align:left">如果文件存在且为块特殊文件则为真</td>
</tr>
</tbody>
</table>
<p>实例演示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /bin</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -e ./bash</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'文件已存在!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'文件不存在!'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>文件已存在!</p>
</blockquote>
<p>另外，Shell还提供了与( <code>-a</code> )、或( <code>-o </code>)、非( <code>!</code> )三个逻辑操作符用于将测试条件连接起来，其优先级为：&quot;<code>!</code>“最高，”<code>-a</code>“次之，”<code>-o</code>&quot;最低。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /bin</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -e ./notFile -o -e ./bash</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'至少有一个文件存在!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个文件都不存在'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>至少有一个文件存在!</p>
</blockquote>
<hr>
<h2 id="Shell-流程控制"><a class="header-anchor" href="#Shell-流程控制">¶</a>Shell 流程控制</h2>
<p>和Java、PHP等语言不一样，sh的流程控制不可为空，如(以下为PHP流程控制写法)：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">"q"</span>])) &#123;</span><br><span class="line">    search(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不做任何事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在sh/bash里可不能这么写，如果<code>else</code>分支没有语句执行，就不要写这个<code>else</code>。</p>
<h3 id="if-else"><a class="header-anchor" href="#if-else">¶</a><code>if else</code></h3>
<h4 id="if"><a class="header-anchor" href="#if">¶</a><code>if</code></h4>
<p><code>if</code> 语句语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>写成一行（适用于终端命令提示符）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ $(ps -ef | grep -c <span class="string">"ssh"</span>) -gt 1 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"true"</span>; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>末尾的<code>fi</code>就是<code>if</code>倒过来拼写，后面还会遇到类似的。</p>
<h4 id="if-else-v2"><a class="header-anchor" href="#if-else-v2">¶</a><code>if else</code></h4>
<p><code>if else</code> 语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h4 id="if-else-if-else"><a class="header-anchor" href="#if-else-if-else">¶</a><code>if else-if else</code></h4>
<p><code>if else-if else</code> 语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> condition2 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>以下实例判断两个变量是否相等：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a 等于 b"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -gt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a 大于 b"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -lt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"a 小于 b"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"没有符合的条件"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>a 小于 b</p>
</blockquote>
<p><code>if else</code>语句经常与<code>test</code>命令结合使用，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">num1=$[2*3]</span><br><span class="line">num2=$[1+5]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> $[num1] -eq $[num2]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个数字相等!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个数字不相等!'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>两个数字相等!</p>
</blockquote>
<h3 id="for-循环"><a class="header-anchor" href="#for-循环">¶</a><code>for</code> 循环</h3>
<p>与其他编程语言类似，Shell支持<code>for</code>循环。</p>
<p><code>for</code>循环一般格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>写成一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN; <span class="keyword">do</span> command1; command2… <span class="keyword">done</span>;</span><br></pre></td></tr></table></figure>
<p>当变量值在列表里，<code>for</code>循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的shell命令和语句。<code>in</code>列表可以包含替换、字符串和文件名。</p>
<p><code>in</code>列表是可选的，如果不用它，<code>for</code>循环使用命令行的位置参数。</p>
<p>例如，顺序输出当前列表中的数字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> loop <span class="keyword">in</span> 1 2 3 4 5</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"The value is: <span class="variable">$loop</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>The value is: 1<br>
The value is: 2<br>
The value is: 3<br>
The value is: 4<br>
The value is: 5</p>
</blockquote>
<p>顺序输出字符串中的字符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> str <span class="keyword">in</span> <span class="string">'This is a string'</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>This is a string</p>
</blockquote>
<h3 id="while-语句"><a class="header-anchor" href="#while-语句">¶</a><code>while</code> 语句</h3>
<p><code>while</code>循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>以下是一个基本的<code>while</code>循环，测试条件是：如果<code>int</code>小于等于5，那么条件返回真。<code>int</code>从0开始，每次循环处理时，<code>int</code>加1。运行上述脚本，返回数字1到5，然后终止。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">int=1</span><br><span class="line"><span class="keyword">while</span>(( <span class="variable">$int</span>&lt;=5 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$int</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">"int++"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>运行脚本，输出：</p>
<blockquote>
<p>1<br>
2<br>
3<br>
4<br>
5<br>
使用中使用了 Bash <code>let</code> 命令，它用于执行一个或多个表达式，变量计算中不需要加上 <code>$</code> 来表示变量，具体可查阅：<a href="http://www.runoob.com/linux/linux-comm-let.html" target="_blank" rel="noopener">Bash let</a> 命令</p>
</blockquote>
<p>。<br>
while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<code>&lt;Ctrl-D&gt;</code>结束循环。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'按下 &lt;CTRL-D&gt; 退出'</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">'输入你最喜欢的网站名: '</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> FILM</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"是的！<span class="variable">$FILM</span> 是一个好网站"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>运行脚本，输出类似下面：</p>
<blockquote>
<p>按下 <code>&lt;CTRL-D&gt;</code> 退出<br>
输入你最喜欢的网站名:菜鸟教程<br>
是的！菜鸟教程 是一个好网站</p>
</blockquote>
<h4 id="无限循环"><a class="header-anchor" href="#无限循环">¶</a>无限循环</h4>
<p>无限循环语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( ; ; ))</span><br></pre></td></tr></table></figure>
<h3 id="until-循环"><a class="header-anchor" href="#until-循环">¶</a><code>until</code> 循环</h3>
<p><code>until</code> 循环执行一系列命令直至条件为 <code>true</code> 时停止。<br>
<code>until</code> 循环与 <code>while</code> 循环在处理方式上刚好相反。<br>
一般 <code>while</code> 循环优于 <code>until</code> 循环，但在某些时候—也只是极少数情况下，<code>until</code> 循环更加有用。</p>
<p><code>until</code> 语法格式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">until condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><code>condition</code> 一般为条件表达式，如果返回值为 <code>false</code>，则继续执行循环体内的语句，否则跳出循环。<br>
以下实例我们使用 <code>until</code> 命令来输出 0 ~ 9 的数字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=0</span><br><span class="line"></span><br><span class="line">until [ ! <span class="variable">$a</span> -lt 10 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">   a=`expr <span class="variable">$a</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<blockquote>
<p>0<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9</p>
</blockquote>
<h3 id="case"><a class="header-anchor" href="#case">¶</a><code>case</code></h3>
<p>Shell <code>case</code>语句为多选择语句。可以用<code>case</code>语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。<code>case</code>语句格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 值 <span class="keyword">in</span></span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p><code>case</code>工作方式如上所示。取值后面必须为单词<code>in</code>，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 <code>;;</code>。<br>
取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 <code>*</code> 捕获该值，再执行后面的命令。<br>
下面的脚本提示输入1到4，与每一种模式进行匹配：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'输入 1 到 4 之间的数字:'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'你输入的数字为:'</span></span><br><span class="line"><span class="built_in">read</span> aNum</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">    1)  <span class="built_in">echo</span> <span class="string">'你选择了 1'</span></span><br><span class="line">    ;;</span><br><span class="line">    2)  <span class="built_in">echo</span> <span class="string">'你选择了 2'</span></span><br><span class="line">    ;;</span><br><span class="line">    3)  <span class="built_in">echo</span> <span class="string">'你选择了 3'</span></span><br><span class="line">    ;;</span><br><span class="line">    4)  <span class="built_in">echo</span> <span class="string">'你选择了 4'</span></span><br><span class="line">    ;;</span><br><span class="line">    *)  <span class="built_in">echo</span> <span class="string">'你没有输入 1 到 4 之间的数字'</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>输入不同的内容，会有不同的结果，例如：</p>
<blockquote>
<p>输入 1 到 4 之间的数字:<br>
你输入的数字为:<br>
3<br>
你选择了 3</p>
</blockquote>
<h3 id="跳出循环"><a class="header-anchor" href="#跳出循环">¶</a>跳出循环</h3>
<p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：<code>break</code>和<code>continue</code>。</p>
<h4 id="break命令"><a class="header-anchor" href="#break命令">¶</a><code>break</code>命令</h4>
<p><code>break</code>命令允许跳出所有循环（终止执行后面的所有循环）。</p>
<p>下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用<code>break</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"输入 1 到 5 之间的数字:"</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">"你输入的数字为 <span class="variable">$aNum</span>!"</span></span><br><span class="line">        ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">"你输入的数字不是 1 到 5 之间的! 游戏结束"</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<blockquote>
<p>输入 1 到 5 之间的数字:3<br>
你输入的数字为 3!<br>
输入 1 到 5 之间的数字:7<br>
你输入的数字不是 1 到 5 之间的! 游戏结束</p>
</blockquote>
<h4 id="continue"><a class="header-anchor" href="#continue">¶</a><code>continue</code></h4>
<p><code>continue</code>命令与<code>break</code>命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>
<p>对上面的例子进行修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"输入 1 到 5 之间的数字: "</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$aNum</span> <span class="keyword">in</span></span><br><span class="line">        1|2|3|4|5) <span class="built_in">echo</span> <span class="string">"你输入的数字为 <span class="variable">$aNum</span>!"</span></span><br><span class="line">        ;;</span><br><span class="line">        *) <span class="built_in">echo</span> <span class="string">"你输入的数字不是 1 到 5 之间的!"</span></span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"游戏结束"</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 <code>echo &quot;游戏结束&quot;</code> 永远不会被执行。</p>
<h3 id="esac"><a class="header-anchor" href="#esac">¶</a><code>esac</code></h3>
<p><code>case</code>的语法和C family语言差别很大，它需要一个<code>esac</code>（就是<code>case</code>反过来）作为结束标记，每个<code>case</code>分支用右圆括号，用两个分号表示<code>break</code>。</p>
<hr>
<h3 id="Shell-函数"><a class="header-anchor" href="#Shell-函数">¶</a>Shell 函数</h3>
<p>linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p>
<p>shell中函数的定义格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>可以带<code>function fun()</code> 定义，也可以直接<code>fun()</code> 定义,不带任何参数。</li>
<li>参数返回，可以显示加：<code>return</code> 返回，如果不加，将以最后一条命令运行结果，作为返回值。 <code>return</code>后跟数值n(0-255</li>
</ol>
<p>下面的例子定义了一个函数并进行调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">demoFun</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"这是我的第一个 shell 函数!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"-----函数开始执行-----"</span></span><br><span class="line">demoFun</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"-----函数执行完毕-----"</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>-----函数开始执行-----<br>
这是我的第一个 shell 函数!<br>
-----函数执行完毕-----</p>
</blockquote>
<p>下面定义一个带有return语句的函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">funWithReturn</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"这个函数会对输入的两个数字进行相加运算..."</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"输入第一个数字: "</span></span><br><span class="line">    <span class="built_in">read</span> aNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"输入第二个数字: "</span></span><br><span class="line">    <span class="built_in">read</span> anotherNum</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"两个数字分别为 <span class="variable">$aNum</span> 和 <span class="variable">$anotherNum</span> !"</span></span><br><span class="line">    <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$anotherNum</span>))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"输入的两个数字之和为 $? !"</span></span><br></pre></td></tr></table></figure>
<p>输出类似下面：</p>
<blockquote>
<p>这个函数会对输入的两个数字进行相加运算…<br>
输入第一个数字:<br>
1<br>
输入第二个数字:<br>
2<br>
两个数字分别为 1 和 2 !<br>
输入的两个数字之和为 3 !</p>
</blockquote>
<p>函数返回值在调用该函数后通过 <code>$?</code> 来获得。</p>
<p><strong>注意</strong>：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>
<h3 id="函数参数"><a class="header-anchor" href="#函数参数">¶</a>函数参数</h3>
<p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 <code>$n</code> 的形式来获取参数的值，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数…</p>
<p>带参数的函数示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># author:菜鸟教程</span></span><br><span class="line"><span class="comment"># url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">funWithParam</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第一个参数为 <span class="variable">$1</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第二个参数为 <span class="variable">$2</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十个参数为 <span class="variable">$10</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十个参数为 <span class="variable">$&#123;10&#125;</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十一个参数为 <span class="variable">$&#123;11&#125;</span> !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"参数总数有 <span class="variable">$#</span> 个!"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"作为一个字符串输出所有参数 $* !"</span></span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>第一个参数为 1 !<br>
第二个参数为 2 !<br>
第十个参数为 10 !<br>
第十个参数为 34 !<br>
第十一个参数为 73 !<br>
参数总数有 11 个!<br>
作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</p>
</blockquote>
<p><font color=red><strong>注意，<code>$10</code> 不能获取第十个参数，获取第十个参数需要<code>${10}</code>。当n&gt;=10时，需要使用<code>${n}</code>来获取参数。</strong></font></p>
<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数处理</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$#</td>
<td style="text-align:left">传递到脚本的参数个数</td>
</tr>
<tr>
<td style="text-align:left">$*</td>
<td style="text-align:left">以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td style="text-align:left">$$</td>
<td style="text-align:left">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td style="text-align:left">$!</td>
<td style="text-align:left">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td style="text-align:left">$@</td>
<td style="text-align:left">与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td style="text-align:left">$-</td>
<td style="text-align:left">显示Shell使用的当前选项，与<code>set</code>命令功能相同。</td>
</tr>
<tr>
<td style="text-align:left">$?</td>
<td style="text-align:left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Linux</tag>
        <tag>bash</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux使用手册</title>
    <url>/2018/10/19/Tmux%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1>Tmux使用手册</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="导读"><a class="header-anchor" href="#导读">¶</a>导读</h2>
<p>  我一直信奉简洁至上的原则，桌面窗口的数量越少，我的心情就越放松，开发的效率也就越高。反之，杂乱的桌面，暴涨的Chrome tab数量，或是无数的终端窗口，它们会逐步侵占我的注意力，分散我的思维，最终令我难以专注。因此桌面上我很少放文件，使用Chrome时常点<a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall" target="_blank" rel="noopener">OneTab</a> 回收标签页，切进终端时使用tmux管理窗口。<br>
  那么，有没有可能开机后不需要任何操作，本地的十几种web开发服务就自动运行？当然我不希望连续弹出十几个窗口或是tab，我需要的是静默无感知的启用服务，然后还能快速地进入到现场进行操作，web服务运行时不占据终端窗口，关闭iTem2后操作现场不会被销毁。诸如此类，tmux都能实现，除了这些，tmux还能做得更多更好。<br>
  到目前为止，tmux帮助我两年有余，它带给我许多惊喜。独乐不如众乐，愿你也能一同享受tmux带来的快乐。</p>
<hr>
<h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2>
<p>  tmux是一款优秀的终端复用软件，它比Screen更加强大，至于如何强大，网上有大量的文章讨论了这点，本文不再重复。tmux之所以受人们喜爱，主要得益于以下三处功能：</p>
<ul>
<li>丝滑分屏（split），虽然iTem2也提供了横向和竖向分屏功能，但这种分屏功能非常拙劣，完全等同于屏幕新开一个窗口，新开的pane不会自动进入到当前目录，也没有记住当前登录状态。这意味着如果我ssh进入到远程服务器时，iTem2新开的pane中，我依然要重新走一遍ssh登录的老路（omg）。tmux就不会这样，tmux窗口中，新开的pane，默认进入到之前的路径，如果是ssh连接，登录状态也依旧保持着，如此一来，我就可以随意的增删pane，这种灵活性，好处不言而喻。</li>
<li>保护现场（attach），即使命令行的工作只进行到一半，关闭终端后还可以重新进入到操作现场，继续工作。对于ssh远程连接而言，即使网络不稳定也没有关系，掉线后重新连接，可以直奔现场，之前运行中的任务，依旧在跑，就好像从来没有离开过一样；特别是在远程服务器上运行耗时的任务，tmux可以帮你一直保持住会话。如此一来，你就可以随时随地放心地进行移动办公，只要你附近的计算机装有tmux（没有你也可以花几分钟装一个），你就能继续刚才的工作。</li>
<li>会话共享（适用于结对编程或远程教学），将 tmux 会话的地址分享给他人，这样他们就可以通过 SSH 接入该会话。如果你要给同事演示远程服务器的操作，他不必直勾勾地盯着你的屏幕，借助tmux，他完全可以进入到你的会话，然后静静地看着他桌面上你风骚的键盘走位，只要他愿意，甚至还可以录个屏。</li>
</ul>
<p>  以上，只是主要功能，更多功能还在后头，接下来我将详细地介绍tmux的使用技巧。</p>
<hr>
<h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2>
<p>  首先安装之。<br>
  在Mac中安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先安装Homebrew，有则跳过</span></span><br><span class="line">ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br><span class="line"><span class="comment"># 安装tmux</span></span><br><span class="line">brew install tmux</span><br></pre></td></tr></table></figure>
<p>  在Linux中安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tmux</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="基本概念"><a class="header-anchor" href="#基本概念">¶</a>基本概念</h2>
<p>  开始之前，我们先了解下基本概念：<br>
  tmux采用C/S模型构建，输入tmux命令就相当于开启了一个服务器，此时默认将新建一个会话，然后会话中默认新建一个窗口，窗口中默认新建一个面板。会话、窗口、面板之间的联系如下：</p>
<ul>
<li>
<p>一个tmux session（会话）可以包含多个window（窗口），窗口默认充满会话界面，因此这些窗口中可以运行相关性不大的任务。</p>
</li>
<li>
<p>一个window又可以包含多个pane（面板），窗口下的面板，都处于同一界面下，这些面板适合运行相关性高的任务，以便同时观察到它们的运行情况。</p>
</li>
</ul>
<p><img src="http://louiszhai.github.io/docImages/tmux01.png" alt="基本概念"></p>
<hr>
<h2 id="会话"><a class="header-anchor" href="#会话">¶</a>会话</h2>
<h3 id="新建会话"><a class="header-anchor" href="#新建会话">¶</a>新建会话</h3>
<p>  新建一个tmux session非常简单，语法为tmux new -s session-name，也可以简写为tmux，为了方便管理，建议指定会话名称，如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux <span class="comment"># 新建一个无名称的会话</span></span><br><span class="line">tmux new -s demo <span class="comment"># 新建一个名称为demo的会话</span></span><br></pre></td></tr></table></figure>
<h3 id="断开当前会话"><a class="header-anchor" href="#断开当前会话">¶</a>断开当前会话</h3>
<p>  会话中操作了一段时间，我希望断开会话同时下次还能接着用，怎么做？此时可以使用detach命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux detach <span class="comment"># 断开当前会话，会话在后台运行</span></span><br></pre></td></tr></table></figure>
<p>  也许你觉得这个太麻烦了，是的，tmux的会话中，我们已经可以使用tmux快捷键了。使用快捷键组合Ctrl+b + d，三次按键就可以断开当前会话。</p>
<h3 id="进入之前的会话"><a class="header-anchor" href="#进入之前的会话">¶</a>进入之前的会话</h3>
<p>  断开会话后，想要接着上次留下的现场继续工作，就要使用到tmux的attach命令了，语法为tmux attach-session -t session-name，可简写为tmux a -t session-name 或 tmux a。通常我们使用如下两种方式之一即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux a <span class="comment"># 默认进入第一个会话</span></span><br><span class="line">tmux a -t demo <span class="comment"># 进入到名称为demo的会话</span></span><br></pre></td></tr></table></figure>
<h3 id="关闭会话"><a class="header-anchor" href="#关闭会话">¶</a>关闭会话</h3>
<p>  会话的使命完成后，一定是要关闭的。我们可以使用tmux的kill命令，kill命令有kill-pane、kill-server、kill-session 和 kill-window共四种，其中kill-session的语法为tmux kill-session -t session-name。如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux <span class="built_in">kill</span>-session -t demo <span class="comment"># 关闭demo会话</span></span><br><span class="line">tmux <span class="built_in">kill</span>-server <span class="comment"># 关闭服务器，所有的会话都将关闭</span></span><br></pre></td></tr></table></figure>
<h3 id="查看所有会话"><a class="header-anchor" href="#查看所有会话">¶</a>查看所有会话</h3>
<p>  管理会话的第一步就是要查看所有的会话，我们可以使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux list-session <span class="comment"># 查看所有会话</span></span><br><span class="line">tmux ls <span class="comment"># 查看所有会话，提倡使用简写形式</span></span><br></pre></td></tr></table></figure>
<p>  如果刚好处于会话中怎么办？别担心，我们可以使用对应的tmux快捷键Ctrl+b + s，此时tmux将打开一个会话列表，按上下键(↑↓︎)或者鼠标滚轮，可选中目标会话，按左右键（←→︎）可收起或展开会话的窗口，选中目标会话或窗口后，按回车键即可完成切换。</p>
<p><img src="http://louiszhai.github.io/docImages/tmux02.png" alt="查看会话"></p>
<h2 id="Tmux快捷指令"><a class="header-anchor" href="#Tmux快捷指令">¶</a>Tmux快捷指令</h2>
<p>  关于快捷指令，首先要认识到的是：tmux的所有指令，都包含同一个前缀，默认为Ctrl+b，输入完前缀过后，控制台激活，命令按键才能生效。前面tmux会话相关的操作中，我们共用到了两个快捷键Ctrl+b + d、Ctrl+b + s，但这仅仅是冰山一角，欲窥tmux庞大的快捷键体系，请看下表。</p>
<p>表一：系统指令。</p>
<table>
<thead>
<tr>
<th style="text-align:center">前缀</th>
<th style="text-align:center">指令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">?</td>
<td style="text-align:center">显示快捷键帮助文档</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">d</td>
<td style="text-align:center">断开当前会话</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">D</td>
<td style="text-align:center">选择要断开的会话</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">Ctrl+z</td>
<td style="text-align:center">挂起当前会话</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">r</td>
<td style="text-align:center">强制重载当前会话</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">s</td>
<td style="text-align:center">显示会话列表用于选择并切换</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">:</td>
<td style="text-align:center">进入命令行模式，此时可直接输入ls等命令</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">[</td>
<td style="text-align:center">进入复制模式，按q退出</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">]</td>
<td style="text-align:center">粘贴复制模式中复制的文本</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">~</td>
<td style="text-align:center">列出提示信息缓存</td>
</tr>
</tbody>
</table>
<p>表二：窗口（window）指令。</p>
<table>
<thead>
<tr>
<th style="text-align:center">前缀</th>
<th style="text-align:center">指令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">c</td>
<td style="text-align:center">新建窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">关闭当前窗口（关闭前需输入y or n确认）</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">0~9</td>
<td style="text-align:center">切换到指定窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">p</td>
<td style="text-align:center">切换到上一窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">n</td>
<td style="text-align:center">切换到下一窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">w</td>
<td style="text-align:center">打开窗口列表，用于且切换窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">,</td>
<td style="text-align:center">重命名当前窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">.</td>
<td style="text-align:center">修改当前窗口编号（适用于窗口重新排序）</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">f</td>
<td style="text-align:center">快速定位到窗口（输入关键字匹配窗口名称）</td>
</tr>
</tbody>
</table>
<p>表三：面板（pane）指令。</p>
<table>
<thead>
<tr>
<th style="text-align:center">前缀</th>
<th style="text-align:center">指令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">&quot;</td>
<td style="text-align:center">当前面板上下一分为二，下侧新建面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">%</td>
<td style="text-align:center">当前面板左右一分为二，右侧新建面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">x</td>
<td style="text-align:center">关闭当前面板（关闭前需输入y or n确认）</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">z</td>
<td style="text-align:center">最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增）</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">!</td>
<td style="text-align:center">将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效）</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">;</td>
<td style="text-align:center">切换到最后一次使用的面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">q</td>
<td style="text-align:center">显示面板编号，在编号消失前输入对应的数字可切换到相应的面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">{</td>
<td style="text-align:center">向前置换当前面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">}</td>
<td style="text-align:center">向后置换当前面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">Ctrl+o</td>
<td style="text-align:center">顺时针旋转当前窗口中的所有面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">方向键</td>
<td style="text-align:center">移动光标切换面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">o</td>
<td style="text-align:center">选择下一面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">空格键</td>
<td style="text-align:center">在自带的面板布局中循环切换</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">Alt+方向键</td>
<td style="text-align:center">以5个单元格为单位调整当前面板边缘</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">Ctrl+方向键</td>
<td style="text-align:center">以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖）</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">t</td>
<td style="text-align:center">显示时钟</td>
</tr>
</tbody>
</table>
<p>  tmux的丝滑分屏功能正是得益于以上系统、窗口、面板的快捷指令，只要你愿意，你就可以解除任意的快捷指令，然后绑上你喜欢的指令，当然这就涉及到它的可配置性了，请继续往下读。</p>
<hr>
<h2 id="灵活的配置性"><a class="header-anchor" href="#灵活的配置性">¶</a>灵活的配置性</h2>
<p>  除了快捷指令外，tmux还提供了类似vim的配置性功能。可配置性是软件的一项进阶级功能，只有具备了可配置性，软件才有了鲜活的个性，用户才能体会到操作的快感。</p>
<h3 id="修改指令前缀"><a class="header-anchor" href="#修改指令前缀">¶</a>修改指令前缀</h3>
<p>  相信只要你用过几次tmux，就会发现Ctrl+b指令前缀，着实不太方便。这两个键相距太远，按键成本太高了。因此我们首先需要将它更换为距离更近的Ctrl+a组合键，或者不常用的 ` 键（当然其他键也是可以的）。<br>
  tmux的用户级配置文件为~/.tmux.conf（没有的话就创建一个），修改快捷指令，只需要增加如下三行即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g prefix C<span class="_">-a</span> <span class="comment">#</span></span><br><span class="line">unbind C-b <span class="comment"># C-b即Ctrl+b键，unbind意味着解除绑定</span></span><br><span class="line"><span class="built_in">bind</span> C<span class="_">-a</span> send-prefix <span class="comment"># 绑定Ctrl+a为新的指令前缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从tmux v1.6版起，支持设置第二个指令前缀</span></span><br><span class="line"><span class="built_in">set</span>-option -g prefix2 ` <span class="comment"># 设置一个不常用的`键作为指令前缀，按键更快些</span></span><br></pre></td></tr></table></figure>
<p>  修改的~/.tmux.conf配置文件有如下两种方式可以令其生效：</p>
<ul>
<li>restart tmux。</li>
<li>在tmux窗口中，先按下Ctrl+b指令前缀，然后按下系统指令:，进入到命令模式后输入source-file ~/.tmux.conf，回车后生效。</li>
</ul>
<p>  既然快捷指令如此方便，更为优雅的做法是新增一个加载配置文件的快捷指令 ，这样就可以随时随地load新的配置了，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绑定快捷键为r</span></span><br><span class="line"><span class="built_in">bind</span> r <span class="built_in">source</span>-file ~/.tmux.conf \; display-message <span class="string">"Config reloaded.."</span></span><br></pre></td></tr></table></figure>
<p>  请特别注意，在已经创建的窗口中，即使加载了新的配置，旧的配置依然有效（只要你新加的功能没有覆盖旧的配置，因此如果你第一次绑定快捷指令为x键，然后又改为绑定y键，那么x和y都将有效），新建会话不受此影响，将直接采用新的配置。<br>
  既然我们已经迈出配置化的第一步，那么接下来我们可以做得更多。</p>
<h3 id="新增面板"><a class="header-anchor" href="#新增面板">¶</a>新增面板</h3>
<p>  tmux中，使用最多的功能之一就是新增一个面板。水平方向新增面板的指令是 prefix + &quot; ，垂直方向是 prefix + %，&quot; 和 %需要两个键同时按下才能完成，加上指令前缀至少需要3~4次按键才能组成一个完整的指令，同时这个两个键也不够醒目和方便，因此我们可以绑定两个更常用的指令 -、|，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unbind <span class="string">'"'</span></span><br><span class="line"><span class="built_in">bind</span> - splitw -v -c <span class="string">'#&#123;pane_current_path&#125;'</span> <span class="comment"># 垂直方向新增面板，默认进入当前目录</span></span><br><span class="line">unbind %</span><br><span class="line"><span class="built_in">bind</span> | splitw -h -c <span class="string">'#&#123;pane_current_path&#125;'</span> <span class="comment"># 水平方向新增面板，默认进入当前目录</span></span><br></pre></td></tr></table></figure>
<h3 id="开启鼠标支持"><a class="header-anchor" href="#开启鼠标支持">¶</a>开启鼠标支持</h3>
<p>  默认情况下，tmux的多窗口之间的切换以及面板大小调整，需要输入指令才能完成，这一过程，涉及到的指令较多，而且操作麻烦，特别是面板大小调整，指令难以一步到位，这个时候开启鼠标支持就完美了。<br>
  对于tmux v2.1(2015.10.28)之前的版本，需加入如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setw -g mode-mouse on <span class="comment"># 支持鼠标选取文本等</span></span><br><span class="line">setw -g mouse-resize-pane on <span class="comment"># 支持鼠标拖动调整面板的大小(通过拖动面板间的分割线)</span></span><br><span class="line">setw -g mouse-select-pane on <span class="comment"># 支持鼠标选中并切换面板</span></span><br><span class="line">setw -g mouse-select-window on <span class="comment"># 支持鼠标选中并切换窗口(通过点击状态栏窗口名称)</span></span><br></pre></td></tr></table></figure>
<p>  有的地方可能会出现set-window-option的写法，setw就是它的别名。<br>
  对于tmux v2.1及以上的版本，仅需加入如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>-option -g mouse on <span class="comment"># 等同于以上4个指令的效果</span></span><br></pre></td></tr></table></figure>
<p>  需要注意的是，开启鼠标支持后，iTem2默认的鼠标选中即复制功能需要同时按下 Alt 键，才会生效。</p>
<h3 id="快速面板切换"><a class="header-anchor" href="#快速面板切换">¶</a>快速面板切换</h3>
<p>  鼠标支持确实能带来很大的便捷性，特别是对于习惯了鼠标操作的tmux新手，但对于键盘爱好者而言，这不是什么好消息，对他们而言，双手不离键盘是基本素质。<br>
虽然指令前缀加方向键可以切换面板，但方向键太远，不够快，不够Geek。没关系，我们可以将面板切换升级为熟悉的h、j、k、l键位。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绑定hjkl键为面板切换的上下左右键</span></span><br><span class="line"><span class="built_in">bind</span> -r k select-pane -U <span class="comment"># 绑定k为↑</span></span><br><span class="line"><span class="built_in">bind</span> -r j select-pane -D <span class="comment"># 绑定j为↓</span></span><br><span class="line"><span class="built_in">bind</span> -r h select-pane -L <span class="comment"># 绑定h为←</span></span><br><span class="line"><span class="built_in">bind</span> -r l select-pane -R <span class="comment"># 绑定l为→</span></span><br></pre></td></tr></table></figure>
<p>  -r表示可重复按键，大概500ms之内，重复的h、j、k、l按键都将有效，完美支持了快速切换的Geek需求。<br>
  除了上下左右外， 还有几个快捷指令可以设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> -r e lastp <span class="comment"># 选择最后一个面板</span></span><br><span class="line"><span class="built_in">bind</span> -r ^e last <span class="comment"># 选择最后一个窗口</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bind</span> -r ^u swapp -U <span class="comment"># 与前一个面板交换位置</span></span><br><span class="line"><span class="built_in">bind</span> -r ^d swapp -D <span class="comment"># 与后一个面板交换位置</span></span><br></pre></td></tr></table></figure>
<h3 id="面板大小调整"><a class="header-anchor" href="#面板大小调整">¶</a>面板大小调整</h3>
<p>  习惯了全键盘操作后，命令的便捷性不言而喻。既然面板切换的指令都可以升级，面板大小调整的指令自然也不能落后。如下配置就可以升级你的操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绑定Ctrl+hjkl键为面板上下左右调整边缘的快捷指令</span></span><br><span class="line"><span class="built_in">bind</span> -r ^k resizep -U 10 <span class="comment"># 绑定Ctrl+k为往↑调整面板边缘10个单元格</span></span><br><span class="line"><span class="built_in">bind</span> -r ^j resizep -D 10 <span class="comment"># 绑定Ctrl+j为往↓调整面板边缘10个单元格</span></span><br><span class="line"><span class="built_in">bind</span> -r ^h resizep -L 10 <span class="comment"># 绑定Ctrl+h为往←调整面板边缘10个单元格</span></span><br><span class="line"><span class="built_in">bind</span> -r ^l resizep -R 10 <span class="comment"># 绑定Ctrl+l为往→调整面板边缘10个单元格</span></span><br></pre></td></tr></table></figure>
<p>  以上，resizep即resize-pane的别名。</p>
<h3 id="面板最大化"><a class="header-anchor" href="#面板最大化">¶</a>面板最大化</h3>
<p>  当窗口中面板的数量逐渐增多时，每个面板的空间就会逐渐减少。为了保证有足够的空间显示内容，tmux从v1.8版本起，提供了面板的最大化功能，输入tmux-prefix+z，就可以最大化当前面板至窗口大小，只要再重复输入一次，便恢复正常。那么tmux v1.8以下的版本，怎么办呢？别急，有大神提供了如下的解决方案。<br>
  首先编写一个zoom脚本，该脚本通过新建一个窗口，交换当前面板与新的窗口默认面板位置，来模拟最大的功能；通过重复一次按键，还原面板位置，并关闭新建的窗口，来模拟还原功能，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash -f</span></span><br><span class="line">currentwindow=`tmux list-window | tr <span class="string">'\t'</span> <span class="string">' '</span> | sed -n -e <span class="string">'/(active)/s/^[^:]*: *\([^ ]*\) .*/\1/gp'</span>`;</span><br><span class="line">currentpane=`tmux list-panes | sed -n -e <span class="string">'/(active)/s/^\([^:]*\):.*/\1/gp'</span>`;</span><br><span class="line">panecount=`tmux list-panes | wc | sed -e <span class="string">'s/^ *//g'</span> -e <span class="string">'s/ .*$//g'</span>`;</span><br><span class="line">inzoom=`<span class="built_in">echo</span> <span class="variable">$currentwindow</span> | sed -n -e <span class="string">'/^zoom/p'</span>`;</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$panecount</span> -ne 1 ]; <span class="keyword">then</span></span><br><span class="line">    inzoom=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$inzoom</span> ]; <span class="keyword">then</span></span><br><span class="line">    lastpane=`<span class="built_in">echo</span> <span class="variable">$currentwindow</span> | rev | cut -f 1 -d <span class="string">'@'</span> | rev`;</span><br><span class="line">    lastwindow=`<span class="built_in">echo</span> <span class="variable">$currentwindow</span> | cut -f 2- -d <span class="string">'@'</span> | rev | cut -f 2- -d <span class="string">'@'</span> | rev`;</span><br><span class="line">    tmux select-window -t <span class="variable">$lastwindow</span>;</span><br><span class="line">    tmux select-pane -t <span class="variable">$lastpane</span>;</span><br><span class="line">    tmux swap-pane -s <span class="variable">$currentwindow</span>;</span><br><span class="line">    tmux <span class="built_in">kill</span>-window -t <span class="variable">$currentwindow</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    newwindowname=zoom@<span class="variable">$currentwindow</span>@<span class="variable">$currentpane</span>;</span><br><span class="line">    tmux new-window -d -n <span class="variable">$newwindowname</span>;</span><br><span class="line">    tmux swap-pane -s <span class="variable">$newwindowname</span>;</span><br><span class="line">    tmux select-window -t <span class="variable">$newwindowname</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>  不妨将该脚本存放在~/.tmux目录中（没有则新建目录），接下来只需要绑定一个快捷指令就行，如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unbind z</span><br><span class="line"><span class="built_in">bind</span> z run <span class="string">". ~/.tmux/zoom"</span></span><br></pre></td></tr></table></figure>
<h3 id="窗口变为面板"><a class="header-anchor" href="#窗口变为面板">¶</a>窗口变为面板</h3>
<p>  通过上面的zoom脚本，面板可以轻松地最大化为一个新的窗口。那么反过来，窗口是不是可以最小化为一个面板呢？</p>
<blockquote>
<p>试想这样一个场景：当你打开多个窗口后，然后想将其中几个窗口合并到当前窗口中，以便对比观察输出。</p>
</blockquote>
<p>  实际上，你的要求就是将其它窗口变成面板，然后合并到当前窗口中。对于这种操作，我们可以在当前窗口，按下prefix + :，打开命令行，然后输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">join-pane -s window01 <span class="comment"># 合并名称为window01的窗口的默认（第一个）面板到当前窗口中</span></span><br><span class="line">join-pane -s window01.1 <span class="comment"># .1显式指定了第一个面板，.2就是第二个面板(我本地将面板编号起始值设置为1，默认是0)</span></span><br></pre></td></tr></table></figure>
<p>  每次执行join-pane命令都会合并一个面板，并且指定的窗口会减少一个面板，直到面板数量为0，窗口关闭。<br>
  除了在当前会话中操作外，join-pane命令甚至可以从其它指定会话中合并面板，格式为join-pane -s [session_name]:[window].[pane]，如join-pane -s 2:1.1 即合并第二个会话的第一个窗口的第一个面板到当前窗口，当目标会话的窗口和面板数量为0时，会话便会关闭。</p>
<p>  注：上一节中的swap-pane命令与join-pane语法基本一致。</p>
<h3 id="其他配置"><a class="header-anchor" href="#其他配置">¶</a>其他配置</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> m <span class="built_in">command</span>-prompt <span class="string">"splitw -h 'exec man %%'"</span>   <span class="comment"># 绑定m键为在新的panel打开man</span></span><br><span class="line"><span class="comment"># 绑定P键为开启日志功能，如下，面板的输出日志将存储到桌面</span></span><br><span class="line"><span class="built_in">bind</span> P pipe-pane -o <span class="string">"cat &gt;&gt;~/Desktop/#W.log"</span> \; display <span class="string">"Toggled logging to ~/Desktop/#W.log"</span></span><br></pre></td></tr></table></figure>
<h3 id="恢复用户空间"><a class="header-anchor" href="#恢复用户空间">¶</a>恢复用户空间</h3>
<p>  tmux会话中，Mac的部分命令如 osascript、open、pbcopy 或 pbpaste等可能会失效（失效命令未列全）。<br>
  部分bug列表如下：</p>
<ul>
<li><a href="https://apple.stackexchange.com/questions/174779/unable-to-run-display-notification-using-osascript-in-a-tmux-session" target="_blank" rel="noopener">applescript - Unable to run ‘display notification’ using osascript in a tmux session</a></li>
<li><a href="https://stackoverflow.com/questions/30404944/open-command-doesnt-work-properly-inside-tmux/30412054#30412054" target="_blank" rel="noopener">osx - “open” command doesn’t work properly inside tmux</a></li>
<li><a href="https://stackoverflow.com/questions/16618992/cant-paste-into-macvim/16661806#16661806" target="_blank" rel="noopener">clipboard - Can’t paste into MacVim</a></li>
</ul>
<p>  对此，我们可以通过安装reattach-to-user-namespace包装程序来解决这个问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install reattach-to-user-namespace</span><br></pre></td></tr></table></figure>
<p>  在~/.tmux.conf中添加配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g default-command <span class="string">"reattach-to-user-namespace -l <span class="variable">$SHELL</span>"</span></span><br></pre></td></tr></table></figure>
<p>  这样你的交互式shell最终能够重新连接到用户级的命名空间。由于连接状态能够被子进程继承，故以上配置保证了所有从 shell 启动的命令能够被正确地连接。<br>
  有些时候，我们可能会在不同的操作系统中共享配置文件，如果你的tmux版本大于1.9，我们还可以使用if-shell来判断是否Mac系统，然后再指定default-command。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>-shell <span class="string">'test "$(uname -s)" = Darwin'</span> <span class="string">'set-option -g default-command "exec reattach-to-user-namespace -l $SHELL"'</span></span><br></pre></td></tr></table></figure>
<p>  对于tmux v1.8及更早的版本，可以使用如下包装后的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>-option -g default-command <span class="string">'command -v reattach-to-user-namespace &gt;/dev/null &amp;&amp; exec reattach-to-user-namespace -l "$SHELL" || exec "$SHELL"'</span></span><br></pre></td></tr></table></figure>
<p>  以上，$SHELL对应于你的默认Shell，通常是/usr/bin/bash 或 /usr/local/bin/zsh。</p>
<hr>
<h2 id="复制模式"><a class="header-anchor" href="#复制模式">¶</a>复制模式</h2>
<p>  tmux中操作文本，自然离不开复制模式，通常使用复制模式的步骤如下：</p>
<ol>
<li>输入 `+[ 进入复制模式</li>
<li>按下 空格键 开始复制，移动光标选择复制区域</li>
<li>按下 回车键 复制选中文本并退出复制模式</li>
<li>按下 `+] 粘贴文本</li>
</ol>
<p>  查看复制模式默认的快捷键风格：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux show-window-options -g mode-keys <span class="comment"># mode-keys emacs</span></span><br></pre></td></tr></table></figure>
<p>  默认情况下，快捷键为emacs风格。<br>
  为了让复制模式更加方便，我们可以将快捷键设置为熟悉的vi风格，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setw -g mode-keys vi <span class="comment"># 开启vi风格后，支持vi的C-d、C-u、hjkl等快捷键</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义复制和选择快捷键"><a class="header-anchor" href="#自定义复制和选择快捷键">¶</a>自定义复制和选择快捷键</h3>
<p>  除了快捷键外，复制模式的启用、选择、复制、粘贴等按键也可以向vi风格靠拢。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> Escape copy-mode <span class="comment"># 绑定esc键为进入复制模式</span></span><br><span class="line"><span class="built_in">bind</span> -t vi-copy v begin-selection <span class="comment"># 绑定v键为开始选择文本</span></span><br><span class="line"><span class="built_in">bind</span> -t vi-copy y copy-selection <span class="comment"># 绑定y键为复制选中文本</span></span><br><span class="line"><span class="built_in">bind</span> p pasteb <span class="comment"># 绑定p键为粘贴文本（p键默认用于进入上一个窗口，不建议覆盖）</span></span><br></pre></td></tr></table></figure>
<p>  以上，绑定 v、y两键的设置只在tmux v2.4版本以下才有效，对于v2.4及以上的版本，绑定快捷键需要使用 -T 选项，发送指令需要使用 -X 选项，请参考如下设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> -T copy-mode-vi v send-keys -X begin-selection</span><br><span class="line"><span class="built_in">bind</span> -T copy-mode-vi y send-keys -X copy-selection-and-cancel</span><br></pre></td></tr></table></figure>
<h3 id="Buffer缓存"><a class="header-anchor" href="#Buffer缓存">¶</a>Buffer缓存</h3>
<p>  tmux复制操作的内容默认会存进buffer里，buffer是一个粘贴缓存区，新的缓存总是位于栈顶，它的操作命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux list-buffers <span class="comment"># 展示所有的 buffers</span></span><br><span class="line">tmux show-buffer [-b buffer-name] <span class="comment"># 显示指定的 buffer 内容</span></span><br><span class="line">tmux choose-buffer <span class="comment"># 进入 buffer 选择页面(支持jk上下移动选择，回车选中并粘贴 buffer 内容到面板上)</span></span><br><span class="line">tmux <span class="built_in">set</span>-buffer <span class="comment"># 设置buffer内容</span></span><br><span class="line">tmux load-buffer [-b buffer-name] file-path <span class="comment"># 从文件中加载文本到buffer缓存</span></span><br><span class="line">tmux save-buffer [-a] [-b buffer-name] path <span class="comment"># 保存tmux的buffer缓存到本地</span></span><br><span class="line">tmux paste-buffer <span class="comment"># 粘贴buffer内容到会话中</span></span><br><span class="line">tmux delete-buffer [-b buffer-name] <span class="comment"># 删除指定名称的buffer</span></span><br></pre></td></tr></table></figure>
<p>  以上buffer操作在不指定buffer-name时，默认处理是栈顶的buffer缓存。<br>
  在tmux会话的命令行输入时，可以省略上述tmux前缀，其中list-buffers的操作如下所示：</p>
<p><img src="http://louiszhai.github.io/docImages/tmux06.png" alt="list-buffers"></p>
<p>  choose-buffer的操作如下所示：</p>
<p><img src="http://louiszhai.github.io/docImages/tmux05.png" alt="choose-buffer"></p>
<p>  默认情况下，buffers内容是独立于系统粘贴板的，它存在于tmux进程中，且可以在会话间共享。</p>
<h3 id="使用系统粘贴板"><a class="header-anchor" href="#使用系统粘贴板">¶</a>使用系统粘贴板</h3>
<p>  存在于tmux进程中的buffer缓存，虽然可以在会话间共享，但不能直接与系统粘贴板共享，不免有些遗憾。幸运的是，现在我们有成熟的方案来实现这个功能。</p>
<h4 id="在Linux上使用粘贴板"><a class="header-anchor" href="#在Linux上使用粘贴板">¶</a>在Linux上使用粘贴板</h4>
<p>  通常，Linux中可以使用xclip工具来接入系统粘贴板。<br>
  首先，需要安装xclip。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install xclip</span><br></pre></td></tr></table></figure>
<p>  然后，.tmux.conf的配置如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># buffer缓存复制到Linux系统粘贴板</span></span><br><span class="line"><span class="built_in">bind</span> C-c run <span class="string">" tmux save-buffer - | xclip -i -sel clipboard"</span></span><br><span class="line"><span class="comment"># Linux系统粘贴板内容复制到会话</span></span><br><span class="line"><span class="built_in">bind</span> C-v run <span class="string">" tmux set-buffer \"<span class="variable">$(xclip -o -sel clipboard)</span>\"; tmux paste-buffer"</span></span><br></pre></td></tr></table></figure>
<p>  按下prefix + Ctrl + c 键，buffer缓存的内容将通过xlip程序复制到粘贴板，按下prefix + Ctrl + v键，tmux将通过xclip访问粘贴板，然后由set-buffer命令设置给buffer缓存，最后由paste-buffer粘贴到tmux会话中。</p>
<h4 id="在Mac上使用粘贴板"><a class="header-anchor" href="#在Mac上使用粘贴板">¶</a>在Mac上使用粘贴板</h4>
<p>  我们都知道，Mac自带 pbcopy 和 pbpaste命令，分别用于复制和粘贴，但在tmux命令中它们却不能正常运行。这里我将详细介绍下原因：</p>
<blockquote>
<p>Mac的粘贴板服务是在引导命名空间注册的。命名空间存在层次之分，更高级别的命名空间拥有访问低级别命名空间（如root引导命名空间）的权限，反之却不行。流程创建的属于Mac登录会话的一部分，它会被自动包含在用户级的引导命名空间中，因此只有用户级的命名空间才能访问粘贴板服务。tmux使用守护进程(3)库函数创建其服务器进程，在Mac OS X 10.5中，苹果改变了守护进程(3)的策略，将生成的过程从最初的引导命名空间移到了根引导命名空间。而根引导命名空间访问权限较低，这意味着tmux服务器，和它的子进程，一同失去了原引导命名空间的访问权限（即无权限访问粘贴板服务）。</p>
</blockquote>
<p>  如此，我们可以使用一个小小的包装程序来重新连接到合适的命名空间，然后执行访问用户级命名空间的粘贴板服务，这个包装程序就是reattach-to-user-namespace。<br>
  那么，Mac下.tmux.conf的配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># buffer缓存复制到Mac系统粘贴板</span></span><br><span class="line"><span class="built_in">bind</span> C-c run <span class="string">"tmux save-buffer - | reattach-to-user-namespace pbcopy"</span></span><br><span class="line"><span class="comment"># Mac系统粘贴板内容复制到会话</span></span><br><span class="line"><span class="built_in">bind</span> C-v run <span class="string">"reattach-to-user-namespace pbpaste | tmux load-buffer - \; paste-buffer -d"</span></span><br></pre></td></tr></table></figure>
<p>  reattach-to-user-namespace 作为包装程序来访问Mac粘贴板，按下prefix + Ctrl + c 键，buffer缓存的内容将复制到粘贴板，按下prefix + Ctrl + v键，粘贴板的内容将通过 load-buffer 加载，然后由 paste-buffer 粘贴到tmux会话中。<br>
  为了在复制模式中使用Mac系统的粘贴板，可做如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绑定y键为复制选中文本到Mac系统粘贴板</span></span><br><span class="line"><span class="built_in">bind</span>-key -T copy-mode-vi <span class="string">'y'</span> send-keys -X copy-pipe-and-cancel <span class="string">'reattach-to-user-namespace pbcopy'</span></span><br><span class="line"><span class="comment"># 鼠标拖动选中文本，并复制到Mac系统粘贴板</span></span><br><span class="line"><span class="built_in">bind</span>-key -T copy-mode-vi MouseDragEnd1Pane send -X copy-pipe-and-cancel <span class="string">"pbcopy"</span></span><br></pre></td></tr></table></figure>
<p>  完成以上配置后记得重启tmux服务器。至此，复制模式中，按y键将保存选中的文本到Mac系统粘贴板，随后按Command + v键便可粘贴。</p>
<hr>
<h2 id="保存Tmux会话"><a class="header-anchor" href="#保存Tmux会话">¶</a>保存Tmux会话</h2>
<p>  信息时代，数据尤为重要。tmux保护现场的能力依赖于tmux进程，如果进程退出，则意味着会话数据的丢失，因此关机重启后，tmux中的会话将被清空，这不是我们想要见到的。幸运的是，目前有这样两款插件：Tmux Resurrect 和 Tmux Continuum，可以永久保存tmux会话（它们均适用于tmux v1.9及以上版本）。</p>
<h3 id="Tmux-Resurrect"><a class="header-anchor" href="#Tmux-Resurrect">¶</a>Tmux Resurrect</h3>
<p>  Tmux Resurrect无须任何配置，就能够备份tmux会话中的各种细节，包括窗口、面板的顺序、布局、工作目录，运行程序等等数据。因此它能在系统重启后完全地恢复会话。由于其幂等的恢复机制，它不会试图去恢复一个已经存在的窗口或者面板，所以，即使你不小心多恢复了几次会话，它也不会出现问题，这样主动恢复时我们就不必担心手抖多按了一次。另外，如果你是tmuxinator用户，我也建议你迁移到 tmux-resurrect插件上来，具体请参考<a href="https://github.com/tmux-plugins/tmux-resurrect/blob/master/docs/migrating_from_tmuxinator.md#migrating-from-tmuxinator" target="_blank" rel="noopener">Migrating from tmuxinator</a>。<br>
  Tmux Resurrec安装过程如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.tmux</span><br><span class="line">mkdir plugins</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/tmux-plugins/tmux-resurrect.git</span><br></pre></td></tr></table></figure>
<p>  安装后需在~/.tmux.conf中增加一行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run-shell ~/.tmux/plugins/tmux-resurrect/resurrect.tmux</span><br></pre></td></tr></table></figure>
<p>  至此安装成功，按下prefix + r重载tmux配置。<br>
  Tmux Resurrec提供如下两个操作：</p>
<ul>
<li>保存，快捷指令是prefix + Ctrl + s，tmux状态栏在保存开始，保存后分别提示”Saving…”，”Tmux environment saved !”。</li>
<li>恢复，快捷指令是prefix + Ctrl + r，tmux状态栏在恢复开始，恢复后分别提示”Restoring…”，”Tmux restore complete !”。</li>
</ul>
<p>  保存时，tmux会话的详细信息会以文本文件的格式保存到~/.tmux/resurrect目录，恢复时则从此处读取，由于数据文件是明文的，因此你完全可以自由管理或者编辑这些会话状态文件（如果备份频繁，记得定期清除历史备份）。</p>
<h4 id="可选的配置"><a class="header-anchor" href="#可选的配置">¶</a>可选的配置</h4>
<p>  Tmux Resurrec本身是免配置开箱即用的，但同时也提供了如下选项以便修改其默认设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @resurrect-save <span class="string">'S'</span> <span class="comment"># 修改保存指令为S</span></span><br><span class="line"><span class="built_in">set</span> -g @resurrect-restore <span class="string">'R'</span> 修改恢复指令为R</span><br><span class="line"><span class="comment"># 修改会话数据的保持路径，此处不能使用除了$HOME, $HOSTNAME, ~之外的环境变量</span></span><br><span class="line"><span class="built_in">set</span> -g @resurrect-dir <span class="string">'/some/path'</span></span><br></pre></td></tr></table></figure>
<p>  默认情况下只有一个保守的列表项（即vi vim nvim emacs man less more tail top htop irssi mutt）可以恢复，对此 Restoring programs doc 解释了怎么去恢复额外的项目。</p>
<h4 id="进阶的备份"><a class="header-anchor" href="#进阶的备份">¶</a>进阶的备份</h4>
<p>  除了基础备份外，Tmux Resurrec还提供进阶的备份功能，如下所示：</p>
<ul>
<li>恢复vim 和 neovim 会话</li>
<li>恢复面板内容</li>
<li>恢复shell的历史记录（实验性功能）</li>
</ul>
<p>  进阶的备份功能默认不开启，需要特别配置。</p>
<p>1. 恢复vim 和 neovim 会话，需要完成如下两步：</p>
<ul>
<li>通过vim的vim-obsession插件保存vim/neovim会话。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.vim/bundle</span><br><span class="line">git <span class="built_in">clone</span> git://github.com/tpope/vim-obsession.git</span><br><span class="line">vim -u NONE -c <span class="string">"helptags vim-obsession/doc"</span> -c q</span><br></pre></td></tr></table></figure>
<ul>
<li>在~/.tmux.conf中增加两行配置：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @resurrect-strategy-vim <span class="string">'session'</span> <span class="comment"># for vim</span></span><br><span class="line"><span class="built_in">set</span> -g @resurrect-strategy-nvim <span class="string">'session'</span> <span class="comment"># for neovim</span></span><br></pre></td></tr></table></figure>
<p>2. 恢复面板内容，需在~/.tmux.conf中增加一行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @resurrect-capture-pane-contents <span class="string">'on'</span> <span class="comment"># 开启恢复面板内容功能</span></span><br></pre></td></tr></table></figure>
<p>  目前使用该功能时，请确保tmux的default-command没有包含&amp;&amp; 或者||操作符，否则将导致bug。（查看default-command的值，请使用命令tmux show -g default-command。）</p>
<p>3. 恢复shell的历史记录，需在~/.tmux.conf中增加一行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @resurrect-save-shell-history <span class="string">'on'</span></span><br></pre></td></tr></table></figure>
<p>  由于技术的限制，保存时，只有无前台任务运行的面板，它的shell历史记录才能被保存。</p>
<h3 id="Tmux-Continuum"><a class="header-anchor" href="#Tmux-Continuum">¶</a>Tmux Continuum</h3>
<p>  可能你嫌手动保存和恢复太过麻烦，别担心，这不是问题。Tmux Continuum 在 Tmux Resurrec的基础上更进一步，现在保存和恢复全部自动化了，如你所愿，可以无感使用tmux，不用再担心备份问题。<br>
  Tmux Continuum安装过程如下所示（它依赖Tmux Resurrect，请保证已安装Tmux Resurrect插件）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.tmux/plugins</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/tmux-plugins/tmux-continuum.git</span><br></pre></td></tr></table></figure>
<p>  安装后需在~/.tmux.conf中增加一行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run-shell ~/.tmux/plugins/tmux-continuum/continuum.tmux</span><br></pre></td></tr></table></figure>
<p>  Tmux Continuum默认每隔15mins备份一次，我设置的是一天一次：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @continuum-save-interval <span class="string">'1440'</span></span><br></pre></td></tr></table></figure>
<p>  <strong>关闭自动备份</strong>，只需设置时间间隔为 0 即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @continuum-save-interval <span class="string">'0'</span></span><br></pre></td></tr></table></figure>
<p>  想要在<strong>tmux启动时就恢复最后一次保存的会话环境</strong>，需增加如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @continuum-restore <span class="string">'on'</span> <span class="comment"># 启用自动恢复</span></span><br></pre></td></tr></table></figure>
<p>  如果不想要启动时自动恢复的功能了，直接移除上面这行就行。想要绝对确定自动恢复不会发生，就在用户根目录下创建一个tmux_no_auto_restore空文件（创建命令：touch ~/tmux_no_auto_restore），该文件存在时，自动恢复将不触发。<br>
  对于tmux高级用户（可能就是你）而言，同时运行多个tmux服务器也是有可能的。你可能并不希望后面启用的几个tmux服务器自动恢复或者自动保存会话。因此Tmux Continuum会优先在第一个启用的tmux服务器中生效，随后启用的tmux服务器不再享受自动恢复或自动保存会话的待遇。<br>
  实际上，不管Tmux Continuum功能有没有启用，或者多久保存一次，我们都有办法从状态栏知晓。Tmux Continuum提供了一个查看运行状态的插值#{continuum_status}，它支持status-right 和 status-left两种状态栏设置，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g status-right <span class="string">'Continuum status: #&#123;continuum_status&#125;'</span></span><br></pre></td></tr></table></figure>
<p>  tmux运行时，#{continuum_status} 将显示保存的时间间隔（单位为分钟），此时状态栏会显示：</p>
<pre><code>Continuum status: 1440
</code></pre>
<p>  如果其自动保存功能关闭了，那么状态栏会显示：</p>
<pre><code>Continuum status: off
</code></pre>
<p>  借助Tmux Continuum插件，Mac重启时，我们甚至可以选择在Terminal 或者 iTerm2 中自动全屏启用tmux。<br>
  为此，需在~/.tmux.conf中增加一行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g @continuum-boot <span class="string">'on'</span></span><br></pre></td></tr></table></figure>
<p>  Mac下，自动启用tmux还支持如下选项：</p>
<ul>
<li><code>set -g @continuum-boot-options 'fullscreen' ，Terminal自动全屏，tmux命令在Terminal中执行。</code></li>
<li><code>set -g @continuum-boot-options 'iterm' ， iTerm2 替换 Terminal 应用，tmux命令在iTerm2中执行。</code></li>
<li><code>set -g @continuum-boot-options 'iterm,fullscreen'，iTerm2自动全屏，tmux命令在iTerm2中执行。</code><br>
  Linux中则没有这些选项，它只能设置为自动启用tmux服务器。</li>
</ul>
<h3 id="Tpm"><a class="header-anchor" href="#Tpm">¶</a>Tpm</h3>
<p>  以上，我们直接安装了tmux插件。这没有问题，可当插件越来越多时，我们就会需要统一的插件管理器。因此官方提供了tpm（支持tmux v1.9及以上版本）。<br>
  tpm安装过程如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.tmux/plugins</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/tmux-plugins/tpm</span><br></pre></td></tr></table></figure>
<p>  安装后需在~/.tmux.conf中增加如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认需要引入的插件</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tpm'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-sensible'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入其他插件的示例</span></span><br><span class="line"><span class="comment"># set -g @plugin 'github_username/plugin_name' # 格式：github用户名/插件名</span></span><br><span class="line"><span class="comment"># set -g @plugin 'git@github.com/user/plugin' # 格式：git@github插件地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化tmux插件管理器(保证这行在~/.tmux.conf的非常靠后的位置)</span></span><br><span class="line">run <span class="string">'~/.tmux/plugins/tpm/tpm'</span></span><br></pre></td></tr></table></figure>
<p>  然后按下prefix + r重载tmux配置，使得tpm生效。<br>
  基于tpm插件管理器，安装插件仅需如下两步：</p>
<ol>
<li>在~/.tmux.conf中增加新的插件，如set -g @plugin ‘…’。</li>
<li>按下prefix + I键下载插件，并刷新tmux环境。</li>
</ol>
<p>  <strong>更新插件</strong>，请按下prefix + U 键，选择待更新的插件后，回车确认并更新。<br>
  <strong>卸载插件</strong>，需如下两步：</p>
<ol>
<li>在~/.tmux.conf中移除插件所在行。</li>
<li>按下prefix + alt + u 移除插件。</li>
</ol>
<h2 id="会话共享"><a class="header-anchor" href="#会话共享">¶</a>会话共享</h2>
<h3 id="结对编程"><a class="header-anchor" href="#结对编程">¶</a>结对编程</h3>
<p>  tmux多会话连接实时同步的功能，使得结对编程成为了可能，这也是开发者最喜欢的功能之一。现在就差一步了，就是借助tmate把tmux会话分享出去。</p>
<p>  tmate是tmux的管理工具，它可以轻松的创建tmux会话，并且自动生成ssh链接。</p>
<p>  安装tmate</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install tmate</span><br></pre></td></tr></table></figure>
<p>  使用tmate新建一个tmux会话</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmate</span><br></pre></td></tr></table></figure>
<p>此时屏幕下方会显示ssh url，如下所示：</p>
<p><img src="http://louiszhai.github.io/docImages/tmux07.png" alt="ssh url"></p>
<p>  查看tmate生成的ssh链接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmate show-messages</span><br></pre></td></tr></table></figure>
<p>  生成的ssh url如下所示，其中一个为只读，另一个可编辑。</p>
<p><img src="http://louiszhai.github.io/docImages/tmux08.png" alt="ssh url"></p>
<h3 id="共享账号-组会话"><a class="header-anchor" href="#共享账号-组会话">¶</a>共享账号&amp;组会话</h3>
<p>  使用tmate远程共享tmux会话，受制于多方的网络质量，必然会存在些许延迟。如果共享会话的多方拥有同一个远程服务器的账号，那么我们可以使用组会话解决这个问题。<br>
  先在远程服务器上新建一个公共会话，命名为groupSession。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux new -s groupSession</span><br></pre></td></tr></table></figure>
<p>  其他用户不去直接连接这个会话，而是通过创建一个新的会话来加入上面的公共会话groupSession。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux new -t groupSession -s otherSession</span><br></pre></td></tr></table></figure>
<p>  此时两个用户都可以在同一个会话里操作，就会好像第二个用户连接到了groupSession的会话一样。此时两个用户都可以创建新建的窗口，新窗口的内容依然会实时同步，但是其中一个用户切换到其它窗口，对另外一个用户没有任何影响，因此在这个共享的组会话中，用户各自的操作可以通过新建窗口来执行。即使第二个用户关闭otherSession会话，共享会话groupSession依然存在。<br>
  组会话在共享的同时，又保留了相对的独立，非常适合结对编程场景，它是结对编程最简单的方式，如果账号不能共享，我们就要使用下面的方案了。</p>
<h3 id="独立账号-Socket共享会话"><a class="header-anchor" href="#独立账号-Socket共享会话">¶</a>独立账号&amp;Socket共享会话</h3>
<p>  开始之前我们需要确保用户对远程服务器上同一个目录拥有相同的读写权限，假设这个目录为/var/tmux/。<br>
  使用new-session（简写new）创建会话时，使用的是默认的socket位置，默认socket无法操作，所以我们需要创建一个指定socket文件的会话。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux -S /var/tmux/sharefile</span><br></pre></td></tr></table></figure>
<p>  另一个用户进入时，需要指定socket文件加入会话。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux -S /var/tmux/sharefile attach</span><br></pre></td></tr></table></figure>
<p>  这样，两个不同的用户就可以共享同一个会话了。<br>
  通常情况下，不同的用户使用不同的配置文件来创建会话，但是，使用指定socket文件创建的tmux会话，会话加载的是第一个创建会话的用户的~/.tmux.conf配置文件，随后加入会话的其他用户，依然使用同一份配置文件。</p>
<h2 id="Tmux优化"><a class="header-anchor" href="#Tmux优化">¶</a>Tmux优化</h2>
<p>  要想tmux更加人性化、性能更佳，不妨参考下如下配置。</p>
<h3 id="设置窗口面板起始序号"><a class="header-anchor" href="#设置窗口面板起始序号">¶</a>设置窗口面板起始序号</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g base-index 1 <span class="comment"># 设置窗口的起始下标为1</span></span><br><span class="line"><span class="built_in">set</span> -g pane-base-index 1 <span class="comment"># 设置面板的起始下标为1</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义状态栏"><a class="header-anchor" href="#自定义状态栏">¶</a>自定义状态栏</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g status-utf8 on <span class="comment"># 状态栏支持utf8</span></span><br><span class="line"><span class="built_in">set</span> -g status-interval 1 <span class="comment"># 状态栏刷新时间</span></span><br><span class="line"><span class="built_in">set</span> -g status-justify left <span class="comment"># 状态栏列表左对齐</span></span><br><span class="line">setw -g monitor-activity on <span class="comment"># 非当前窗口有内容更新时在状态栏通知</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -g status-bg black <span class="comment"># 设置状态栏背景黑色</span></span><br><span class="line"><span class="built_in">set</span> -g status-fg yellow <span class="comment"># 设置状态栏前景黄色</span></span><br><span class="line"><span class="built_in">set</span> -g status-style <span class="string">"bg=black, fg=yellow"</span> <span class="comment"># 状态栏前景背景色</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -g status-left <span class="string">"#[bg=#FF661D] ❐ #S "</span> <span class="comment"># 状态栏左侧内容</span></span><br><span class="line"><span class="built_in">set</span> -g status-right <span class="string">'Continuum status: #&#123;continuum_status&#125;'</span> <span class="comment"># 状态栏右侧内容</span></span><br><span class="line"><span class="built_in">set</span> -g status-left-length 300 <span class="comment"># 状态栏左边长度300</span></span><br><span class="line"><span class="built_in">set</span> -g status-right-length 500 <span class="comment"># 状态栏左边长度500</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -wg window-status-format <span class="string">" #I #W "</span> <span class="comment"># 状态栏窗口名称格式</span></span><br><span class="line"><span class="built_in">set</span> -wg window-status-current-format <span class="string">" #I:#W#F "</span> <span class="comment"># 状态栏当前窗口名称格式(#I：序号，#w：窗口名称，#F：间隔符)</span></span><br><span class="line"><span class="built_in">set</span> -wg window-status-separator <span class="string">""</span> <span class="comment"># 状态栏窗口名称之间的间隔</span></span><br><span class="line"><span class="built_in">set</span> -wg window-status-current-style <span class="string">"bg=red"</span> <span class="comment"># 状态栏当前窗口名称的样式</span></span><br><span class="line"><span class="built_in">set</span> -wg window-status-last-style <span class="string">"fg=red"</span> <span class="comment"># 状态栏最后一个窗口名称的样式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -g message-style <span class="string">"bg=#202529, fg=#91A8BA"</span> <span class="comment"># 指定消息通知的前景、后景色</span></span><br></pre></td></tr></table></figure>
<h3 id="开启256-colors支持"><a class="header-anchor" href="#开启256-colors支持">¶</a>开启256 colors支持</h3>
<p>  默认情况下，tmux中使用vim编辑器，文本内容的配色和直接使用vim时有些差距，此时需要开启256 colors的支持，配置如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g default-terminal <span class="string">"screen-256color"</span></span><br></pre></td></tr></table></figure>
<p>  或者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g default-terminal <span class="string">"tmux-256color"</span></span><br></pre></td></tr></table></figure>
<p>  或者启动tmux时增加参数-2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> tmux=<span class="string">'tmux -2'</span> <span class="comment"># Force tmux to assume the terminal supports 256 colours</span></span><br></pre></td></tr></table></figure>
<h3 id="关闭默认的rename机制"><a class="header-anchor" href="#关闭默认的rename机制">¶</a>关闭默认的rename机制</h3>
<p>  tmux默认会自动重命名窗口，频繁的命令行操作，将频繁触发重命名，比较浪费CPU性能，性能差的计算机上，问题可能更为明显。建议添加如下配置关闭rename机制。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setw -g automatic-rename off</span><br><span class="line">setw -g allow-rename off</span><br></pre></td></tr></table></figure>
<h3 id="去掉小圆点"><a class="header-anchor" href="#去掉小圆点">¶</a>去掉小圆点</h3>
<p>  tmux默认会同步同一个会话的操作到所有会话连接的终端窗口中，这种同步机制，限制了窗口的大小为最小的会话连接。因此当你开一个大窗口去连接会话时，实际的窗口将自动调整为最小的那个会话连接的窗口，终端剩余的空间将填充排列整齐的小圆点，如下所示。</p>
<p><img src="http://louiszhai.github.io/docImages/tmux03.png" alt="dot"></p>
<p>  为了避免这种问题，我们可以在连接会话的时候，断开其他的会话连接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux a -d</span><br></pre></td></tr></table></figure>
<p>  如果已经进入了tmux会话中，才发现这种问题，这个时候可以输入命令达到同样的效果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`: a -d</span><br></pre></td></tr></table></figure>
<p><img src="http://louiszhai.github.io/docImages/tmux04.gif" alt="remove dot"></p>
<h2 id="脚本化的Tmux"><a class="header-anchor" href="#脚本化的Tmux">¶</a>脚本化的Tmux</h2>
<p>  tmux作为终端复用软件，支持纯命令行操作也是其一大亮点。你既可以启用可视化界面创建会话，也可以运行脚本生成会话，对于tmux依赖者而言，编写几个tmux脚本批量维护会话列表，快速重启、切换、甚至分享部分会话都是非常方便的。可能会有人说为什么不用Tmux Resurrect呢？是的，Tmux Resurrect很好，一键恢复也很诱人，但是对于一个维护大量tmux会话的用户而言，一键恢复可能不见得好，分批次恢复可能是他（她）更想要的，脚本化的tmux就很好地满足了这点。<br>
  脚本中创建tmux会话时，由于不需要开启可视化界面，需要输入-d参数指定会话后台运行，如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux new -s init -d <span class="comment"># 后台创建一个名称为init的会话</span></span><br></pre></td></tr></table></figure>
<p>  新建的会话，建议重命令会话的窗口名称，以便后续维护。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命名init会话的第一个窗口名称为service</span></span><br><span class="line">tmux rename-window -t <span class="string">"init:1"</span> service</span><br></pre></td></tr></table></figure>
<p>  现在，可以在刚才的窗口中输入指令了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到指定目录并运行python服务</span></span><br><span class="line">tmux send -t <span class="string">"init:service"</span> <span class="string">"cd ~/workspace/language/python/;python2.7 server.py"</span> Enter</span><br></pre></td></tr></table></figure>
<p>  一个面板占用一个窗口可能太浪费了，我们来分个屏吧。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认上下分屏</span></span><br><span class="line">tmux split-window -t <span class="string">"init:service"</span></span><br><span class="line"><span class="comment"># 切换到指定目录并运行node服务</span></span><br><span class="line">tmux send -t <span class="string">"init:service"</span> <span class="string">'cd ~/data/louiszhai/node-webserver/;npm start'</span> Enter</span><br></pre></td></tr></table></figure>
<p>  现在一个窗口拥有上下两个面板，是时候创建一个新的窗口来运行更多的程序了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个名称为tool的窗口</span></span><br><span class="line">tmux neww -a -n tool -t init <span class="comment"># neww等同于new window</span></span><br><span class="line"><span class="comment"># 运行weinre调试工具</span></span><br><span class="line">tmux send -t <span class="string">"init:tool"</span> <span class="string">"weinre --httpPort 8881 --boundHost -all-"</span> Enter</span><br></pre></td></tr></table></figure>
<p>  另外新建窗口运行程序，有更方便的方式，比如使用 processes 选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux neww-n processes ls <span class="comment"># 新建窗口并执行命令，命令执行结束后窗口将关闭</span></span><br><span class="line">tmux neww-n processes top <span class="comment"># 由于top命令持续在前台运行，因此窗口将保留，直到top命令退出</span></span><br></pre></td></tr></table></figure>
<p>  新的窗口，我们尝试下水平分屏。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 水平分屏</span></span><br><span class="line">tmux split-window -h -t <span class="string">"init:tool"</span></span><br><span class="line"><span class="comment"># 切换到指定目录并启用aria2 web管理后台</span></span><br><span class="line">tmux send -t <span class="string">"init:tool"</span> <span class="string">"cd ~/data/tools/AriaNg/dist/;python -m SimpleHTTPServer 10108"</span> Enter</span><br></pre></td></tr></table></figure>
<p>  类似的脚本，我们可以编写一打，这样快速重启、切换、甚至分享会话都将更加便捷。</p>
<h2 id="开启自动启用Web服务器"><a class="header-anchor" href="#开启自动启用Web服务器">¶</a>开启自动启用Web服务器</h2>
<p>  开机自动准备工作环境是一个很好的idea，但却不好实现。对于程序员而言，一个开机即用的计算机会节省大量的初始化操作，特别是前端工程师，本地常常会启用多个服务器，每次开机挨个启动将耗时耗力。为此，在遇到tmux之前，我常常拖延重启计算机的时机，一度连续运行Mac一月之久，直到它不堪重负。<br>
  有了tmux脚本化的基础，开机自动启用web服务器就不在话下了，接杯水的时间，计算机就重启恢复了满血。如下是操作步骤：<br>
  首先，上面的tmux脚本，可以合并到同一个文件中，指定文件权限为可执行，<a href="http://xn--init-uh5fn22anwa323d.sh" target="_blank" rel="noopener">并命名为init.sh</a>（名称可自取）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod u+x ./init.sh</span><br></pre></td></tr></table></figure>
<p>  然后，打开 系统偏好设置 - 用户与群组 - 登录项，点击添加按钮+，选择刚刚保存的init.sh脚本，最终效果如下：</p>
<p><img src="http://louiszhai.github.io/docImages/tmux09.png" alt="init.sh"></p>
<p>  至此，Mac开机将自动运行 <a href="http://init.sh" target="_blank" rel="noopener">init.sh</a> 脚本，自动启用web服务器。<br>
  完成了上面这些配置，就真正实现了一键开机。<br>
  最后，附上我本地的配置文件<a href="https://github.com/Louiszhai/tmux/blob/master/.tmux.conf" target="_blank" rel="noopener">.tmux.conf</a>，以及启动脚本 <a href="https://github.com/Louiszhai/tmux/blob/master/init.sh" target="_blank" rel="noopener">init.sh</a>。明天就是国庆了，祝大家国庆快乐！</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>Elisp 学习笔记（一）</title>
    <url>/2019/10/05/Elisp-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h1>Elisp 学习笔记（一）</h1>
<h2 id="基础知识"><a class="header-anchor" href="#基础知识">¶</a>基础知识</h2>
<h3 id="函数和变量"><a class="header-anchor" href="#函数和变量">¶</a>函数和变量</h3>
<h4 id="函数"><a class="header-anchor" href="#函数">¶</a>函数</h4>
<ul>
<li>
<p>elisp 函数的一般形式：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> function-name (<span class="name">arguments-list</span>)</span><br><span class="line">  <span class="string">"document string"</span></span><br><span class="line">  body)</span><br></pre></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> hello-world (<span class="name">name</span>)</span><br><span class="line">  <span class="string">"Say hello to user whose name is NAME."</span></span><br><span class="line">  (<span class="name">message</span> <span class="string">"Hello, %s"</span> name))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>每个函数都有一个返回值。这个返回值一般是函数定义里的最后一个表达式的值。</p>
</li>
<li>
<p>elisp 中函数是全局的。</p>
</li>
</ul>
<h4 id="lambda-表达式"><a class="header-anchor" href="#lambda-表达式">¶</a><code>lambda</code> 表达式</h4>
<p>它的形式和 <code>defun</code> 是完全一样的：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">lambda</span> (<span class="name">arguments-list</span>)</span><br><span class="line">  <span class="string">"documentation string"</span></span><br><span class="line">  body)</span><br></pre></td></tr></table></figure>
<p>调用 <code>lambda</code> 方法如下：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">funcall</span> (<span class="name">lambda</span> (<span class="name">name</span>)</span><br><span class="line">           (<span class="name">message</span> <span class="string">"Hello, %s!"</span> name)) <span class="string">"Emacser"</span>)</span><br></pre></td></tr></table></figure>
<p>你也可以把 <code>lambda</code> 表达式赋值给一个变量，然后用 <code>funcall</code> 调用：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> foo (<span class="name">lambda</span> (<span class="name">name</span>)</span><br><span class="line">            (<span class="name">message</span> <span class="string">"Hello, %s!"</span> name)))</span><br><span class="line">(<span class="name">funcall</span> foo <span class="string">"Emacser"</span>)                   <span class="comment">; =&gt; "Hello, Emacser!"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>lambda</code> 表达式最常用的是作为参数传递给其它函数，比如 <code>mapc</code>。</p>
</blockquote>
<h4 id="变量"><a class="header-anchor" href="#变量">¶</a>变量</h4>
<ul>
<li>
<p>elisp 里的变量使用无需象 C 语言那样需要声明，你可以用 <code>setq</code> 直接对一个变量赋值。</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> foo <span class="string">"I'm foo"</span>)                    <span class="comment">; =&gt; "I'm foo"</span></span><br><span class="line">(<span class="name">message</span> foo)                           <span class="comment">; =&gt; "I'm foo"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>有一个特殊表达式（special form）<code>defvar</code>，它可以声明一个变量，一般的形式是：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defvar</span> variable-name value</span><br><span class="line">  <span class="string">"document string"</span>)</span><br></pre></td></tr></table></figure>
<p>它与 <code>setq</code> 的区别：</p>
<ol>
<li>
<p>如果变量在声明之前，这个变量已经有一个值的话，用 <code>defvar</code> 声明的变量值不会改变成声明的那个值。</p>
</li>
<li>
<p><code>defvar</code> 可以为变量提供文档字符串，当变量是在文件中定义的话，<code>C-h v</code> 后能给出变量定义的位置。比如：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defvar</span> foo <span class="string">"Did I have a value?"</span></span><br><span class="line">  <span class="string">"A demo variable"</span>)                    <span class="comment">; =&gt; foo</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; "I'm foo"</span></span><br><span class="line">(<span class="name">defvar</span> bar <span class="string">"I'm bar"</span></span><br><span class="line">  <span class="string">"A demo variable named \"bar\""</span>)      <span class="comment">; =&gt; bar</span></span><br><span class="line">bar                                     <span class="comment">; =&gt; "I'm bar"</span></span><br></pre></td></tr></table></figure>
<p>用 <code>C-h v</code> 查看 <code>foo</code> 的文档，可以看到它已经变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo&#39;s value is &quot;I&#39;m foo&quot;</span><br><span class="line">	</span><br><span class="line">Documentation:</span><br><span class="line">A demo variable</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>局部作用域的变量</p>
<p>如果没有局部作用域的变量，都使用 <strong>全局变量</strong>，函数会相当难写。elisp 里可以用 <code>let</code> 和 <code>let*</code> 进行局部变量的绑定。</p>
<ul>
<li>
<p><code>let</code> 使用的形式是：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">let</span> (<span class="name">bindings</span>)</span><br><span class="line">  body)</span><br></pre></td></tr></table></figure>
<p><code>bingdings</code> 可以是 <code>(var value)</code> 这样对 <code>var</code> 赋初始值的形式，或者用 <code>var</code> 声明一个初始值为 <code>nil</code> 的变量。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> circle-area (<span class="name">radix</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">pi</span> <span class="number">3.1415926</span>)</span><br><span class="line">        area)</span><br><span class="line">    (<span class="name">setq</span> area (<span class="name">*</span> pi radix radix))</span><br><span class="line">    (<span class="name">message</span> <span class="string">"直径为 %.2f 的圆面积是 %.2f"</span> radix area)))</span><br><span class="line">(<span class="name">circle-area</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><code>C-h v</code> 查看 <code>area</code> 和 <code>pi</code> 应该没有这两个变量。</p>
</li>
<li>
<p><code>let*</code> 和 <code>let</code> 的使用形式完全相同，唯一的区别是在 <code>let*</code> 声明中就能使用前面声明的变量，比如：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> circle-area (<span class="name">radix</span>)</span><br><span class="line">  (<span class="name">let*</span> ((<span class="name">pi</span> <span class="number">3.1415926</span>)</span><br><span class="line">        (<span class="name">area</span> (<span class="name">*</span> pi radix radix)))</span><br><span class="line">   (<span class="name">message</span> <span class="string">"直径为 %.2f 的圆面积是 %.2f"</span> radix area)))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="控制结构"><a class="header-anchor" href="#控制结构">¶</a>控制结构</h4>
<ul>
<li>
<p>顺序执行</p>
<p>一般来说程序都是按表达式顺序依次执行的。这在 <code>defun</code> 等特殊环境中是自动进行的。**但是一般情况下都不是这样的。比如你无法用 <code>eval-last-sexp</code> 同时执行两个表达式，在 <code>if</code> 表达式中的条件为真时执行的部分也只能运行一个表达式。**这时就需要用 <code>progn</code> 这个特殊表达式。它的使用形式如下：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">progn</span> A B C ...)</span><br></pre></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">progn</span></span><br><span class="line">  (<span class="name">setq</span> foo <span class="number">3</span>)</span><br><span class="line">  (<span class="name">message</span> <span class="string">"Square of %d is %d"</span> foo (<span class="name">*</span> foo foo)))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>条件判断</p>
<ul>
<li>
<p><code>if</code> ：</p>
<p>形式：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">if</span> condition</span><br><span class="line">    then</span><br><span class="line">	else)</span><br></pre></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> my-max (<span class="name">a</span> b)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> a b)</span><br><span class="line">      a b))</span><br><span class="line">(<span class="name">my-max</span> <span class="number">3</span> <span class="number">4</span>)                            <span class="comment">; =&gt; 4</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>cond</code> ：</p>
<p>形式：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">cond</span> (<span class="name">case1</span> do-when-case1)</span><br><span class="line">	(<span class="name">case2</span> do-when-case2)</span><br><span class="line">  ...</span><br><span class="line">	(<span class="name">t</span> do-when-none-meet))</span><br></pre></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> fib (<span class="name">n</span>)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">=</span> n <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">       ((<span class="name">=</span> n <span class="number">1</span>) <span class="number">1</span>)</span><br><span class="line">       (<span class="name">t</span> (<span class="name">+</span> (<span class="name">fib</span> (<span class="name">-</span> n <span class="number">1</span>))</span><br><span class="line">	      (<span class="name">fib</span> (<span class="name">-</span> n <span class="number">2</span>))))))</span><br><span class="line">(<span class="name">fib</span> <span class="number">10</span>)                                <span class="comment">; =&gt; 55</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>when</code> ：</p>
<p>形式：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">when</span> condition</span><br><span class="line">    ...)</span><br><span class="line"><span class="comment">;; 等同于</span></span><br><span class="line"><span class="comment">;;	(if condition</span></span><br><span class="line"><span class="comment">;;	    (progn</span></span><br><span class="line"><span class="comment">;;			...))</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>unless</code> ：</p>
<p>等同于：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">when</span> not condition</span><br><span class="line">	...)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>循环</p>
<p>循环使用的是 <code>while</code> 表达式。它的形式是：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">while</span> condition</span><br><span class="line">  body)</span><br></pre></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> factorial (<span class="name">n</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">res</span> <span class="number">1</span>))</span><br><span class="line">    (<span class="name">while</span> (<span class="name">&gt;</span> n <span class="number">1</span>)</span><br><span class="line">      (<span class="name">setq</span> res (<span class="name">*</span> res n)</span><br><span class="line">           n (<span class="name">-</span> n <span class="number">1</span>)))</span><br><span class="line">    res))</span><br><span class="line">(<span class="name">factorial</span> <span class="number">10</span>)                          <span class="comment">; =&gt; 3628800</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="逻辑运算"><a class="header-anchor" href="#逻辑运算">¶</a>逻辑运算</h4>
<p>条件的逻辑运算和其它语言都是很类似的，使用 <code>and</code>、<code>or</code>、<code>not</code>。<code>and</code> 和 <code>or</code> 也同样具有短路性质。很多人喜欢在表达式短路时，用 <code>and</code> 代替 <code>when</code>，<code>or</code> 代替 <code>unless</code>。<strong>当然这时一般不关心它们的返回值，而是在于表达式其它子句的副作用</strong>。比如 <code>or</code> 经常用于设置函数的缺省值，而 <code>and</code> 常用于参数检查：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> hello-world (<span class="name">&amp;optional</span> name)</span><br><span class="line">  (<span class="name">or</span> name (<span class="name">setq</span> name <span class="string">"Emacser"</span>))</span><br><span class="line">  (<span class="name">message</span> <span class="string">"Hello, %s"</span> name))           <span class="comment">; =&gt; hello-world</span></span><br><span class="line">(<span class="name">hello-world</span>)                           <span class="comment">; =&gt; "Hello, Emacser"</span></span><br><span class="line">(<span class="name">hello-world</span> <span class="string">"Ye"</span>)                      <span class="comment">; =&gt; "Hello, Ye"</span></span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> square-number-p (<span class="name">n</span>)</span><br><span class="line">  (<span class="name">and</span> (<span class="name">&gt;=</span> n <span class="number">0</span>)</span><br><span class="line">       (<span class="name">=</span> (<span class="name">/</span> n (<span class="name">sqrt</span> n)) (<span class="name">sqrt</span> n))))</span><br><span class="line">(<span class="name">square-number-p</span> <span class="number">-1</span>)                    <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">square-number-p</span> <span class="number">25</span>)                    <span class="comment">; =&gt; t</span></span><br></pre></td></tr></table></figure>
<h2 id="基本数据类型"><a class="header-anchor" href="#基本数据类型">¶</a>基本数据类型</h2>
<ul>
<li>
<p>内建的 emacs 数据类型称为 primitive types，包括：</p>
<ul>
<li>整数</li>
<li>浮点数</li>
<li>cons</li>
<li>符号 (symbol)</li>
<li>字符串</li>
<li>向量 (vector)</li>
<li>散列表 (hash-table)</li>
<li>subr（内建函数，比如 <code>cons</code>, <code>if</code>, <code>and</code> 之类）</li>
<li>byte-code function</li>
<li>其它特殊类型，例如缓冲区（buffer）</li>
</ul>
</li>
<li>
<p>读入语法和输出形式</p>
<ul>
<li>
<p>读入语法是让 elisp 解释器明白输入字符所代表的对象。简单的来说，一种数据类型有（也可能没有，比如散列表）对应的规则来让解释器产生这种数据类型，比如 <code>123</code> 产生整数 <code>123</code>，<code>(a . b)</code> 产生一个 cons。</p>
</li>
<li>
<p>所谓输出形式是解释器用产生一个字符串来表示一个数据对象。比如整数 <code>123</code> 的输出形式就是 <code>12</code>3，<code>cons cell (a . b)</code> 的输出形式是 <code>(a . b)</code>。与读入语法不同的是，<strong>数据对象都有输出形式</strong>。比如散列表的输出可能是这样的：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">#&lt;hash-table 'eql <span class="literal">nil</span> <span class="number">0/65</span> <span class="number">0</span>xa7344c8&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="数字"><a class="header-anchor" href="#数字">¶</a>数字</h3>
<p>emacs 的数字分为 <strong>整数</strong> 和 <strong>浮点数</strong>（<strong>和 C 比没有双精度数 double</strong>）。<code>1</code>， <code>1.</code>，<code>+1</code>, <code>-1</code>, <code>536870913</code>, <code>0</code>, <code>-0</code> 这些都是整数。整数的范围是和机器是有关的，一般来最小范围是在 <code>-268435456</code> to <code>268435455</code>（29位，<code>-2**28</code> ~ <code>2**28-1</code>）。<strong>可以从 <code>most-positive-fixnum</code> 和 <code>most-negative-fixnum</code> 两个变量得到整数的范围。</strong></p>
<ul>
<li>
<p>整数</p>
<p>你可以用多种进制来输入一个整数。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"><span class="number">#b101100</span> =&gt; <span class="number">44</span>      <span class="comment">; 二进制</span></span><br><span class="line"><span class="number">#o54</span> =&gt; <span class="number">44</span>          <span class="comment">; 八进制</span></span><br><span class="line"><span class="number">#x2c</span> =&gt; <span class="number">44</span>          <span class="comment">; 十进制</span></span><br></pre></td></tr></table></figure>
<p>最神奇的是你可以用 <code>2</code> 到 <code>36</code> 之间任意一个数作为基数，比如：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">#24r1k =&gt; <span class="number">44</span>        <span class="comment">; 二十四进制</span></span><br></pre></td></tr></table></figure>
<p>之所以最大是 36，是因为只有 <code>0-9</code> 和 <code>a-z</code> 36 个。</p>
</li>
<li>
<p>浮点数</p>
<p><code>1500.0</code>, <code>15e2</code>, <code>15.0e2</code>, <code>1.5e3</code>, 和 <code>.15e4</code> 都可以用来表示一个浮点数 <code>1500.</code>。遵循 IEEE 标准，elisp 也有一个特殊类型的值称为 <code>NaN</code> (not-a-number)。你可以用 <code>(/ 0.0 0.0)</code> 产生这个数。</p>
</li>
</ul>
<h4 id="测试函数"><a class="header-anchor" href="#测试函数">¶</a>测试函数</h4>
<p>整数类型测试函数是 <code>integerp</code>，浮点数类型测试函数是 <code>floatp</code>。数字类型测试用 <code>numberp</code>。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">integerp</span> <span class="number">1</span>.)                           <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">integerp</span> <span class="number">1.0</span>)                          <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">floatp</span> <span class="number">1</span>.)                             <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">floatp</span> <span class="number">-0.0</span>e+NaN)                      <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">numberp</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>还提供一些特殊测试，比如测试是否是零的 <code>zerop</code>，还有非负整数测试的 <code>wholenump</code>。</p>
<blockquote>
<p>注：<strong>elisp 测试函数一般都是用 p 来结尾，p 是 predicate 的第一个字母。如果函数名是一个单词，通常只是在这个单词后加一个 p，如果是多个单词，一般是加 -p</strong>。</p>
</blockquote>
<h4 id="数的比较"><a class="header-anchor" href="#数的比较">¶</a>数的比较</h4>
<p>常用的比较操作符号是我们在其它言中都很熟悉的，比如 <code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>，不一样的是，由于赋值是使用 <code>set</code> 函数，所以 <strong><code>=</code> 不再是一个赋值运算符了，而是测试数字相等符号</strong>。和其它语言类似，<strong>对于浮点数的相等测试都是不可靠的</strong>。比如：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> foo (<span class="name">-</span> (<span class="name">+</span> <span class="number">1.0</span> <span class="number">1.0e-3</span>) <span class="number">1.0</span>))       <span class="comment">; =&gt; 0.0009999999999998899</span></span><br><span class="line">(<span class="name">setq</span> bar <span class="number">1.0e-3</span>)                       <span class="comment">; =&gt; 0.001</span></span><br><span class="line">(<span class="name">=</span> foo bar)                             <span class="comment">; =&gt; nil</span></span><br></pre></td></tr></table></figure>
<p>所以一定要确定两个浮点数是否相同，是要在一定误差内进行比较。这里给出一个函数：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defvar</span> fuzz-factor <span class="number">1.0e-6</span>)</span><br><span class="line">(<span class="name">defun</span> approx-equal (<span class="name">x</span> y)</span><br><span class="line">  (<span class="name">or</span> (<span class="name">and</span> (<span class="name">=</span> x <span class="number">0</span>) (<span class="name">=</span> y <span class="number">0</span>))</span><br><span class="line">      (<span class="name">&lt;</span> (<span class="name">/</span> (<span class="name">abs</span> (<span class="name">-</span> x y))</span><br><span class="line">            (<span class="name">max</span> (<span class="name">abs</span> x) (<span class="name">abs</span> y)))</span><br><span class="line">         fuzz-factor)))</span><br><span class="line">(<span class="name">approx-equal</span> foo bar)                  <span class="comment">; =&gt; t</span></span><br></pre></td></tr></table></figure>
<p>还有一个测试数字是否相等的函数 <code>eql</code>，这是函数不仅测试数字的值是否相等，还测试数字类型是否一致，比如：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">=</span> <span class="number">1.0</span> <span class="number">1</span>)                               <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">eql</span> <span class="number">1.0</span> <span class="number">1</span>)                             <span class="comment">; =&gt; nil</span></span><br></pre></td></tr></table></figure>
<p><strong>elisp 没有 <code>+=</code>, <code>-=</code>, <code>/=</code>, <code>*=</code> 这样的命令式语言里常见符号</strong>，如果你想实现类似功能的语句，只能用赋值函数 setq 来实现了。 <strong><code>/=</code> 符号被用来作为不等于的测试了</strong>。</p>
<h4 id="数的转换"><a class="header-anchor" href="#数的转换">¶</a>数的转换</h4>
<ul>
<li>
<p>整数向浮点数转换是通过 <code>float</code> 函数进行的。</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">float</span> <span class="number">1</span>)                             <span class="comment">; =&gt; 1.0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>浮点数转换成整数有这样几个函数：</p>
<ul>
<li>
<p><code>truncate</code> 转换成靠近 0 的整数：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">truncate</span> <span class="number">1.2</span>)                      <span class="comment">; =&gt; 1 (#o1, #x1)</span></span><br><span class="line">(<span class="name">truncate</span> <span class="number">1.7</span>)                      <span class="comment">; =&gt; 1 (#o1, #x1)</span></span><br><span class="line">(<span class="name">truncate</span> <span class="number">-1.2</span>)                     <span class="comment">; =&gt; 1 (#o3777777777777, #x3ffffffffff)</span></span><br><span class="line">(<span class="name">truncate</span> <span class="number">-1.7</span>)                     <span class="comment">; =&gt; 1 (#o3777777777777, #x3ffffffffff)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>floor</code> 转换成最接近的不比本身大的整数</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">floor</span> <span class="number">1.2</span>)                      <span class="comment">; =&gt; 1 (#o1, #x1)</span></span><br><span class="line">(<span class="name">floor</span> <span class="number">1.7</span>)                      <span class="comment">; =&gt; 1 (#o1, #x1)</span></span><br><span class="line">(<span class="name">floor</span> <span class="number">-1.2</span>)                     <span class="comment">; =&gt; 1 (#o3777777777776, #x3fffffffffe)</span></span><br><span class="line">(<span class="name">floor</span> <span class="number">-1.7</span>)                     <span class="comment">; =&gt; 1 (#o3777777777776, #x3fffffffff6)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>ceiling</code> 转换成最接近的不比本身小的整数</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">ceiling</span> <span class="number">1.2</span>)                      <span class="comment">; =&gt; 2 (#o2, #x2)</span></span><br><span class="line">(<span class="name">ceiling</span> <span class="number">1.7</span>)                      <span class="comment">; =&gt; 2 (#o2, #x2)</span></span><br><span class="line">(<span class="name">ceiling</span> <span class="number">-1.2</span>)                     <span class="comment">; =&gt; -1 (#o3777777777777, #x3ffffffffff)</span></span><br><span class="line">(<span class="name">ceiling</span> <span class="number">-1.7</span>)                     <span class="comment">; =&gt; -1 (#o3777777777776, #x3fffffffff6)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>round</code> 四舍五入后的整数，换句话说和它的差绝对值最小的整数</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">round</span> <span class="number">1.2</span>)                      <span class="comment">; =&gt; 1 (#o1, #x1)</span></span><br><span class="line">(<span class="name">round</span> <span class="number">1.7</span>)                      <span class="comment">; =&gt; 2 (#o2, #x2)</span></span><br><span class="line">(<span class="name">ceiling</span> <span class="number">-1.2</span>)                     <span class="comment">; =&gt; -1 (#o3777777777777, #x3ffffffffff)</span></span><br><span class="line">(<span class="name">ceiling</span> <span class="number">-1.7</span>)                     <span class="comment">; =&gt; -2 (#o3777777777776, #x3fffffffff6)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这里提一个问题，浮点数的范围是无穷大的，而整数是有范围的。如果用前面的函数转换 <code>1e20</code> 将会报错。</p>
</blockquote>
</li>
</ul>
<h4 id="数的运算"><a class="header-anchor" href="#数的运算">¶</a>数的运算</h4>
<ul>
<li>
<p>四则运算 <code>+</code> <code>-</code> <code>*</code> <code>/</code></p>
<p><strong>和 C 语言类似，如果参数都是整数，作除法时要记住 <code>(/ 5 6)</code> 是会等于 <code>0</code> 的。如果参数中有浮点数，整数会自动转换成浮点数进行运算，所以 <code>(/ 5 6.0)</code> 的值才会是 <code>5/6</code>。</strong></p>
</li>
<li>
<p><code>++</code> 和 <code>--</code></p>
<p>没有 <code>++</code> 和 <code>--</code> 操作了，类似的两个函数是 <code>1+</code> 和 <code>1-</code>。可以用 <code>setq</code> 赋值来代替 <code>++</code> 和 <code>--</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> foo <span class="number">10</span>)                           <span class="comment">; =&gt; 10</span></span><br><span class="line">(<span class="name">setq</span> foo (<span class="number">1</span>+ foo))                     <span class="comment">; =&gt; 11</span></span><br><span class="line">(<span class="name">setq</span> foo (<span class="number">1</span>- foo))                     <span class="comment">; =&gt; 10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可能有人看过有 <code>incf</code> 和 <code>decf</code> 两个实现 <code>++</code> 和 <code>--</code> 操作。这两个宏是可以用的。这两个宏是 Common Lisp 里的，emacs 有模拟的 Common Lisp 的库 <code>cl</code>。但是 RMS 认为最好不要使用这个库。但是你可以在你的 elisp 包中使用这两个宏，只要在文件头写上：</p>
</blockquote>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">eval-when-compile</span></span><br><span class="line">  (<span class="name">require</span> 'cl))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <code>abs</code> 取数的绝对值。</p>
</li>
<li>
<p>取整</p>
<p>有两个取整的函数，一个是符号 <code>%</code>，一个是函数 <code>mod</code>。这两个函数的区别是：</p>
<ol>
<li>
<p><code>%</code> 的第一个参数必须是整数，而 <code>mod</code> 的第一个参数可以是整数也可以是浮点数。</p>
</li>
<li>
<p>即使对相同的参数，两个函数也不一定有相同的返回值：</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">+</span> (% DIVIDEND DIVISOR)</span><br><span class="line">   (<span class="name">*</span> (<span class="name">/</span> DIVIDEND DIVISOR) DIVISOR))</span><br></pre></td></tr></table></figure>
<p>和 <code>DIVIDEND</code> 是相同的。而：</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">+</span> (<span class="name">mod</span> DIVIDEND DIVISOR)</span><br><span class="line">   (<span class="name">*</span> (<span class="name">floor</span> DIVIDEND DIVISOR) DIVISOR))</span><br></pre></td></tr></table></figure>
<p>和 <code>DIVIDEND</code> 是相同的。</p>
<blockquote>
<p>注：<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Arithmetic-Operations.html" target="_blank" rel="noopener">原文</a></p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>三角函数</p>
<ul>
<li><code>sin</code></li>
<li><code>cos</code></li>
<li><code>tan</code></li>
<li><code>asin</code></li>
<li><code>acos</code></li>
<li><code>atan</code></li>
</ul>
</li>
<li>
<p>开方</p>
<p><code>sqrt</code></p>
</li>
<li>
<p>指数和对数</p>
<ul>
<li><code>exp</code>：以 e 为底指数运算。</li>
<li><code>expt</code>：指定底数指数运算。</li>
<li><code>log</code>：对数运算，<strong>默认底数是 e</strong>。</li>
<li><code>logb</code>：以 2 为底的对数运算，但<strong>返回的是一个整数</strong>。用于计算数的位。</li>
</ul>
</li>
<li>
<p>随机数</p>
<p><code>random</code> 可以产生随机数。可以用 <code>(random t)</code> 来产生一个新种子。虽然 emacs 每次启动后调用 <code>random</code> 总是产生相同的随机数，但是运行过程中，你不知道调用了多少次，所以使用时还是不需要再调用一次 <code>(random t)</code> 来产生新的种子。</p>
</li>
<li>
<p>整数位运算</p>
<p>位运算在 emacs lisp 中仅适用于整数。</p>
<ul>
<li>
<p><code>(lsh integer1 count)</code>：逻辑位移。如果 <code>count</code> 为正数，则将 <code>integer1</code> 左移 <code>count</code> 位；如果 <code>count</code> 为负数，则将 <code>integer1</code> 右移 <code>-count</code> 位，空位补 <code>0</code>，并且，<code>count</code> 为负数时，<code>lsh</code> 的补 <code>0</code> 方式是在<strong>最高有效位依次插 <code>0</code></strong>。</p>
<p>例（仅考虑低8位，其它位为 0）：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">lsh</span> <span class="number">5</span> <span class="number">1</span>)  <span class="comment">;; 十进制 5 逻辑左移 1 位变为 10；二进制 00000101 变为 00001010</span></span><br><span class="line">(<span class="name">lsh</span> <span class="number">3</span> <span class="number">2</span>)  <span class="comment">;; 十进制 3 逻辑左移 2 位变为 12；二进制 00000011 变为 00001100</span></span><br><span class="line">(<span class="name">lsh</span> <span class="number">6</span> <span class="number">-1</span>)  <span class="comment">;; 十进制 6 逻辑右移 1 位变为 3；二进制 00000110 变为 00000011</span></span><br></pre></td></tr></table></figure>
<p>与所有 emacs lisp 算术运算函数一样，位移运算不检查溢出，所以左移操作可能会忽略符号位（significant bits）并改变数的正负。例如在 28 位计算机上将 <code>134217727</code> 左移 1 位将会得到 <code>-2</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">lsh</span> <span class="number">134217727</span> <span class="number">1</span>)  <span class="comment">;; 十进制 134217727 逻辑左移 1 位变为 -2；二进制 0111  1111 1111  1111 1111  1111 1111 变为 1111  1111 1111  1111 1111  1111 1110</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>(ash integer1 count)</code>：算术位移。除非 <code>integer1</code> 和 <code>count</code> 全是负数，否则 <code>ash</code> 和 <code>lsh</code> 返回的结果是一样的。当 <code>integer1</code> 和 <code>count</code> 全为负时，<code>lsh</code> 会在左侧补 <code>0</code>，而 <code>ash</code> 会在左侧补 <code>1</code>。</p>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">ash</span> <span class="number">-6</span> <span class="number">-1</span>) <span class="comment">;; 十进制 -6 算术右移 1 位变为 -3；二进制1111  1111 1111  1111 1111  1111 1010 变为 1111  1111 1111  1111 1111  1111 1101</span></span><br><span class="line">(<span class="name">lsh</span> <span class="number">-6</span> <span class="number">-1</span>) <span class="comment">;; 十进制 -6 逻辑右移 1 位变为 134217725；二进制1111  1111 1111  1111 1111  1111 1010 变为 0111  1111 1111  1111 1111  1111 1101</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>logand</code>、<code>logior</code>、<code>logexor</code> 和 <code>lognot</code> 参考<a href="http://ftp.gnu.org/old-gnu/Manuals/elisp-manual-21-2.8/html_node/elisp_65.html" target="_blank" rel="noopener">这里</a>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="字符和字符串"><a class="header-anchor" href="#字符和字符串">¶</a>字符和字符串</h3>
<p>在 emacs 里<strong>字符串是有序的字符数组</strong>。和 C 语言的字符串数组不同，emacs 的字符串可以容纳任何字符，包括 <code>\0</code>：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> foo <span class="string">"abc\000abc"</span>)                 <span class="comment">; =&gt; "abc^@abc"</span></span><br></pre></td></tr></table></figure>
<h4 id="字符的读入"><a class="header-anchor" href="#字符的读入">¶</a>字符的读入</h4>
<p>构成字符串的字符其实就是一个整数。一个字符 <code>'A'</code> 就是一个整数 <code>65</code>。但是目前字符串中的字符被限制在 0-524287 之间。字符的读入语法是在字符前加上一个问号，比如 <code>?A</code> 代表字符 <code>'A'</code>。<br>
对于标点来说，也可以用同样的语法，但是最好在前面加上转义字符 <code>\</code>，因为有些标点会有岐义，比如 <code>?\(</code>。<code>\</code> 必须用 <code>?\\</code> 表示。控制字符，退格、制表符，换行符，垂直制表符，换页符，空格，回车，删除和 escape 分别表示为 <code>?\a</code>, <code>?\b</code>, <code>?\t</code>, <code>?\n</code>, <code>?\v</code>, <code>?\f</code>, <code>?\s</code>, <code>?\r</code>, <code>?\d</code>, 和 <code>?\e</code>。**对于没有特殊意义的字符，加上转义字符 <code>\</code> 是没有副作用的，比如 <code>?\+</code> 和 <code>?+</code> 是完全一样的。**所以标点还是都用转义字符来表示吧。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">?\a =&gt; 7                 ; control-g, `C-g'</span><br><span class="line">?\b =&gt; 8                 ; backspace, &lt;BS&gt;, `C-h'</span><br><span class="line">?\t =&gt; 9                 ; tab, &lt;TAB&gt;, `C-i'</span><br><span class="line">?\n =&gt; 10                ; newline, `C-j'</span><br><span class="line">?\v =&gt; 11                ; vertical tab, `C-k'</span><br><span class="line">?\f =&gt; 12                ; formfeed character, `C-l'</span><br><span class="line">?\r =&gt; 13                ; carriage return, &lt;RET&gt;, `C-m'</span><br><span class="line">?\e =&gt; 27                ; escape character, &lt;ESC&gt;, `C-['</span><br><span class="line">?\s =&gt; 32                ; space character, &lt;SPC&gt;</span><br><span class="line">?\\ =&gt; 92                ; backslash character, `\'</span><br><span class="line">?\d =&gt; 127               ; delete character, &lt;DEL&gt;</span><br></pre></td></tr></table></figure>
<p>控制字符可以有多种表示方式，比如 <code>C-i</code>，这些都是对的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">?\^I  ?\^i  ?\C-I  ?\C-i</span><br></pre></td></tr></table></figure>
<p>它们都对应数字 <code>9</code>。<br>
meta 字符是用 修饰键（通常就是 Alt 键）输入的字符。之所以称为修饰键，是因为这样输入的字符就是在其修饰字符的第 27 位由 <code>0</code> 变成 <code>1</code> 而成，也就是如下操作：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">(<span class="name">logior</span> (<span class="name">lsh</span> <span class="number">1</span> <span class="number">27</span>) ?A)                  <span class="comment">; =&gt; 134217793</span></span><br><span class="line">?\M-A                                   ; =&gt; 134217793</span><br></pre></td></tr></table></figure>
<p>你可以用 <code>\M-</code> 代表 meta 键，加上修饰的字符就是新生成的字符。比如：<code>?\M-A</code>, <code>?\M-\C-b</code>。 后面这个也可以写成 <code>?\C-\M-b</code>。</p>
<p>如果你还记得前面说过字符串里的字符不能超过 524287 的话，这就可以看出字符串是不能放下一个 meta 字符的。所以按键序列在这时只能用 vector 来储存。</p>
<p>其它的修饰键也是类似的。emacs 用 <code>2**25</code> 位来表示 shift 键，<code>2**24</code> 对应 hyper，<code>2**23</code> 对应 super，<code>2**22</code> 对应 alt。</p>
<h4 id="测试函数-v2"><a class="header-anchor" href="#测试函数-v2">¶</a>测试函数</h4>
<ul>
<li>字符串测试使用 <code>stringp</code>，没有 <code>charp</code>，因为字符就是整数。</li>
<li><code>string-or-null-p</code> 当对象是一个字符或 <code>nil</code> 时返回 <code>t</code>。</li>
<li><code>char-or-string-p</code> 测试是否是字符串或者字符类型。</li>
</ul>
<p>比较头疼的是 emacs 没有测试字符串是否为空的函数。这是我用的这个测试函数，使用前要测试字符串是否为 <code>nil</code>：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> string-emptyp (<span class="name">str</span>)</span><br><span class="line">  (<span class="name">not</span> (<span class="name">string&lt;</span> <span class="string">""</span> str)))</span><br></pre></td></tr></table></figure>
<h4 id="构造函数"><a class="header-anchor" href="#构造函数">¶</a>构造函数</h4>
<ul>
<li>
<p>产生一个字符串可以用 <code>make-string</code>。这样生成的字符串包含的字符都是一样的。</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">make-string</span> <span class="number">5</span> ?x)                      <span class="comment">; =&gt; "xxxxx"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>要生成不同的字符串可以用 <code>string</code> 函数。</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">string</span> ?a ?b ?c)                       <span class="comment">; =&gt; "abc"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在已有的字符串生成新的字符串的方法有 <code>substring</code>, <code>concat</code>。</p>
<ul>
<li>
<p><code>substring</code> 的后两个参数是起点和终点的位置。如果终点越界或者终点比起点小都会产生一个错误。这个在使用 <code>substring</code> 时要特别小心。</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">substring</span> <span class="string">"0123456789"</span> <span class="number">3</span>)              <span class="comment">; =&gt; "3456789"</span></span><br><span class="line">(<span class="name">substring</span> <span class="string">"0123456789"</span> <span class="number">3</span> <span class="number">5</span>)            <span class="comment">; =&gt; "34"</span></span><br><span class="line">(<span class="name">substring</span> <span class="string">"0123456789"</span> <span class="number">-3</span> <span class="number">-1</span>)          <span class="comment">; =&gt; "78"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>concat</code> 函数相对简单，就是把几个字符串连接起来：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">concat</span> <span class="string">"foo"</span> <span class="string">"bar"</span>)                    <span class="comment">; =&gt; "foobar"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="字符串比较"><a class="header-anchor" href="#字符串比较">¶</a>字符串比较</h4>
<ul>
<li>
<p><code>char-equal</code> 可以比较两个字符是否相等。与整数比较不同，这个函数还考虑了大小写。<strong>如果 <code>case-fold-search</code> 变量是 <code>t</code> 时，这个函数的字符比较是忽略大小写的。</strong></p>
<blockquote>
<p>编程时要小心，因为通常 <code>case-fold-search</code> 都是 <code>t</code>，这样如果要考虑字符的大小写时就不能用 <code>char-equal</code> 函数了。</p>
</blockquote>
</li>
<li>
<p>字符串比较使用 <code>string=</code>，<code>string-equal</code> 是一个别名。</p>
</li>
<li>
<p><code>string&lt;</code> 是按字典序比较两个字符串，<code>string-less</code> 是它的别名。**空字符串小于所有字符串，除了空字符串。**前面 <code>string-emptyp</code> 就是用这个特性。当然直接用 <code>length</code> 检测字符串长度应该也可以，还可以省去检测字符串是否为空。</p>
<blockquote>
<p>没有 <code>string&gt;</code> 函数。</p>
</blockquote>
</li>
</ul>
<h4 id="转换函数"><a class="header-anchor" href="#转换函数">¶</a>转换函数</h4>
<ul>
<li>
<p>字符转换成字符串可以用 <code>char-to-string</code> 函数。</p>
</li>
<li>
<p>字符串转换成字符可以用 <code>string-to-char</code>。当然只是返回字符串的第一个字符。</p>
</li>
<li>
<p>数字转换成字符串可以用 <code>number-to-string </code>：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">number-to-string</span> <span class="number">256</span>)                  <span class="comment">; =&gt; "256"</span></span><br></pre></td></tr></table></figure>
<p><code>number-to-string</code> 只能转换成十进制的数字。如果要输出八进制或者十六进制，可以用 <code>format</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="string">"%#o"</span> <span class="number">256</span>)                      <span class="comment">; =&gt; "0400"</span></span><br><span class="line">(<span class="name">format</span> <span class="string">"%#x"</span> <span class="number">256</span>)                      <span class="comment">; =&gt; "0x100"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>字符串转换成数字可以用 <code>string-to-number</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">string-to-number</span> <span class="string">"256"</span>)                <span class="comment">; =&gt; 256</span></span><br></pre></td></tr></table></figure>
<p><code>string-to-number</code> 可以设置字符串的进制，可以从 <code>2</code> 到 <code>16</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">string-to-number</span> <span class="string">"111000"</span> <span class="number">2</span>)                <span class="comment">; =&gt; 56</span></span><br><span class="line">(<span class="name">string-to-number</span> <span class="string">"256"</span> <span class="number">8</span>)                   <span class="comment">; =&gt; 174</span></span><br><span class="line">(<span class="name">string-to-number</span> <span class="string">"256"</span> <span class="number">16</span>)                  <span class="comment">; =&gt; 598</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>concat</code> 可以把一个字符构成的列表或者向量转换成字符串：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">concat</span> '(?a ?b ?c ?d ?e))              <span class="comment">; =&gt; "abcde"</span></span><br><span class="line">(<span class="name">concat</span> [?a ?b ?c ?d ?e])               <span class="comment">; =&gt; "abcde"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>vconcat</code> 可以把一个字符串转换成一个向量：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">vconcat</span> <span class="string">"abdef"</span>)                       <span class="comment">; =&gt; [97 98 100 101 102]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>append</code> 可以把一个字符串转换成一个列表：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">append</span> <span class="string">"abcdef"</span> <span class="literal">nil</span>)                   <span class="comment">; =&gt; (97 98 99 100 101 102)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>downcase</code> 可以把一个字符串或者字符转换成小写：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">downcase</span> <span class="string">"The cat in the hat"</span>)         <span class="comment">; =&gt; "the cat in the hat"</span></span><br><span class="line">(<span class="name">downcase</span> ?X)                           <span class="comment">; =&gt; 120</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>upcase</code> 可以把一个字符串或者字符转换成大写：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">upcase</span> <span class="string">"The cat in the hat"</span>)           <span class="comment">; =&gt; "THE CAT IN THE HAT"</span></span><br><span class="line">(<span class="name">upcase</span> ?x)                             <span class="comment">; =&gt; 88</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>capitalize</code> 可以使字符串中单词的第一个字符大写，其它字符小写：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">capitalize</span> <span class="string">"The CAT in tHe hat"</span>)       <span class="comment">; =&gt; "The Cat In The Hat"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code> upcase-initials</code> 只使第一个单词的第一个字符大写，其它字符小写：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">upcase-initials</span> <span class="string">"The CAT in the hAt"</span>)  <span class="comment">; =&gt; "The CAT In The HAt"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="格式化字符串"><a class="header-anchor" href="#格式化字符串">¶</a>格式化字符串</h4>
<p><code>format</code> 类似于 C 语言里的 <code>printf</code> 可以实现对象的字符串化。数字的格式化和 <code>printf</code> 的参数差不多。</p>
<blockquote>
<p>值得一提的是 <code>%S</code> 这个格式化形式，它可以把对象的输出形式转换成字符串，这在调试时是很有用的。</p>
</blockquote>
<h4 id="查找和替换"><a class="header-anchor" href="#查找和替换">¶</a>查找和替换</h4>
<h5 id="查找"><a class="header-anchor" href="#查找">¶</a>查找</h5>
<p>字符串查找的核心函数是 <code>string-match</code>。这个函数可以从指定的位置对字符串进行正则表达式匹配，如果匹配成功，则返回匹配的起点，如：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">string-match</span> <span class="string">"34"</span> <span class="string">"01234567890123456789"</span>)    <span class="comment">; =&gt; 3</span></span><br><span class="line">(<span class="name">string-match</span> <span class="string">"34"</span> <span class="string">"01234567890123456789"</span> <span class="number">10</span>) <span class="comment">; =&gt; 13</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 <code>string-match</code> 的参数是一个正则表达式。emacs 好象没有内建的查找子串的函数。如果你想把 <code>string-match</code> 作为一个查找子串的函数，可以先用 <code>regexp-quote</code> 函数先处理一下子串。比如：</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">string-match</span> <span class="string">"2*"</span> <span class="string">"232*3=696"</span>)                <span class="comment">; =&gt; 0</span></span><br><span class="line">(<span class="name">string-match</span> (<span class="name">regexp-quote</span> <span class="string">"2*"</span>) <span class="string">"232*3=696"</span>) <span class="comment">; =&gt; 2</span></span><br></pre></td></tr></table></figure>
<p><code>string-match</code> 在查找的同时，还会记录下每个要捕捉的字符串的位置。这个位置可以在匹配后用 <code>match-data</code>、<code>match-beginning</code> 和 <code>match-end</code> 等函数来获得。先看一下例子：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">progn</span></span><br><span class="line">  (<span class="name">string-match</span> <span class="string">"3\\(4\\)"</span> <span class="string">"01234567890123456789"</span>)</span><br><span class="line">  (<span class="name">match-data</span>))                         <span class="comment">; =&gt; (3 5 4 5)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&quot;3\\(4\\)&quot;</code> 并未在正则表达式中转义括号。参照本文《<a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a>》一章。</p>
</blockquote>
<p>正则表达式捕捉的字符串按括号的顺序对应一个序号，整个模式对应序号 <code>0</code>，第一个括号对应序号 <code>1</code>，第二个括号对应序号 <code>2</code>，以此类推。所以 <code>&quot;3\(4\)&quot;</code> 这个正则表达式中有序号 <code>0</code> 和 <code>1</code>，最后 <code>match-data</code> 返回的一系列数字对应的分别是要捕捉字符串的起点和终点位置，也就是说子串 <code>&quot;34&quot;</code> 起点从位置 <code>3</code> 开始，到位置 <code>5</code> 结束，而捕捉的字符串 <code>&quot;4&quot;</code> 的起点是从 <code>4</code> 开始，到 <code>5</code> 结束。这些位置可以用 <code>match-beginning</code> 和 <code>match-end</code> 函数用对应的序号得到。</p>
<blockquote>
<p>注意：起点位置是捕捉字符串的第一个字符的位置，而终点位置不是捕捉的字符串最后一个字符的位置，而是下一个字符的位置。这个性质对于循环是很方便的。比如要查找上面这个字符串中所有 <code>34</code> 出现的位置：</p>
</blockquote>
<blockquote>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">start</span> <span class="number">0</span>))</span><br><span class="line">  (<span class="name">while</span> (<span class="name">string-match</span> <span class="string">"34"</span> <span class="string">"01234567890123456789"</span> start)</span><br><span class="line">    (<span class="name">princ</span> (<span class="name">format</span> <span class="string">"find at %d\n"</span> (<span class="name">match-beginning</span> <span class="number">0</span>)))</span><br><span class="line">    (<span class="name">setq</span> start (<span class="name">match-end</span> <span class="number">0</span>))))</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="替换"><a class="header-anchor" href="#替换">¶</a>替换</h5>
<p>替换使用的函数是 <code>replace-match</code>。这个函数既可以用于字符串的替换，也可以用于缓冲区的文本替换。对于字符串的替换，<code>replace-match</code> 只是按给定的序号把字符串中的那一部分用提供的字符串替换了而已：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">str</span> <span class="string">"01234567890123456789"</span>))</span><br><span class="line">  (<span class="name">string-match</span> <span class="string">"34"</span> str)</span><br><span class="line">  (<span class="name">princ</span> (<span class="name">replace-match</span> <span class="string">"x"</span> <span class="literal">nil</span> <span class="literal">nil</span> str <span class="number">0</span>))</span><br><span class="line">  (<span class="name">princ</span> <span class="string">"\n"</span>)</span><br><span class="line">  (<span class="name">princ</span> str))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看出 <code>replace-match</code> 返回的字符串是替换后的新字符串，原字符串被没有改变。</p>
</blockquote>
<p>如果你想挑战一下，想想怎样把上面这个字符串中所有的 <code>34</code> 都替换掉？如果想就使用同一个字符串来存储，可能对于固定的字符串，这个还容易一些，如果不是的话，就要花一些脑筋了，<strong>因为替换之后，新的字符串下一个搜索起点的位置就不能用 <code>(match-end 0)</code> 给出来的位置了，而是要扣除替换的字符串和被替换的字符串长度的差值。</strong></p>
<p>emacs 对字符串的替换有一个函数 <code>replace-regexp-in-string</code>。这个函数的实现方法是把每次匹配部分之前的子串收集起来，最后再把所有字符串连接起来。</p>
<p>单字符的替换有 <code>subst-char-in-string</code> 函数。但是 emacs 没有类似 perl函数或者程序 tr 那样进行字符替换的函数。只能自己建表进行循环操作了。</p>
<h3 id="cons-cell-和列表"><a class="header-anchor" href="#cons-cell-和列表">¶</a>cons cell 和列表</h3>
<h4 id="cons-cell"><a class="header-anchor" href="#cons-cell">¶</a>cons cell</h4>
<p>cons cell 其实非常简单的，就是两个有顺序的元素。<br>
cons cell 的读入语法是用 . 分开两个部分，比如：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">'(<span class="number">1</span> . <span class="number">2</span>)                                <span class="comment">; =&gt; (1 . 2)</span></span><br><span class="line">'(?a . <span class="number">1</span>)                               <span class="comment">; =&gt; (97 . 1)</span></span><br><span class="line">'(<span class="number">1</span> . <span class="string">"a"</span>)                              <span class="comment">; =&gt; (1 . "a")</span></span><br><span class="line">'(<span class="number">1</span> . nil)                              <span class="comment">; =&gt; (1)</span></span><br><span class="line">'(nil . nil)                            <span class="comment">; =&gt; (nil)</span></span><br></pre></td></tr></table></figure>
<p>上述代码中关于 <code>'</code> 的解释：</p>
<p><code>eval-last-sexp</code> 其实包含了两个步骤，一是读入前一个 S-表达式，二是对读入的 S-表达式求值。这样如果读入的 S-表达式是一个 cons cell 的话，求值时会把这个 cons cell 的第一个元素作为一个函数来调用。而事实上，前面这些例子的第一个元素都不是一个函数，这样就会产生一个错误 invalid-function。之所以前面没有遇到这个问题，<strong>那是因为前面数字和字符串是一类特殊的 S-表达式，它们求值后和求值前是不变，称为自求值表达式（self-evaluating form）</strong>。’ 号其实是一个特殊的函数 <code>quote</code>，它的作用是将它的参数返回而不作求值。<code>'(1 . 2)</code> 等价于 <code>(quote (1 . 2))</code>。为了证明 cons cell 的读入语法确实就是它的输出形式。</p>
<h4 id="列表"><a class="header-anchor" href="#列表">¶</a>列表</h4>
<p>列表包括了 cons cell。但是列表中有一个特殊的元素──空表 <code>nil</code>。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"><span class="literal">nil</span>                                     <span class="comment">; =&gt; nil</span></span><br><span class="line">'()                                     <span class="comment">; =&gt; nil</span></span><br></pre></td></tr></table></figure>
<p>空表不是一个 cons cell，因为它没有 CAR 和 CDR 两个部分，事实上空表里没有任何内容。<strong>但是为了编程的方便，可以认为 <code>nil</code> 的 CAR 和 CDR 都是 <code>nil</code></strong>：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">car</span> <span class="literal">nil</span>)                               <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">cdr</span> <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>按列表<strong>最后一个 cons cell</strong> 的 CDR 部分的类型分，可以把列表分为三类：</p>
<ul>
<li>如果它是 <code>nil</code> 的话，这个列表也称为**“真列表”(true list)**。</li>
<li>如果既不是 <code>nil</code> 也不是一个 cons cell，则这个列表称为**“点列表”(dotted list)。**</li>
<li>还有一种可能，它指向列表中之前的一个 cons cell，则称为<strong>环形列表(circular list)。</strong></li>
</ul>
<p>这里分别给出一个例子：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">'(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)                                  <span class="comment">; =&gt; (1 2 3)</span></span><br><span class="line">'(<span class="number">1</span> <span class="number">2</span> . <span class="number">3</span>)                                <span class="comment">; =&gt; (1 2 . 3)</span></span><br><span class="line">'(<span class="number">1</span> . #1=(<span class="number">2</span> <span class="number">3</span> . #1#))                     <span class="comment">; =&gt; (1 2 3 . #1)</span></span><br></pre></td></tr></table></figure>
<p>如果把真列表最后一个 cons cell 的 <code>nil</code> 省略不写，也就是 <code>(1 . nil)</code> 简写成 <code>(1)</code>，把 <code>( obj1 . ( obj2 . list))</code> 简写成 <code>(obj1 obj2 . list)</code>，那么列表最后可以写成一个用括号括起的元素列表：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">'(<span class="number">1</span> . (<span class="number">2</span> . (<span class="number">3</span> . <span class="literal">nil</span>)))                  <span class="comment">; =&gt; (1 2 3)</span></span><br></pre></td></tr></table></figure>
<h4 id="测试函数-v3"><a class="header-anchor" href="#测试函数-v3">¶</a>测试函数</h4>
<ul>
<li>
<p>测试一个对象是否是 cons cell 用 <code>consp</code>，是否是列表用 <code>listp</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">consp</span> '(<span class="number">1</span> . <span class="number">2</span>))                        <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">consp</span> '(<span class="number">1</span> . (<span class="number">2</span> . <span class="literal">nil</span>)))                <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">consp</span> <span class="literal">nil</span>)                             <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">listp</span> '(<span class="number">1</span> . <span class="number">2</span>))                        <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">listp</span> '(<span class="number">1</span> . (<span class="number">2</span> . <span class="literal">nil</span>)))                <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">listp</span> <span class="literal">nil</span>)                             <span class="comment">; =&gt; t</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>测试一个对象是否是 <code>nil</code> 用 <code>null</code> 函数。只有当对象是空表时，<code>null</code> 才返回空值。</p>
</li>
</ul>
<h4 id="span-id-constructors-in-list-构造函数-span"><a class="header-anchor" href="#span-id-constructors-in-list-构造函数-span">¶</a><span id="constructors_in_list">构造函数</span></h4>
<ul>
<li>
<p>生成一个 cons cell 可以用 <code>cons</code> 函数。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">cons</span> <span class="number">1</span> <span class="number">2</span>)                              <span class="comment">; =&gt; (1 . 2)</span></span><br><span class="line">(<span class="name">cons</span> <span class="number">1</span> '())                            <span class="comment">; =&gt; (1)</span></span><br></pre></td></tr></table></figure>
<p>也可以使用在列表前面增加元素的方法。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> foo '(a b))                       <span class="comment">; =&gt; (a b)</span></span><br><span class="line">(<span class="name">cons</span> 'x foo)                           <span class="comment">; =&gt; (x a b)</span></span><br></pre></td></tr></table></figure>
<p><strong>值得注意的是前面这个例子的 <code>foo</code> 值并没有改变。</strong><br>
事实上有一个宏 <code>push</code> 可以加入元素的同时改变列表的值：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">push</span> 'x foo)                           <span class="comment">; =&gt; (x a b)</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; (x a b)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>生成一个列表的函数是 <code>list</code>。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)                            <span class="comment">; =&gt; (1 2 3)</span></span><br></pre></td></tr></table></figure>
<p>可能这时你有一个疑惑，前面产生一个列表，我常用 <code>quote</code>（也就是 <code>'</code> 符号）这个函数，它和这个 <code>cons</code> 和 <code>list</code> 函数有什么区别呢？其实区别是很明显的，<strong><code>quote</code> 是把参数直接返回不进行求值，而 <code>list</code> 和 <code>cons</code> 是对参数求值后再生成一个列表或者 cons cell</strong>。看下面这个例子：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">'((+ <span class="number">1</span> <span class="number">2</span>) <span class="number">3</span>)                            <span class="comment">; =&gt; ((+ 1 2) 3)</span></span><br><span class="line">(<span class="name">list</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>) <span class="number">3</span>)                        <span class="comment">; =&gt; (3 3)</span></span><br></pre></td></tr></table></figure>
<p>前一个生成的列表的 CAR 部分是 <code>(+ 1 2)</code> 这个列表，而后一个是先对 <code>(+ 1 2)</code> 求值得到 <code>3</code> 后再生成列表。</p>
</li>
</ul>
<blockquote>
<p>思考题<br>
怎样用 <code>list</code> 函数构造一个 <code>(a b c)</code> 这样的列表呢？<br>
答：<code>(list 'a 'b 'c)</code></p>
</blockquote>
<ul>
<li>
<p><strong>前面提到在列表前端增加元素的方法是用 <code>cons</code></strong>，在列表后端增加元素的函数是用 <code>append</code>。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">append</span> '(a b) '(c))                    <span class="comment">; =&gt; (a b c)</span></span><br><span class="line">(<span class="name">append</span> '(a b) '(c) '(d))               <span class="comment">; =&gt; (a b c d)</span></span><br></pre></td></tr></table></figure>
<p><code>append</code> 的功能可以认为它是把第一个参数最后一个列表的 <code>nil</code> 换成第二个参数。<br>
一般来说 <code>append</code> 的参数都要是列表，但是最后一个参数可以不是一个列表，这也不违背前面说的，因为 cons cell 的 CDR 部分本来就可以是任何对象：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">append</span> '(a b) 'c)                      <span class="comment">; =&gt; (a b . c)</span></span><br></pre></td></tr></table></figure>
<p><strong>但这样得到的结果就不再是一个真列表了，如果再进行 <code>append</code> 操作就会产生一个错误。</strong></p>
<p><code>append</code> 的参数不限于列表，还可以是字符串或者向量。前面字符串里已经提到可以把一个字符串转换成一个字符列表，同样可能把向量转换成一个列表：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">append</span> [a b] <span class="string">"cd"</span> <span class="literal">nil</span>)                 <span class="comment">; =&gt; (a b 99 100)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：前面最后一个参数 <code>nil</code> 是必要的，不然你可以想象得到的结果是什么。</p>
</blockquote>
</li>
</ul>
<h4 id="把列表当数组用"><a class="header-anchor" href="#把列表当数组用">¶</a>把列表当数组用</h4>
<h5 id="访问"><a class="header-anchor" href="#访问">¶</a>访问</h5>
<ul>
<li>
<p>可以用 <code>nth</code> 函数来访问第 <code>n</code> 个元素：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">nth</span> <span class="number">3</span> '(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))                  <span class="comment">; =&gt; 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>取得序列里第 <code>n</code> 个元素也可以用 <code>elt</code> 函数。但是我建议，对于已知类型的序列，还是用对应的函数比较好。也就是说，如果是列表就用 <code>nth</code>，如果是数组就用 <code>aref</code>。这样一方面是省去 <code>elt</code> 内部的判断，另一方面读代码时能很清楚知道序列的类型。</p>
</blockquote>
</li>
<li>
<p><code>nthcdr</code> 函数返回第 <code>n</code> 个元素后的列表：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">nthcdr</span> <span class="number">2</span> '(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))               <span class="comment">; =&gt; (2 3 4 5)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>last</code> 函数返回倒数 <code>n</code> 个长度的列表：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">last</span> '(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>) <span class="number">2</span>)                 <span class="comment">; =&gt; (4 5)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>butlast</code> 返回的除了倒数 <code>n</code> 个元素的列表。</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">butlast</span> '(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>) <span class="number">2</span>)              <span class="comment">; =&gt; (0 1 2 3)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>链表这种数据结构是不适合随机访问的，代价比较高，如果你的代码中频繁使用这样的函数或者对一个很长的列表使用这样的函数，就应该考虑是不是应该用数组来实现。</p>
</blockquote>
<h5 id="修改"><a class="header-anchor" href="#修改">¶</a>修改</h5>
<ul>
<li>
<p><code>setcar</code> 和 <code>setcdr</code> 可以修改一个 cons cell 的 CAR 部分和 CDR 部分。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> foo '(a b c))                     <span class="comment">; =&gt; (a b c)</span></span><br><span class="line">(<span class="name">setcar</span> foo 'x)                         <span class="comment">; =&gt; x</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; (x b c)</span></span><br><span class="line">(<span class="name">setcdr</span> foo '(y z))                     <span class="comment">; =&gt; (y z)</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; (x y z)</span></span><br></pre></td></tr></table></figure>
<p>要像数组那样直接修改列表。使用 <code>setcar</code> 和 <code>nthcdr</code> 的组合就可以实现了：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> foo '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))                     <span class="comment">; =&gt; (1 2 3)</span></span><br><span class="line">(<span class="name">setcar</span> foo 'a)                         <span class="comment">; =&gt; a</span></span><br><span class="line">(<span class="name">setcar</span> (<span class="name">cdr</span> foo) 'b)                   <span class="comment">; =&gt; b</span></span><br><span class="line">(<span class="name">setcar</span> (<span class="name">nthcdr</span> <span class="number">2</span> foo) 'c)              <span class="comment">; =&gt; c</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; (a b c)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="把列表当堆栈用"><a class="header-anchor" href="#把列表当堆栈用">¶</a>把列表当堆栈用</h4>
<p>前面已经提到过可以用 <code>push</code> 向列表头端增加元素，在结合 <code>pop</code> 函数，列表就可以做为一个堆栈了：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> foo <span class="literal">nil</span>)                          <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">push</span> 'a foo)                           <span class="comment">; =&gt; (a)</span></span><br><span class="line">(<span class="name">push</span> 'b foo)                           <span class="comment">; =&gt; (b a)</span></span><br><span class="line">(<span class="name">pop</span> foo)                               <span class="comment">; =&gt; b</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; (a)</span></span><br></pre></td></tr></table></figure>
<h4 id="重排列表"><a class="header-anchor" href="#重排列表">¶</a>重排列表</h4>
<ul>
<li>
<p>列表反序 <code>reverse</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> foo '(a b c))                     <span class="comment">; =&gt; (a b c)</span></span><br><span class="line">(<span class="name">reverse</span> foo)                           <span class="comment">; =&gt; (c b a)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：使用 <code>reverse</code> 后 <code>foo</code> 值并没有改变。<code>nreverse</code> 和 <code>reverse</code> 差别就在于它是一个有破坏性的函数，也就是说它会修改它的参数：</p>
</blockquote>
<blockquote>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">nreverse</span> foo)                          <span class="comment">; =&gt; (c b a)</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; (a)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>elisp 还有一些是具有破坏性的函数。最常用的就是 <code>sort</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> foo '(<span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">5</span>))                 <span class="comment">; =&gt; (3 2 4 1 5)</span></span><br><span class="line">(<span class="name">sort</span> foo '&lt;)                           <span class="comment">; =&gt; (1 2 3 4 5)</span></span><br><span class="line">foo                                     <span class="comment">; =&gt; (3 4 5)</span></span><br></pre></td></tr></table></figure>
<p>如果我既要保留原列表，又要进行 <code>sort</code> 操作怎么办呢？可以用 <code>copy-sequence</code> 函数。这个函数只对列表进行复制，<strong>返回的列表的元素还是原列表里的元素，不会拷贝列表的元素</strong>。</p>
<blockquote>
<p><code>nconc</code> 和 <code>append</code> 功能相似，但是它会修改除最后一个参数以外的所有的参数，<code>nbutlast</code> 和 <code>butlast</code> 功能相似，也会修改参数。这些函数都是在效率优先时才使用。总而言之，以 <code>n</code> 开头的函数都要慎用。<br>
<code>copy-sequence</code> 不能用于点列表和环形列表。对于点列表可以用 <code>copy-tree</code> 函数。环形列表就没有办法复制了。 好在这样的数据结构很少用到。</p>
</blockquote>
</li>
</ul>
<h4 id="把列表当集合用"><a class="header-anchor" href="#把列表当集合用">¶</a>把列表当集合用</h4>
<p>列表可以作为无序的集合。</p>
<ul>
<li>
<p>合并集合用 <code>append</code> 函数。</p>
</li>
<li>
<p>去除重复的 <code>equal</code> 元素用 <code>delete-dups</code>。</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">delete-dups</span> (<span class="name">list</span> <span class="string">"foo"</span> <span class="string">"bar"</span> <span class="literal">nil</span> <span class="string">"moo"</span> <span class="string">"bar"</span> <span class="string">"moo"</span> <span class="literal">nil</span> <span class="string">"affe"</span>)) <span class="comment">; =&gt; ("foo" "bar" nil "moo" "affe")</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查找一个元素是否在列表中，返回以此元素开头的列表，如果找不到，则返回 <code>nil</code></p>
<ul>
<li>如果测试函数是用 <code>eq</code>，就用 <code>memq</code>；</li>
<li>如果测试用 <code>equal</code>，可以用 <code>member</code>。</li>
</ul>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">member</span> 'foo '(foo bar quux))           <span class="comment">; =&gt; non-nil</span></span><br><span class="line">(<span class="name">member</span> <span class="string">"foo"</span> '(<span class="string">"foo"</span> <span class="string">"bar"</span> <span class="string">"quux"</span>))    <span class="comment">; =&gt; non-nil</span></span><br><span class="line">(<span class="name">member</span> <span class="number">111</span> '(<span class="number">111</span> <span class="number">222</span> <span class="number">333</span>))             <span class="comment">; =&gt; non-nil</span></span><br><span class="line"></span><br><span class="line">(<span class="name">memq</span>   'foo '(foo bar quux))           <span class="comment">; =&gt; non-nil</span></span><br><span class="line">(<span class="name">memq</span>   <span class="string">"foo"</span> '(<span class="string">"foo"</span> <span class="string">"bar"</span> <span class="string">"quux"</span>))    <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">memq</span>   <span class="number">111</span> '(<span class="number">111</span> <span class="number">222</span> <span class="number">333</span>))             <span class="comment">; =&gt; non-nil</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除列表中的指定的元素，删除列表中所有的该元素</p>
<ul>
<li>测试函数为 <code>eq</code> 对应 <code>delq</code> 函数，<strong>原列表被破坏并返回一个新的列表</strong>；</li>
<li>测试函数为 <code>equal</code> 对应 <code>delete</code>，<strong>原列表被破坏并返回一个新的列表</strong>；</li>
<li><code>remove</code> 与 <code>delete</code> 相同，但<strong>不破坏原列表</strong>；</li>
<li><code>remq</code> 与 <code>delq</code> 相同，但<strong>不破坏原列表</strong>。</li>
</ul>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> xx '(<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; always set result to the same var. because original is usually destroyed</span></span><br><span class="line">(<span class="name">setq</span> xx (<span class="name">delete</span> <span class="number">4</span> xx)) <span class="comment">; (3 5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; on vector</span></span><br><span class="line">(<span class="name">setq</span> xx [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>])</span><br><span class="line">(<span class="name">setq</span> xx (<span class="name">delete</span> <span class="number">4</span> xx)) <span class="comment">; [3 5]</span></span><br><span class="line"></span><br><span class="line">setq xx '(3 4 5))</span><br><span class="line">(<span class="name">remove</span> <span class="number">4</span> xx) <span class="comment">;; (3 5)</span></span><br><span class="line">xx <span class="comment">; (3 4 5)</span></span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> xx '(<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; always set result to the same var</span></span><br><span class="line">(<span class="name">setq</span> xx (<span class="name">delq</span> <span class="number">4</span> xx)) <span class="comment">; (3 5)</span></span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> xx '(<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))</span><br><span class="line">(<span class="name">remq</span> <span class="number">4</span> xx) <span class="comment">; (3 5)</span></span><br><span class="line">xx <span class="comment">; (3 4 5)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>eq</code> ：当且仅当 <code>x</code> 和 <code>y</code> 是同一个对象 (identical object) 时（笔记：同一个内存地址。并且应该仅应用于结构：conses、数组、结构、对象），返回 <code>t</code>。</li>
<li><code>eql</code> ：当其参数判断为 <code>eq</code>，或它们是相同的非结构化值（即相同类型的数字或字符值的相同数值）时，返回 <code>t</code>。</li>
<li><code>equal</code> ：当其参数为结构相似对象 (structurally similar (isomorphic)) 时，返回 <code>t</code>。粗略地从经验来看就是如果两个对象输出形式一样，那它们就是 <code>equal</code> 的。</li>
<li><code>equalp</code> ：当两个对象是 <code>equal</code> 的，那它们也是 <code>equalp</code> 的。另外如果它们是字符，且是 char-equal 的，即忽略大小写和特定的其它字符属性后是 <code>equal</code> 的，或者说它们是数字且有相同的数字值，而不管它们是否是同的类型，或者说它们的组成部分是 <code>equalp</code> 的，那么它们就是 <code>equalp</code> 的。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="把列表当关联表"><a class="header-anchor" href="#把列表当关联表">¶</a>把列表当关联表</h4>
<p>所谓关联表，就是可以用一个字符串（通常叫关键字，key）来查找对应值的数据结构。由列表实现的关联表有一个专门的名字叫 association list。尽管 elisp 里也有 hash table，但是 hash table 相比于 association list 至少这样几个缺点：</p>
<ul>
<li>hash table 里的关键字（key）是无序的，而 association list 的关键字 可以按想要的顺序排列；</li>
<li>hash table 没有列表那样丰富的函数，只有一个 <code>maphash</code> 函数可以遍历列表。而 association list 就是一个列表，所有列表函数都能适用；</li>
<li>hash table 没有读入语法和输入形式，这对于调试和使用都带来很多不便。</li>
</ul>
<p>只要不对效率要求很高，通常直接用association list。<br>
根据比较方法的不同，有 <code>assq</code> 和 <code>assoc</code> 两个函数，它们分别对应查找使用 <code>eq</code> 和 <code>equal</code> 两种方法。例如：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">assoc</span> <span class="string">"a"</span> '((<span class="string">"a"</span> <span class="number">97</span>) (<span class="string">"b"</span> <span class="number">98</span>)))        <span class="comment">; =&gt; ("a" 97)</span></span><br><span class="line">(<span class="name">assq</span> 'a '((a . <span class="number">97</span>) (b . <span class="number">98</span>)))          <span class="comment">; =&gt; (a . 97)</span></span><br></pre></td></tr></table></figure>
<p>通常我们只需要查找对应的数据，所以一般来说都要用 <code>cdr</code> 来得到对应的数据：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">cdr</span> (<span class="name">assoc</span> <span class="string">"a"</span> '((<span class="string">"a"</span> <span class="number">97</span>) (<span class="string">"b"</span> <span class="number">98</span>))))  <span class="comment">; =&gt; (97)</span></span><br><span class="line">(<span class="name">cdr</span> (<span class="name">assq</span> 'a '((a . <span class="number">97</span>) (b . <span class="number">98</span>))))    <span class="comment">; =&gt; 97</span></span><br></pre></td></tr></table></figure>
<p><code>assoc-default</code> 可以一步完成这样的操作：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">assoc-default</span> <span class="string">"a"</span> '((<span class="string">"a"</span> <span class="number">97</span>) (<span class="string">"b"</span> <span class="number">98</span>)))          <span class="comment">; =&gt; (97)</span></span><br></pre></td></tr></table></figure>
<p>还可以用 <code>rassoc</code> 和 <code>rassq</code> 来根据数据查找键值：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">rassoc</span> '(<span class="number">97</span>) '((<span class="string">"a"</span> <span class="number">97</span>) (<span class="string">"b"</span> <span class="number">98</span>)))     <span class="comment">; =&gt; ("a" 97)</span></span><br><span class="line">(<span class="name">rassq</span> '<span class="number">97</span> '((a . <span class="number">97</span>) (b . <span class="number">98</span>)))        <span class="comment">; =&gt; (a . 97)</span></span><br></pre></td></tr></table></figure>
<p>如果要修改关键字对应的值</p>
<ul>
<li>
<p>最省事的作法就是用 <code>cons</code> 把新的键值对加到列表的头端。但是这会让列表越来越长，浪费空间。</p>
</li>
<li>
<p>如果要替换已经存在的值，一个想法就是用 <code>setcdr</code> 来更改键值对应的数据。但是在更改之前要先确定这个键值在对应的列表里，否则会产生一个错误。</p>
</li>
<li>
<p>另一个想法是用 <code>assoc</code> 查找到对应的元素，再用 <code>delq</code> 删除这个数据，然后用 <code>cons</code> 加到列表里：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> foo '((<span class="string">"a"</span> . <span class="number">97</span>) (<span class="string">"b"</span> . <span class="number">98</span>)))     <span class="comment">; =&gt; (("a" . 97) ("b" . 98))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; update value by setcdr</span></span><br><span class="line">(<span class="name">if</span> (<span class="name">setq</span> bar (<span class="name">assoc</span> <span class="string">"a"</span> foo))</span><br><span class="line">    (<span class="name">setcdr</span> bar <span class="string">"this is a"</span>)</span><br><span class="line">  (<span class="name">setq</span> foo (<span class="name">cons</span> '(<span class="string">"a"</span> . <span class="string">"this is a"</span>) foo))) <span class="comment">; =&gt; "this is a"</span></span><br><span class="line">foo                         <span class="comment">; =&gt; (("a" . "this is a") ("b" . 98))</span></span><br><span class="line"><span class="comment">;; update value by delq and cons</span></span><br><span class="line">(<span class="name">setq</span> foo (<span class="name">cons</span> '(<span class="string">"a"</span> . <span class="number">97</span>)</span><br><span class="line">               (<span class="name">delq</span> (<span class="name">assoc</span> <span class="string">"a"</span> foo) foo))) <span class="comment">; =&gt; (("a" . 97) ("b" . 98))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果不对顺序有要求的话，推荐用后一种方法。</p>
<h4 id="把列表当树用"><a class="header-anchor" href="#把列表当树用">¶</a>把列表当树用</h4>
<p>列表的第一个元素如果作为结点的数据，其它元素看作是子节点，就是一个树了。</p>
<h4 id="遍历列表"><a class="header-anchor" href="#遍历列表">¶</a>遍历列表</h4>
<ul>
<li>
<p>遍历列表最常用的函数就是 <code>mapc</code> 和 <code>mapcar</code> 了。它们的第一个参数都是一个函数，这个函数只接受一个参数，每次处理一个列表里的元素。这两个函数唯一的差别是前者返回的还是输入的列表，而 <code>mapcar</code> 返回的函数返回值构成的列表：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">mapc</span> '<span class="number">1</span>+ '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))                     <span class="comment">; =&gt; (1 2 3)</span></span><br><span class="line">(<span class="name">mapcar</span> '<span class="number">1</span>+ '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))                   <span class="comment">; =&gt; (2 3 4)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>另一个比较常用的遍历列表的方法是用 <code>dolist</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">dolist</span> (<span class="name">var</span> list [result]) body...)</span><br></pre></td></tr></table></figure>
<p>其中 <code>var</code> 是一个临时变量，在 <code>body</code> 里可以用来得到列表中元素的值。使用 <code>dolist</code> 的好处是不用写 lambda 函数。一般情况下它的返回值是 <code>nil</code>，但是你也可以指定一个值作为返回值（我觉得这个特性没有什么用，只省了一步而已）：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">dolist</span> (<span class="name">foo</span> '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">  (<span class="name">incf</span> foo))                           <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">setq</span> bar <span class="literal">nil</span>)</span><br><span class="line">(<span class="name">dolist</span> (<span class="name">foo</span> '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) bar)</span><br><span class="line">  (<span class="name">push</span> (<span class="name">incf</span> foo) bar))                <span class="comment">; =&gt; (4 3 2)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="散列表"><a class="header-anchor" href="#散列表">¶</a>散列表</h4>
<p>散列表，也就是 hash-table，在编程过程中会经常使用到，它以“关键字–数值”这样的对应关系保存数据，适合用于保存那些需要通过关键字查找数值的数据。</p>
<ul>
<li>
<p>创建散列表：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> my-hash-t (<span class="name">make-hash-table</span>))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>需要获取散列表中某一个关键字对应的数值，可以使用 <code>gethash</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">gethash</span> 'NB001 my-hash-t)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为了给散列表添加元素，可以直接使用 <code>setq</code> 函数，第一个参数是 <code>gethash</code> 获得的关键字位置，第二个参数是希望添加的数值，如：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> (<span class="name">gethash</span> 'NB002 my-hash-t) <span class="string">"Tom"</span>)</span><br></pre></td></tr></table></figure>
<p>需要注意的是<strong>散列表中一个关键字只能对应一个数值，同一个关键字无法赋予两个不同的值</strong>。如下面的代码会将 <code>NB001</code> 的数值设置为 <code>&quot;Jerry&quot;</code>。后面那句 <code>setq</code> 生效，这个和变量的赋值的类似的：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> (<span class="name">gethash</span> 'NB001 my-hash-t) <span class="string">"Mike"</span>)</span><br><span class="line"> (<span class="name">setq</span> (<span class="name">gethash</span> 'NB001 my-hash-t) <span class="string">"Jerry"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>散列表的遍历，elisp 中的散列表可以通过 <code>maphash</code> 函数进行迭代，形式如下：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">maphash</span> #'(lambda (key value) </span><br><span class="line">	(format *query-io* <span class="string">"key: ~a  value: ~a  ~%"</span> key value))</span><br><span class="line">  my-hash-t)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="其它常用函数"><a class="header-anchor" href="#其它常用函数">¶</a>其它常用函数</h4>
<ul>
<li>
<p><code>fold</code> 和 <code>filter</code><br>
如果看过一些函数式语言教程的话，一定对 <code>fold</code>（或叫 <code>accumulate</code>、<code>reduce</code>）和 <code>filter</code> 这些函数记忆深刻。不过 elisp 里好像没有提供这样的函数。<code>remove-if</code> 和 <code>remove-if-not</code> 可以作 <code>filter</code> 函数，但是它们是 cl 里的，自己用用没有关系，不能强迫别人也跟着用，所以不能写到 elisp 里。如果不用这两个函数，也不用别人的函数的话，自己实现不妨用这样的方法：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> my-remove-if (<span class="name">predicate</span> list)</span><br><span class="line">  (<span class="name">delq</span> <span class="literal">nil</span> (<span class="name">mapcar</span> (<span class="name">lambda</span> (<span class="name">n</span>)</span><br><span class="line">                      (<span class="name">and</span> (<span class="name">not</span> (<span class="name">funcall</span> predicate n)) n))</span><br><span class="line">                    list)))</span><br><span class="line">(<span class="name">defun</span> evenp (<span class="name">n</span>)</span><br><span class="line">  (<span class="name">=</span> (% n <span class="number">2</span>) <span class="number">0</span>))</span><br><span class="line">(<span class="name">my-remove-if</span> 'evenp '(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>))    <span class="comment">; =&gt; (1 3 5)</span></span><br></pre></td></tr></table></figure>
<p><code>fold</code> 的操作只能用变量加循环或 <code>mapc</code> 操作来代替了：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">defun</span> my-fold-left (<span class="name">op</span> initial list)</span><br><span class="line">  (<span class="name">dolist</span> (<span class="name">var</span> list initial)</span><br><span class="line">    (<span class="name">setq</span> initial (<span class="name">funcall</span> op initial var))))</span><br><span class="line">(<span class="name">my-fold-left</span> '+ <span class="number">0</span> '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>))          <span class="comment">; =&gt; 10</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>产生数列常用的方法是用 <code>number-sequence</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">number-sequence</span> <span class="number">5</span>)         <span class="comment">; =&gt; (5)</span></span><br><span class="line">(<span class="name">number-sequence</span> <span class="number">1</span> <span class="number">5</span>)       <span class="comment">; =&gt; (1 2 3 4 5)</span></span><br><span class="line">(<span class="name">number-sequence</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span>)     <span class="comment">; =&gt; (1 3 5)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>解析文本时一个很常用的操作是把字符串按分隔符分解，可以用 <code>split-string</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">split-string</span> <span class="string">"key = val"</span> <span class="string">"\\s-*=\\s-*"</span>)  <span class="comment">; =&gt; ("key" "val")</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>与 <code>split-string</code> 对应是把几个字符串用一个分隔符连接起来，这可以用 <code>mapconcat</code> 完成。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">mapconcat</span> 'identity '(<span class="string">"a"</span> <span class="string">"b"</span> <span class="string">"c"</span>) <span class="string">"\t"</span>) <span class="comment">; =&gt; "a   b   c"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>identity</code> 是一个特殊的函数，它会直接返回参数。<code>mapconcat</code> 第一个参数是一个函数，可以很灵活的使用。</p>
</blockquote>
</li>
<li>
<p>函数 <code>length</code> 可以得到序列的长度。但是这个函数只对真列表有效。对于一个点列表和环形列表这个函数就不适用了。点列表会出参数类型不对的错误，而环形列表就更危险，会陷入死循环。如果不确定参数类型，不妨用 <code>safe-length</code>。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">safe-length</span> '(a . b))                  <span class="comment">; =&gt; 1</span></span><br><span class="line">(<span class="name">safe-length</span> '#1=(<span class="number">1</span> <span class="number">2</span> . #1#))           <span class="comment">; =&gt; 3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组和序列"><a class="header-anchor" href="#数组和序列">¶</a>数组和序列</h3>
<p>序列是列表和数组的统称，也就是说列表和数组都是序列。它们的共性是内部的元素都是有序的。elisp 里的数组包括字符串、向量、char-table 和布尔向量。它们的关系可以用下面图表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> _____________________________________________</span><br><span class="line">|                                             |</span><br><span class="line">|          Sequence                           |</span><br><span class="line">|  ______   ________________________________  |</span><br><span class="line">| |      | |                                | |</span><br><span class="line">| | List | |             Array              | |</span><br><span class="line">| |      | |    ________       ________     | |</span><br><span class="line">| |______| |   |        |     |        |    | |</span><br><span class="line">|          |   | Vector |     | String |    | |</span><br><span class="line">|          |   |________|     |________|    | |</span><br><span class="line">|          |  ____________   _____________  | |</span><br><span class="line">|          | |            | |             | | |</span><br><span class="line">|          | | Char-table | | Bool-vector | | |</span><br><span class="line">|          | |____________| |_____________| | |</span><br><span class="line">|          |________________________________| |</span><br><span class="line">|_____________________________________________|</span><br></pre></td></tr></table></figure>
<p>数组有这样一些特性：</p>
<ul>
<li>数组内的元素都对应一个下标，第一个元素下标为 <code>0</code>，接下来是 <code>1</code>。数组内 的元素可以在常数时间内访问。</li>
<li>数组在创建之后就无法改变它的长度。</li>
<li>数组是自求值的。</li>
<li>数组里的元素都可以用 <code>aref</code> 来访问，用 <code>aset</code> 来设置。</li>
</ul>
<h4 id="数组类型"><a class="header-anchor" href="#数组类型">¶</a>数组类型</h4>
<ul>
<li><strong>向量</strong>可以看成是一种通用的数组，它的元素可以是任意的对象。</li>
<li><strong>字符串</strong>是一种特殊的数组，它的元素只能是字符。如果元素是字符时，使用字符串相比向量更好，因为字符串需要的空间更少（只需要向量的 1/4），输出更直观，能用文本属性（text property），能使用 emacs 的 IO 操作。但是有时必须使用向量，比如存储按键序列。</li>
<li><strong>char-table</strong>与向量类似，只不过它的索引是字符码。任何无修改器的字符码都可作为 char-table 的索引。可以通过 <code>aref</code> 和 <code>aset</code> 像访问数组一样访问 char-table。另外，一个 char-table 可以包含一些与特定字符码无关的额外数据。与向量一样，char-table 求值以后（evaluated）就不允许改变。char-table 的元素可以是任意对象。</li>
<li><strong>bool-vector</strong>与向量类似，只不过它只存储 <code>t</code> 和 <code>nil</code>。如果向其中存入任意非 <code>nil</code> 值，则会变为存储 <code>t</code>。与数组一样，bool-vector 的索引是从 <code>0</code> 开始的，并且 bool-vector 一旦生成，它的长度即固定。</li>
</ul>
<h5 id="测试函数-v4"><a class="header-anchor" href="#测试函数-v4">¶</a>测试函数</h5>
<p><code>sequencep</code> 用来测试一个对象是否是一个序列。<code>arrayp</code> 测试对象是否是数组。<code>vectorp</code>、<code>char-table-p</code> 和 <code>bool-vector-p</code> 分别测试对象是否是向量、char-table、bool-vector。</p>
<h5 id="序列的通用函数"><a class="header-anchor" href="#序列的通用函数">¶</a>序列的通用函数</h5>
<ul>
<li>获取数组长度使用 <code>length</code> 或 <code>safe-length</code>。(见<a href="#%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">上一章</a>)</li>
<li>取得数组里第 <code>n</code> 个元素可以用 <code>elt</code> 函数或 <code>aref</code> 函数。(见<a href="#%E8%AE%BF%E9%97%AE">上一章</a>)</li>
<li>复制数组使用 <code>copy-sequence</code> 函数。(见<a href="#%E9%87%8D%E6%8E%92%E5%88%97%E8%A1%A8">上一章</a>)</li>
</ul>
<h5 id="数组操作"><a class="header-anchor" href="#数组操作">¶</a>数组操作</h5>
<ul>
<li>
<p>创建向量</p>
<ul>
<li>
<p>创建向量可以用 <code>vector</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">vector</span> 'foo <span class="number">23</span> [bar baz] <span class="string">"rats"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当然也可以直接用向量的读入语法创建向量，但是由于 <strong>数组是自求值的</strong>，所以这样得到的向量和原来是一样的，也就是说参数不进行求值，看下面的例子就明白了：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">foo                                     <span class="comment">; =&gt; (a b)</span></span><br><span class="line">[foo]                                   ; =&gt; [foo]</span><br><span class="line">(<span class="name">vector</span> foo)                            <span class="comment">; =&gt; [(a b)]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用 <code>make-vector</code> 可以生成元素相同的向量：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">make-vector</span> <span class="number">9</span> 'Z)                      <span class="comment">; =&gt; [Z Z Z Z Z Z Z Z Z]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>fillarray</code> 可以把整个数组用某个元素填充：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">fillarray</span> (<span class="name">make-vector</span> <span class="number">3</span> 'Z) <span class="number">5</span>)        <span class="comment">; =&gt; [5 5 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>aref</code> 和 <code>aset</code> 可以用于访问和修改数组的元素。如果使用下标超出数组长度的话，会产生一个错误。所以要先确定数组的长度才能用这两个函数：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> myarray [a b c d e])      <span class="comment">; =&gt; [a b c d e]</span></span><br><span class="line">(<span class="name">aref</span> myarray <span class="number">0</span>)                <span class="comment">; =&gt; a</span></span><br><span class="line">(<span class="name">aref</span> myarray <span class="number">3</span>)                <span class="comment">; =&gt; d</span></span><br><span class="line">(<span class="name">aset</span> myarray <span class="number">2</span> 'guai)          <span class="comment">; =&gt; guai</span></span><br><span class="line">myarray                         <span class="comment">; =&gt; [a b guai d e]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>vconcat</code> 可以把多个序列连接成一个向量。但是<strong>这些个序列必须是真列表</strong>。这也是把列表转换成向量的方法。</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">vconcat</span> [A B C] <span class="string">"aa"</span> '(foo (<span class="number">6</span> <span class="number">7</span>)))     <span class="comment">; =&gt; [A B C 97 97 foo (6 7)]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>把向量转换成列表可以用 <code>append</code> 函数，这在<a href="#constructors_in_list">上一章</a>中已经提到。</p>
</li>
</ul>
<h3 id="符号"><a class="header-anchor" href="#符号">¶</a>符号</h3>
<p>符号是有名字的对象。可能这么说有点抽象。作个不恰当的比方，<strong>符号可以看作是 C 语言里的指针</strong>。通过符号你可以得到和这个符号相关联的信息，比如值，函数，属性列表等等。</p>
<h4 id="符号的命名规则"><a class="header-anchor" href="#符号的命名规则">¶</a>符号的命名规则</h4>
<ul>
<li>
<p>符号名字可以含有任何字符。</p>
</li>
<li>
<p>名字前缀要足够把符号名和数字区分开来，如果需要的话，可以在前面用 <code>\</code> 表示为符号，比如：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">symbolp</span> '+1)                           <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">symbolp</span> '\<span class="number">+1</span>)                          <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">symbol-name</span> '\<span class="number">+1</span>)                      <span class="comment">; =&gt; "+1"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>其它字符 <code>_~!@$%^&amp;amp;:&lt;&gt;{}?</code> 用的比较少。但是也可以直接作为符号的名字。</p>
</li>
<li>
<p>任何其它字符都可以用 <code>\</code> 转义后用在符号名字里。</p>
<blockquote>
<p>**注意：**和字符串里字符表示不同，<code>\</code> 转义后只是表示其后的字符，比如 <code>\t</code> 代表的字符 <code>t</code>，而不是制表符。如果要在符号名里使用制表符，必须在 <code>\</code> 后加上制表符本身。</p>
</blockquote>
</li>
<li>
<p>符号名是区分大小写的。</p>
</li>
</ul>
<p>这里有一些符号名的例子：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">foo                 <span class="comment">; 名为 `foo' 的符号</span></span><br><span class="line">FOO                 <span class="comment">; 名为 `FOO' 的符号，和 `foo' 不同</span></span><br><span class="line">char-to-string      <span class="comment">; 名为 `char-to-string' 的符号</span></span><br><span class="line"><span class="number">1</span>+                  <span class="comment">; 名为 `1+' 的符号 (不是整数 `+1')</span></span><br><span class="line">\+1                 ; 名为 `+1' 的符号 (可读性很差的名字)</span><br><span class="line">\(*\ 1\ 2\)         ; 名为 `(* 1 2)' 的符号 (更差劲的名字).</span><br><span class="line">+-*/_~!@$%^&amp;=:&lt;&gt;&#123;&#125;  ; 名为 `+-*/_~!@$%^&amp;=:&lt;&gt;&#123;&#125;' 的符号.</span><br><span class="line">                    <span class="comment">;   这些字符无须转义</span></span><br></pre></td></tr></table></figure>
<h4 id="创建符号"><a class="header-anchor" href="#创建符号">¶</a>创建符号</h4>
<p>符号名要有唯一性，所以一定会有一个表与名字关联，这个表在 elisp 里称为 obarray。从这个名字可以看出这个表是用数组类型，<strong>事实上是一个向量</strong>。</p>
<h5 id="intern"><a class="header-anchor" href="#intern">¶</a><code>intern</code></h5>
<p>当 lisp 读入一个符号时，通常会先查找这个符号是否在 obarray 里出现过，如果没有则会把这个符号加入到 obarray 里。这样查找并加入一个符号的过程称为是 <code>intern</code>。<code>intern</code> 函数可以查找或加入一个名字到 obarray 里，返回对应的符号。默认是全局的 obarray，也可以指定一个 obarray。</p>
<h5 id="intern-soft"><a class="header-anchor" href="#intern-soft">¶</a><code>intern-soft</code></h5>
<p><code>intern-soft</code> 与 <code>intern</code> 不同的是，当名字不在 obarray 里时，<code>intern-soft</code> 会返回 <code>nil</code>，而 <code>intern</code> 会加入到 obarray里。为了不污染 obarray，我下面的例子中尽量在 <code>foo</code> 这个 obarray 里进行。一般来说，去了 <code>foo</code> 参数，则会在 obarray 里进行。其结果应该是相同的：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> foo (<span class="name">make-vector</span> <span class="number">10</span> <span class="number">0</span>))           <span class="comment">; =&gt; [0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line">(<span class="name">intern-soft</span> <span class="string">"abc"</span> foo)                 <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">intern</span> <span class="string">"abc"</span> foo)                      <span class="comment">; =&gt; abc</span></span><br><span class="line">(<span class="name">intern-soft</span> <span class="string">"abc"</span> foo)                 <span class="comment">; =&gt; abc</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>lisp 每读入一个符号都会 <code>intern</code> 到 obarray 里，如果想避免，可以用在符号名前加上 <code>#:</code>：</p>
</blockquote>
<blockquote>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">intern-soft</span> <span class="string">"abc"</span>)                     <span class="comment">; =&gt; nil</span></span><br><span class="line">'abc                                    <span class="comment">; =&gt; abc</span></span><br><span class="line">(<span class="name">intern-soft</span> <span class="string">"abc"</span>)                     <span class="comment">; =&gt; abc</span></span><br><span class="line">(<span class="name">intern-soft</span> <span class="string">"abcd"</span>)                    <span class="comment">; =&gt; nil</span></span><br><span class="line">'#:abcd                                 ; =&gt; abcd</span><br><span class="line">(<span class="name">intern-soft</span> <span class="string">"abcd"</span>)                    <span class="comment">; =&gt; nil</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="unintern"><a class="header-anchor" href="#unintern">¶</a><code>unintern</code></h5>
<p>如果想除去 obarray 里的符号，可以用 <code>unintern</code> 函数。<code>unintern</code> 可以用符号名或符号作参数在指定的 obarray 里去除符号，成功去除则返回 t，如果没有查找到对应的符号则返回 <code>nil</code>：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">intern-soft</span> <span class="string">"abc"</span> foo)                 <span class="comment">; =&gt; abc</span></span><br><span class="line">(<span class="name">unintern</span> <span class="string">"abc"</span> foo)                    <span class="comment">; =&gt; t</span></span><br><span class="line">(<span class="name">intern-soft</span> <span class="string">"abc"</span> foo)                 <span class="comment">; =&gt; nil</span></span><br></pre></td></tr></table></figure>
<h5 id="mapatoms"><a class="header-anchor" href="#mapatoms">¶</a><code>mapatoms</code></h5>
<p><a href="#%E6%95%A3%E5%88%97%E8%A1%A8">和 hash-table 一样</a>，obarray 也提供一个 <code>mapatoms</code> 函数来遍历整个 obarray。比如要计算 obarray 里所有的符号数量：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> count <span class="number">0</span>)                          <span class="comment">; =&gt; 0</span></span><br><span class="line">(<span class="name">defun</span> count-syms (<span class="name">s</span>)</span><br><span class="line">  (<span class="name">setq</span> count (<span class="number">1</span>+ count)))              <span class="comment">; =&gt; count-syms</span></span><br><span class="line">(<span class="name">mapatoms</span> 'count-syms)                  <span class="comment">; =&gt; nil</span></span><br><span class="line">count                                   <span class="comment">; =&gt; 28371</span></span><br><span class="line">(<span class="name">length</span> obarray)                        <span class="comment">; =&gt; 1511</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>由前面的例子可以看出 elisp 中的向量长度都是有限的，而 obarray 里的符号有成千上万个。那这些符号是怎样放到 obarray 里的呢？<br>
其实<strong>这和散列的的实现是一样的</strong>。obarray 里的每一个元素通常称为 bucket。 一个 bucket 是可以容纳多个相同 hash 值的字符串和它们的数据。</p>
</blockquote>
<h4 id="符号的组成"><a class="header-anchor" href="#符号的组成">¶</a>符号的组成</h4>
<p>每个符号可以对应四个组成部分：名字、值、函数部分和属性列表(property list)。</p>
<h5 id="符号的名字和值"><a class="header-anchor" href="#符号的名字和值">¶</a>符号的名字和值</h5>
<ul>
<li>
<p>符号的名字可以用 <code>symbol-name</code> 访问。符号的值。</p>
</li>
<li>
<p>符号的值可以通过 <code>set</code> 函数来设置，用 <code>symbol-value</code> 来访问：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">set</span> (<span class="name">intern</span> <span class="string">"abc"</span> foo) <span class="string">"I'm abc"</span>)      <span class="comment">; =&gt; "I'm abc"</span></span><br><span class="line">(<span class="name">symbol-value</span> (<span class="name">intern</span> <span class="string">"abc"</span> foo))       <span class="comment">; =&gt; "I'm abc"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可能大家最常见到 <code>setq</code> 函数，而 <code>set</code> 函数确很少见到。<code>setq</code> 可以看成是一个宏，它可以让你用 <code>(setq sym val)</code> 代替 <code>(set (quote sym) val)</code>。事实上这也是它名字的来源 (q 代表 quoted)。但是 <strong><code>setq</code> 只能设置 obarray 里的变量，前面这个例子中就只能用 <code>set</code> 函数</strong>。</p>
</blockquote>
<blockquote>
<p>如果一个符号的值已经有设置过的话，则 <code>boundp</code> 测试返回 <code>t</code>，否则为 <code>nil</code>。对于 <code>boundp</code> 测试返回 <code>nil</code> 的符号，使用符号的值会引起一个变量值为 void 的错误。</p>
</blockquote>
</li>
<li>
<p>符号的第三个组成部分是函数。它可以用 <code>symbol-function</code> 来访问，用 <code>fset</code> 来设置：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">fset</span> (<span class="name">intern</span> <span class="string">"abc"</span> foo) (<span class="name">symbol-function</span> 'car)) <span class="comment">; =&gt; #&lt;subr car&gt;</span></span><br><span class="line">(<span class="name">funcall</span> (<span class="name">intern</span> <span class="string">"abc"</span> foo) '(a . b))            <span class="comment">; =&gt; a</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>类似的，可以用 <code>fboundp</code> 测试一个符号的函数部分是否有设置。</p>
</blockquote>
</li>
<li>
<p>符号的第四个组成部分是属性列表(property list)。通常属性列表用于存储和符号相关的信息，比如变量和函数的文档，定义的文件名和位置，语法类型。属性名和值可以是任意的 lisp 对象，但是通常名字是符号，可以用 <code>get</code> 和 <code>put</code> 来访问和修改属性值，用 <code>symbol-plist</code> 得到所有的属性列表：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">put</span> (<span class="name">intern</span> <span class="string">"abc"</span> foo) 'doc <span class="string">"this is abc"</span>)      <span class="comment">; =&gt; "this is abc"</span></span><br><span class="line">(<span class="name">get</span> (<span class="name">intern</span> <span class="string">"abc"</span> foo) 'doc)                    <span class="comment">; =&gt; "this is abc"</span></span><br><span class="line">(<span class="name">symbol-plist</span> (<span class="name">intern</span> <span class="string">"abc"</span> foo))                <span class="comment">; =&gt; (doc "this is abc")</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关联列表和属性列表很相似。符号的属性列表在内部表示上是用 <code>(prop1 value1 prop2 value2 ...)</code> 的形式，和关联列表也是很相似的。属性列表在查找和这个符号相关的信息时，要比直接用关联列表要简单快捷的多。所以变量的文档等信息都是放在符号的属性列表里。但是关联表在头端加入元素是很快的，而且它可以删除表里的元素。而属性列表则不能删除一个属性。</p>
</blockquote>
<blockquote>
<p>如果已经把属性列表取出，那么还可以用 plist-get 和 plist-put 的方法来访问和设置属性列表</p>
</blockquote>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">plist-get</span> '(foo <span class="number">4</span>) 'foo)               <span class="comment">; =&gt; 4</span></span><br><span class="line">(<span class="name">plist-get</span> '(foo <span class="number">4</span> bad) 'bar)           <span class="comment">; =&gt; nil</span></span><br><span class="line">(<span class="name">setq</span> my-plist '(bar t foo <span class="number">4</span>))          <span class="comment">; =&gt; (bar t foo 4)</span></span><br><span class="line">(<span class="name">setq</span> my-plist (<span class="name">plist-put</span> my-plist 'foo <span class="number">69</span>)) <span class="comment">; =&gt; (bar t foo 69)</span></span><br><span class="line">(<span class="name">setq</span> my-plist (<span class="name">plist-put</span> my-plist 'quux '(a))) <span class="comment">; =&gt; (bar t foo 69 quux (a))</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Emacs</tag>
        <tag>Lisp</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 程序设计语言学习笔记（二）</title>
    <url>/2019/03/03/Rust-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1>Rust 程序设计语言学习笔记（二）</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="6-枚举与模式匹配"><a class="header-anchor" href="#6-枚举与模式匹配">¶</a>6. 枚举与模式匹配</h2>
<h3 id="6-1-定义枚举"><a class="header-anchor" href="#6-1-定义枚举">¶</a>6.1 定义枚举</h3>
<h4 id="枚举值"><a class="header-anchor" href="#枚举值">¶</a>枚举值</h4>
<p>仅仅使用枚举并将数据直接放进每一个枚举成员而不是将枚举作为结构体的一部分。<code>IpAddr</code> 枚举的新定义表明了 <code>V4</code> 和 <code>V6</code> 成员都关联了 <code>String</code> 值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">String</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br></pre></td></tr></table></figure>
<p>我们直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了。</p>
<p>来看看下面另一个枚举的例子：它的成员中内嵌了多种多样的类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个枚举有四个含有不同类型的成员：</p>
<ul>
<li><code>Quit</code> 没有关联任何数据。</li>
<li><code>Move</code> 包含一个匿名结构体。</li>
<li><code>Write</code> 包含单独一个 <code>String</code>。</li>
<li><code>ChangeColor</code> 包含三个 <code>i32</code>。</li>
</ul>
<p>就像可以使用 <code>impl</code> 来为结构体定义方法那样，也可以在枚举上定义方法。这是一个定义于我们 <code>Message</code> 枚举上的叫做 <code>call</code> 的方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> Message &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这里定义方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = Message::Write(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">m.call();</span><br></pre></td></tr></table></figure>
<p>方法体使用了 <code>self</code> 来获取调用方法的值。这个例子中，创建了一个值为 <code>Message::Write(String::from(&quot;hello&quot;))</code> 的变量 <code>m</code>，而且这就是当 <code>m.call()</code> 运行时 <code>call</code> 方法中的 <code>self</code> 的值。</p>
<h4 id="Option-枚举和其相对于空值的优势"><a class="header-anchor" href="#Option-枚举和其相对于空值的优势">¶</a><code>Option</code> 枚举和其相对于空值的优势</h4>
<p>空值尝试表达的概念仍然是有意义的：空值是一个因为某种原因目前无效或缺失的值。<br>
问题不在于概念而在于具体的实现。为此，Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 <code>Option&lt;T&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只要一个值不是 <code>Option&lt;T&gt;</code> 类型，你就 <strong>可以</strong> 安全的认定它的值不为空。</p>
</blockquote>
<h3 id="6-2-match-控制流运算符"><a class="header-anchor" href="#6-2-match-控制流运算符">¶</a>6.2 <code>match</code> 控制流运算符</h3>
<p>一个枚举和一个以枚举成员作为模式的 <code>match</code> 表达式的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果分支代码较短的话通常不使用大括号，正如上例 中的每个分支都只是返回一个值。如果想要在分支中运行多行代码，可以使用大括号。例如，如下代码在每次使用<code>Coin::Penny</code> 调用时都会打印出 “Lucky penny!”，同时仍然返回代码块最后的值，<code>1</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Lucky penny!"</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配是穷尽的"><a class="header-anchor" href="#匹配是穷尽的">¶</a>匹配是穷尽的</h3>
<p>match 还有另一方面需要讨论。考虑一下 <code>plus_one</code> 函数的这个版本，它有一个 bug 并不能编译：<br>
这些代码不能编译！</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们没有处理 <code>None</code> 的情况，所以这些代码会造成一个 bug。幸运的是，这是一个 Rust 知道如何处理的 bug。如果尝试编译这段代码，会得到这个错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error[E0004]: non-exhaustive patterns: &#96;None&#96; not covered</span><br><span class="line"> --&gt;</span><br><span class="line">  |</span><br><span class="line">6 |         match x &#123;</span><br><span class="line">  |               ^ pattern &#96;None&#96; not covered</span><br></pre></td></tr></table></figure>
<p>Rust 知道我们没有覆盖所有可能的情况甚至知道哪些模式被忘记了！Rust 中的匹配是 穷尽的（<em>exhaustive</em>）：必须穷举到最后的可能性来使代码有效。特别的在这个 <code>Option&lt;T&gt;</code> 的例子中，Rust 防止我们忘记明确的处理 <code>None</code> 的情况，这使我们免于假设拥有一个实际上为空的值。</p>
<h4 id="通配符"><a class="header-anchor" href="#通配符">¶</a><code>_</code> 通配符</h4>
<p>Rust 也提供了一个模式用于不想列举出所有可能值的场景：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> some_u8_value = <span class="number">0u8</span>;</span><br><span class="line"><span class="keyword">match</span> some_u8_value &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one"</span>),</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">    <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"five"</span>),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">"seven"</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_</code> 模式会匹配所有的值。通过将其放置于其他分支之后，<code>_</code> 将会匹配所有之前没有指定的可能的值。<code>()</code> 就是 <code>unit</code> 值，所以 <code>_</code> 的情况什么也不会发生。</p>
<h3 id="6-3-if-let-简洁控制流"><a class="header-anchor" href="#6-3-if-let-简洁控制流">¶</a>6.3 <code>if let</code> 简洁控制流</h3>
<p>为了满足 <code>match</code> 表达式（穷尽性）的要求，必须在处理完这唯一的成员后加上 <code>_ =&gt; ()</code>，这样也要增加很多样板代码。<br>
我们可以使用 <code>if let</code> 这种更短的方式编写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在 <code>if let</code> 中包含一个 <code>else</code>。<code>else</code> 块中的代码与 <code>match</code> 表达式中的 <code>_</code> 分支块中的代码相同，这样的 <code>match</code> 表达式就等同于 <code>if let</code> 和 <code>else</code>。这样一个 match 表达式：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">match</span> coin &#123;</span><br><span class="line">    Coin::Quarter(state) =&gt; <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state),</span><br><span class="line">    _ =&gt; count += <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> Coin::Quarter(state) = coin &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;!"</span>, state);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-包、crate-与模块"><a class="header-anchor" href="#7-包、crate-与模块">¶</a>7. 包、crate 与模块</h2>
<h3 id="7-1-包和-crate-用来创建库和二进制项目"><a class="header-anchor" href="#7-1-包和-crate-用来创建库和二进制项目">¶</a>7.1 包和 crate 用来创建库和二进制项目</h3>
<ul>
<li><em>crate</em> 是一个二进制或库项目。</li>
<li><strong>crate 根</strong>（<em>crate root</em>）是一个用来描述如何构建 crate 的文件。</li>
<li>带有 <em>Cargo.toml</em> 文件的 <strong>包</strong> 用以描述如何构建一个或多个 crate。一个包中至多可以有一个库项目。</li>
</ul>
<p>所以当运行 <code>cargo new</code> 时是在创建一个包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo new my-project</span><br><span class="line">     Created binary (application) `my-project` package</span><br><span class="line">$ ls my-project</span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line">$ ls my-project/src</span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>Cargo 的约定是如果在代表包的 <em>Cargo.toml</em> 的同级目录下包含 <em>src</em> 目录且其中包含 <em><a href="http://main.rs" target="_blank" rel="noopener">main.rs</a></em> 文件的话，Cargo 就知道这个包带有一个与包同名的二进制 crate，且 <em>src/main.rs</em> 就是 crate 根。</li>
<li>另一个约定如果包目录中包含 <em>src/lib.rs</em>，则包带有与其同名的库 crate，且 <em>src/lib.rs</em> 是 crate 根。crate 根文件将由 Cargo 传递给 <code>rustc</code> 来实际构建库或者二进制项目。</li>
</ul>
</blockquote>
<h3 id="7-2-模块系统用来控制作用域和私有性"><a class="header-anchor" href="#7-2-模块系统用来控制作用域和私有性">¶</a>7.2 模块系统用来控制作用域和私有性</h3>
<h4 id="使用-super-开始相对路径"><a class="header-anchor" href="#使用-super-开始相对路径">¶</a>使用 <code>super</code> 开始相对路径</h4>
<p>可以使用 <code>super</code> 开头来构建相对路径。这么做类似于文件系统中以 <code>..</code> 开头：该路径从 <strong>父</strong> 模块开始而不是当前模块。这在下面示例这样的情况下有用处，在这里 clarinet 函数通过指定以 <code>super</code> 开头的路径调用 <code>breathe_in</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> instrument &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;</span><br><span class="line">        super::breathe_in();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">breathe_in</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>clarinet</code> 函数位于 <code>instrument</code> 模块中，所以可以使用 <code>super</code> 进入 <code>instrument</code> 的父模块，也就是根 <code>crate</code>。从这里可以找到 <code>breathe_in</code>。成功！</p>
<h4 id="对结构体和枚举使用-pub"><a class="header-anchor" href="#对结构体和枚举使用-pub">¶</a>对结构体和枚举使用 <code>pub</code></h4>
<p>如果在结构体定义中使用 <code>pub</code>，可以使结构体公有。然而结构体的字段仍是私有的。可以在每一个字段的基准上选择其是否公有：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> plant &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vegetable</span></span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> name: <span class="built_in">String</span>,</span><br><span class="line">        id: <span class="built_in">i32</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Vegetable &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name: &amp;<span class="built_in">str</span>) -&gt; Vegetable &#123;</span><br><span class="line">            Vegetable &#123;</span><br><span class="line">                name: <span class="built_in">String</span>::from(name),</span><br><span class="line">                id: <span class="number">1</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = plant::Vegetable::new(<span class="string">"squash"</span>);</span><br><span class="line"></span><br><span class="line">    v.name = <span class="built_in">String</span>::from(<span class="string">"butternut squash"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125; are delicious"</span>, v.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果将如下行取消注释代码将无法编译:</span></span><br><span class="line">    <span class="comment">// println!("The ID is &#123;&#125;", v.id);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相反，如果有一个公有枚举，其所有成员都是公有。只需在 <code>enum</code> 关键词前加上 <code>pub</code>。</p>
<h4 id="使用-use-关键字将名称引入作用域"><a class="header-anchor" href="#使用-use-关键字将名称引入作用域">¶</a>使用 <code>use</code> 关键字将名称引入作用域</h4>
<p>有一次性将路径引入作用域然后就像调用本地项那样的方法：使用 <code>use</code> 关键字。</p>
<p>如果希望通过 use 和相对路径来将项引入作用域，则与直接通过相对路径调用项有些小的区别：不同于从当前作用域的名称开始，use 中的路径必须以 self</p>
<h4 id="use-函数路径使用习惯-VS-其他项"><a class="header-anchor" href="#use-函数路径使用习惯-VS-其他项">¶</a><code>use</code> 函数路径使用习惯 VS 其他项</h4>
<ul>
<li>
<p>对于函数来说，通过 <code>use</code> 指定函数的父模块接着指定父模块来调用方法被认为是习惯用法。这么做而不是像下面示例那样通过 <code>use</code> 指定函数的路径，清楚的表明了函数不是本地定义的，同时仍最小化了指定全路径时的重复：</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> sound &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> instrument &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;</span><br><span class="line">            <span class="comment">// 函数体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::sound::instrument::clarinet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    clarinet();</span><br><span class="line">    clarinet();</span><br><span class="line">    clarinet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对于结构体、枚举和其它项，通过 <code>use</code> 指定项的全路径是习惯用法。例如，下面示例展示了将标准库中 <code>HashMap</code> 结构体引入作用域的习惯用法。</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">    map.insert(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这个习惯的一个例外是如果 <code>use</code> 语句会将两个同名的项引入作用域时，这是不允许的。下面示例展示了如何将两个不同父模块的 <code>Result</code> 类型引入作用域并引用它们。</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function1</span></span>() -&gt; fmt::<span class="built_in">Result</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">function2</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为如果我们指定 <code>use std::fmt::Result</code> 和 <code>use std::io::Result</code>，则作用域中会有两个 <code>Result</code> 类型，Rust 无法知道我们想用哪个 <code>Result</code>。</p>
</li>
</ul>
<h4 id="使用-pub-use-重导出名称"><a class="header-anchor" href="#使用-pub-use-重导出名称">¶</a>使用 <code>pub use</code> 重导出名称</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> sound &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> instrument &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;</span><br><span class="line">            <span class="comment">// 函数体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> performance_group &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">use</span> crate::sound::instrument;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clarinet_trio</span></span>() &#123;</span><br><span class="line">        instrument::clarinet();</span><br><span class="line">        instrument::clarinet();</span><br><span class="line">        instrument::clarinet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    performance_group::clarinet_trio();</span><br><span class="line">    performance_group::instrument::clarinet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>pub use</code>，现在 <code>main</code> 函数可以通过新路径 <code>performance_group::instrument::clarinet</code> 来调用 <code>clarinet</code> 函数。如果没有指定 <code>pub use</code>，<code>clarinet_trio</code> 函数可以在其作用域中调用 <code>instrument::clarinet</code> 但 <code>main</code> 则不允许使用这个新路径。</p>
<h4 id="嵌套路径来消除大量的-use-行"><a class="header-anchor" href="#嵌套路径来消除大量的-use-行">¶</a>嵌套路径来消除大量的 <code>use</code> 行</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp:Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br></pre></td></tr></table></figure>
<p>另外：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io:Write;</span><br></pre></td></tr></table></figure>
<h4 id="通过-glob-运算符将所有的公有定义引入作用域"><a class="header-anchor" href="#通过-glob-运算符将所有的公有定义引入作用域">¶</a>通过 <code>glob</code> 运算符将所有的公有定义引入作用域</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></table></figure>
<p>这个 <code>use</code> 语句将 <code>std::collections</code> 中定义的所有公有项引入当前作用域。</p>
<blockquote>
<p>使用 glob 运算符时请多加小心！<strong>如此难以推导作用域中有什么名称和它们是在何处定义的</strong>。<br>
glob 运算符经常用于测试模块 <code>tests</code> 中，这时会将所有内容引入作用域。</p>
</blockquote>
<h4 id="将模块分割进不同文件"><a class="header-anchor" href="#将模块分割进不同文件">¶</a>将模块分割进不同文件</h4>
<p><em>src/sound/instrument.rs</em> 中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clarinet</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>src/sound.rs</em> 中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> instrument;</span><br></pre></td></tr></table></figure>
<p><em>src/main.rs</em> 中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> sound;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::sound::instrument::clarinet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    sound::instrument::clarinet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-通用集合类型"><a class="header-anchor" href="#8-通用集合类型">¶</a>8. 通用集合类型</h2>
<h3 id="8-1-vector"><a class="header-anchor" href="#8-1-vector">¶</a>8.1 vector</h3>
<h4 id="新建-vector"><a class="header-anchor" href="#新建-vector">¶</a>新建 vector</h4>
<p>为了创建一个新的空 vector，可以调用 <code>Vec::new</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br></pre></td></tr></table></figure>
<p>在更实际的代码中，一旦插入值 Rust 就可以推断出想要存放的类型，所以你很少会需要这些类型注解。更常见的做法是使用初始值来创建一个 <code>Vec</code>，而且为了方便 Rust 提供了 <code>vec!</code> 宏。这个宏会根据我们提供的值来创建一个新的 <code>Vec</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h4 id="更新-vector"><a class="header-anchor" href="#更新-vector">¶</a>更新 vector</h4>
<p>对于新建一个 vector 并向其增加元素，可以使用 <code>push</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">v.push(<span class="number">5</span>);</span><br><span class="line">v.push(<span class="number">6</span>);</span><br><span class="line">v.push(<span class="number">7</span>);</span><br><span class="line">v.push(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>放入其中的所有值都是 <code>i32</code> 类型的，而且 Rust 也根据数据做出如此判断，所以不需要 <code>Vec&lt;i32&gt;</code> 注解。</p>
<h4 id="读取-vector-的元素"><a class="header-anchor" href="#读取-vector-的元素">¶</a>读取 vector 的元素</h4>
<p>有两种方法引用 vector 中储存的值，索引语法或者 <code>get</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The third element is &#123;&#125;"</span>, third);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">"The third element is &#123;&#125;"</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"There is no third element."</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个需要注意的地方：</p>
<blockquote>
<ul>
<li>我们使用索引值 <code>2</code> 来获取第三个元素，索引是从 <code>0</code> 开始的。</li>
<li>这两个不同的获取第三个元素的方式分别为：使用 <code>&amp;</code> 和 <code>[]</code> 返回一个引用；或者使用 <code>get</code> 方法以索引作为参数来返回一个 <code>Option&lt;&amp;T&gt;</code>。</li>
</ul>
</blockquote>
<p>一旦程序获取了一个有效的引用，借用检查器将会执行所有权和借用规则来确保 vector 内容的这个引用和任何其他引用保持有效。回忆一下不能在相同作用域中同时存在可变和不可变引用的规则。当我们获取了 vector 的 <strong>第一个元素</strong> 的不可变引用并尝试在 vector 末尾增加一个元素的时候，这是行不通的：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = &amp;v[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">v.push(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The first element is: &#123;&#125;"</span>, first);</span><br></pre></td></tr></table></figure>
<p>编译会给出这个错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error[E0502]: cannot borrow &#96;v&#96; as mutable because it is also borrowed as immutable</span><br><span class="line">  --&gt; src&#x2F;main.rs:10:5</span><br><span class="line">   |</span><br><span class="line">8  |     let first &#x3D; &amp;v[0];</span><br><span class="line">   |                  - immutable borrow occurs here</span><br><span class="line">9  |</span><br><span class="line">10 |     v.push(6);</span><br><span class="line">   |     ^^^^^^^^^ mutable borrow occurs here</span><br><span class="line">11 |</span><br><span class="line">12 |     println!(&quot;The first element is: &#123;&#125;&quot;, first);</span><br><span class="line">   |                                          ----- borrow later used here</span><br></pre></td></tr></table></figure>
<p>为什么第一个元素的引用会关心 vector 结尾的变化？不能这么做的原因是由于 vector 的工作方式：在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况。</p>
<h4 id="遍历-vector-中的元素"><a class="header-anchor" href="#遍历-vector-中的元素">¶</a>遍历 vector 中的元素</h4>
<p>使用 <code>for</code> 循环来获取 <code>i32</code> 值的 vector 中的每一个元素的不可变引用并将其打印：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以遍历可变 vector 的每一个元素的可变引用以便能改变他们：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用枚举来储存多种类型"><a class="header-anchor" href="#使用枚举来储存多种类型">¶</a>使用枚举来储存多种类型</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">    Int(<span class="built_in">i32</span>),</span><br><span class="line">    Float(<span class="built_in">f64</span>),</span><br><span class="line">    Text(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">"blue"</span>)),</span><br><span class="line">    SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h3 id="8-2-字符串"><a class="header-anchor" href="#8-2-字符串">¶</a>8.2 字符串</h3>
<h4 id="什么是字符串"><a class="header-anchor" href="#什么是字符串">¶</a>什么是字符串</h4>
<p><strong>Rust 的核心语言中只有一种字符串类型：<code>str</code>，字符串 slice，它通常以被借用的形式出现，<code>&amp;str</code>。</strong></p>
<h4 id="新建字符串"><a class="header-anchor" href="#新建字符串">¶</a>新建字符串</h4>
<p>很多 <code>Vec</code> 可用的操作在 <code>String</code> 中同样可用，从以 <code>new</code> 函数创建字符串开始：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br></pre></td></tr></table></figure>
<p>这新建了一个叫做 <code>s</code> 的空的字符串，接着我们可以向其中装载数据。通常字符串会有初始数据，因为我们希望一开始就有这个字符串。为此，可以使用 <code>to_string</code> 方法，<strong>它能用于任何实现了 <code>Display</code> trait 的类型，字符串字面值也实现了它 </strong>。</p>
<p>使用 <code>to_string</code> 方法从字符串字面值创建 <code>String</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="string">"initial contents"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = data.to_string();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法也可直接用于字符串字面值：</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">"initial contents"</span>.to_string();</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>String::from</code> 函数来从字符串字面值创建 <code>String</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"initial contents"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="更新字符串"><a class="header-anchor" href="#更新字符串">¶</a>更新字符串</h4>
<p><code>String</code> 的大小可以增长其内容也可以改变，就像可以放入更多数据来改变 <code>Vec</code> 的内容一样。另外，可以方便的使用 <code>+</code> 运算符或 <code>format!</code> 宏来拼接 <code>String</code> 值。</p>
<h5 id="使用-push-str-和-push-附加字符串"><a class="header-anchor" href="#使用-push-str-和-push-附加字符串">¶</a>使用 <code>push_str</code> 和 <code>push</code> 附加字符串</h5>
<p><code>push_str</code> 方法获取字符串 slice，因为我们<strong>并不需要获取参数的所有权</strong>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s1 = <span class="built_in">String</span>::from(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">"bar"</span>;</span><br><span class="line">s1.push_str(s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"s2 is &#123;&#125;"</span>, s2);</span><br></pre></td></tr></table></figure>
<p><code>push</code> 方法被定义为获取一个单独的字符作为参数，并附加到 <code>String</code> 中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"lo"</span>);</span><br><span class="line">s.push(<span class="string">'l'</span>);</span><br></pre></td></tr></table></figure>
<h5 id="使用-运算符或-format-宏拼接字符串"><a class="header-anchor" href="#使用-运算符或-format-宏拼接字符串">¶</a>使用 <code>+</code> 运算符或 <code>format!</code> 宏拼接字符串</h5>
<p>通常你会希望将两个已知的字符串合并在一起。一种办法是像这样使用 <code>+</code> 运算符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"Hello, "</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"world!"</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = s1 + &amp;s2; <span class="comment">// 注意 s1 被移动了，不能继续使用</span></span><br></pre></td></tr></table></figure>
<h4 id="索引字符串"><a class="header-anchor" href="#索引字符串">¶</a>索引字符串</h4>
<p>Rust 的字符串不支持索引。</p>
<h5 id="内部表现"><a class="header-anchor" href="#内部表现">¶</a>内部表现</h5>
<p><code>String</code> 是一个 <code>Vec&lt;u8&gt;</code> 的封装。为了避免返回意想不到值并造成不能立刻发现的 bug。Rust 选择不编译这些代码并及早杜绝了误会的发生。</p>
<h5 id="字节、标量值和字形簇！天呐！"><a class="header-anchor" href="#字节、标量值和字形簇！天呐！">¶</a>字节、标量值和字形簇！天呐！</h5>
<p>最后一个 Rust 不允许使用索引获取 <code>String</code> 字符的原因是索引操作预期总是需要常数时间 (O(1))。但是对于 <code>String</code> 不可能保证这样的性能，因为 Rust 不得不检查从字符串的开头到索引位置的内容来确定这里有多少有效的字符。</p>
<h4 id="字符串-slice"><a class="header-anchor" href="#字符串-slice">¶</a>字符串 slice</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">"Здравствуйте"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>这里，<code>s</code> 会是一个 <code>&amp;str</code>，它包含字符串的头四个字节。早些时候，我们提到了这些字母都是两个字节长的，所以这意味着 <code>s</code> 将会是 “Зд”。</p>
<p>如果获取 <code>&amp;hello[0..1]</code> 会发生什么呢？答案是：在运行时会 <code>panic</code>，就跟访问 vector 中的无效索引时一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread &#39;main&#39; panicked at &#39;byte index 1 is not a char boundary; it is inside &#39;З&#39; (bytes 0..2) of &#96;Здравствуйте&#96;&#39;, src&#x2F;libcore&#x2F;str&#x2F;mod.rs:2188:4</span><br></pre></td></tr></table></figure>
<h4 id="遍历字符串的方法"><a class="header-anchor" href="#遍历字符串的方法">¶</a>遍历字符串的方法</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">"नमस्ते"</span>.chars() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码会打印出如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">न</span><br><span class="line">म</span><br><span class="line">स</span><br><span class="line">्</span><br><span class="line">त</span><br><span class="line">े</span><br></pre></td></tr></table></figure>
<p><code>bytes</code> 方法返回每一个原始字节，这可能会适合你的使用场景：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">"नमस्ते"</span>.bytes() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码会打印出组成 <code>String</code> 的 18 个字节：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">224</span><br><span class="line">164</span><br><span class="line">&#x2F;&#x2F; --snip--</span><br><span class="line">165</span><br><span class="line">135</span><br></pre></td></tr></table></figure>
<h3 id="8-3-哈希-map"><a class="header-anchor" href="#8-3-哈希-map">¶</a>8.3 哈希 map</h3>
<h4 id="新建一个哈希-map"><a class="header-anchor" href="#新建一个哈希-map">¶</a>新建一个哈希 map</h4>
<p>可以使用 <code>new</code> 创建一个空的 <code>HashMap</code>，并使用 <code>insert</code> 增加元素：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>另一个构建哈希 map 的方法是使用一个元组的 vector 的 <code>collect</code> 方法，其中每个元组包含一个键值对。<code>collect</code> 方法可以将数据收集进一系列的集合类型，包括 <code>HashMap</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> teams  = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)];</span><br><span class="line"><span class="keyword">let</span> initial_scores = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();</span><br></pre></td></tr></table></figure>
<p>这里 <code>HashMap&lt;_, _&gt;</code> 类型注解是必要的，因为可能 <code>collect</code> 很多不同的数据结构，而除非显式指定否则 Rust 无从得知你需要的类型。但是对于键和值的类型参数来说，可以使用下划线占位，而 Rust 能够根据 vector 中数据的类型推断出 <code>HashMap</code> 所包含的类型。</p>
<h4 id="哈希-map-和所有权"><a class="header-anchor" href="#哈希-map-和所有权">¶</a>哈希 map 和所有权</h4>
<p>对于像 <code>i32</code> 这样的实现了 <code>Copy</code> trait 的类型，其值可以拷贝进哈希 map。对于像 <code>String</code> 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> field_name = <span class="built_in">String</span>::from(<span class="string">"Favorite color"</span>);</span><br><span class="line"><span class="keyword">let</span> field_value = <span class="built_in">String</span>::from(<span class="string">"Blue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">map.insert(field_name, field_value);</span><br><span class="line"><span class="comment">// 这里 field_name 和 field_value 不再有效，</span></span><br><span class="line"><span class="comment">// 尝试使用它们看看会出现什么编译错误！</span></span><br></pre></td></tr></table></figure>
<h4 id="访问哈希-map-中的值"><a class="header-anchor" href="#访问哈希-map-中的值">¶</a>访问哈希 map 中的值</h4>
<p>可以通过 <code>get</code> 方法并提供对应的键来从哈希 map 中获取值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> team_name = <span class="built_in">String</span>::from(<span class="string">"Blue"</span>);</span><br><span class="line"><span class="keyword">let</span> score = scores.get(&amp;team_name);</span><br></pre></td></tr></table></figure>
<p>这里，<code>score</code> 是与蓝队分数相关的值，应为 <code>Some(10)</code>。因为 <code>get</code> 返回 <code>Option&lt;V&gt;</code>，所以结果被装进 <code>Some</code>；如果某个键在哈希 map 中没有对应的值，<code>get</code> 会返回 <code>None</code>。</p>
<h4 id="更新哈希-map"><a class="header-anchor" href="#更新哈希-map">¶</a>更新哈希 map</h4>
<h5 id="覆盖一个值"><a class="header-anchor" href="#覆盖一个值">¶</a>覆盖一个值</h5>
<p><strong>如果我们插入了一个键值对，接着用相同的键插入一个不同的值，与这个键相关联的旧值将被替换：</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br></pre></td></tr></table></figure>
<p>这会打印出 <code>{&quot;Blue&quot;: 25}</code>。原始的值 <code>10</code> 则被覆盖了。</p>
<h5 id="只在键没有对应值时插入"><a class="header-anchor" href="#只在键没有对应值时插入">¶</a>只在键没有对应值时插入</h5>
<p>我们经常会检查某个特定的键是否有值，如果没有就插入一个值。为此哈希 map 有一个特有的 API，叫做 <code>entry</code>，它获取我们想要检查的键作为参数。<code>entry</code> 函数的返回值是一个枚举，<code>Entry</code>，它代表了可能存在也可能不存在的值。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br></pre></td></tr></table></figure>
<p><code>Entry</code> 的 <code>or_insert</code> 方法在键对应的值存在时就返回这个值的 <code>Entry</code>，如果不存在则将参数作为新值插入并返回修改过的 <code>Entry</code>。这比编写自己的逻辑要简明的多，另外也与借用检查器结合得更好。</p>
<h5 id="根据旧值更新一个值"><a class="header-anchor" href="#根据旧值更新一个值">¶</a>根据旧值更新一个值</h5>
<p>另一个常见的哈希 map 的应用场景是找到一个键对应的值并根据旧的值更新它。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">"hello world wonderful world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = map.entry(word).or_insert(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, map);</span><br></pre></td></tr></table></figure>
<h2 id="9-错误处理"><a class="header-anchor" href="#9-错误处理">¶</a>9. 错误处理</h2>
<h3 id="9-1-panic-与不可恢复的错误"><a class="header-anchor" href="#9-1-panic-与不可恢复的错误">¶</a>9.1 <code>panic!</code> 与不可恢复的错误</h3>
<h4 id="对应-panic-时的栈展开或终止"><a class="header-anchor" href="#对应-panic-时的栈展开或终止">¶</a>对应 panic 时的栈展开或终止</h4>
<p>当出现 panic 时，程序默认会开始 <strong>展开</strong>（<em>unwinding</em>），这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。另一种选择是直接 <strong>终止</strong>（<em>abort</em>），这会不清理数据就退出程序。那么程序所使用的内存需要由操作系统来清理。如果你需要项目的最终二进制文件越小越好，panic 时通过在 <em>Cargo.toml</em> 的 <code>[profile]</code> 部分增加 <code>panic = 'abort'</code>，可以由展开切换为终止。例如，如果你想要在release模式中 panic 时直接终止：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">'abort'</span></span><br></pre></td></tr></table></figure>
<h4 id="使用-panic-的-backtrace"><a class="header-anchor" href="#使用-panic-的-backtrace">¶</a>使用 <code>panic!</code> 的 backtrace</h4>
<p>我们可以设置 <code>RUST_BACKTRACE</code> 环境变量来得到一个 backtrace <em>backtrace</em> 是一个执行到目前位置所有被调用的函数的列表。</p>
<p>你实际看到的输出可能因不同的操作系统和 Rust 版本而有所不同。为了获取带有这些信息的 backtrace，必须启用 debug 标识。当不使用 <code>--release</code> 参数运行 cargo build 或 cargo run 时 debug 标识会默认启用。</p>
<h4 id="失败时-panic-的简写：unwrap-和-expect"><a class="header-anchor" href="#失败时-panic-的简写：unwrap-和-expect">¶</a>失败时 panic 的简写：<code>unwrap</code> 和 <code>expect</code></h4>
<p><code>unwrap</code> 实现就类似于 <code>match</code> 语句。如果 <code>Result</code> 值是成员 <code>Ok</code>，<code>unwrap</code> 会返回 <code>Ok</code> 中的值。如果 <code>Result</code> 是成员 <code>Err</code>，<code>unwrap</code> 会为我们调用 <code>panic!</code>。这里是一个实践 <code>unwrap</code> 的例子：</p>
<p>如果调用这段代码时不存在 <em>hello.txt</em> 文件，我们将会看到一个 <code>unwrap</code> 调用 <code>panic!</code> 时提供的错误信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread &#39;main&#39; panicked at &#39;called &#96;Result::unwrap()&#96; on an &#96;Err&#96; value: Error &#123;</span><br><span class="line">repr: Os &#123; code: 2, message: &quot;No such file or directory&quot; &#125; &#125;&#39;,</span><br><span class="line">src&#x2F;libcore&#x2F;result.rs:906:4</span><br></pre></td></tr></table></figure>
<p>还有另一个类似于 <code>unwrap</code> 的方法它还允许我们选择 <code>panic!</code> 的错误信息：<code>expect</code>。使用 <code>expect</code> 而不是 <code>unwrap</code> 并提供一个好的错误信息可以表明你的意图并更易于追踪 panic 的根源。<code>expect</code> 的语法看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>).expect(<span class="string">"Failed to open hello.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread &#39;main&#39; panicked at &#39;Failed to open hello.txt: Error &#123; repr: Os &#123; code:</span><br><span class="line">2, message: &quot;No such file or directory&quot; &#125; &#125;&#39;, src&#x2F;libcore&#x2F;result.rs:906:4</span><br></pre></td></tr></table></figure>
<h4 id="传播错误的简写："><a class="header-anchor" href="#传播错误的简写：">¶</a>传播错误的简写：<code>?</code></h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> f = File::open(<span class="string">"hello.txt"</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line">    f.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>Result</code> 的值是 <code>Ok</code>，这个表达式将会返回 <code>Ok</code> 中的值而程序将继续执行。如果值是 <code>Err</code>，<code>Err</code> 中的值将作为整个函数的返回值，就好像使用了 return 关键字一样，这样错误值就被传播给了调用者。</p>
<blockquote>
<p><code>?</code> 所使用的错误值被传递给了 from 函数，它定义于标准库的 <code>From</code> trait 中，其用来将错误从一种类型转换为另一种类型。当 <code>?</code> 调用 <code>from</code> 函数时，收到的错误类型被转换为定义为当前函数返回的错误类型。</p>
</blockquote>
<p><code>?</code> 消除了大量样板代码并使得函数的实现更简单。我们甚至可以在 <code>?</code> 之后直接使用链式方法调用来进一步缩短代码，：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br><span class="line"></span><br><span class="line">    File::open(<span class="string">"hello.txt"</span>)?.read_to_string(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至还有一个更短的写法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read_username_from_file</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::read_to_string(<span class="string">"hello.txt"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将文件读取到一个字符串是相当常见的操作，所以 Rust 提供了名为 <code>fs::read_to_string</code> 的函数，它会打开文件、新建一个 <code>String</code>、读取文件的内容，并将内容放入 <code>String</code>，接着返回它。当然，这样做就没有展示所有这些错误处理的机会了，所以我们最初就选择了艰苦的道路。</p>
<h4 id="只能被用于返回-Result-的函数"><a class="header-anchor" href="#只能被用于返回-Result-的函数">¶</a><code>?</code> 只能被用于返回 <code>Result</code> 的函数</h4>
<p><code>?</code> 只能被用于返回值类型为 <code>Result</code> 的函数。<br>
在 <code>main</code> 函数中使用 <code>?</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>)?;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会得到如下错误信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error[E0277]: the &#96;?&#96; operator can only be used in a function that returns &#96;Result&#96; or &#96;Option&#96; (or another type that implements &#96;std::ops::Try&#96;)</span><br><span class="line"> --&gt; src&#x2F;main.rs:4:13</span><br><span class="line">  |</span><br><span class="line">4 |     let f &#x3D; File::open(&quot;hello.txt&quot;)?;</span><br><span class="line">  |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the &#96;?&#96; operator in a function that returns &#96;()&#96;</span><br><span class="line">  |</span><br><span class="line">  &#x3D; help: the trait &#96;std::ops::Try&#96; is not implemented for &#96;()&#96;</span><br><span class="line">  &#x3D; note: required by &#96;std::ops::Try::from_error&#96;</span><br></pre></td></tr></table></figure>
<p>不过 <code>main</code> 函数可以返回一个 <code>Result&lt;T, E&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">"hello.txt"</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-泛型、trait-与生命周期"><a class="header-anchor" href="#10-泛型、trait-与生命周期">¶</a>10. 泛型、trait 与生命周期</h2>
<h3 id="10-1-泛型数据类型"><a class="header-anchor" href="#10-1-泛型数据类型">¶</a>10.1 泛型数据类型</h3>
<h4 id="方法定义中的泛型"><a class="header-anchor" href="#方法定义中的泛型">¶</a>方法定义中的泛型</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p.x = &#123;&#125;"</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意必须在 <code>impl</code> 后面声明 <code>T</code>，这样就可以在 <code>Point&lt;T&gt;</code> 上实现的方法中使用它了。在 <code>impl</code> 之后声明泛型 <code>T</code> ，这样 Rust 就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型。</p>
<p>例如，可以选择为 <code>Point&lt;f32&gt;</code> 实例实现方法，而不是为泛型 <code>Point</code> 实例。下面示例展示了一个没有在 <code>impl</code> 之后（的尖括号）声明泛型的例子，这里使用了一个具体类型，<code>f32</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> Point&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">distance_from_origin</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.powi(<span class="number">2</span>) + <span class="keyword">self</span>.y.powi(<span class="number">2</span>)).sqrt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-trait：定义共享的行为"><a class="header-anchor" href="#10-2-trait：定义共享的行为">¶</a>10.2 trait：定义共享的行为</h3>
<h4 id="为类型实现-trait"><a class="header-anchor" href="#为类型实现-trait">¶</a>为类型实现 trait</h4>
<blockquote>
<p>实现 trait 时需要注意的是，只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait。例如，可以为多媒体聚合库 crate 的自定义类型 <code>Tweet</code> 实现如标准库中的 <code>Display</code> trait，这是因为 <code>Tweet</code> 类型位于多媒体聚合库 crate 本地的作用域中。类似地，也可以在多媒体聚合库 crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Summary</code>，这是因为 <code>Summary</code> trait 位于多媒体聚合库 crate 本地作用域中。</p>
</blockquote>
<blockquote>
<p>但是不能为外部类型实现外部 trait。例如，不能在多媒体聚合库 crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Display</code> trait。这是因为 <code>Display</code> 和 Vec<T> 都定义于标准库中，它们并不位于多媒体聚合库的 crate 本地作用域中。这个限制是被称为 <strong>相干性</strong>（<em>coherence</em>） 的程序属性的一部分，或者更具体的说是 <strong>孤儿规则</strong>（<em>orphan rule</em>），其得名于不存在父类型。这条规则确保了其他人编写的代码不会破坏你代码，反之亦然。没有这条规则的话，两个 crate 可以分别对相同类型实现相同的 trait，而 Rust 将无从得知应该使用哪一个实现。</p>
</blockquote>
<h4 id="默认实现"><a class="header-anchor" href="#默认实现">¶</a>默认实现</h4>
<p>有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"(Read more...)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要对 <code>NewsArticle</code> 实例使用这个默认实现，而不是定义一个自己的实现，则可以通过 <code>impl Summary for NewsArticle {}</code> 指定一个空的 <code>impl</code> 块。</p>
<blockquote>
<p>注意无法从相同方法的重载实现中调用默认方法。</p>
</blockquote>
<h4 id="trait-作为参数"><a class="header-anchor" href="#trait-作为参数">¶</a>trait 作为参数</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>notify</code> 函数体中，可以调用任何来自 <code>Summary</code> trait 的方法，比如 <code>summarize</code>。</p>
<h5 id="Trait-Bounds"><a class="header-anchor" href="#Trait-Bounds">¶</a>Trait Bounds</h5>
<p><code>impl Trait</code> 语法适用于短小的例子，它不过是一个较长形式的语法糖。这被称为 <em>trait bound</em>，这看起来像：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然 <code>impl Trait</code> 适用于短小的例子，trait bound 则适用于更复杂的场景。例如，比如需要获取两个实现了 <code>Summary</code> 的类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item1: <span class="keyword">impl</span> Summary, item2: <span class="keyword">impl</span> Summary) &#123;</span><br></pre></td></tr></table></figure>
<p>这适用于 <code>item1</code> 和 <code>item2</code> 允许是不同类型的情况（只要它们都实现了 <code>Summary</code>）。不过如果你希望强制它们都是相同类型呢？这只有在使用 trait bound 时才有可能：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item1: T, item2: T) &#123;</span><br></pre></td></tr></table></figure>
<h5 id="通过-指定多个-trait"><a class="header-anchor" href="#通过-指定多个-trait">¶</a>通过 <code>+</code> 指定多个 trait</h5>
<p>如果 <code>notify</code> 需要显示 <code>item</code> 的格式化形式，同时也要使用 <code>summarize</code> 方法，那么 <code>item</code> 就需要同时实现两个不同的 trait：<code>Display</code> 和 <code>Summary</code>。这可以通过 <code>+</code> 语法实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary + Display) &#123;</span><br></pre></td></tr></table></figure>
<p>这个语法也适用于泛型的 trait bound：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display&gt;(item: T) &#123;</span><br></pre></td></tr></table></figure>
<h5 id="通过-where-简化代码"><a class="header-anchor" href="#通过-where-简化代码">¶</a>通过 <code>where</code> 简化代码</h5>
<p>Rust 有另一个在函数签名之后的 <code>where</code> 从句中指定 trait bound 的语法。所以除了这么写：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: T, u: U) -&gt; <span class="built_in">i32</span> &#123;</span><br></pre></td></tr></table></figure>
<p>还可以像这样使用 <code>where</code> 从句：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T, U&gt;(t: T, u: U) -&gt; <span class="built_in">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<h4 id="返回-trait"><a class="header-anchor" href="#返回-trait">¶</a>返回 trait</h4>
<p>也可以在返回值中使用 impl Trait 语法，来返回实现了某个 trait 的类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>() -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"horse_ebooks"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"of course, as you probably already know, people"</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这只适用于返回 <strong>单一类型</strong> 的情况。例如，这样就 <strong>不行</strong>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>(switch: <span class="built_in">bool</span>) -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        NewsArticle &#123;</span><br><span class="line">            headline: <span class="built_in">String</span>::from(<span class="string">"Penguins win the Stanley Cup Championship!"</span>),</span><br><span class="line">            location: <span class="built_in">String</span>::from(<span class="string">"Pittsburgh, PA, USA"</span>),</span><br><span class="line">            author: <span class="built_in">String</span>::from(<span class="string">"Iceburgh"</span>),</span><br><span class="line">            content: <span class="built_in">String</span>::from(<span class="string">"The Pittsburgh Penguins once again are the best</span></span><br><span class="line"><span class="string">            hockey team in the NHL."</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Tweet &#123;</span><br><span class="line">            username: <span class="built_in">String</span>::from(<span class="string">"horse_ebooks"</span>),</span><br><span class="line">            content: <span class="built_in">String</span>::from(<span class="string">"of course, as you probably already know, people"</span>),</span><br><span class="line">            reply: <span class="literal">false</span>,</span><br><span class="line">            retweet: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-trait-bound-有条件地实现方法"><a class="header-anchor" href="#使用-trait-bound-有条件地实现方法">¶</a>使用 trait bound 有条件地实现方法</h4>
<p>下面示例中的类型 <code>Pair&lt;T&gt;</code> 总是实现了 <code>new</code> 方法，不过只有那些为 <code>T</code> 类型实现了 <code>PartialOrd</code> trait （来允许比较） 和 <code>Display</code> trait （来启用打印）的 <code>Pair&lt;T&gt;</code> 才会实现 <code>cmp_display</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T, y: T) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            x,</span><br><span class="line">            y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cmp_display</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is x = &#123;&#125;"</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is y = &#123;&#125;"</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以对任何实现了特定 trait 的类型有条件地实现 trait。例如，标准库为任何实现了 <code>Display</code> trait 的类型实现了 <code>ToString</code> trait。这个 <code>impl</code> 块看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> T &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对任何满足特定 trait bound 的类型实现 trait 被称为 <em>blanket implementations</em>。</p>
</blockquote>
<h3 id="10-3-生命周期与引用有效期"><a class="header-anchor" href="#10-3-生命周期与引用有效期">¶</a>10.3 生命周期与引用有效期</h3>
<h4 id="生命周期省略（Lifetime-Elision）"><a class="header-anchor" href="#生命周期省略（Lifetime-Elision）">¶</a>生命周期省略（Lifetime Elision）</h4>
<p>函数或方法的参数的生命周期被称为 <strong>输入生命周期</strong>（<em>input lifetimes</em>），而返回值的生命周期被称为 <strong>输出生命周期</strong>（<em>output lifetimes</em>）。</p>
<p>编译器采用三条规则来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误：</p>
<ol>
<li>每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>，有两个引用参数的函数有两个不同的生命周期参数，<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>，依此类推。</li>
<li>如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>。</li>
<li>如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那么 <code>self</code> 的生命周期被赋给所有输出生命周期参数。这使得方法更容易读写，因为只需更少的符号。</li>
</ol>
<h4 id="方法定义中的生命周期注解"><a class="header-anchor" href="#方法定义中的生命周期注解">¶</a>方法定义中的生命周期注解</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; ImportantExcerpt&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">level</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>impl</code> 之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注 <code>self</code> 引用的生命周期。</p>
<h4 id="静态生命同期"><a class="header-anchor" href="#静态生命同期">¶</a>静态生命同期</h4>
<p>这里有一种特殊的生命周期值得讨论：<code>'static</code>，其生命周期存活于整个程序期间。所有的字符串字面值都拥有 <code>'static</code> 生命周期，我们也可以选择像下面这样标注出来：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"I have a static lifetime."</span>;</span><br></pre></td></tr></table></figure>
<h4 id="结合泛型类型参数、trait-bounds-和生命周期"><a class="header-anchor" href="#结合泛型类型参数、trait-bounds-和生命周期">¶</a>结合泛型类型参数、trait bounds 和生命周期</h4>
<p>让我们简要的看一下在同一函数中指定泛型类型参数、trait bounds 和生命周期的语法！</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest_with_an_announcement</span></span>&lt;<span class="symbol">'a</span>, T&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, ann: T) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span></span><br><span class="line">    <span class="keyword">where</span> T: Display</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Announcement! &#123;&#125;"</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是示例中那个返回两个字符串 slice 中较长者的 <code>longest</code> 函数，不过带有一个额外的参数 <code>ann</code>。<code>ann </code>的类型是泛型 <code>T</code>，它可以被放入任何实现了 <code>where</code> 从句中指定的 <code>Display</code> trait 的类型。这个额外的参数会在函数比较字符串 slice 的长度之前被打印出来，这也就是为什么 <code>Display</code> trait bound 是必须的。因为生命周期也是泛型，所以生命周期参数 <code>'a</code> 和泛型类型参数 <code>T</code> 都位于函数名后的同一尖括号列表中。</p>
<h2 id="11-测试"><a class="header-anchor" href="#11-测试">¶</a>11. 测试</h2>
<h3 id="11-1-编写测试"><a class="header-anchor" href="#11-1-编写测试">¶</a>11.1. 编写测试</h3>
<p>Rust 中的测试函数是用来验证非测试代码是否按照期望的方式运行的。测试函数体通常执行如下三种操作：</p>
<ol>
<li>设置任何所需的数据或状态</li>
<li>运行需要测试的代码</li>
<li>断言其结果是我们所期望的</li>
</ol>
<h4 id="测试函数剖析"><a class="header-anchor" href="#测试函数剖析">¶</a>测试函数剖析</h4>
<p>我们创建一个新的库项目 <code>adder</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo new adder --lib</span><br><span class="line">     Created library `adder` project</span><br><span class="line">$ <span class="built_in">cd</span> adder</span><br></pre></td></tr></table></figure>
<p>由 cargo new 自动生成的测试模块和函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义失败信息"><a class="header-anchor" href="#自定义失败信息">¶</a>自定义失败信息</h4>
<p>让我们为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 greeting 函数的值：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">greeting_contains_name</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = greeting(<span class="string">"Carol"</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(</span><br><span class="line">        result.contains(<span class="string">"Carol"</span>),</span><br><span class="line">        <span class="string">"Greeting did not contain name, value was `&#123;&#125;`"</span>, result</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-should-panic-检查-panic"><a class="header-anchor" href="#使用-should-panic-检查-panic">¶</a>使用 <code>should_panic</code> 检查 panic</h4>
<p>下面示例展示了一个检查 Guess::new 是否按照我们的期望出错的测试：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Guess</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Guess &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(value: <span class="built_in">i32</span>) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Guess value must be between 1 and 100, got &#123;&#125;."</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123;</span><br><span class="line">            value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greater_than_100</span></span>() &#123;</span><br><span class="line">        Guess::new(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>#[should_panic]</code> 属性位于 <code>#[test]</code> 之后，对应的测试函数之前。<br>
一个会带有特定错误信息的 <code>panic!</code> 条件的测试：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> Guess &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(value: <span class="built_in">i32</span>) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Guess value must be greater than or equal to 1, got &#123;&#125;."</span>,</span><br><span class="line">                   value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">"Guess value must be less than or equal to 100, got &#123;&#125;."</span>,</span><br><span class="line">                   value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123;</span><br><span class="line">            value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic(expected = <span class="meta-string">"Guess value must be less than or equal to 100"</span>)]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">greater_than_100</span></span>() &#123;</span><br><span class="line">        Guess::new(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="将-Result-T-E-用于测试"><a class="header-anchor" href="#将-Result-T-E-用于测试">¶</a>将 Result&lt;T, E&gt; 用于测试</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span> &#123;</span><br><span class="line">            <span class="literal">Ok</span>(())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">Err</span>(<span class="built_in">String</span>::from(<span class="string">"two plus two does not equal four"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们将 <code>it\_works</code> 改为返回 Result。同时在函数体中，在成功时返回 <code>Ok(())</code> 而不是 <code>assert_eq!</code>，而失败时返回带有 <code>String</code> 的 <code>Err</code>。跟之前一样，这个测试可能成功或失败，不过不再通过 panic，可以通过 <code>Result&lt;T, E&gt;</code> 来判断结果。为此不能在对这些函数使用 <code>#[should_panic]</code>；而是应该返回 <code>Err</code>！</p>
<h3 id="11-2-运行测试"><a class="header-anchor" href="#11-2-运行测试">¶</a>11.2 运行测试</h3>
<h4 id="并行或连续的运行测试"><a class="header-anchor" href="#并行或连续的运行测试">¶</a>并行或连续的运行测试</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> -- --<span class="built_in">test</span>-threads=1</span><br></pre></td></tr></table></figure>
<p>这里将测试线程设置为 <code>1</code>，告诉程序不要使用任何并行机制。这也会比并行运行花费更多时间，不过在有共享的状态时，测试就不会潜在的相互干扰了。</p>
<h4 id="显示函数输出"><a class="header-anchor" href="#显示函数输出">¶</a>显示函数输出</h4>
<p>默认情况下，当测试通过时，Rust 的测试库会截获打印到标准输出的所有内容。比如在测试中调用了 <code>println!</code> 而测试通过了，我们将不会在终端看到 <code>println!</code> 的输出：只会看到说明测试通过的提示行。如果测试失败了，则会看到所有标准输出和其他错误信息：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">prints_and_returns_10</span></span>(a: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"I got the value &#123;&#125;"</span>, a);</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">this_test_will_pass</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> value = prints_and_returns_10(<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">10</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">this_test_will_fail</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> value = prints_and_returns_10(<span class="number">8</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">5</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 cargo test 将会看到这些测试的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">running 2 tests</span><br><span class="line">test tests::this_test_will_pass ... ok</span><br><span class="line">test tests::this_test_will_fail ... FAILED</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line"></span><br><span class="line">---- tests::this_test_will_fail stdout ----</span><br><span class="line">        I got the value 8</span><br><span class="line">thread &#39;tests::this_test_will_fail&#39; panicked at &#39;assertion failed: &#96;(left &#x3D;&#x3D; right)&#96;</span><br><span class="line">  left: &#96;5&#96;,</span><br><span class="line"> right: &#96;10&#96;&#39;, src&#x2F;lib.rs:19:8</span><br><span class="line">note: Run with &#96;RUST_BACKTRACE&#x3D;1&#96; for a backtrace.</span><br><span class="line"></span><br><span class="line">failures:</span><br><span class="line">    tests::this_test_will_fail</span><br><span class="line"></span><br><span class="line">test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out</span><br></pre></td></tr></table></figure>
<h4 id="通过指定名字来运行部分测试"><a class="header-anchor" href="#通过指定名字来运行部分测试">¶</a>通过指定名字来运行部分测试</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_two</span></span>(a: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add_two_and_two</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, add_two(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add_three_and_two</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">5</span>, add_two(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">one_hundred</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">102</span>, add_two(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="运行单个测试"><a class="header-anchor" href="#运行单个测试">¶</a>运行单个测试</h5>
<p>可以向 <code>cargo test</code> 传递任意测试的名称来只运行这个测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cargo test one_hundred</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs</span><br><span class="line">     Running target&#x2F;debug&#x2F;deps&#x2F;adder-06a75b4a1f2515e9</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::one_hundred ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out</span><br></pre></td></tr></table></figure>
<h5 id="过滤运行多个测试"><a class="header-anchor" href="#过滤运行多个测试">¶</a>过滤运行多个测试</h5>
<p>我们可以指定部分测试的名称，任何名称匹配这个名称的测试会被运行。例如，因为头两个测试的名称包含 <code>add</code>，可以通过 <code>cargo test add</code> 来运行这两个测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cargo test add</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs</span><br><span class="line">     Running target&#x2F;debug&#x2F;deps&#x2F;adder-06a75b4a1f2515e9</span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line">test tests::add_two_and_two ... ok</span><br><span class="line">test tests::add_three_and_two ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out</span><br></pre></td></tr></table></figure>
<p>这运行了所有名字中带有 <code>add</code> 的测试，也过滤掉了名为 <code>one_hundred</code> 的测试。</p>
<blockquote>
<p><strong>同时注意测试所在的模块也是测试名称的一部分，所以可以通过模块名来运行一个模块中的所有测试。</strong></p>
</blockquote>
<h4 id="忽略某些测试"><a class="header-anchor" href="#忽略某些测试">¶</a>忽略某些测试</h4>
<p>对于想要排除的测试，我们在 <code>#[test]</code> 之后增加了 <code>#[ignore]</code> 行：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">it_works</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">expensive_test</span></span>() &#123;</span><br><span class="line">    <span class="comment">// code that takes an hour to run</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果我们只希望运行被忽略的测试，可以使用 <code>cargo test -- --ignored</code>。</p>
</blockquote>
<h3 id="11-3-测试的组织结构"><a class="header-anchor" href="#11-3-测试的组织结构">¶</a>11.3 测试的组织结构</h3>
<h4 id="单元测试"><a class="header-anchor" href="#单元测试">¶</a>单元测试</h4>
<h5 id="测试模块和-cfg-test"><a class="header-anchor" href="#测试模块和-cfg-test">¶</a>测试模块和 <code>cfg(test)</code></h5>
<p>测试模块的 <code>#[cfg(test)]</code> 注解告诉 Rust 只在执行 <code>cargo test</code> 时才编译和运行测试代码，而在运行 <code>cargo build</code> 时不这么做。</p>
<blockquote>
<p>与之对应的集成测试因为位于另一个文件夹，所以它们并不需要 <code>#[cfg(test)]</code> 注解。</p>
</blockquote>
<h5 id="测试私有函数"><a class="header-anchor" href="#测试私有函数">¶</a>测试私有函数</h5>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_two</span></span>(a: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    internal_adder(a, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">internal_adder</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">internal</span></span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, internal_adder(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <code>internal_adder</code> 函数并没有标记为 <code>pub</code>，不过因为测试也不过是 Rust 代码同时 <code>tests</code> 也仅仅是另一个模块，我们完全可以在测试中导入和调用 <code>internal_adder</code>。</p>
<h4 id="集成测试"><a class="header-anchor" href="#集成测试">¶</a>集成测试</h4>
<p>在 Rust 中，集成测试对于你需要测试的库来说完全是外部的。同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 API 。为了创建集成测试，你需要先创建一个 <em>tests</em> 目录。</p>
<h5 id="tests-目录"><a class="header-anchor" href="#tests-目录">¶</a><em>tests</em> 目录</h5>
<p>为了编写集成测试，需要在项目根目录创建一个 <em>tests</em> 目录，与 <em>src</em> 同级。Cargo 知道如何去寻找这个目录中的集成测试文件。接着可以随意在这个目录中创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译。</p>
<p>创建一个 <em>tests</em> 目录，新建一个文件 <em>tests/integration_test.rs</em>。一个 <code>adder</code> crate 中函数的集成测试：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">it_adds_two</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::add_two(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与单元测试不同，我们需要在文件顶部添加 <code>use adder</code>。这是因为每一个 <em>tests</em> 目录中的测试文件都是完全独立的 crate，所以需要在每一个文件中导入库。</p>
<h2 id="12-一个I-O项目：构建命令行程序"><a class="header-anchor" href="#12-一个I-O项目：构建命令行程序">¶</a>12. 一个I/O项目：构建命令行程序</h2>
<h3 id="12-1-接受命令行参数"><a class="header-anchor" href="#12-1-接受命令行参数">¶</a>12.1. 接受命令行参数</h3>
<h4 id="读取参数"><a class="header-anchor" href="#读取参数">¶</a>读取参数</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><code>args</code> 函数和无效的 Unicode</strong><br>
注意 <code>std::env::args</code> 在其任何参数包含无效 Unicode 字符时会 panic。如果你需要接受包含无效 Unicode 字符的参数，使用 <code>std::env::args_os</code> 代替。这个函数返回 <code>OsString</code> 值而不是 <code>String</code> 值。这里出于简单考虑使用了 <code>std::env::args</code>，因为 <code>OsString</code> 值每个平台都不一样而且比 <code>String</code> 值处理起来更为复杂。</p>
</blockquote>
<h4 id="将参数保存进变量"><a class="header-anchor" href="#将参数保存进变量">¶</a>将参数保存进变量</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> query = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> filename = &amp;args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Searching for &#123;&#125;"</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"In file &#123;&#125;"</span>, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-2-读取文件"><a class="header-anchor" href="#12-2-读取文件">¶</a>12.2. 读取文件</h3>
<p>poem.txt：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I&#39;m nobody! Who are you?</span><br><span class="line">Are you nobody, too?</span><br><span class="line">Then there&#39;s a pair of us - don&#39;t tell!</span><br><span class="line">They&#39;d banish us, you know.</span><br><span class="line"></span><br><span class="line">How dreary to be somebody!</span><br><span class="line">How public, like a frog</span><br><span class="line">To tell your name the livelong day</span><br><span class="line">To an admiring bog!</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> query = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> filename = &amp;args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Searching for &#123;&#125;"</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"In file &#123;&#125;"</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(filename)</span><br><span class="line">        .expect(<span class="string">"Something went wrong reading the file"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"With text:\n&#123;&#125;"</span>, contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-3-重构以改进模块化错误处理"><a class="header-anchor" href="#12-3-重构以改进模块化错误处理">¶</a>12.3. 重构以改进模块化错误处理</h3>
<h4 id="二进制项目的关注分离"><a class="header-anchor" href="#二进制项目的关注分离">¶</a>二进制项目的关注分离</h4>
<p><code>main</code> 函数负责多个任务的组织问题在许多二进制项目中很常见。所以 Rust 社区开发出一类在 <code>main</code> 函数开始变得庞大时进行二进制程序的关注分离的指导性过程。这些过程有如下步骤：</p>
<ol>
<li>将程序拆分成 <em><a href="http://main.rs" target="_blank" rel="noopener">main.rs</a></em> 和 <em><a href="http://lib.rs" target="_blank" rel="noopener">lib.rs</a></em> 并将程序的逻辑放入 <em><a href="http://lib.rs" target="_blank" rel="noopener">lib.rs</a></em> 中。</li>
<li>当命令行解析逻辑比较小时，可以保留在 <em><a href="http://main.rs" target="_blank" rel="noopener">main.rs</a></em> 中。</li>
<li>当命令行解析开始变得复杂时，也同样将其从 <em><a href="http://main.rs" target="_blank" rel="noopener">main.rs</a></em> 提取到 <em><a href="http://lib.rs" target="_blank" rel="noopener">lib.rs</a></em> 中。</li>
<li>经过这些过程之后保留在 <code>main</code> 函数中的责任应该被限制为：
<ul>
<li>使用参数值调用命令行解析逻辑</li>
<li>设置任何其他的配置</li>
<li>调用 <em><a href="http://lib.rs" target="_blank" rel="noopener">lib.rs</a></em> 中的 <code>run</code> 函数</li>
<li>如果 <code>run</code> 返回错误，则处理这个错误</li>
</ul>
</li>
</ol>
<h4 id="提取参数解析器"><a class="header-anchor" href="#提取参数解析器">¶</a>提取参数解析器</h4>
<p>从 <code>main</code> 中提取出 <code>parse_config</code> 函数:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (query, filename) = parse_config(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Searching for &#123;&#125;"</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"In file &#123;&#125;"</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(filename)</span><br><span class="line">        .expect(<span class="string">"Something went wrong reading the file"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"With text:\n&#123;&#125;"</span>, contents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_config</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; (&amp;<span class="built_in">str</span>, &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> query = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> filename = &amp;args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    (query, filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组合配置值"><a class="header-anchor" href="#组合配置值">¶</a>组合配置值</h4>
<blockquote>
<p>将在复杂类型更为合适的场景下使用基本类型的反模式称为 <strong>基本类型偏执</strong>（<em>primitive obsession</em>）。</p>
</blockquote>
<p>下面示例展示了新定义的结构体 <code>Config</code>，它有字段 <code>query</code> 和 <code>filename</code>。我们也改变了 <code>parse_config</code> 函数来返回一个 <code>Config</code> 结构体的实例，并更新 <code>main</code> 来使用结构体字段而不是单独的变量：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> config = parse_config(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Searching for &#123;&#125;"</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"In file &#123;&#125;"</span>, config.filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(config.filename)</span><br><span class="line">        .expect(<span class="string">"Something went wrong reading the file"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"With text:\n&#123;&#125;"</span>, contents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">    query: <span class="built_in">String</span>,</span><br><span class="line">    filename: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_config</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; Config &#123;</span><br><span class="line">    <span class="keyword">let</span> query = args[<span class="number">1</span>].clone();</span><br><span class="line">    <span class="keyword">let</span> filename = args[<span class="number">2</span>].clone();</span><br><span class="line"></span><br><span class="line">    Config &#123; query, filename &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>parse_config</code> 的签名表明它现在返回一个 <code>Config</code> 值。在之前的 <code>parse_config</code> 函数体中，我们返回了引用 <code>args</code> 中 <code>String</code> 值的字符串 slice，现在我们定义 <code>Config</code>来包含拥有所有权的 <code>String</code> 值。<code>main</code> 中的 <code>args</code> 变量是参数值的所有者并只允许 <code>parse_config</code> 函数借用他们，这意味着如果 <code>Config</code> 尝试获取 <code>args</code> 中值的所有权将违反 Rust 的借用规则。</p>
<h4 id="创建一个-Config-构造函数"><a class="header-anchor" href="#创建一个-Config-构造函数">¶</a>创建一个 Config 构造函数</h4>
<p>将 <code>parse_config</code> 变为 <code>Config::new</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> config = Config::new(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Searching for &#123;&#125;"</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"In file &#123;&#125;"</span>, config.filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(config.filename)</span><br><span class="line">        .expect(<span class="string">"Something went wrong reading the file"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"With text:\n&#123;&#125;"</span>, contents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">    query: <span class="built_in">String</span>,</span><br><span class="line">    filename: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Config &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; Config &#123;</span><br><span class="line">        <span class="keyword">let</span> query = args[<span class="number">1</span>].clone();</span><br><span class="line">        <span class="keyword">let</span> filename = args[<span class="number">2</span>].clone();</span><br><span class="line"></span><br><span class="line">        Config &#123; query, filename &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复错误处理"><a class="header-anchor" href="#修复错误处理">¶</a>修复错误处理</h4>
<h5 id="改善错误信息"><a class="header-anchor" href="#改善错误信息">¶</a>改善错误信息</h5>
<p>增加一个参数数量检查：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; Config &#123;</span><br><span class="line">    <span class="keyword">if</span> args.len() &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">"not enough arguments"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>
<h5 id="从-new-中返回-Result-而不是调用-panic"><a class="header-anchor" href="#从-new-中返回-Result-而不是调用-panic">¶</a>从 <code>new</code> 中返回 <code>Result</code> 而不是调用 <code>panic!</code></h5>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> Config &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; <span class="built_in">Result</span>&lt;Config, &amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.len() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">Err</span>(<span class="string">"not enough arguments"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> query = args[<span class="number">1</span>].clone();</span><br><span class="line">        <span class="keyword">let</span> filename = args[<span class="number">2</span>].clone();</span><br><span class="line"></span><br><span class="line">        <span class="literal">Ok</span>(Config &#123; query, filename &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Config-new-调用并处理错误"><a class="header-anchor" href="#Config-new-调用并处理错误">¶</a><code>Config::new</code> 调用并处理错误</h5>
<p>如果新建 <code>Config</code> 失败则使用错误码退出：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> config = Config::new(&amp;args).unwrap_or_else(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Problem parsing arguments: &#123;&#125;"</span>, err);</span><br><span class="line">        process::exit(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>
<h4 id="从-main-提取逻辑"><a class="header-anchor" href="#从-main-提取逻辑">¶</a>从 <code>main</code> 提取逻辑</h4>
<p>下面示例展示了提取出来的 <code>run</code> 函数。目前我们只进行小的增量式的提取函数的改进：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Searching for &#123;&#125;"</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"In file &#123;&#125;"</span>, config.filename);</span><br><span class="line"></span><br><span class="line">    run(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(config: Config) &#123;</span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(config.filename)</span><br><span class="line">        .expect(<span class="string">"something went wrong reading the file"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"With text:\n&#123;&#125;"</span>, contents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>
<h5 id="从-run-函数中返回错误"><a class="header-anchor" href="#从-run-函数中返回错误">¶</a>从 <code>run</code> 函数中返回错误</h5>
<p>下面示例展示了 run 签名和函数体中的改变：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(config: Config) -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> contents = fs::read_to_string(config.filename)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"With text:\n&#123;&#125;"</span>, contents);</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们做出了三个明显的修改：</p>
<ol>
<li>将 <code>run</code> 函数的返回类型变为 R<code>esult&lt;(), Box&lt;Error&gt;&gt;</code>。之前这个函数返回 unit 类型 <code>()</code>，现在它仍然保持作为 <code>Ok</code> 时的返回值。<br>
对于错误类型，使用了 trait 对象 <code>Box&lt;dyn Error&gt;</code>（在开头使用了 <code>use</code> 语句将 <code>std::error::Error</code> 引入作用域）。目前只需知道 <code>Box&lt;dyn Error&gt;</code> 意味着函数会返回实现了 <code>Error</code> trait 的类型，不过无需指定具体将会返回的值的类型。这提供了在不同的错误场景可能有不同类型的错误返回值的灵活性。这也就是 <code>dyn</code>，它是 “动态的”（“dynamic”）的缩写。</li>
<li>第二个改变是去掉了 <code>expect</code> 调用并替换为第九章讲到的 <code>?</code>。不同于遇到错误就 <code>panic!</code>，<code>?</code> 会从函数中返回错误值并让调用者来处理它。</li>
<li>第三个修改是现在成功时这个函数会返回一个 <code>Ok</code> 值。因为 <code>run</code> 函数签名中声明成功类型返回值是 <code>()</code>，这意味着需要将 unit 类型值包装进 <code>Ok</code> 值中。<code>Ok(())</code> 一开始看起来有点奇怪，不过这样使用 <code>()</code> 是表明我们调用 <code>run</code> 只是为了它的副作用的惯用方式；它并没有返回什么有意义的值。</li>
</ol>
<h5 id="处理-main-中-run-返回的错误"><a class="header-anchor" href="#处理-main-中-run-返回的错误">¶</a>处理 <code>main</code> 中 <code>run</code> 返回的错误</h5>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Searching for &#123;&#125;"</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"In file &#123;&#125;"</span>, config.filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(e) = run(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Application error: &#123;&#125;"</span>, e);</span><br><span class="line"></span><br><span class="line">        process::exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只关心检测错误，所以并不需要 <code>unwrap_or_else</code> 来返回未封装的值，因为它只会是 <code>()</code>。</p>
<h4 id="将代码拆分到库-crate"><a class="header-anchor" href="#将代码拆分到库-crate">¶</a>将代码拆分到库 crate</h4>
<p>让我们将所有不是 <code>main</code> 函数的代码从 <em>src/main.rs</em> 移动到新文件 <em>src/lib.rs</em> 中：</p>
<ul>
<li><code>run</code> 函数定义</li>
<li>相关的 <code>use</code> 语句</li>
<li><code>Config</code> 的定义</li>
<li><code>Config::new</code> 函数定义</li>
</ul>
<p>现在代码还不能编译：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Config &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(args: &amp;[<span class="built_in">String</span>]) -&gt; <span class="built_in">Result</span>&lt;Config, &amp;<span class="symbol">'static</span> <span class="built_in">str</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(config: Config) -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>minigrep</code> crate 引入 <em>src/main.rs</em> 的作用域中：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> minigrep;</span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(e) = minigrep::run(config) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-6-将错误信息输出到标准错误而不是标准输出"><a class="header-anchor" href="#12-6-将错误信息输出到标准错误而不是标准输出">¶</a>12.6. 将错误信息输出到标准错误而不是标准输出</h3>
<h4 id="将错误打印到标准错误"><a class="header-anchor" href="#将错误打印到标准错误">¶</a>将错误打印到标准错误</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> config = Config::new(&amp;args).unwrap_or_else(|err| &#123;</span><br><span class="line">        eprintln!(<span class="string">"Problem parsing arguments: &#123;&#125;"</span>, err);</span><br><span class="line">        process::exit(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(e) = minigrep::run(config) &#123;</span><br><span class="line">        eprintln!(<span class="string">"Application error: &#123;&#125;"</span>, e);</span><br><span class="line"></span><br><span class="line">        process::exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>println!</code> 改为 <code>eprintln!</code> 之后，让我们再次尝试用同样的方式运行程序，不使用任何参数并通过 <code>&gt;</code> 重定向标准输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo run &gt; output.txt</span><br><span class="line">Problem parsing arguments: not enough arguments</span><br></pre></td></tr></table></figure>
<p>现在我们看到了屏幕上的错误信息，同时 <em>output.txt</em> 里什么也没有，这正是命令行程序所期望的行为。<br>
如果使用不会造成错误的参数再次运行程序，不过仍然将标准输出重定向到一个文件，像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo run to poem.txt &gt; output.txt</span><br></pre></td></tr></table></figure>
<p>我们并不会在终端看到任何输出，同时 <em>output.txt</em> 将会包含其结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Are you nobody, too?</span><br><span class="line">How dreary to be somebody!</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer （第五版）》学习笔记 -- 之二</title>
    <url>/2020/02/18/C++-Primer-%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1>C++ Primer 第五版学习笔记（二）</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="第二章-变量和基本类型"><a class="header-anchor" href="#第二章-变量和基本类型">¶</a>第二章 变量和基本类型</h2>
<p>C++ 语言支持广泛的数据类型。它定义了几种 <strong>基本内置类型</strong>  (如字符、整型、浮点数等)，同时也为程序员提供了自定义数据类型的机制。基于此，<strong>C++ 标准库定义了一些更加复杂的数据类型</strong> ，比如可变长字符串和向量等。本章将主要讲述内置类型，并带领大家初步了解 C++ 语言是如何支持更复杂的数据类型。</p>
<h3 id="2-1-基本内置类型"><a class="header-anchor" href="#2-1-基本内置类型">¶</a>2.1 基本内置类型</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                          +--字符（char, wchar_t, char16_t, char32_t）</span><br><span class="line">                          |</span><br><span class="line">                          +--整型（int, long, long long）</span><br><span class="line">                          |</span><br><span class="line">               +--算术类型 -+-布尔值</span><br><span class="line">               |          |</span><br><span class="line">C++ 基本内置类型 +          +--浮点（float, double, long double）</span><br><span class="line">               |</span><br><span class="line">               +--空类型</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>一个 <code>int</code> 至少和一个 <code>short</code> 一样大</strong>；</li>
<li><strong>一个 <code>long</code> 到少和一个 <code>int</code> 一样大</strong>；</li>
<li><strong>一个 <code>long long</code> 至少和一个 <code>long</code> 一样大</strong>；</li>
</ul>
<blockquote>
<p><strong>C++11</strong></p>
<hr>
<p><code>long long</code> 是 C++11 中新定义。</p>
</blockquote>
<h4 id="2-1-1-算术类型"><a class="header-anchor" href="#2-1-1-算术类型">¶</a>2.1.1 算术类型</h4>
<p>算术类型分为：</p>
<ul>
<li>整型 (integer type，<strong>包括字符和布尔类型在内</strong>)</li>
<li>浮点型</li>
</ul>
<p><strong>内置类型的机器实现</strong>：</p>
<ul>
<li>
<p>计算机以比特序列存储数据，每个比特非 <code>0</code> 即 <code>1</code>。</p>
</li>
<li>
<p>可寻址的最小内存块称为“字节(byte)”，存储的基本单元称为“字(word)”，它通常由几个字节组成。</p>
</li>
<li>
<p>若一机器字节为 8 比特、字为 32 比特，假如某一内存区域如下所示：</p>
  <table style="border: 0">
      <tr>
          <td style="border: 0">736424</td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
          <td>1</td>
          <td>1</td>
          <td>0</td>
          <td>1</td>
          <td>1</td>
      </tr>
      <tr>
          <td style="border: 0">736425</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
          <td>1</td>
          <td>0</td>
          <td>1</td>
          <td>1</td>
      </tr>
      <tr>
          <td style="border: 0">736426</td>
          <td>0</td>
          <td>1</td>
          <td>1</td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
      </tr>
      <tr>
          <td style="border: 0">736427</td>
          <td>0</td>
          <td>1</td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
      </tr>
  </table>
<p>如果位置 736424 的对象类型是 <code>float</code>，并且该机器中 <code>float</code> 以 32 比特存储，那么这个对象内容占满了整个字。<strong>这个 <code>float</code> 的实际值依赖于该机器是如何存储浮点数的</strong>；若此处的对象是 <code>unsigned char</code>，并且该机器使用 ISO-Latin-1 字符集，则该位置处的字节表示一个分号。</p>
</li>
<li>
<p>若一机器字节为 8 比特、字为 32 比特，则通常 <code>float</code> 以 1 个字 (32 比特) 来表示，<code>double</code> 以 2 个字 (64 比特) 来表示， <code>long double</code> 以 3 或4 个字 (96 或 128 比特) 来表示。<strong>一般来说，类型 <code>float</code> 和 <code>double</code> 分别有 7 和 16 个有效位；类型 <code>long double</code> 则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同</strong>。</p>
</li>
</ul>
<h5 id="带符号类型和无符号类型"><a class="header-anchor" href="#带符号类型和无符号类型">¶</a>带符号类型和无符号类型</h5>
<ul>
<li>
<p>类型 <code>int</code>、<code>short</code>、<code>long</code> 和 <code>long long</code> 都是带符号的，通过在这些类型名前添加 <code>unsigned</code> 就可以得到无符号类型。</p>
</li>
<li>
<p>字符型被分为了 <strong>三种</strong>：</p>
<ol>
<li><code>char</code></li>
<li><code>signed char</code></li>
<li><code>unsigned char</code></li>
</ol>
<p><strong>类型 <code>char</code> 实际上会表现为无符号的和有符号的形式中的某一种，具体是哪种由编译器决定。</strong></p>
</li>
<li>
<p>无符号类型中所有比特都用来存储值，例如：8 比特的 <code>unsigned char</code> 可以表示 0 ~ 255 区间内的值。</p>
</li>
<li>
<p>C++ 标准并未规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。<strong>因此，8 比特的 <code>unsigned char</code> 理论上应该可以表示 -127 ~ 127 区间内的值，大多数现代计算机将实际的表示范围定为 -128 ~ 127</strong>。</p>
</li>
</ul>
<blockquote>
<p><strong>建议：如何选择类型</strong></p>
<hr>
<ol>
<li>尽可能地接近硬件。</li>
<li>当明确知晓数值不可能为负时，选用无符号类型。</li>
<li>使用 <code>int</code> 执行整数运算。在实际应用中， <code>short</code> 常常显得太小而 <strong><code>long</code> 一般和 <code>int</code> 有一样的尺寸</strong>。如果你的数值超过了 <code>int</code> 的表示范围，选用 <code>long long</code>。</li>
<li>在算术表达式中不要使用 <code>char</code> 或 <code>bool</code>。<strong>因为 <code>char</code> 在一些机器上是有符号的，而在另一些机器上又是无符号的</strong>。</li>
<li>如果你需要一个不大的整数，那么明确指定它的类型是 <code>signed char</code> 或者 <code>unsigned char</code>。</li>
<li>执行浮点数运算选用 <code>double</code>，<strong>因为 <code>float</code> 通常精度不够而且双精度浮点和单精度浮点的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。</strong></li>
</ol>
</blockquote>
<h5 id="2-1-1-节练习"><a class="header-anchor" href="#2-1-1-节练习">¶</a>2.1.1 节练习</h5>
<ul>
<li>
<p>练习 2.1：类型 <code>int</code>、<code>long</code>、<code>long long</code> 和 <code>short</code> 的区别是什么？无符号类型和带符号类型的区别是什么？ <code>float</code> 和 <code>double</code> 的区别是什么？</p>
<p>解：</p>
<ol>
<li>
<p>类型 <code>int</code>、<code>long</code>、<code>long long</code> 和 <code>short</code> 的区别：</p>
<ul>
<li>一个 <code>int</code> 至少和一个 <code>short</code> 一样大；</li>
<li>一个 <code>long</code> 到少和一个 <code>int</code> 一样大；</li>
<li>一个 <code>long long</code> 至少和一个 <code>long</code> 一样大；</li>
<li><code>long long</code> 是 C++11 中新定义。</li>
</ul>
</li>
<li>
<p>无符号类型和带符号类型的区别：</p>
<ul>
<li>带符号类型可以表示正数、负数或 0。</li>
<li>无符号类型仅能表示大于等于 0 的值。</li>
<li>无符号类型中所有比特都用来存储值。</li>
<li>C++ 标准约定了带符号类型在表示范围内正值和负值的量应该平衡。</li>
</ul>
</li>
<li>
<p><code>float</code> 和 <code>double</code> 的区别：</p>
<p>若一机器字节为 8 比特、字为 32 比特，则通常</p>
<ul>
<li><code>float</code> 以 1 个字 (32 比特) 来表示，一般来说 <code>float</code> 类型有 7 个有效位。</li>
<li><code>double</code> 以 2 个字 (64 比特) 来表示， 一般来说 <code>double</code> 类型有 16 个有效位。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="2-1-2-类型转换"><a class="header-anchor" href="#2-1-2-类型转换">¶</a>2.1.2 类型转换</h4>
<p>当我们把一种算术类型的值赋给另外一种类型时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> b = <span class="number">42</span>;             <span class="comment">// b 为真</span></span><br><span class="line"><span class="keyword">int</span> i = b;               <span class="comment">// i 的值为 1</span></span><br><span class="line">i = <span class="number">3.14</span>;                <span class="comment">// i 的值为 3</span></span><br><span class="line"><span class="keyword">double</span> pi = i;           <span class="comment">// pi 的值为 3.0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">-1</span>;    <span class="comment">// 假设 char 占 8 比特，c 的值为 255</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c2 = <span class="number">256</span>;    <span class="comment">// 假设 char 占 8 比特，c 的值是未定义的</span></span><br></pre></td></tr></table></figure>
<p>类型所能表示的值的范围决定了转换的过程：</p>
<ul>
<li>
<p>当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为 <code>0</code> 则结果为 <code>false</code>，否则结果为 <code>true</code>。</p>
</li>
<li>
<p>当我们把一个布尔值赋给非布尔类型时，初始值为 <code>false</code> 则结果为 <code>0</code>，初始值为 <code>true</code> 则结果为 <code>1</code>。</p>
</li>
<li>
<p>当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。</p>
</li>
<li>
<p>当我们把一个整数值赋给浮点类型时，小数部分记为 <code>0</code>。如果该整数所占空间超过了浮点类型的容量，精确度 <strong>可能</strong> 有损失。</p>
</li>
<li>
<p><strong>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示 <span span style="border-bottom:3px double black">数值总数</span> 取模后的余数。</strong></p>
<p>例如：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假如 unsigned char 可以表示 0 ~ 255 区间的值，则它能表示的数值总数为 256</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> val = <span class="number">257</span>; <span class="comment">// 赋给 unsigned char 类型一个大于 255 的值。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">int</span>(val) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">val = <span class="number">-1</span>; <span class="comment">//赋给 unsigned char 类型一个小于 0 的值。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">int</span>(val) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">255</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>笔记</strong>：</p>
<hr>
<p>取模运算遵循商取最趋近 -∞ 的整数原则（取余运算为商取最趋近于 0 的整数原则）。所以 -1 % 256 商 -0.00390625，故商取 -1。而 -1 x 256 + 255 = -1，所以模为 255。</p>
</blockquote>
</li>
<li>
<p><strong>当在程序的某处使用了一种算术类型的值而其实所需的是另一种类型的值时，编译器同样会执行上述的类型转换。</strong> 例如，如果我们使用了一个非布尔值作为条件，那么它会被自动地转换成布尔值，这一做法和把非布尔值赋给布尔变量时的操作完全一样。</p>
<p><strong>所以，如果我们把一个布尔值用在算术表达式里，则它的聚会非 <code>0</code> 即 <code>1</code>，所以一般不宜在算术表达式里使用布尔值。</strong></p>
</li>
</ul>
<h5 id="2-1-2-节练习"><a class="header-anchor" href="#2-1-2-节练习">¶</a>2.1.2 节练习</h5>
<ul>
<li>
<p>练习 2.3：读程序写结果。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u = <span class="number">10</span>, u2 = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u2 - u &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u - u2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>, i2 = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i2 - i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i - i2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i - u &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u - i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>解：</p>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32</span><br><span class="line">4294967264</span><br><span class="line">32</span><br><span class="line">-32</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 2.4：编写程序检查你的估计是否正确，如果不正确，请仔细研读本节直到弄明白问题所在。</p>
<p>解：</p>
<p>见练习 2.4。</p>
</li>
</ul>
<h4 id="2-1-3-字面值常量"><a class="header-anchor" href="#2-1-3-字面值常量">¶</a>2.1.3 字面值常量</h4>
<h5 id="整型和浮点型字面值"><a class="header-anchor" href="#整型和浮点型字面值">¶</a>整型和浮点型字面值</h5>
<ul>
<li>默认情况下，<strong>十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的</strong>。</li>
<li>十进制字面值的类型是 <code>int</code>、<code>long</code> 和 <code>long long</code> 中尺寸最小的那个，当然前提是这种类型要能容纳下当前值。八进制和十六进制字面值的类型是能容纳其数值的 <code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>long long</code> 和 <code>unsigned long long</code> 中的尺寸最小者。</li>
<li><strong>类型 <code>short</code> 没有对应的字面值。</strong></li>
<li><span style="border-bottom: 3px black double">严格来说</span>，<span style="border-bottom: 3px black double">十进制</span> 字面值 <span style="border-bottom: 3px black double">不会</span> 是负数。例如 -42 的负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。</li>
<li>默认的，浮点型字面值是一个 <code>double</code>。</li>
</ul>
<h5 id="字符和字符串字面值"><a class="header-anchor" href="#字符和字符串字面值">¶</a>字符和字符串字面值</h5>
<ul>
<li>
<p>由单引号括起来的一个字符称为 <code>char</code> 型字面值，双引号括起来的零个或多个字符则构成字符串字面值。</p>
</li>
<li>
<p>字符串字面值 的类型实际上是由常量字符构成的 <strong>数组</strong> (array)。</p>
</li>
<li>
<p>编译器在每个字符串 (笔记：字面值？) 的结尾处添加一个空字符 (<code>\0</code>)。<strong>因此，字符串字面值的实际长度要比它的内容多 1。</strong></p>
</li>
<li>
<p>如果两个字符串字面值位置紧邻且仅由 <strong>空格</strong>、<strong>缩进</strong> 和 <strong>换行符</strong> 分隔，则它们实际上是一个整体。例如：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a really, really long string literal "</span></span><br><span class="line">             <span class="string">"that spans two lines"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="转义序列"><a class="header-anchor" href="#转义序列">¶</a>转义序列</h5>
<ul>
<li>
<p>C++ 语言规定的转义序列包括：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">换行符</td>
<td style="text-align:center"><code>\n</code></td>
</tr>
<tr>
<td style="text-align:center">纵向制表符</td>
<td style="text-align:center"><code>\v</code></td>
</tr>
<tr>
<td style="text-align:center">反斜线</td>
<td style="text-align:center"><code>\\</code></td>
</tr>
<tr>
<td style="text-align:center">回车符</td>
<td style="text-align:center"><code>\r</code></td>
</tr>
<tr>
<td style="text-align:center">横向制表符</td>
<td style="text-align:center"><code>\t</code></td>
</tr>
<tr>
<td style="text-align:center">退格符</td>
<td style="text-align:center"><code>\b</code></td>
</tr>
<tr>
<td style="text-align:center">问号</td>
<td style="text-align:center"><code>\?</code></td>
</tr>
<tr>
<td style="text-align:center">进纸符</td>
<td style="text-align:center"><code>\f</code></td>
</tr>
<tr>
<td style="text-align:center">报警 (响铃)符</td>
<td style="text-align:center"><code>\a</code></td>
</tr>
<tr>
<td style="text-align:center">双引号</td>
<td style="text-align:center"><code>\&quot;</code></td>
</tr>
<tr>
<td style="text-align:center">单引号</td>
<td style="text-align:center"><code>\'</code></td>
</tr>
</tbody>
</table>
<p>上述转义序列被当作 <strong>一个</strong> 字符使用。</p>
</li>
<li>
<p>我们也可以泛化转义序列，<strong>其形式是 <code>\x</code> 后紧跟 1 个或多个十六进制数字，或者 <code>\</code> 后紧跟 1 个、2 个或 3 个八进制数字，其中数字部分表示的是字符对应的数值</strong>。</p>
<p>例如，假设使用的是 Latin-1 字符集：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">响铃</td>
<td style="text-align:center"><code>\7</code></td>
</tr>
<tr>
<td style="text-align:center">空字符</td>
<td style="text-align:center"><code>\0</code></td>
</tr>
<tr>
<td style="text-align:center">换行符</td>
<td style="text-align:center"><code>\12</code></td>
</tr>
<tr>
<td style="text-align:center">字符 M</td>
<td style="text-align:center"><code>\115</code></td>
</tr>
<tr>
<td style="text-align:center">空格</td>
<td style="text-align:center"><code>\40</code></td>
</tr>
<tr>
<td style="text-align:center">字符 M</td>
<td style="text-align:center"><code>\x4d</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<ul>
<li>
<p>如果 <code>\</code> 后面跟着的八进制数字超过 3 个，则只有前 3 个数字与 <code>\</code> 构成转义序列。</p>
<p>例如：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\1234"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// "\123" 为字符 “S”</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S4</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>相反，<code>\x</code> 要用到后面跟着的所有数字。</p>
<p>例如：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\x1234"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>编译输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用于 x64 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.24.28316 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">prog1.cc</span><br><span class="line">prog1.cc(4): error C2022: “4660”: 对字符来说太大</span><br></pre></td></tr></table></figure>
<p>因为大多数机器的 <code>char</code> 型数据占 8 位，所以上面这个例子可能会报错。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="指定字面值的类型"><a class="header-anchor" href="#指定字面值的类型">¶</a>指定字面值的类型</h5>
<ul>
<li>
<p>字符和字符串字面值：</p>
<table>
<thead>
<tr>
<th style="text-align:center">前缀</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>u</code></td>
<td style="text-align:center">Unicode 16 字符</td>
<td style="text-align:center"><code>char16_t</code></td>
</tr>
<tr>
<td style="text-align:center"><code>U</code></td>
<td style="text-align:center">Unicode 32 字符</td>
<td style="text-align:center"><code>char32_t</code></td>
</tr>
<tr>
<td style="text-align:center"><code>L</code></td>
<td style="text-align:center">宽字符</td>
<td style="text-align:center"><code>wchar_t</code></td>
</tr>
<tr>
<td style="text-align:center"><code>u8</code></td>
<td style="text-align:center">UTF-8 (仅用于字符串字面常量)</td>
<td style="text-align:center"><code>char</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>整型字面值：</p>
<table>
<thead>
<tr>
<th style="text-align:center">后缀</th>
<th style="text-align:center">最小匹配类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>u</code> 或 <code>U</code></td>
<td style="text-align:center"><code>unsigned</code></td>
</tr>
<tr>
<td style="text-align:center"><code>l</code> 或 <code>L</code></td>
<td style="text-align:center"><code>long</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ll</code> 或 <code>LL</code></td>
<td style="text-align:center"><code>long long</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>浮点型字面值：</p>
<table>
<thead>
<tr>
<th style="text-align:center">后缀</th>
<th style="text-align:center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>f</code> 或 <code>F</code></td>
<td style="text-align:center"><code>float</code></td>
</tr>
<tr>
<td style="text-align:center"><code>l</code> 或 <code>L</code></td>
<td style="text-align:center"><code>long double</code></td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">L'a'</span>     <span class="comment">// 宽字符型字面值，类型是 wchar_t</span></span><br><span class="line"><span class="string">u8"hi!"</span>  <span class="comment">// utf-8 字符串字面值 (utf-8 用 8 位编码一个 Unicode 字符)</span></span><br><span class="line"><span class="number">42U</span>LL    <span class="comment">// 无符号整型字面值，类型是 unsigned long long</span></span><br><span class="line"><span class="number">1E-3</span>F    <span class="comment">// 单精度浮点型字面值，类型是 float</span></span><br><span class="line"><span class="number">3.14159L</span> <span class="comment">// 扩展精度浮点型字面值，类型是 long double</span></span><br></pre></td></tr></table></figure>
<h5 id="布尔字面值和指针字面值"><a class="header-anchor" href="#布尔字面值和指针字面值">¶</a>布尔字面值和指针字面值</h5>
<p><code>true</code> 和 <code>false</code>。</p>
<h5 id="指针字面值"><a class="header-anchor" href="#指针字面值">¶</a>指针字面值</h5>
<p><code>nullptr</code></p>
<h5 id="2-1-3-节练习"><a class="header-anchor" href="#2-1-3-节练习">¶</a>2.1.3 节练习</h5>
<ul>
<li>
<p>练习 2.5：指出下述字面值的数据类型并说明每一组内几种字面值的区别：</p>
<p>(a) <code>'a'</code>，<code>L'a'</code>，<code>&quot;a&quot;</code>，<code>L&quot;a&quot;</code></p>
<p>(b) <code>10</code>，<code>10u</code>，<code>10L</code>，<code>10uL</code>，<code>012</code>，<code>0xC</code></p>
<p>(c) <code>3.14</code>，<code>3.14f</code>，<code>3.14L</code></p>
<p>(d) <code>10</code>，<code>10u</code>，<code>10.</code>，<code>10e-2</code></p>
<p>解：</p>
<p>(a)</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">'a'</span>  <span class="comment">// 字符字面量，类型 char</span></span><br><span class="line"><span class="string">L'a'</span> <span class="comment">// 字符字面量，类型 wchar_t</span></span><br><span class="line"><span class="string">"a"</span>  <span class="comment">// char 类型组成的字符串字面量</span></span><br><span class="line"><span class="string">L"a"</span> <span class="comment">// wchar_t 类型组成的字符串字面量</span></span><br></pre></td></tr></table></figure>
<p>(b)</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>   <span class="comment">// 十进制带符号整型字面量，类型 int</span></span><br><span class="line"><span class="number">10u</span>  <span class="comment">// 十进制无符号整型字面量，类型 usigned int</span></span><br><span class="line"><span class="number">10L</span>  <span class="comment">// 十进制带符号整型字面量，类型 long</span></span><br><span class="line"><span class="number">10u</span>L <span class="comment">// 十进制无符号整型字面量，类型 unsigned long</span></span><br><span class="line"><span class="number">012</span>  <span class="comment">// 八进制带符号整型字面量，类型 int</span></span><br><span class="line"><span class="number">0xC</span>  <span class="comment">// 十六进制带符号整型字面量，类型 int</span></span><br></pre></td></tr></table></figure>
<p>(c)</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14</span>  <span class="comment">// double</span></span><br><span class="line"><span class="number">3.14f</span> <span class="comment">// float</span></span><br><span class="line"><span class="number">3.14</span>  <span class="comment">// long double</span></span><br></pre></td></tr></table></figure>
<p>(d)</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>    <span class="comment">// 十进制带符号整型字面量，类型 int</span></span><br><span class="line"><span class="number">10u</span>   <span class="comment">// 十进制无符号整型字面量，类型 usigned int</span></span><br><span class="line"><span class="number">10.</span>   <span class="comment">// double</span></span><br><span class="line"><span class="number">10e-2</span> <span class="comment">// double</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 2.6：下面两组定义是否有区别，如果有，请叙述之：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> month = <span class="number">9</span>, day = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> month = <span class="number">09</span>, day = <span class="number">07</span>;</span><br></pre></td></tr></table></figure>
<p>解：有区别。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> month = <span class="number">9</span>, day = <span class="number">7</span>; <span class="comment">// 9 和 7 都是十进制带符号整型字面量。</span></span><br><span class="line"><span class="keyword">int</span> month = <span class="number">09</span> <span class="comment">/* 无法通过编译。因为 09 表面上是八进制带符号整型字面量，但是 9 对于八进制是非法值 */</span>, day = <span class="number">07</span> <span class="comment">/* 07 是八进制带符号整型字面量，但与前面定义是 day 值相等。 */</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 2.7：下述字面值表示何种含义？它们各自的数据类型是什么？</p>
<p>(a) <code>&quot;Who goes with F\145rgus?\012&quot;</code></p>
<p>(b) <code>3.13e1L</code></p>
<p>(c) <code>1024f</code></p>
<p>(d) <code>3.14L</code></p>
<p>解：</p>
<p>(a) 相当于 <code>&quot;Who goes with Fergus?\n&quot;</code>，是 <code>char</code> 字符组成的字符串字面值。</p>
<p>(b) 值为 31.4 的 <code>long double</code> 型字面值。</p>
<p>(c) 值为 1024.0 的 <code>float</code> 型字面值。</p>
<p>(d) 值为 3.14 的 <code>long double</code> 型字面值。</p>
</li>
<li>
<p>练习 2.8：请利用转义序列编写一段程序，要求先输出 2M，然后转到新一行。修改程序使其先输出 2，然后输出制表符，再输出 M，最后转到新一行。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2\115\r"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2M</span><br></pre></td></tr></table></figure>
<hr>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2\t\115\r"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2       M</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-变量"><a class="header-anchor" href="#2-2-变量">¶</a>2.2 变量</h3>
<p>对 C++ 程序员来说，“变量 (variable)”和“对象 (object)”一般可以互换使用。</p>
<h4 id="2-2-1-变量定义"><a class="header-anchor" href="#2-2-1-变量定义">¶</a>2.2.1 变量定义</h4>
<p>本书遵循 <strong>大多数人</strong> 的习惯用法，即认为 <strong>对象是具有某种数据类型的内存空间</strong>。</p>
<h5 id="初始值"><a class="header-anchor" href="#初始值">¶</a>初始值</h5>
<p>当对象在创建时获得了一个特定的值，我们说这个对象被初始化了(initialized)。</p>
<p>在同一条定义语句中，可以用先定义的变量值去初始化后定义的其它变量。</p>
<p><strong>在 C++ 语言中，初始化和赋值是两个完全不同的操作</strong>。然而在很多编程语言中二者的区别几乎可以忽略不计。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>初始化不是赋值， 初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p>
</blockquote>
<h5 id="列表初始化"><a class="header-anchor" href="#列表初始化">¶</a>列表初始化</h5>
<p>C++ 语言定义了初始化的好几种不同形式。例如，要想定义一个名为 <code>units_sold</code> 的 <code>int</code> 变量并初始化 <code>0</code>，以下的 4 条语句都可以实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>C++11</strong></p>
<hr>
<p>用 <strong>花括号</strong> 来初始化变量在 C++11 标准中得到了全面应用，而在此之前，这种初始化形式仅在某些受限的场合下才能使用。这种初始化的形式被称为 <strong>列表初始化</strong> (list initialization)。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>当用于 <strong>内置类型</strong> 的变量时，这种初始化形式有一个重要特点：<strong>如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错</strong>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;, b = &#123;ld&#125;;  <span class="comment">// 错误：转换未执行，因为存在丢失信息的危险。其中至少 ld 的小数部分会丢失掉，而且 int 也可能能存不下 ld 的整数部分</span></span><br><span class="line">int c(ld), d = ld;    // 正确：转换执行，且确实丢失了部分值</span><br></pre></td></tr></table></figure>
<p>编译输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用于 x64 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.24.28316 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">prog1.cc</span><br><span class="line">.\prog1.cc(5): error C2397: 从“long double”转换到“int”需要收缩转换</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="默认初始化"><a class="header-anchor" href="#默认初始化">¶</a>默认初始化</h5>
<p>如果定义变量没有指定初始值，则变量被 <strong>默认初始化</strong> (default initialized)，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，<strong>同时定义变量的位置也会对此有影响</strong>：</p>
<ul>
<li>如果是 <strong>内置类型</strong> 的变量未被显式初始化，<strong>它的值由定义的位置决定</strong>。定义于任何函数体之外的变量被初始化为 <code>0</code>。</li>
<li>定义在函数体内部的 <strong>内置类型</strong> 变量将 <strong>不被初始化</strong> (uninitialized)。一个未被初始化的内置类型变量的值是 <strong>未定义的</strong>，如果试图拷贝或以其它形式访问此类值将引发错误。(如 6.1.1 节所示，P185)</li>
<li>每个 <strong>类</strong> 各自决定其初始化对象的方式。而且，<strong>是否允许不经初始化就定义对象也由类自己决定</strong>。<strong>如果类允许这种行为，它将自己决定对象的初始值到底是什么</strong>。</li>
</ul>
<h5 id="2-2-1-节练习"><a class="header-anchor" href="#2-2-1-节练习">¶</a>2.2.1 节练习</h5>
<ul>
<li>
<p>练习 2.9：解释下列定义的含义。对于非法的定义，请说明错误在何处并将其改正。</p>
<p>(a) <code>std::cin &gt;&gt; int input_value;</code></p>
<p>(b) <code>int i = { 3.14 };</code></p>
<p>(c) <code>double salary = wage = 9999.99;</code></p>
<p>(d) <code>int i = 3.14;</code></p>
<p>解：</p>
<p>(a) 该语句试图定义一个整型变量并从标准输入获取用户输入存入其中。此处的变量定义是非法的，因为</p>
<ul>
<li>根据 1.2 节 (P7)，输入运算符 (<code>&gt;&gt;</code>) 接受<span style="border-bottom: 3px black double">一个</span> <strong>对象</strong> 作为其右侧的运算对象。而题干语句输入运算符右侧是一个 <strong>类</strong> 和一个变量，造成语法错误。</li>
<li>且根据 2.2.1 节 (P38)，变量定义的基本形式是：<span style="border-bottom: 3px black double">首先</span> 是类型说明符，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。该语句并不是以类型说明符开始，造成语法错误。</li>
</ul>
<p>编译输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用于 x64 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.24.28316 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">prog1.cc</span><br><span class="line">.\prog1.cc(4): error C2062: 意外的类型“int”</span><br></pre></td></tr></table></figure>
<p>改正：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> input_value;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; input_value;</span><br></pre></td></tr></table></figure>
<p>(b) 该语句试图以列表初始化的方式用一个 <code>double</code> 类型的字面值初始化一个 <code>int</code> 类型变量。此语句是非法的，因为根据 2.2.1 节 (P39)：如果我们使用列表初始化且初始值存在丢失的风险，则编译器将报错。在该初始化语句中若赋值成功，则 3.14 的小数部分将丢失，所以编译器将报错。</p>
<p>编译输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用于 x64 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.24.28316 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">prog1.cc</span><br><span class="line">.\prog1.cc(4): error C2397: 从“double”转换到“int”需要收缩转换</span><br></pre></td></tr></table></figure>
<p>改正：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> i = &#123; <span class="number">3.14</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>(c) 该语句试图同时定义两个 <code>double</code> 型变量  <code>salary</code> 和 <code>wage</code>，并将它们同时初始化为 <code>9999.99</code>。此语句是非法的，因为 <code>salary</code> 在 <code>wage</code> 之前被定义，根据 2.2.1 节 (P39)：在同一条定义语句中，可以用先定义的变量值去初始化后定义的其它变量。在此语句中 <code>salary</code> 定义时 <code>wage</code> 尚未定义，所以无法通过编译。</p>
<p>编译输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用于 x64 的 Microsoft (R) C&#x2F;C++ 优化编译器 19.24.28316 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">prog1.cc</span><br><span class="line">.\prog1.cc(4): error C2065: “wage”: 未声明的标识符</span><br></pre></td></tr></table></figure>
<p>改正：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double wage &#x3D; 9999.99, salary &#x3D; wage;</span><br></pre></td></tr></table></figure>
<p>(d) 该语句试图用一个 <code>double</code> 类型的字面值初始化一个 <code>int</code> 类型变量。语句合法，但会丢失 3.14 的小数部分。</p>
</li>
</ul>
<h4 id="2-2-2-变量声明和定义的关系"><a class="header-anchor" href="#2-2-2-变量声明和定义的关系">¶</a>2.2.2 变量声明和定义的关系</h4>
<p>为了允许把程序拆分成多个逻辑部分来编写，C++ 语言支持 <strong>分离式编译</strong> (separate compilation) 机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p>
<p>为了支持分离式编译，C++ 语言将声明和定义区分开来。</p>
<ul>
<li><strong>声明</strong> (declaration) 使得名字为程序所知，<strong>一个文件如果想使用别处定义的名字则必须包含对那个名字的声明</strong>。如果想声明一个变量而非定义它，就在变量名前添加关键字 <code>extern</code>， <span style="border-bottom: 3px black double">而且不要显式地初始化变量</span>。</li>
<li><strong>定义</strong> (definition) 负责创建与名字相关联的实体。</li>
<li>声明和定义的区别：
<ul>
<li>变量声明 <strong>规定了变量的类型和名字</strong>；</li>
<li>变量的定义 <span style="border-bottom: 3px black double">除了规定变量的类型和名字外</span> 还 <strong>申请存储空间</strong>，也 <strong>可能</strong> 会为变量赋一个初始值；</li>
<li><strong>变量能且只能定义一次，但是可以被多次声明</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<ul>
<li>任何包含了显式初始化的声明即成为定义。这么做也就抵消了 <code>extern</code> 的作用。</li>
<li>在函数体内部，如果试图初始化一个由 <code>extern</code> 关键字标记的变量，将引发错误。</li>
</ul>
</blockquote>
<h5 id="2-2-2-节练习"><a class="header-anchor" href="#2-2-2-节练习">¶</a>2.2.2 节练习</h5>
<ul>
<li>
<p>练习 2.11：指出下面的语句是声明还是定义：</p>
<p>(a) <code>extern int ix = 1024;</code></p>
<p>(b) <code>int iy;</code></p>
<p>(c) <code>extern int iz;</code></p>
<p>解：</p>
<p>(a) 定义。</p>
<p>(b) 定义。</p>
<p>(c) 声明。</p>
</li>
</ul>
<h4 id="2-2-3-标识符"><a class="header-anchor" href="#2-2-3-标识符">¶</a>2.2.3 标识符</h4>
<p>C++ 的标识符 (identifier) 由字母、数字和下划线组成，其中 <strong>必须以字母或下划线开头</strong>。</p>
<p>用户自定义的标识符中：</p>
<ul>
<li><strong>不能连续出现两个下划线</strong>。</li>
<li><strong>不能以下划线紧连大写字母开头</strong>。</li>
<li><strong>定义在函数体外的标识符不能以下划线开头</strong>。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>违反上述约定并不能导致编译错误，但上述标识符约定是为编译器预留，用户自定义可能会与编译器预定义标识符冲突。</p>
</blockquote>
<h5 id="变量命名规范"><a class="header-anchor" href="#变量命名规范">¶</a>变量命名规范</h5>
<p>下面的这些规范能有效提高程序的可读性：</p>
<ul>
<li>标识符要能体现实际含义。</li>
<li>变量名一般用小写字母，如 <code>index</code>，不要使用 <code>Index</code> 或 <code>INDEX</code>。</li>
<li>用户自定义的类名一般以大写字母开头，如 <code>Sales_item</code>。</li>
<li>如果标识符由多个单词组成，则单词间应有明显区别，如 <code>student_loan</code> 或 <code>studnetLoan</code>，不要使用 <code>studentloan</code>。</li>
</ul>
<h5 id="2-2-3-节练习"><a class="header-anchor" href="#2-2-3-节练习">¶</a>2.2.3 节练习</h5>
<ul>
<li>
<p>练习 2.12：请指出下面的名字中哪些是非法的？</p>
<p>(a) <code>int double = 3.14</code>;</p>
<p>(b) <code>int _;</code></p>
<p>(c) <code>int catch-22;</code></p>
<p>(d) <code>int 1_or_2 = 1</code>;</p>
<p>(e) <code>double Double = 3.14;</code></p>
<p>解：</p>
<p>(a) 不合法，用户自定义标识符 <code>double</code> 与关键字 <code>double</code> 冲突。</p>
<p>(b) 合法，但若在函数体外定义，则可能存在隐患。</p>
<p>(c) 不合法，标识符只能由字母、数字和下划线组成。</p>
<p>(d) 不合法，标识符只能由字母或下划线开头。</p>
<p>(e) 合法。</p>
</li>
</ul>
<h4 id="2-2-4-名字的作用域"><a class="header-anchor" href="#2-2-4-名字的作用域">¶</a>2.2.4 名字的作用域</h4>
<p>C++ 语言中大多数作用域都以花括号分隔。</p>
<p>名字 <code>main</code> 定义于所有花括号之外，它和其它大多数定义在函数体之外的名字一样拥有 <strong>全局作用域</strong> (global scope)。</p>
<blockquote>
<p><strong>建议</strong>：当你第一次使用变量时再定义它</p>
<hr>
<p>一般来说，在对象第一次使用的地方附近定义它是一种好的选择，因为这样做有助于更容易地找到变量的定义。更重要的是，<strong>当变量的定义与它第一次被使用的地方很近时，我们也会赋给它一个比较合理的初始值</strong>。</p>
</blockquote>
<h5 id="嵌套的作用域"><a class="header-anchor" href="#嵌套的作用域">¶</a>嵌套的作用域</h5>
<p>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时允许在内层作用域中重新定义外层作用域已有的名字：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> reused = <span class="number">42</span>; <span class="comment">// reused 拥有全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> unique = <span class="number">0</span>; <span class="comment">// unique 拥有块作用域</span></span><br><span class="line">    <span class="comment">// 输出 #1：使用全局变量 reused；输出 42 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; reused &lt;&lt; <span class="string">""</span> &lt;&lt; unique &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> reused = <span class="number">0</span>; <span class="comment">// 新建局部变量 reused，覆盖了全局变量 reused</span></span><br><span class="line">    <span class="comment">// 输出 #2：使用局部变量 reused；输出 0 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; reused &lt;&lt; <span class="string">""</span> &lt;&lt; unique &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出 #3：显式地访问全局变量 reused；输出 42 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::reused &lt;&lt; <span class="string">""</span> &lt;&lt; unique &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。</p>
</blockquote>
<h5 id="2-2-4-节练习"><a class="header-anchor" href="#2-2-4-节练习">¶</a>2.2.4 节练习</h5>
<ul>
<li>
<p>练习 2.13：下面程序中 <code>j</code> 的值是多少？</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解：<code>j</code> 的值是 <code>100</code>。因为局部变量 <code>i</code> 的值覆盖了全局同名变量 <code>i</code> 的值。</p>
</li>
<li>
<p>练习 2.14：下面的程序合法吗？如果合法，它将输出什么？</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    sum += i;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>解：</p>
<p>合法。</p>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100 45</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-3-复合类型"><a class="header-anchor" href="#2-3-复合类型">¶</a>2.3 复合类型</h3>
<p><strong>复合类型</strong> (compound type) 是指基于其它类型定义的类型。</p>
<p>本章只涉及两种复合类型：</p>
<ul>
<li>引用</li>
<li>指针</li>
</ul>
<h4 id="2-3-1-引用"><a class="header-anchor" href="#2-3-1-引用">¶</a>2.3.1 引用</h4>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>C++11 中新增了一种引用：“右值引用 (rvalue reference) (第 13.6.1 节，P471)”，这种引用主要用于内置类。<strong>严格来说，当我们使用术语“引用 (reference)”时，指的其实是“左值引用 (lvalue reference)”</strong>。</p>
</blockquote>
<ul>
<li>引用类型引用 (refers to) 另外一种类型。</li>
<li><strong>引用必须初始化</strong>。</li>
<li><strong>引用必须用另一个对象初始化</strong>。</li>
<li>引用的类型要与之绑定的对象严格匹配。（除 2.4.1 节，P55 和 15.2.3 节，P534 两种例外情况外。）</li>
</ul>
<blockquote>
<p><strong>原理</strong>：</p>
<hr>
<p>定义引用时，程序把引用它的初始值 <strong>绑定</strong> (bind) 在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival;   <span class="comment">// refVal 指向 ival (是 ival 的另一个名字)</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2;         <span class="comment">// 报错：引用必须被初始化</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3 = <span class="number">1024</span>;  <span class="comment">// 报错：引用必须用另一个对象初始化</span></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal4 = dval;  <span class="comment">// 错误：此处引用类型的初始值必须是 int 对象</span></span><br></pre></td></tr></table></figure>
<h5 id="引用即别名"><a class="header-anchor" href="#引用即别名">¶</a>引用即别名</h5>
<ul>
<li>
<p>获取引用的值，实际上是获取了与引用绑定的对象的值。所以，**以引用作为初始值，实际上是以与引用绑定的对象作为初始值。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确：refVal5 绑定到了那个与 refVal 绑定的对象上，这里就是绑定到 ival 上</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal5 = refVal;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>引用本身不是一个对象，所以不能 <strong>直接</strong> 定义引用的引用。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;refVal = ival;</span><br><span class="line">    <span class="keyword">int</span> &amp;(&amp;refVal2) = refVal; <span class="comment">// 错误：不能直接定义引用的引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是可以间接定义 (转自<a href="https://www.zhihu.com/question/28023545" target="_blank" rel="noopener">知乎</a>) ：</p>
<ol>
<li>
<p>方法一，使用类型别名：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> intRef = <span class="keyword">int</span> &amp;; <span class="comment">// 用 typedef 亦可</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">intRef &amp; rrefa = a;   <span class="comment">// rrefa 是引用的引用</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法二，使用模板：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T &amp;&amp;t)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">func(a);</span><br><span class="line"><span class="comment">/***************** 注意 *****************/</span></span><br><span class="line"><span class="comment">/* 如果func是普通函数而非函数模板，则这段代码会报错 */</span></span><br><span class="line"><span class="comment">/* 因为左值不能绑定到右值引用上 */</span></span><br><span class="line"><span class="comment">/* void func(int &amp;&amp; t)&#123;&#125; －－－func(a) --- ERROR!!! */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数模板是个特例，此处会触发引用折叠 */</span></span><br></pre></td></tr></table></figure>
<p>引用折叠规则：<br>
<code>X&amp; &amp;</code> (引用的引用)、<code>X&amp; &amp;&amp;</code> (右值引用的引用)、<code>X&amp;&amp; &amp;</code> (引用的右值引用) 均折叠为 <code>X &amp;</code>。<br>
<code>X&amp;&amp; &amp;&amp;</code> (右值引用的右值引用) 折叠为 <code>X &amp;&amp;</code>。</p>
<p>上面的类型别名和函数模板均触发了引用折叠。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p><strong>引用折叠的前提必须是类型别名或者模板参数。标准禁止直接定义引用的引用。</strong></p>
</blockquote>
<p>为什么需要引用折叠：<br>
引用折叠是 <code>std::move</code>、<code>std::forward</code> 等的工作基础。</p>
</li>
</ol>
</li>
</ul>
<h5 id="引用的定义"><a class="header-anchor" href="#引用的定义">¶</a>引用的定义</h5>
<p>略，见 P46。</p>
<h5 id="2-3-1-节练习"><a class="header-anchor" href="#2-3-1-节练习">¶</a>2.3.1 节练习</h5>
<ul>
<li>
<p>练习 2.15：下面哪个定义是不合法的？为什么？</p>
<p>(a) <code>int ival = 1.01</code>;</p>
<p>(b) <code>int &amp;rval1 = 1.01;</code></p>
<p>(c) <code>int &amp;rval2 = ival;</code></p>
<p>(d) <code>int &amp;rval3;</code></p>
<p>解：</p>
<p>(a) 合法。但会丢失 <code>1.01</code> 的小数部分。</p>
<p>(b) 不合法。根据第 2.3.1 节 (P46)：引用的对象必须是一个对象。</p>
<p>(c) 合法。</p>
<p>(d) 不合法。根据第 2.3.1 节 (P45)：引用必须被初始化。</p>
</li>
<li>
<p>练习 2.16：考查下面的所有赋值然后回答：哪些赋值是不合法的？为什么？哪些赋值的合法的？它们执行了什么样的操作？</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;r1 = i;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">0</span>, &amp;r2 = d;</span><br></pre></td></tr></table></figure>
<p>(a) <code>r2 = 3.14159;</code></p>
<p>(b) <code>r2 = r1;</code></p>
<p>(c) <code>i = r2;</code></p>
<p>(d) <code>r1 = d;</code></p>
<p>解：</p>
<p>(a) 合法。此赋值语句将与引用 <code>r2</code> 绑定的对象 <code>d</code> 赋予字面值 <code>3.14159</code>。</p>
<p>(b) 合法。此赋值语句将与引用 <code>r2</code> 绑定的对象 <code>d</code> 赋予与引用 <code>r1</code> 绑定的对象 <code>i</code> 的值。赋值过程中进行了类型转换。</p>
<p>(c) 合法。此赋值语句将对象 <code>i</code> 赋予与引用 <code>r2</code> 绑定的对象 <code>d</code> 的值。但丢失了 <code>3.14159</code> 的小数部分。</p>
<p>(d) 不合法。根据第 2.3.1 节 (P46)：除了 2.4.1 节 (P55) 和第 15.2.3 节 (P534)  介绍的两种例外情况，其它所有引用的类型都要和与之绑定的对象严格匹配。</p>
</li>
<li>
<p>练习 2.17：执行下面的代码段将输出什么结果？</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, &amp;ri = i;</span><br><span class="line">i = <span class="number">5</span>; ri = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; ri &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>解：</p>
<p>输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 10</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-3-2-指针"><a class="header-anchor" href="#2-3-2-指针">¶</a>2.3.2 指针</h4>
<p>指针与引用的区别：</p>
<ul>
<li><strong>指针本身就是一个对象</strong>，允许对指针的赋值和拷贝。</li>
<li>指针无须在定义时赋初值。和其它内置类型一样，<strong><span style="border-bottom: 3px black double">在块作用域内</span> 定义的指针如果没有被初始化，也将拥有一个不确定的值</strong>。</li>
</ul>
<p>定义指针类型的方法将 <strong>声明符</strong> 写成 <code>*d</code> 的形式，<strong>其中 <code>d</code> 是变量名</strong>。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号 <code>*</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip1, *ip2;  <span class="comment">// ip1 和 ip2 都是指向 int 型对象的指针</span></span><br><span class="line"><span class="keyword">double</span> dp, *dp2; <span class="comment">// dp 是 double 型对象，dp2 是指向 double 型对象的指针</span></span><br></pre></td></tr></table></figure>
<h5 id="获取对象的地址"><a class="header-anchor" href="#获取对象的地址">¶</a>获取对象的地址</h5>
<p>除了第 2.4.2 节 (P56) 和第 15.2.3 节 (P534) 介绍的两种例外情况，其它所有指针的类型都要和它所指向的对象严格匹配：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line"><span class="keyword">double</span> *pd = &amp;dval;  <span class="comment">// 正确：初始值是 double 型对象的地址</span></span><br><span class="line"><span class="keyword">double</span> *pd2 = pd;    <span class="comment">// 正确：初始值是指向 double 对象的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi = pd;        <span class="comment">// 错误：指针 pi 的类型和 pd 的类型不匹配</span></span><br><span class="line">pi = &amp;dval;          <span class="comment">// 错误：试图把 double 型对象的地址赋给 int 型指针</span></span><br></pre></td></tr></table></figure>
<h5 id="指针值"><a class="header-anchor" href="#指针值">¶</a>指针值</h5>
<p>指针的值 (即地址) 应属下列 4 种状态之一：</p>
<ol>
<li>指向一个对象。</li>
<li>指向紧邻对象所占空间的下一个位置。</li>
<li>空指针，意味着指针没有指向任何对象。</li>
<li>无效指针，也就是上述情况之外的其它值。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<ul>
<li>试图拷贝或以其它方式访问无效指针的值都将引发错误。但 <strong>编译器并不负责检查此类错误</strong>。这一点和试图使用未经初始化的变量是一样的。访问 <strong>无效指针的后果无法预计</strong>。</li>
<li>第 2 种和第 3 种形式的指针同样受到限制。因为这些指针没有指向任何具体对象，所以试图访问此类指针 (假定的) 对象的行为不被允许。</li>
</ul>
</blockquote>
<h5 id="利用指针访问对象"><a class="header-anchor" href="#利用指针访问对象">¶</a>利用指针访问对象</h5>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>解引用操作仅适用于那些 <strong>确实指向了某个对象</strong> (状态 2、3 有可能没有指向任何具体对象)的 <strong>有效指针</strong>。</p>
</blockquote>
<h5 id="空指针"><a class="header-anchor" href="#空指针">¶</a>空指针</h5>
<p><strong>空指针</strong> (null pointer) 不指向任何对象。</p>
<blockquote>
<p><strong>C++11</strong></p>
<hr>
<p>得到空指针最直接的办法就是用字面值 <code>nullptr</code> 来初始化指针，这也是 C++11 标准刚刚引入的一种方法。</p>
</blockquote>
<p><code>nullptr</code> 是一种特殊类型的 <strong>字面值</strong>。<strong>它可以被转换成任意其它的指针类型</strong>。</p>
<p>得到空指针的方法：</p>
<ul>
<li>用字面值 <code>nullptr</code> 初始化指针。</li>
<li>通过将指针初始化为字面值 <code>0</code>。</li>
<li>通过将指针初始化为 <strong>预处理变量</strong> (preprocessor variable) <code>NULL</code> 的值，这个变量在头文件 <em>cstdlib</em> 中定义。它的值就是 <code>0</code>。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<ul>
<li>预处理器是运行于编译过程之前的一段程序。预处理变量不属于命名空间 <code>std</code>，它由预处理器负责管理，因此使用预处理变量时无须在前面加上 <code>std::</code>。<br>
当用到一个预处理变量时，预处理器会自动地将它替换为实际值，因此使用 <code>NULL</code> 初始化指针和用 <code>0</code> 初始化指针是一样的。<strong>在新标准下，现在的 C++ 程序最好使用 <code>nullptr</code>，同时发尽量避免使用 <code>NULL</code></strong>。</li>
<li>把 <code>int</code> 变量 <strong>直接</strong> 赋给指针是错误的操作，编译器将报错，即使 <code>int</code> 变量的值恰好等于 <code>0</code> 也不行。</li>
</ul>
</blockquote>
<h5 id="赋值和指针"><a class="header-anchor" href="#赋值和指针">¶</a>赋值和指针</h5>
<p>略，见 P49。</p>
<h5 id="其它指针操作"><a class="header-anchor" href="#其它指针操作">¶</a>其它指针操作</h5>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>不论是作为条件出现在还是参与比较运算，都必须使用合法指针，<strong>使用非法指针作为条件或进行比较都会引发不可预计的后果</strong>。</p>
</blockquote>
<h5 id="void-指针"><a class="header-anchor" href="#void-指针">¶</a><code>void*</code> 指针</h5>
<p><code>void*</code> 指针是一种特殊的指针类型，可用于存放任意对象的地址。</p>
<ul>
<li>可以拿 <code>void*</code> 指针和别的指针进行比较。</li>
<li>可以拿 <code>void*</code> 指针作为函数的输入或输出。</li>
<li>可以把 <code>void*</code> 指针赋给另个一个 <code>void*</code> 指针。</li>
<li><strong>不能直接</strong> 操作 <code>void*</code> 指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。</li>
</ul>
<h5 id="2-3-2-节练习"><a class="header-anchor" href="#2-3-2-节练习">¶</a>2.3.2 节练习</h5>
<ul>
<li>
<p>练习 2.18：编写代码分别更改指针的值以及指针所指对象的值。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ival = <span class="number">1024</span>, ival2 = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">int</span> *pi = &amp;ival;</span><br><span class="line">    </span><br><span class="line">    pi = &amp;ival2; <span class="comment">// 更改指针的值</span></span><br><span class="line">    *pi = <span class="number">4096</span>;  <span class="comment">// 更改指针所指对象的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 2.19：说明指针和引用的主要区别。</p>
<p>解：</p>
<ul>
<li>指针本身就是一个对象，允许对指针的赋值和拷贝；引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象。</li>
<li>指针无须在定义时赋初值。引用在定义时必须指明要绑定的对象。</li>
</ul>
</li>
<li>
<p>练习 2.20：请叙述下面这段代码的作用。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;i;</span><br><span class="line">*p1 = *p1 * *p1;</span><br></pre></td></tr></table></figure>
<p>解：</p>
<p>代码第一行将整型字面值 <code>42</code> 赋给整型变量 <code>i</code>。第二行将整型指针 <code>p</code> 指向变量 <code>i</code>。第三行将指针 <code>p</code> 所指向变量的值进行平方运算后再赋给 <code>p</code> 所指向的变量，即变量 <code>i</code>。</p>
</li>
<li>
<p>练习 2.21： 请解释下术定义。在这些定义中有非法的吗？如果有，为什么。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>(a) <code>double* dp = &amp;i;</code></p>
<p>(b) <code>int *ip = i;</code></p>
<p>(c) <code>int *p = &amp;i;</code></p>
<p>解：</p>
<p>(a) 该定义试图将 <code>double</code> 型指针直接指向一个 <code>int</code> 型变量。该定义是非法的，因为根据第 2.3.2 节 (P47)： 除了第 2.4.2 节 (P56) 和第 15.2.3 节 (P534) 介绍的两种例外情况，其它所有指针的类型都要和它所指向的对象严格匹配。该定义中的指针类型与所指向的变量类型不严格匹配。</p>
<p>(b) 该定义试图将一个 <code>int</code> 型变量的值直接赋给一个 <code>int</code> 型指针。该定义是非法的。因为把 <code>int</code> 变量直接赋给指针是错误的操作，编译器将报错，即使 <code>int</code> 变量的值恰好等于 <code>0</code> 也不行 (第 2.3.2 节，P49)。</p>
<p>(c) 该定义试图将 <code>int</code> 型指针直接指向一个 <code>int</code> 型变量。该定义是合法的。</p>
</li>
<li>
<p>练习 2.22：假设 <code>p</code> 是一个 <code>int</code> 型指针，请说明下述代码的含义：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p)   <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span>(*p)  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p)   <span class="comment">// 判断指针 p 的值是否为 nullptr 或 0</span></span><br><span class="line"><span class="keyword">if</span>(*p)  <span class="comment">// 判断指针 p 所指向的 int 变量的值是否是 0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 2.23：给定指针 <code>p</code>，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，也请说明原因。</p>
<p>解：</p>
<p>不一定能。因为指针的值可以为下列 4 种状态：</p>
<ol>
<li>指向一个对象。</li>
<li>指向紧邻对象所占空间的下一个位置。</li>
<li>空指针，意味着指针没有指向任何对象。</li>
<li>无效指针，也就是上述情况之外的其它值。</li>
</ol>
<p>如果 <code>p</code> 处于状态 3 可以使用 <code>if</code> 语句判断出 <code>p</code> 指向了 <code>nullptr</code> 字面量，或 <code>p</code> 的值为 <code>0</code>。但无法判断 <code>p</code> 是否处于其它三种状态。</p>
</li>
<li>
<p>练习 2.24：在下面这段代码中为什么 <code>p</code> 合法而 <code>lp</code> 非法？</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;i;</span><br><span class="line"><span class="keyword">long</span> *lp = &amp;i;</span><br></pre></td></tr></table></figure>
<p>解：</p>
<p>因为根据第 2.3.2 节 (P50)：<code>void*</code> 是一种特殊的指针类型，可用于存放任意对象的地址。而根据第 2.3.2 节 (P47)：除了第 2.4.2 节 (P56) 和第 15.2.3 节 (P534) 介绍的两种例外情况，其它所有指针的类型都要和它所指向的对象严格匹配。</p>
</li>
</ul>
<h4 id="2-3-3-理解复合类型的声明"><a class="header-anchor" href="#2-3-3-理解复合类型的声明">¶</a>2.3.3 理解复合类型的声明</h4>
<p>变量的定义包括一个基本数据类型 (base type) 和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i 是一个 int 型的数，p 是一个 int 型指针，r 是一个 int 型引用</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>类型修饰符是声明符的一部分。</p>
</blockquote>
<h5 id="定义多个变量"><a class="header-anchor" href="#定义多个变量">¶</a>定义多个变量</h5>
<p>略，见 P51。</p>
<h5 id="指向指针的指针"><a class="header-anchor" href="#指向指针的指针">¶</a>指向指针的指针</h5>
<p>一般来说，声明符中的修饰符的个数并没有限制。当有多个修饰符连写在一起时，按照其逻辑关系详加解释即可。</p>
<h5 id="指向指针的引用"><a class="header-anchor" href="#指向指针的引用">¶</a>指向指针的引用</h5>
<p>引用本身不是一个对象，因此 <strong>不能定义指向引用的指针</strong>。但指针是对象，所以 <strong>存在对指针的引用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> p;       <span class="comment">// p 是一个 int 型指针</span></span><br><span class="line"><span class="keyword">int</span> *&amp;r = p; <span class="comment">// r 是一个对指针 p 的引用</span></span><br><span class="line">r = &amp;i;      <span class="comment">// r 引用了一个指针，因此给 r 赋值 &amp;i 就是令 p 指向 i</span></span><br><span class="line">*r = <span class="number">0</span>;      <span class="comment">// 解引用了 r 得到 i，也就是 p 指向的对象，将 i 的值改为 0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong>：</p>
<hr>
<p>面对一条比较复杂的指针或引用的声明语句时，<strong>从右向左读</strong> 有助于弄清它的真实含义。</p>
</blockquote>
<h5 id="2-3-3-节练习"><a class="header-anchor" href="#2-3-3-节练习">¶</a>2.3.3 节练习</h5>
<ul>
<li>
<p>练习 2.25：说明下列变量的类型和值。</p>
<p>(a) <code>int* ip, i, &amp;r = i;</code></p>
<p>(b) <code>int i, *ip = 0;</code></p>
<p>(c) <code>int* ip, ip2;</code></p>
<p>解：</p>
<p>(a)</p>
<ul>
<li><code>ip</code> 是 <code>int</code> 类型指针。如果该定义语句在函数体外，则它的值为 <code>nullptr</code>；如果该定义语句在函数体内，则 <code>ip</code> 是未被初始化的，其值是未定义的。</li>
<li><code>i</code> 是 <code>int</code> 类型变量。如果该定义语句在函数体外，则它的值为 <code>0</code>；如果该定义语句在函数体内，则 <code>i</code> 是未被初始化的，其值是未定义的。</li>
<li><code>r</code> 是绑定到 <code>int</code> 型变量 <code>i</code> 上的 <code>int</code> 型引用。它的值即为此时 <code>i</code> 的值。</li>
</ul>
<p>(b)</p>
<ul>
<li><code>i</code> 是 <code>int</code> 类型变量。如果该定义语句在函数体外，则它的值为 <code>0</code>；如果该定义语句在函数体内，则 <code>i</code> 是未被初始化的，其值是未定义的。</li>
<li><code>ip</code> 是 <code>int</code> 类型的空指针。其值为 <code>0</code>。</li>
</ul>
<p>(c)</p>
<ul>
<li><code>ip</code> 是 <code>int</code> 类型指针。如果该定义语句在函数体外，则它的值为 <code>nullptr</code>；如果该定义语句在函数体内，则 <code>ip</code> 是未被初始化的，其值是未定义的。</li>
<li><code>ip2</code> 是 <code>int</code> 类型变量。如果该定义语句在函数体外，则它的值为 <code>0</code>；如果该定义语句在函数体内，则 <code>ip2</code> 是未被初始化的，其值是未定义的。</li>
</ul>
</li>
</ul>
<h3 id="2-4-const-限定符"><a class="header-anchor" href="#2-4-const-限定符">¶</a>2.4 <code>const</code> 限定符</h3>
<p><strong>因为 <code>const</code> 对象一旦创建后其值就不能再改变，所以 <code>const</code> 对象必须初始化，<span style="border-bottom: 3px black double">初始值可以是任意复杂的表达式</span></strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = get_size();  <span class="comment">// 正确，运行时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">42</span>;          <span class="comment">// 正确：编译时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k;               <span class="comment">// 错误：k 是一个未经初始化的常量</span></span><br></pre></td></tr></table></figure>
<h4 id="初始化和-const"><a class="header-anchor" href="#初始化和-const">¶</a>初始化和 <code>const</code></h4>
<p><strong>如果利用一个对象去初始化另外一个对象，则它们是不是 <code>const</code> 都无关紧要</strong>。</p>
<h4 id="默认状态下，const-对象仅在文件内有效"><a class="header-anchor" href="#默认状态下，const-对象仅在文件内有效">¶</a>默认状态下，<code>const</code> 对象仅在文件内有效</h4>
<ul>
<li>
<p>当以 <span style="border-bottom: 3px black double">编译时初始化的方式 </span> 定义一个 <code>const</code> 对象时，<strong>编译器将在编译过程中把用到该变量的地方都替换成对象的值</strong>。如果程序包含多个文件，则每个用了 <code>const</code> 对象的文件都必须得能访问到它的初始值才行。要做到这一点，<strong>就必须在每一个用到变量的文件中都有对它的定义</strong>（第 2.2.2 节，P41）。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，<code>const</code> 对象被设定为仅在文件内有效。<strong>当多个文件中出现了同名的 <code>const</code> 变量时，其实等同于在不同文件中分别定义了独立的变量</strong>。</p>
</li>
<li>
<p>当 <span style="border-bottom: 3px black double">它的初始值不是一个常量表达式 (第 2.4.4 节，P58)</span>，但又确实必要要文件间共享，也就是说要在其它多个文件中声明并使用它时。对于 <code>const</code> 变量不管是声明还是定义都添加 <code>extern</code> 关键字，这样只需定义一次就可以了：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file_1.cc 定义并初始化了一个常量，该常量能被其它文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = fcn();</span><br><span class="line"><span class="comment">// file_1.h 头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;  <span class="comment">// 与 file_1.cc 中定义的 bufSize 是同一个</span></span><br></pre></td></tr></table></figure>
<p><em>file_1.cc</em> 定义并初始化了 <code>bufSize</code>。因为这条语句包含了初始值，所以它（显然）是一次定义。然而，因为 <code>bufSize</code> 是一个常量，必须用 <code>extern</code> 加以限定使其它文件使用。</p>
<p><em>file_1.h</em> 头文件中的声明也由 <code>extern</code> 做了限定，其作用是指明 <code>bufSize</code> 并非本文件所独有，它的定义 <strong>将</strong> 在别处出现。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>如果想在多个文件之间共享 <code>const</code> 对象，必须在变量的定义之前添加 <code>extern</code> 关键字。</p>
</blockquote>
<h4 id="2-4-节练习"><a class="header-anchor" href="#2-4-节练习">¶</a>2.4 节练习</h4>
<ul>
<li>
<p>练习 2.26：下面哪些句子是合法的？如果有不合法的句子，请说明为什么？</p>
<p>(a) <code>const int buf; </code></p>
<p>(b) <code>int cnt = 0;</code></p>
<p>(c) <code>const int sz = cnt;</code></p>
<p>(d) <code>++cnt; ++sz;</code></p>
<p>解：</p>
<p>(a) 不合法。因为根据第 2.4节 (P53)：因为 <code>const</code> 对象一旦创建后其值就不能再改变，所以 <code>const</code> 对象必须初始化。此语句中的 <code>const</code> 对象 <code>buf</code> 未初始化。</p>
<p>(b) 合法。<br>
(c) 合法。</p>
<p>(d) 不合法。因为 <code>const</code> 变量的值不能被改变。题干中 <code>++cnt;</code> 试图改变了 <code>const</code> 变量 <code>cnt</code> 的值。</p>
</li>
</ul>
<h4 id="2-4-1-const-的引用"><a class="header-anchor" href="#2-4-1-const-的引用">¶</a>2.4.1 <code>const</code> 的引用</h4>
<p>可以把引用绑定到 <code>const</code> 对象上，就像绑定到其他对象上一样，我们称之为 <strong>对常量的引用</strong> (reference to const)。<strong>对常量的引用不能被用作修改它所绑定的对象</strong>。</p>
<blockquote>
<p><strong>术语</strong>：常量引用是对 <code>const</code> 的引用</p>
<hr>
<p>严格来说，<strong>并不存在常量引用。因为引用不是一个对象</strong>，所以我们没法让引用本身恒定不变。事实上，由于 C++ 语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解所有的引用又都算是常量。</p>
</blockquote>
<h5 id="初始化和对-const-的引用"><a class="header-anchor" href="#初始化和对-const-的引用">¶</a>初始化和对 <code>const</code> 的引用</h5>
<p>第 2.3.1 节 (P46) 提到，引用的类型与其所引用的对象的类型一致，<strong>但是有两个例外</strong>。</p>
<p>其中之一就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能 <strong>转换成</strong> 引用的类型即可。尤其，<strong>允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;       <span class="comment">// 允许将 const int&amp; 绑定到一个普通 int 对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;      <span class="comment">// 正确：r1 是一个常量引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;  <span class="comment">// 正常：r3 是一个常量引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>;        <span class="comment">// 错误：r4 是一个普通的非常量引用</span></span><br></pre></td></tr></table></figure>
<p>要想理解这种例外情况的原因，最简单的办法是弄清楚当一个常量引用被绑定到另一种类型上时到底发生了什么：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure>
<p>为了确保让 <code>ri</code> 绑定一个整数，编译器把上述代码变成了如下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval; <span class="comment">// 由双精度浮点数生成一个临时的整型常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;  <span class="comment">// 让 ri 绑定这个临时量</span></span><br></pre></td></tr></table></figure>
<ol>
<li>当 <code>ri</code> 绑定的是常量时，<code>ri</code> 绑定了一个 <strong>临时量</strong> (temporary) 对象。</li>
<li>当 <code>ri</code> 不是常量时，如果依旧执行了 1 中的操作，那么由于 <code>ri</code> 不是常量，就允许对 <code>ri</code> 赋值，这样会改变 <code>ri</code> 所引用对象的值。注意，<strong>此时绑定的对象是一个临时量而非 <code>dval</code></strong>。</li>
</ol>
<h5 id="对-const-的引用可能引用一个并非-const-的对象"><a class="header-anchor" href="#对-const-的引用可能引用一个并非-const-的对象">¶</a>对 <code>const</code> 的引用可能引用一个并非 <code>const</code> 的对象</h5>
<p>常量引用仅对引用可参与的操作做出了限定，<strong>对于引用的对象本身是不是一个常量未作限定</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i;        <span class="comment">// 引用 ri 绑定对象 i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;  <span class="comment">// r2 也绑定对象 i，但是不允许通过 r2 修改 i 的值</span></span><br><span class="line">r1 = <span class="number">0</span>;             <span class="comment">// r1 并非常量，i 的值修改为 0</span></span><br><span class="line">r2 = <span class="number">0</span>;             <span class="comment">// 错误：r2 是一个常量引用</span></span><br></pre></td></tr></table></figure>
<p>不允许通过 <code>r2</code> 修改 <code>i</code> 的值。但 <strong><code>i</code> 的值仍然允许通过其它途径修改，既可以直接给 <code>i</code> 赋值，也可以通过像 <code>r1</code> 一样绑定到 <code>i</code> 的其它引用来修改</strong>。</p>
<h4 id="2-4-2-指针和-const"><a class="header-anchor" href="#2-4-2-指针和-const">¶</a>2.4.2 指针和 <code>const</code></h4>
<p>类似于常量引用 (第 2.4.1 节，P54)，<strong>指向常量的指针</strong> (pointer to const) 不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;      <span class="comment">// pi 是个常量，它的值不能改变</span></span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;           <span class="comment">// 错误：ptr 是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;    <span class="comment">// 正确：cptr 可以指向一个双精度常量</span></span><br><span class="line">*cptr = <span class="number">42</span>;                  <span class="comment">// 错误：不能给 *cptr 赋值</span></span><br></pre></td></tr></table></figure>
<p>和对常量的引用一样，<strong>指向常量的指针也没有规定其所指的对象必须是一个常量</strong>。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其它途径改变。</p>
<blockquote>
<p><strong>笔记</strong>：</p>
<hr>
<p>对常量的引用的类型可以与被绑定的对象的类型不同，只要被绑定的对象的类型可以转换成对常量的引用的类型就可以。但 <strong>指向常量的指针不可以</strong>。</p>
</blockquote>
<h5 id="const-指针"><a class="header-anchor" href="#const-指针">¶</a><code>const</code> 指针</h5>
<p><strong>指针是对象而引用不是</strong>，因此允许把指针本身定为常量。<strong>常量指针</strong> (const pointer) <span style="border-bottom: 3px black double">必须初始化</span>，而且一但初始化完成，则它的值就不能再改变了。把 <code>*</code> 放在关键字 <code>const</code> 关键字之前用以说明指针是一个常量，<strong>即不变的是指针本身的值而非指向的那个指</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb;   <span class="comment">// curErr 将一直指向 errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;  <span class="comment">// pip 是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure>
<h5 id="2-4-2-节练习"><a class="header-anchor" href="#2-4-2-节练习">¶</a>2.4.2 节练习</h5>
<ul>
<li>
<p>练习 2.27：下面的哪些初始化是合法的？请说明原因。</p>
<p>(a) <code>int i = -1, &amp;r = 0;</code></p>
<p>(b) <code>int *const p2 = &amp;i2;</code></p>
<p>(c) <code>cosnt int i = -1, &amp;r = 0;</code></p>
<p>(d) <code>const int *const p3 = &amp;i2;</code></p>
<p>(e) <code>const int *p1 = &amp;i2;</code></p>
<p>(f) <code>const int &amp;const r2;</code></p>
<p>(g) <code>const int i2 = i; &amp;r = i</code></p>
<p>解：</p>
<p>(a) 不合法。因为引用必须绑定对象，而 <code>r</code> 绑定到了一个字面值。</p>
<p>(b) 不合法。因为指针可以指向：</p>
<ol>
<li>与指针类型严格相同类型的对象。</li>
<li>与指针类型相同的非常量对象。</li>
</ol>
<p>该指针类型为指向 <code>int</code> 型对象的 <code>int</code> 型的常量指针，而被指向的是对象的类型为指向 <code>int</code> 型常量的 <code>int</code> 型指针，不符合上述任一条件。</p>
<p>(c) 合法。原因参见第 2.4.2 节 (P55)。</p>
<p>(d) 合法。因为指向常量的指针未规定被指向的对象是否是常量，只要基本类型一至即可。</p>
<p>(e) 合法。理由同上。</p>
<p>(f) 不合法。因为：</p>
<ol>
<li>不存在“常量引用”。</li>
<li>引用必须初始化，而 <code>r2</code> 未被初始化。</li>
</ol>
<p>(g) 合法。</p>
</li>
<li>
<p>练习 2.28：说明下面的这些定义是什么意思，挑出其中不合法的。</p>
<p>(a) <code>int i, *const cp;</code></p>
<p>(b) <code>int *p1, *const p2;</code></p>
<p>(c) <code>const int ic, &amp;r = ic;</code></p>
<p>(d) <code>const int *const p3;</code></p>
<p>(e) <code>const int *p;</code></p>
<p>解：</p>
<p>(a) 定义一个 <code>int</code> 型变量和一个 <code>int</code> 型常量指针。该语句不合法，因为根据第 2.4.2 节 (P56)：常量指针必须初始化。</p>
<p>(b) 定义一个指向 <code>int</code> 型变量的 <code>int</code> 型指针，并默认初始化。同时定义一个定义一个指向 <code>int</code> 型变量的 <code>int</code> 型常量指针。该语句不合法，理由同上。</p>
<p>(c) 定义一个 <code>int</code> 型常量，同时定义一个 <code>int</code> 型的引用，并绑定到变量 <code>ic</code>。该语句不合法，因为常量对象必须初始化。</p>
<p>(d) 定义一个指向 <code>int</code> 型常量的 <code>int</code> 型常量指针。该语句不合法，常量指针必须被初始化。</p>
<p>(e) 定义一个指向 <code>int</code> 型常量的指针。该语句合法。</p>
</li>
<li>
<p>练习 2.29：假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的？请说明原因。</p>
<p>(a) <code>i = ic;</code></p>
<p>(b) <code>p1 = p3;</code></p>
<p>(c) <code>p1 = &amp;ic;</code></p>
<p>(d) <code>p3 = &amp;ic;</code></p>
<p>(e) <code>p2 = p1;</code></p>
<p>(f) <code>ic = *p3;</code></p>
<p>解：</p>
<p>(a) 合法。</p>
<p>(b) 不合法，因为 <code>p1</code> 是 <code>int</code> 型指针，而 <code>p3</code> 是指向 <code>int</code> 型常量对象的常量指针。类型不严格相同。</p>
<p>(c) 不合法，原因同 (b)。</p>
<p>(d) 不合法，<code>p3</code> 指向的对象不能再改变。</p>
<p>(e) 不合法，原因同 (d)。</p>
<p>(f) 不合法 <code>const</code> 对象内容不能重新指定。</p>
</li>
</ul>
<h4 id="2-4-3-顶层-const"><a class="header-anchor" href="#2-4-3-顶层-const">¶</a>2.4.3 顶层 <code>const</code></h4>
<ul>
<li><strong>顶层 <code>const</code></strong> (top-level const)：表示对象 (<strong>笔记：原文为“指针”，而下方又有文：更一般的，顶层 <code>const</code> 可以表示任意的对象是常量，这一点对任何数据类型都适用。</strong>) <span style="border-bottom: 3px black double">本身</span> 是个常量。</li>
<li><strong>底层 <code>const</code></strong> (low-level const)：表示指针指的对象是一个常量。</li>
</ul>
<p>当执行对象的拷贝操作时，常量是顶层 <code>const</code> 还是底层 <code>const</code> 区别明显。其中，<strong>顶层 <code>const</code> 不受什么影响</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;       <span class="comment">// 不能改变 p1 的值，这是一个顶层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;        <span class="comment">// 不能改变 ci 的值，这是一个顶层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;      <span class="comment">// 允许改变 p2 的值，这是一个底层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// 靠右的 const 是顶层 const，靠左的是底层 const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;        <span class="comment">// 用于声明引用的 const 都是底层 const</span></span><br><span class="line"></span><br><span class="line">i = ci;   <span class="comment">// 正确：拷贝 ci 的值，ci 是一个顶层 const，对此操作无影响</span></span><br><span class="line">p2 = p3;  <span class="comment">// 正确：p2 和 p3 指向的对象类型相同，p3 顶层 const 的部分不影响</span></span><br></pre></td></tr></table></figure>
<p>当执行拷贝操作时，<strong>拷入和拷出的对象必须具有相同的底层 <code>const</code> 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = p3;          <span class="comment">// 错误：p3 包含底层 const 的定义，而 p 没有</span></span><br><span class="line">p2 = p3;              <span class="comment">// 正确：p2 和 p3 都是底层 const</span></span><br><span class="line">p2 = &amp;i;              <span class="comment">// 正确： int* 能转换成 const int*</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = ci;          <span class="comment">// 错误：普通的 int&amp; 不能绑定到 int 常量上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;    <span class="comment">// 正确： const int&amp; 可以绑定到一个普通 int 上</span></span><br></pre></td></tr></table></figure>
<h5 id="2-4-3-节练习"><a class="header-anchor" href="#2-4-3-节练习">¶</a>2.4.3 节练习</h5>
<ul>
<li>
<p>练习 2.30：对于下面的这些语句，请说明对象被声明成了顶层 <code>const</code> 还是底层 <code>const</code>？</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> v2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> v1 = v2;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;v1, &amp;r1 = v1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;v2, *<span class="keyword">const</span> p3 = &amp;i, &amp;r2 = v2;</span><br></pre></td></tr></table></figure>
<p>解：</p>
<p><code>p2</code> 是底层 <code>const</code>；<code>p3</code> 的左侧 <code>const</code>  是底层 <code>const</code>， 右侧 <code>const</code> 是顶层 <code>const</code>。</p>
</li>
<li>
<p>练习 2.31：假设已有上一个练习中所做的那些声明，则下面的哪 些语句是合法的？请说明顶层 <code>const</code> 和底层 <code>const</code> 在每个例子中有何体现？</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    r1 = v2;</span><br><span class="line">    p1 = p2;</span><br><span class="line">    p2 = p1;</span><br><span class="line">    p1 = p3;</span><br><span class="line">p2 = p3;</span><br></pre></td></tr></table></figure>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">r1 = v2;  <span class="comment">// 合法</span></span><br><span class="line">p1 = p2;  <span class="comment">// 不合法，p1 为 int 型指针，p2 为指向 int 型常量的 int 型指针。p2 的 const 为底层 const。</span></span><br><span class="line">p2 = p1;  <span class="comment">// 合法，根据第 2.4.3 节 (P58)，底层 const 限制为：当执行对象拷贝时，拷入和拷出的对象必须具有相同的底层 const 资格，可两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不能。因为 p2 是常量，p1 是非常量，所以可以兼容。</span></span><br><span class="line">p1 = p3;  <span class="comment">// 不合法，根据同上，p1 是指向 int 型对象的指针，是非常量，p3 是指向 int 型常量的 int 型常量指针，类型不兼容。</span></span><br><span class="line">p2 = p3;  <span class="comment">// 合法，顶层 const 不影响类型兼容性，而底层 const 是兼容的。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-4-4-constexpr-和常量表达式"><a class="header-anchor" href="#2-4-4-constexpr-和常量表达式">¶</a>2.4.4 <code>constexpr</code> 和常量表达式</h4>
<p><strong>常量表达式</strong> (const expression) 是指值不会改变并且在编译过程就能得到计算结果的表达式。</p>
<p><strong>一个对象 (或表达式) 是不是常量表达式由它的数据类型和初始值共同决定</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_files = <span class="number">20</span>;         <span class="comment">// max_files 是常量表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> limit = max_files + <span class="number">1</span>;  <span class="comment">// limit 是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> staff_size = <span class="number">27</span>;              <span class="comment">// staff_size 不是常量表达式，尽管 staff_size 的初始值是个字面值常量，但由于它的数据类型只是一个普通 int 而非 const int，所以它不属于常量表达式。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = get_size();        <span class="comment">// sz 不是常量表达式，尽管 sz 本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是常量表达式。</span></span><br></pre></td></tr></table></figure>
<h5 id="constexpr-变量"><a class="header-anchor" href="#constexpr-变量">¶</a><code>constexpr</code> 变量</h5>
<blockquote>
<p><strong>C++11</strong>：</p>
<hr>
<p>C++11 新标准规定，允许将变量声明为 <code>constexpr</code> 类型以便由编译器来验证变量的值是否是一个常量表达式。</p>
</blockquote>
<p>声明为 <code>constexpr</code> 的变量一定是一个 <strong>常量</strong>，<strong>而且必须用常量表达式初始化</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>;           <span class="comment">// 20 是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>;    <span class="comment">// mf + 1 是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = <span class="built_in">size</span>();       <span class="comment">// 只有当 size 是一个 constexpr 函数时才是一条正确的声明语句</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong>：</p>
<hr>
<p>尽管不能使用普通作为 <code>constexpr</code>  变量的初始值，但是正如第 6.5.2 节 (P214) 将要介绍的，新标准允许定义一种特殊的 <code>constexpr</code> 函数。这种函数应该 <strong>足够简单以使得编译时就可以计算其结果</strong>，这样就能用 <code>constexpr</code> 函数去初始化 <code>constexpr</code> 变量了。</p>
</blockquote>
<blockquote>
<p><strong>最佳实践</strong>：</p>
<hr>
<p>一般来说，如果你认定变量是一个常量表达式，那就把它声明成 <code>constexpr</code> 类型。</p>
</blockquote>
<blockquote>
<p><strong>笔记</strong>：<code>const</code> 和 <code>constexpr</code> 区别（<a href="https://www.zhihu.com/question/35614219/answer/63798713" target="_blank" rel="noopener">原贴</a>）</p>
<hr>
<ol>
<li>
<p>修饰对象：</p>
<ul>
<li><code>const</code> 并未区分出编译期常量和运行期常量，<strong>只保证了运行时不直接被修改（但这个东西仍然可能是个动态变量）</strong>。</li>
<li><code>constexpr</code> 限定在了编译期常量。</li>
</ul>
</li>
<li>
<p>修饰函数：</p>
<p><code>constexpr</code> 修饰的函数，<strong>返回值不一定是编译期常量</strong>：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, foo(5)&gt; arr; <span class="comment">// OK</span></span><br><span class="line">    </span><br><span class="line">    foo(i); <span class="comment">// Call is Ok</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// But...</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, foo(i)&gt; arr1; <span class="comment">// Error</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果其传入的参数可以在编译时期计算出来，那么这个函数就会产生编译时期的值。</li>
<li>如果传入的参数如果不能在编译时期计算出来，那么 <code>constexpr</code> 修饰的函数就和普通函数一样了。</li>
</ul>
</li>
</ol>
</blockquote>
<h5 id="字面值类型"><a class="header-anchor" href="#字面值类型">¶</a>字面值类型</h5>
<p>到目前为止接触过的数据类型中，<strong>算术类型、引用和指针都属于字面值类型 (literal type)</strong>。</p>
<ul>
<li>
<p><strong>自定义类 <code>Sales_item</code>、IO 库、<code>string</code> 类型则不属于字面值类型，<span style="border-bottom: 3px black double">也就不能被定义成 <code>constexpr</code> </span></strong>。</p>
</li>
<li>
<p><strong>尽管指针和引用都能定义成 <code>constexpr</code>，但它们的初始值却受到严格限制：一个 <code>constexpr</code> 指针的初始值必须是 <code>nullptr</code> 或者 <code>0</code>，或者是存储于某个固定地址中的对象</strong>。</p>
</li>
<li>
<p><strong>函数体内定义的</strong> 变量一 般来说并非存放在固定地址中，因此 <code>constexpr</code> 指针 <strong>不能</strong> 指向这样的变量。(第 6.1.1 节，P184)</p>
</li>
<li>
<p>因为允许函数定义一类有效范围超出函数本身的变量 (第 6.1.1 节，P185)，这类变量和定义在函数体之外的变量一样也有固定地址。因此，<code>constexpr</code> 引用能绑定到这样的变量上，<code>constexpr</code> 指针也能指向这样的变量。</p>
</li>
</ul>
<h5 id="指针和-constexpr"><a class="header-anchor" href="#指针和-constexpr">¶</a>指针和 <code>constexpr</code></h5>
<p>在 <code>constexpr</code> 声明中如果定义了一个指针，<strong>限定符 <code>constexpr</code> 仅对指针有效，与指针所指的对象无关</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;       <span class="comment">// p 是一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>;   <span class="comment">// q 是一个指向整型的 **常量指针**</span></span><br></pre></td></tr></table></figure>
<p><code>cosntexpr</code> 指针既可以指向常量也可以指向一个非常量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *np = <span class="literal">nullptr</span>;    <span class="comment">// np 是一个指向整数的常量指针，其值为空</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> i = <span class="number">42</span>;           <span class="comment">// i 的类型是整型常量</span></span><br><span class="line"><span class="comment">// i 和 j 必须定义在函数体之外</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;    <span class="comment">// p 是常量指针，指向整型常量 i</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *p1 = &amp;j;         <span class="comment">// p1 是常量指针，指向整数 j</span></span><br></pre></td></tr></table></figure>
<h5 id="2-4-4-节练习"><a class="header-anchor" href="#2-4-4-节练习">¶</a>2.4.4 节练习</h5>
<ul>
<li>
<p>练习 2.32：下面的代码是否合法？如果非法，请设法将其修改正确。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> null = <span class="number">0</span>, *p = null;</span><br></pre></td></tr></table></figure>
<p>解：不合法。应为：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> null = <span class="number">0</span>, *p = &amp;null;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-5-处理类型"><a class="header-anchor" href="#2-5-处理类型">¶</a>2.5 处理类型</h3>
<h4 id="2-5-1-类型别名"><a class="header-anchor" href="#2-5-1-类型别名">¶</a>2.5.1 类型别名</h4>
<p>有两种方法可用于定义类型别名：</p>
<ul>
<li>
<p>传统的方法是使用关键字 <code>typede</code>：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;    <span class="comment">// wages 是 double 的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wage base, *p;   <span class="comment">// base 是 double 的同义词，p 是 double* 的同义词</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <strong>别名声明</strong> (alias declaration) 来定义类型的别名：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item;   <span class="comment">// SI 是 Sales_item 的同义词</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><strong>C++11</strong>：</p>
<hr>
<p>别名声明是新标准规定的一种新的定义类型别名的方法。</p>
</blockquote>
<h5 id="指针、常量和类型别名"><a class="header-anchor" href="#指针、常量和类型别名">¶</a>指针、常量和类型别名</h5>
<p>如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型 <code>pstring</code>，它实际上是类型 <code>char*</code> 的别名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>;  <span class="comment">// cstr 是指向 char 的常量指针</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps;       <span class="comment">// ps 是一个指针，它的对象是指向 char 的常量指针</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>上述两条声明语句的基本数据类型都是 <code>const pstring</code>，和过去一样，<code>const</code> <strong>是对给定类型的修饰</strong>。<code>pstring</code> 实际上是指向 <code>char</code> 的指针，因此，<strong><span style="border-bottom: 3px black double"><code>const pstring</code> 就是指向 <code>char</code> 的常量指针，而非指向常量字符的指针</span></strong>。</p>
</blockquote>
<h4 id="2-5-2-auto-类型说明符"><a class="header-anchor" href="#2-5-2-auto-类型说明符">¶</a>2.5.2 <code>auto</code> 类型说明符</h4>
<p><code>auto</code> 类型说明符能让编译器替我们去分析表达式所属的类型。<strong>显然，<code>auto</code> 定义的变量必须有初始值</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由 val1 和 val2 相加的结果可以推断出 item 的类型</span></span><br><span class="line"><span class="keyword">auto</span> item = val1 + val2;  <span class="comment">// item 初始化为 val1 和 val2 相加的结果</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>auto</code> 也能在一条语句中声明多个变量。因为<strong>一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;      <span class="comment">// 正确：i 是整数、p 是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;   <span class="comment">// 错误：sz 和 pi 的类型不一致</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>C++11</strong>：</p>
<hr>
<p><code>auto</code> 类型</p>
</blockquote>
<h5 id="复合类型、常量和-auto"><a class="header-anchor" href="#复合类型、常量和-auto">¶</a>复合类型、常量和 <code>auto</code></h5>
<p>编译器推断出来的 <code>auto</code> 类型有时候和初始值的类型 <strong>并不完全一样</strong>，编译器会适当地改变结果类型使其更符合初始化规则：</p>
<ol>
<li>
<p>使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为 <code>auto</code> 的类型：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r;         <span class="comment">// a 是一个整数 (r 是 i 的别名，而 i 是一个整数)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>auto</code> 一般会忽略掉 <span style="border-bottom: 3px black double">顶层</span> <code>const</code> (第 2.4.3 节，P57)，同时底层 <code>const</code> 则会保留下来</strong>：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;    <span class="comment">// b 是一个整数 (ci 的顶层 const 特性被忽略掉了)</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;    <span class="comment">// c 是一个整数 (cr 是 ci 的别名，ci 本身是一个顶层 const)</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;    <span class="comment">// d 是一个整型指针 (整数的地址就是指向整数的指针)</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;   <span class="comment">// e 是一个指向整数指针 (对常量对象取地址是一种底层 const)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>如果希望推断出的 <code>auto</code> 类型是一个顶层 <code>const</code>，需要明确指出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = ci;  <span class="comment">// ci 的推演类型是 int，f 是 const int</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>笔记</strong>：</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;</span><br><span class="line"><span class="keyword">auto</span> c = cr;</span><br></pre></td></tr></table></figure>
<p>上面的代码这样理解：</p>
<ul>
<li><code>ci</code> 是 <code>int</code> 型常量，将它赋给 <code>b</code> 后，<code>b</code> 的推断类型为 <code>const int</code>，且此 <code>const</code> 是顶层 <code>const</code> (第 2.4.3 节，P57)。然而根据每 2.5.2 节 (P62)：<code>auto</code> 一般会忽略掉顶层 <code>const</code>。所以 <code>b</code> 的 <code>const</code> 被忽略掉了。</li>
<li><code>cr</code> 是绑定到 <code>int</code> 型常量 <code>ci</code> 上的引用。由于引用即别名 (第 2.3.1 节，P46)，<code>cr</code> 是 <code>ci</code> 的别名，所以 <code>cr</code> 与  <code>ci</code> 类型应当严格相同，都是 <code>const int</code>。据上一条笔记，<code>c</code> 的顶层 <code>const</code> 也被忽略掉了，所以 <code>c</code> 也是 <code>int</code> 型对象。</li>
</ul>
</blockquote>
</li>
<li>
<p>还可以将引用的类型设为 <code>auto</code>，此时原来的初始化规则仍然适用：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g = ci;         <span class="comment">// g 是一个整型常量引用，绑定到 ci</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>;         <span class="comment">// 错误：不能为非常量引用绑定字面值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>;  <span class="comment">// 正确：可以为常量引用绑定字面值</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="2-5-2-节练习"><a class="header-anchor" href="#2-5-2-节练习">¶</a>2.5.2 节练习</h5>
<ul>
<li>
<p>练习 2.33：利用本节定义的变量，判断下列语句的运行结果。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = <span class="number">42</span>; b = <span class="number">42</span>; c= <span class="number">42</span>;</span><br><span class="line">d = <span class="number">42</span>; e = <span class="number">42</span>; g = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = <span class="number">42</span>;     <span class="comment">// a 是整型对象，值为 42</span></span><br><span class="line">b = <span class="number">42</span>;     <span class="comment">// b 是整型对象，值为 42。ci 的顶层 const 特性被忽略了</span></span><br><span class="line">c = <span class="number">42</span>;     <span class="comment">// c 是整型对象，值为 42。cr 是 ci 的别名，而 ci 本身是一个顶层 const，且它的顶层 const 被忽略掉了</span></span><br><span class="line">d = <span class="number">42</span>;     <span class="comment">// 错误，d 是指向整型对象的指针，而 42 是整型字面量，类型不同</span></span><br><span class="line">e = <span class="number">42</span>;     <span class="comment">// 错误，理由同上</span></span><br><span class="line">g = <span class="number">42</span>;     <span class="comment">// 错误，g 是对 int 型常量的引用，不能改变它所引用的对象的值</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 2.34：基于上一个练习中的变量和语句编写一段程序，输出赋值前后变量的内容，你刚才的推断正确吗？如果不对，请反复研读本节的示例直到你明白错在何处为止。</p>
<p>解：参见练习 2.33 的解。</p>
</li>
<li>
<p>练习 2.35：判断下列定义推断出的类型是什么，然后编写程序进行验证。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> j = i; <span class="keyword">const</span> <span class="keyword">auto</span> &amp;k = i; <span class="keyword">auto</span> *p = &amp;i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> j2 =i, &amp;k2 = i;</span><br></pre></td></tr></table></figure>
<p>解：</p>
<ul>
<li>
<p><code>j</code> 为整型常量。</p>
<p>验证：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(j).name() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出：i</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>k</code> 是整型常量 <code>i</code> 的引用。</p>
<p>验证：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;k = i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(k).name() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出：i</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>p</code> 是指向整型常量 <code>i</code> 的指针。</p>
<p>验证：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> *p = &amp;i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(p).name() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出：PKi</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>j2</code> 是整型常量，初始值为 42。</p>
<p>验证：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> j2 = i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(j2).name() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出：i</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>k2</code> 是整型常量 <code>i</code> 的常量引用。</p>
<p>验证：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;k2 = i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(k2).name() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出：i</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="2-5-2-decltype-类型指示符"><a class="header-anchor" href="#2-5-2-decltype-类型指示符">¶</a>2.5.2 <code>decltype</code> 类型指示符</h4>
<blockquote>
<p><strong>C++11</strong>：</p>
<hr>
<p>有时会遇到这种情况：<strong>希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量</strong>。为了满足这一要求，C++11 新标准引入了第二种类型说明符 <code>decltype</code>。</p>
</blockquote>
<p><code>decltype</code> 的作用的选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却 <strong>不实际计算表达式的值</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum = x; <span class="comment">// sum 的类型就是函数 f 的返回顾类型</span></span><br></pre></td></tr></table></figure>
<p><strong>如果 <code>decltype</code> 使用的表达式是一个变量，则 <code>decltype</code> 返回该变量的类型 (包括 <span style="border-bottom: 3px black double">顶层 <code>const</code> 和引用</span> 在内)</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;           <span class="comment">// x 的类型是 const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;           <span class="comment">// y 的类型是 const int&amp;，y 绑定到变量 x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;               <span class="comment">// 错误：z 是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>引用从来都作为其所指对象的同义词出现，只有用在 <code>decltype</code> 处是一个例外。</p>
</blockquote>
<h5 id="decltype-和引用"><a class="header-anchor" href="#decltype-和引用">¶</a><code>decltype</code> 和引用</h5>
<p><strong><span style="border-bottom: 3px black double">如果表达式的内容是解引用操作，则 <code>decltype</code> 将得到引用类型：</span></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;      <span class="comment">// 正确：加法的结果是 int，因此 b 是一个 (未初始化的) int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;         <span class="comment">// 错误：c 是 int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>笔记</strong>：</p>
<hr>
<p>根据 2.3.2 节 (P48)：对指针解引用会得出所指的对象。由此可看出对指针解引用得到的是一个引用。</p>
</blockquote>
<p><strong>如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果给变量加上了一层<span style="border-bottom: 3px black double">或多层括号</span>，编译器就会把它当成是一个表达式。<span style="border-bottom: 3px black double">变量是一种可以作为赋值语句左值的特殊表达式，所以这样的 <code>decltype</code> 就会得到引用类型</span></strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// decltype 的表达式如果是加上了括号的变量，结果将是引用</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d;  <span class="comment">// 错误：d 是 int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;    <span class="comment">// 正确：e 是一个 (未初始化的) int</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>切记</strong>：</p>
<hr>
<p><code>decltype((variable))</code> (注意是双层括号) 的结果永远是引用，而 <code>decltype(variable)</code> 结果只有当 <code>variable</code> 本身就是一个引用时才是引用。</p>
</blockquote>
<h5 id="2-5-3-节练习"><a class="header-anchor" href="#2-5-3-节练习">¶</a>2.5.3 节练习</h5>
<ul>
<li>
<p>练习 2.36：关于下面的代码，请指出每一个变量的类型以及程序结束时它们各自的值。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) c = a;</span><br><span class="line"><span class="keyword">decltype</span>((b)) d = a;</span><br><span class="line">++c;</span><br><span class="line">++d;</span><br></pre></td></tr></table></figure>
<p>解：</p>
<ul>
<li><code>a</code>、<code>b</code> 和 <code>c</code> 都为 <code>int</code> 型对象，<code>d</code> 为绑定到 <code>int</code> 型对象 <code>a</code> 上的 <code>int</code> 型引用。</li>
<li>运行结束后 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 的值都为 4。</li>
</ul>
</li>
<li>
<p>练习 2.37：赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，<strong>如果 <code>i</code> 是 <code>int</code>，则表达式 <code>i = x</code> 的类型是 <code>int&amp;</code></strong>。根据这一特点，请指出下面的代码中每一个变量的类型和值。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) c = a;</span><br><span class="line"><span class="keyword">decltype</span>(a = b) d = a;</span><br></pre></td></tr></table></figure>
<p>解：</p>
<ul>
<li><code>a</code> <code>b</code> 和 <code>c</code> 为 <code>int</code> 型对象，<code>d</code> 为绑定到 <code>int</code> 型对象 <code>a</code> 的 <code>int</code> 型引用。</li>
<li><code>a</code>、<code>c</code> 和 <code>d</code> 的值为 3，<code>b</code> 的值为 4。</li>
</ul>
</li>
<li>
<p>练习 2.38：说明由 <code>decltype</code> 指定类型和由 <code>auto</code> 指定类型有何区别。请举出一个例子，<code>decltype</code> 指定的类型与 <code>auto</code> 指定的类型一样；再举一个例子，<code>decltype</code> 指定的类型与 <code>auto</code> 指定的类型不一样。</p>
<p>解：</p>
<p>区别：</p>
<ol>
<li>
<p>两者处理顶层 <code>const</code> 方式不同：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> a = ci;        <span class="comment">// a 是 int 型对象，顶层 const 被忽略掉了</span></span><br><span class="line"><span class="keyword">decltype</span>(ci) b = <span class="number">1</span>; <span class="comment">// b 是 int 型常量，顶层 const 未忽略</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>处理表达式方式不同：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>, &amp;cr = i;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, *p = &amp;a;</span><br><span class="line"><span class="keyword">auto</span> j = i + <span class="number">0</span>;       <span class="comment">// j 推断为 int 型对象</span></span><br><span class="line"><span class="keyword">decltype</span>(cr) k = a;   <span class="comment">// k 为绑定到 int 型对象 a 上的常量引用。表达式本身是一个引用，那么 decltype 返回对应类型的引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 decltype 使用的表达式的结果类型可以作为一条赋值语句的左值，那么 decltype 返回一个引用类型，例如解引用操作和变量加括号的类型</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c = a;   <span class="comment">// c 为绑定到 int 型对象 a 上的引用</span></span><br><span class="line"><span class="keyword">decltype</span>((a)) d = a;  <span class="comment">// d 为绑定到 int 型对象 a 上的引用</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) e = a;  <span class="comment">// d 为绑定到 int 型对象 a 上的常量引用</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其它情况相同，如：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// auto 和 decltype 相同的情况</span></span><br><span class="line"><span class="keyword">auto</span> j = j;</span><br><span class="line"><span class="keyword">decltype</span>(i) k = i;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-6-自定义数据结构"><a class="header-anchor" href="#2-6-自定义数据结构">¶</a>2.6 自定义数据结构</h3>
<h4 id="2-6-1-定义-Sales-data-类型"><a class="header-anchor" href="#2-6-1-定义-Sales-data-类型">¶</a>2.6.1 定义 <code>Sales_data</code> 类型</h4>
<p><code>Sales_data</code> 初步定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>类体右侧的表示结束的花括号后必须写一个分号</strong>。</p>
<blockquote>
<p><strong>提示</strong>：</p>
<hr>
<p>这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span> <span class="comment">/* ... */</span> &#125; accum, trans, *salesptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与上一条语句等价，但可能更好一些</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">Sales_data accum, trans, *salesptr;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>C++11</strong>：</p>
<hr>
<p>C++11 新标准规定，可以为数据成员提供一个 <strong>类内初始值</strong> (in-class initializer)。</p>
</blockquote>
<h5 id="2-6-1-节练习"><a class="header-anchor" href="#2-6-1-节练习">¶</a>2.6.1 节练习</h5>
<ul>
<li>
<p>练习 2.39：编译下面的程序观察其运行结果，注意，如果忘记写类定义体后面的分号会发生什么情况？记录下相关信息，以后可能会有用。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span> <span class="comment">/* 此处为空 */</span> &#125; <span class="comment">// 注意：没有分号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解：</p>
<p>编译输出：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\prog1.cc:1:34: error: expected &#39;;&#39; after struct</span><br><span class="line">struct Foo &#123; &#x2F;* 此处为空 *&#x2F; &#125;</span><br><span class="line">                             ^</span><br><span class="line">                             ;</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>练习 2.40：根据自己的理解写出 <code>Sales_data</code> 类，最好与书中的例子有所区别。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-6-2-使用-Sales-data-类"><a class="header-anchor" href="#2-6-2-使用-Sales-data-类">¶</a>2.6.2 使用 <code>Sales_data</code> 类</h4>
<h5 id="添加两个-Sales-data-对象"><a class="header-anchor" href="#添加两个-Sales-data-对象">¶</a>添加两个 <code>Sales_data</code> 对象</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sales_data.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sales_data data1, data2;</span><br><span class="line">    <span class="comment">// 读入 data1 和 data2 的代码</span></span><br><span class="line">    <span class="comment">// 检查 data1 和 data2 的 ISBN 是否相同的代码</span></span><br><span class="line">    <span class="comment">// 如果相同，求 data1 和 data2 的总和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Sales-data-对象读入数据"><a class="header-anchor" href="#Sales-data-对象读入数据">¶</a><code>Sales_data</code> 对象读入数据</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> price = <span class="number">0</span>; <span class="comment">// 书的单价，用于计算销售收入</span></span><br><span class="line"><span class="comment">// 读入 1 笔交易：ISBN、销售数量、单价</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; data1.bookNo &gt;&gt; data1.units_sold &gt;&gt; price;</span><br><span class="line"><span class="comment">// 计算销售收入</span></span><br><span class="line">data1.revenue = data1.units_sold * price;</span><br><span class="line"><span class="comment">// 读入第 2 笔交易</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; data2.bookNo &gt;&gt; data2.units_sold &gt;&gt; price;</span><br><span class="line">data2.revenue = data2.units_sold * price;</span><br></pre></td></tr></table></figure>
<h5 id="输出两个-Sales-data-对象的和"><a class="header-anchor" href="#输出两个-Sales-data-对象的和">¶</a>输出两个 <code>Sales_data</code> 对象的和</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(data1.bookNo == data2.bookNo) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> totalCnt = data1.units_sold + data2.units_sold;</span><br><span class="line">    <span class="keyword">double</span> totalRevenue = data1.revenue + data2.revenue;</span><br><span class="line">    <span class="comment">// 输出：ISBN、总销售量、总销售额、平均价格</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; data1.bookNo &lt;&lt; <span class="string">""</span> &lt;&lt; totalCnt</span><br><span class="line">              &lt;&lt; <span class="string">" "</span> &lt;&lt; totalRevenue &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">if</span>(totalCnt != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; totalRevenu / totalCnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" (no sales) "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 标示成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// 两笔交易的 ISBN 不一样</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Data must refer to the same ISBN"</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 标示失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-6-2-节练习"><a class="header-anchor" href="#2-6-2-节练习">¶</a>2.6.2 节练习</h5>
<ul>
<li>
<p>练习 2.41：使用你自己的 <code>Sales_data</code> 类重写 1.5.1 节 (P20)、1.5.2 节 (P21) 和 1.6 节 (P22) 的练习。眼下先把 <code>Sales_data</code> 类的定义和 <code>main</code> 函数放在同一个文件里。</p>
<p>解：略。</p>
</li>
</ul>
<h4 id="2-6-3-编写自己的头文件"><a class="header-anchor" href="#2-6-3-编写自己的头文件">¶</a>2.6.3 编写自己的头文件</h4>
<p>尽管如第 19.7 节 (P754) 所讲 <strong>可以在函数体内定义类</strong>，但是这样的类毕竟受到了一些限制。所以，<strong>类一般都不定义在函数体内</strong>。</p>
<p>为了确保各个文件中类的定义一致，<strong>类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。</strong></p>
<p>头文件通常包含那些只能被定义一次的实体，如类、<code>const</code> 和 <code>constexpr</code> 变量 (参见第 2.4节，P54) 等。</p>
<h5 id="预处理器概述"><a class="header-anchor" href="#预处理器概述">¶</a>预处理器概述</h5>
<p><strong>预处理器</strong> (preprocessor) 是在编译之前执行的一段程序，可以部分地改变我们所写的程序。</p>
<p>C++ 程序会用到的一项预处理功能是 <strong>头文件保护符</strong> (header guard)，头文件保护符依赖于预处理变量 (第 2.3.2 节，P48)。</p>
<p>预处理变量有两种状态：</p>
<ul>
<li>已定义状态：<code>#define</code> 指令把一个名字设定为预处理变量；当且仅当变量已定义时 <code>#ifdef</code> 为真。</li>
<li>未定义状态。当且仅当变量未定义时 <code>#ifndef</code> 为真。</li>
</ul>
<p>一旦检查结果为真，则执行后续操作直到遇到 <code>#endif</code> 指令为止：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>预处理变量无视 C++ 语言中关于作用域的规则。</p>
</blockquote>
<blockquote>
<p><strong>最佳实践</strong>：</p>
<hr>
<p>头文件即使 (目前还) 没有被包含在任何其它头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要。</p>
</blockquote>
<h5 id="2-6-3-节练习"><a class="header-anchor" href="#2-6-3-节练习">¶</a>2.6.3 节练习</h5>
<ul>
<li>
<p>练习 2.42：根据你自己的理解重写一个 <code>Sales_data.h</code> 头文件，并以此为基础重做 2.6.2 节 ( 第 67 页) 的练习。</p>
<p>解：略。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Entity Framework Core 3.1 教程</title>
    <url>/2020/04/18/Entity%20Framework%20Core%203.1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>Entity Framework Core 3.1 教程</h1>
<h2 id="一、Entity-Framework-Core-简介"><a class="header-anchor" href="#一、Entity-Framework-Core-简介">¶</a>一、Entity Framework Core 简介</h2>
<h3 id="EF-Core-开发方法"><a class="header-anchor" href="#EF-Core-开发方法">¶</a>EF Core 开发方法</h3>
<p>EF Core 支持两种开发方法：</p>
<ul>
<li>
<p>Code-First (代码优先)：在 Code-First 方法中，EF Core API 会根据你的代码中的领域模型中提供的约定和配置，使用迁移来创建数据库和表。此方法在领域驱动设计 (DDD) 中很有用。</p>
</li>
<li>
<p>Database-First (数据库优先)：在 Database-First 方法中，EF Core API 使用 EF Core 命令基于现有数据库创建领域模型和数据库上下文 (DbContext) 类。由于它不支持可视设计器或向导，因此在 EF Core 中的支持有限。</p>
</li>
</ul>
<p>EF  Core 主要针对 Code-First 方法，很少提供对 Database-First 方法的支持，因为从 EF Core  2.0 开始不支持可视化的 DB 模型设计器或向导。</p>
<h2 id="二、安装-Entity-Framework-Core"><a class="header-anchor" href="#二、安装-Entity-Framework-Core">¶</a>二、安装 Entity Framework Core</h2>
<p>EF Core 不是 .NET Core 和标准 .NET 框架的一部分。它以 NuGet 软件包的形式提供。您需要在应用程序中安装两个 NuGet 软件包，才能在应用程序中使用 EF Core：</p>
<ul>
<li>EF Core DB Provider</li>
<li>EF Core Tools</li>
</ul>
<p>EF Core 的安装步骤：</p>
<ol>
<li>
<p>新建新项目，如空控制台项目：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; mkdir EFCoreTutorials</span><br><span class="line">PM&gt; cd EFCoreTutorials</span><br><span class="line">PM&gt; dotnet new console</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装 EF Core DB Provider，以 SQL Server 为例，其它 Provider 参考 <a href="https://docs.microsoft.com/zh-cn/ef/core/providers/?tabs=dotnet-core-cli" target="_blank" rel="noopener">EF Core Provider 列表</a>：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet add package Microsoft.EntityFrameworkCore.SqlServer</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装 EF Core Tools：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet add package Microsoft.EntityFrameworkCore.Tools</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装 EF Core CLI 工具。具体安装和使用方法参考 <a href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/dotnet" target="_blank" rel="noopener">Entity Framework Core 工具参考-.NET CLI</a>：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet add package Microsoft.EntityFrameworkCore.Design</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为项目生成 <em>.config\dotnet-tools.json</em> 文件，没有此文件无法 <strong>为项目</strong> 安装 dotnet-ef  工具。参考上一步中的链接中 <a href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/dotnet" target="_blank" rel="noopener">tool manifest file</a> 说明：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet new tool<span class="literal">-manifest</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装 dotnet-ef 工具：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet tool install dotnet-ef</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="三、在-Entity-Framework-Core-中为现有数据库创建模型-即-Database-First-方法"><a class="header-anchor" href="#三、在-Entity-Framework-Core-中为现有数据库创建模型-即-Database-First-方法">¶</a>三、在 Entity Framework Core 中为现有数据库创建模型 (即 Database-First 方法)</h2>
<p>EF Core 不支持用于可视化设计器的 DB 模型和向导来创建类似于 EF 6 的实体和上下文类。</p>
<p>让我们在下面显示的本地 MS SQL Server 中为以下 SchoolDB 数据库创建实体和上下文类。因此，我们需要使用 <code>Scaffold-DbContext</code> 或 <code>dotnet ef dbcontext scaffold</code> 命令进行 <a href="https://docs.microsoft.com/zh-cn/ef/core/managing-schemas/scaffolding" target="_blank" rel="noopener">反向工程</a>。此反向工程命令基于现有数据库的架构创建实体和上下文类 (通过派生 <code>DbContext</code>)。</p>
<p><img src="/images/efcore/20200207210923466.png" alt="图3-1"></p>
<h3 id="dotnet-ef-dbcontext-scaffold-命令"><a class="header-anchor" href="#dotnet-ef-dbcontext-scaffold-命令">¶</a><code>dotnet ef dbcontext scaffold</code> 命令</h3>
<p>使用 <code>dotnet ef dbcontext scaffold</code> 基于现有数据库创建模型：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet ef dbcontext scaffold [-<span class="type">Connection</span>] [-<span class="type">Provider</span>] [-<span class="type">OutputDir</span>] [-<span class="type">Context</span>] [-<span class="type">Schemas</span>&gt;] [-<span class="type">Tables</span>&gt;] </span><br><span class="line">                    [-<span class="type">DataAnnotations</span>] [-<span class="type">Force</span>] [-<span class="type">Project</span>] [-<span class="type">StartupProject</span>] [&lt;<span class="type">CommonParameters</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>反向本例中的数据库：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet ef dbcontext scaffold <span class="string">"Server=.\SQLExpress;Database=SchoolDB;Trusted_Connection=True;"</span> Microsoft.EntityFrameworkCore.SqlServer <span class="literal">-OutputDir</span> Models</span><br></pre></td></tr></table></figure>
<p>在上面的命令中：</p>
<ul>
<li>第一个参数是一个连接字符串，它包括三个部分：
<ul>
<li>数据库服务器, 数据库名称和安全信息。在这里，<code>Server=.\SQLExpress;</code> 指本地 SQL Server Express 数据库服务器。</li>
<li><code>Database=SchoolDB;</code>  指定我们要为其创建类的数据库名称 “SchoolDB”。</li>
<li><code>Trusted_Connection=True;</code> 指定 Windows 身份验证。<br>
它将使用 Windows 凭据连接到 SQL Server。</li>
</ul>
</li>
<li>第二个参数是提供程序名称。我们将提供程序用于 SQL Server，因此它是 <code>Microsoft.EntityFrameworkCore.SqlServer</code>。</li>
<li><code>-OutputDir</code> 参数指定我们要在其中生成所有类的目录，在本例中为_Models_ 文件夹。</li>
</ul>
<p>上面的 <code>dotnet ef dbcontext scaffold</code> 命令使用为 <em>Models</em> 文件夹中所有实体的 Fluent API 配置为SchoolDB 数据库中的每个表创建实体类，并通过派生 DbContext 创建数据库上下文类。<br>
以下是为 Student 表生成的 <code>Student</code> 实体类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">namespace EFCoreTutorials.Models &#123;</span><br><span class="line">    public partial class Student &#123;</span><br><span class="line">        public Student() &#123;</span><br><span class="line">            StudentCourse &#x3D; new HashSet&lt;StudentCourse&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int StudentId &#123; get; set; &#125;</span><br><span class="line">        public string FirstName &#123; get; set; &#125;</span><br><span class="line">        public string LastName &#123; get; set; &#125;</span><br><span class="line">        public int? StandardId &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">        public Standard Standard &#123; get; set; &#125;</span><br><span class="line">        public StudentAddress StudentAddress &#123; get; set; &#125;</span><br><span class="line">        public ICollection&lt;StudentCourse&gt; StudentCourse &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是 <code>SchoolDBContext</code> 类，可用于保存或检索数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using Microsoft.EntityFrameworkCore;</span><br><span class="line">using Microsoft.EntityFrameworkCore.Metadata;</span><br><span class="line"></span><br><span class="line">namespace EFCoreTutorials.Models &#123;</span><br><span class="line">    public partial class SchoolDBContext : DbContext &#123;</span><br><span class="line">        public virtual DbSet&lt;Course&gt; Course &#123; get; set; &#125;</span><br><span class="line">        public virtual DbSet&lt;Standard&gt; Standard &#123; get; set; &#125;</span><br><span class="line">        public virtual DbSet&lt;Student&gt; Student &#123; get; set; &#125;</span><br><span class="line">        public virtual DbSet&lt;StudentAddress&gt; StudentAddress &#123; get; set; &#125;</span><br><span class="line">        public virtual DbSet&lt;StudentCourse&gt; StudentCourse &#123; get; set; &#125;</span><br><span class="line">        public virtual DbSet&lt;Teacher&gt; Teacher &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;</span><br><span class="line">            if (!optionsBuilder.IsConfigured) &#123;</span><br><span class="line">#warning To protect potentially sensitive information in your connection string, you should move it out of source code. See http:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkId&#x3D;723263 for guidance on storing connection strings.</span><br><span class="line">                optionsBuilder.UseSqlServer(@&quot;Server&#x3D;.\SQLExpress;Database&#x3D;SchoolDB;Trusted_Connection&#x3D;True;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;</span><br><span class="line">            modelBuilder.Entity&lt;Course&gt;(entity &#x3D;&gt; &#123;</span><br><span class="line">                entity.Property(e &#x3D;&gt; e.CourseName)</span><br><span class="line">                    .HasMaxLength(50)</span><br><span class="line">                    .IsUnicode(false);</span><br><span class="line"></span><br><span class="line">                entity.HasOne(d &#x3D;&gt; d.Teacher)</span><br><span class="line">                    .WithMany(p &#x3D;&gt; p.Course)</span><br><span class="line">                    .HasForeignKey(d &#x3D;&gt; d.TeacherId)</span><br><span class="line">                    .OnDelete(DeleteBehavior.Cascade)</span><br><span class="line">                    .HasConstraintName(&quot;FK_Course_Teacher&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            modelBuilder.Entity&lt;Standard&gt;(entity &#x3D;&gt; &#123;</span><br><span class="line">                entity.Property(e &#x3D;&gt; e.Description)</span><br><span class="line">                    .HasMaxLength(50)</span><br><span class="line">                    .IsUnicode(false);</span><br><span class="line"></span><br><span class="line">                entity.Property(e &#x3D;&gt; e.StandardName)</span><br><span class="line">                    .HasMaxLength(50)</span><br><span class="line">                    .IsUnicode(false);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            modelBuilder.Entity&lt;Student&gt;(entity &#x3D;&gt; &#123;</span><br><span class="line">                entity.Property(e &#x3D;&gt; e.StudentId).HasColumnName(&quot;StudentID&quot;);</span><br><span class="line"></span><br><span class="line">                entity.Property(e &#x3D;&gt; e.FirstName)</span><br><span class="line">                    .HasMaxLength(50)</span><br><span class="line">                    .IsUnicode(false);</span><br><span class="line"></span><br><span class="line">                entity.Property(e &#x3D;&gt; e.LastName)</span><br><span class="line">                    .HasMaxLength(50)</span><br><span class="line">                    .IsUnicode(false);</span><br><span class="line"></span><br><span class="line">                entity.HasOne(d &#x3D;&gt; d.Standard)</span><br><span class="line">                    .WithMany(p &#x3D;&gt; p.Student)</span><br><span class="line">                    .HasForeignKey(d &#x3D;&gt; d.StandardId)</span><br><span class="line">                    .OnDelete(DeleteBehavior.Cascade)</span><br><span class="line">                    .HasConstraintName(&quot;FK_Student_Standard&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            modelBuilder.Entity&lt;StudentAddress&gt;(entity &#x3D;&gt; &#123;</span><br><span class="line">                entity.HasKey(e &#x3D;&gt; e.StudentId);</span><br><span class="line"></span><br><span class="line">                entity.Property(e &#x3D;&gt; e.StudentId)</span><br><span class="line">                    .HasColumnName(&quot;StudentID&quot;)</span><br><span class="line">                    .ValueGeneratedNever();</span><br><span class="line"></span><br><span class="line">                entity.Property(e &#x3D;&gt; e.Address1)</span><br><span class="line">                    .IsRequired()</span><br><span class="line">                    .HasMaxLength(50)</span><br><span class="line">                    .IsUnicode(false);</span><br><span class="line"></span><br><span class="line">                entity.Property(e &#x3D;&gt; e.Address2)</span><br><span class="line">                    .HasMaxLength(50)</span><br><span class="line">                    .IsUnicode(false);</span><br><span class="line"></span><br><span class="line">                entity.Property(e &#x3D;&gt; e.City)</span><br><span class="line">                    .IsRequired()</span><br><span class="line">                    .HasMaxLength(50)</span><br><span class="line">                    .IsUnicode(false);</span><br><span class="line"></span><br><span class="line">                entity.Property(e &#x3D;&gt; e.State)</span><br><span class="line">                    .IsRequired()</span><br><span class="line">                    .HasMaxLength(50)</span><br><span class="line">                    .IsUnicode(false);</span><br><span class="line"></span><br><span class="line">                entity.HasOne(d &#x3D;&gt; d.Student)</span><br><span class="line">                    .WithOne(p &#x3D;&gt; p.StudentAddress)</span><br><span class="line">                    .HasForeignKey&lt;StudentAddress&gt;(d &#x3D;&gt; d.StudentId)</span><br><span class="line">                    .HasConstraintName(&quot;FK_StudentAddress_Student&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            modelBuilder.Entity&lt;StudentCourse&gt;(entity &#x3D;&gt; &#123;</span><br><span class="line">                entity.HasKey(e &#x3D;&gt; new &#123; e.StudentId, e.CourseId &#125;);</span><br><span class="line"></span><br><span class="line">                entity.HasOne(d &#x3D;&gt; d.Course)</span><br><span class="line">                    .WithMany(p &#x3D;&gt; p.StudentCourse)</span><br><span class="line">                    .HasForeignKey(d &#x3D;&gt; d.CourseId)</span><br><span class="line">                    .OnDelete(DeleteBehavior.ClientSetNull)</span><br><span class="line">                    .HasConstraintName(&quot;FK_StudentCourse_Course&quot;);</span><br><span class="line"></span><br><span class="line">                entity.HasOne(d &#x3D;&gt; d.Student)</span><br><span class="line">                    .WithMany(p &#x3D;&gt; p.StudentCourse)</span><br><span class="line">                    .HasForeignKey(d &#x3D;&gt; d.StudentId)</span><br><span class="line">                    .HasConstraintName(&quot;FK_StudentCourse_Student&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            modelBuilder.Entity&lt;Teacher&gt;(entity &#x3D;&gt; &#123;</span><br><span class="line">                entity.Property(e &#x3D;&gt; e.StandardId).HasDefaultValueSql(&quot;((0))&quot;);</span><br><span class="line"></span><br><span class="line">                entity.Property(e &#x3D;&gt; e.TeacherName)</span><br><span class="line">                    .HasMaxLength(50)</span><br><span class="line">                    .IsUnicode(false);</span><br><span class="line"></span><br><span class="line">                entity.HasOne(d &#x3D;&gt; d.Standard)</span><br><span class="line">                    .WithMany(p &#x3D;&gt; p.Teacher)</span><br><span class="line">                    .HasForeignKey(d &#x3D;&gt; d.StandardId)</span><br><span class="line">                    .OnDelete(DeleteBehavior.Cascade)</span><br><span class="line">                    .HasConstraintName(&quot;FK_Teacher_Standard&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p><strong>创建模型后，无论何时更改模型，都必须使用“迁移”命令，以使数据库与模型保持最新。</strong></p>
</blockquote>
<h2 id="四、Entity-Framework-Core：DbContext"><a class="header-anchor" href="#四、Entity-Framework-Core：DbContext">¶</a>四、Entity Framework Core：<code>DbContext</code></h2>
<p><code>DbContext</code> 类是 Entity Framework Core 的组成部分。<code>DbContext</code> 实例代表与数据库的会话，可用于查询实体实例并将其保存到数据库。<strong><code>DbContext</code> 是工作单元和存储库模式的组合。</strong></p>
<p>EF Core 中的 <code>DbContext</code> 允许我们执行以下任务：</p>
<ul>
<li>管理数据库连接</li>
<li>配置模型和关系</li>
<li>查询数据库</li>
<li>将数据保存到数据库</li>
<li>配置变更跟踪</li>
<li>缓存</li>
<li>事务管理</li>
</ul>
<p>要在我们的应用程序中使用 <code>DbContext</code>，我们需要创建从 <code>DbContext</code> 派生的类，也称为上下文类。**该上下文类通常包括模型中每个实体的 <code>DbSet&lt;TEntity&gt;</code> 属性。**以下为 EF Core 中 <code>DbContext</code> 类的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SchoolContext : DbContext &#123;</span><br><span class="line">    public SchoolContext() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;实体</span><br><span class="line">    public DbSet&lt;Student&gt; Students &#123; get; set; &#125;</span><br><span class="line">    public DbSet&lt;Course&gt; Courses &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>SchoolContext</code> 类派生自 <code>DbContext</code> 类。</p>
<ul>
<li><code>OnConfiguring()</code> 方法允许我们使用 <code>DbContextOptionsBuilder</code> 选择和配置要与上下文一起使用的 <strong>数据源</strong>。在此处了解如何配置 <code>DbContext</code> 类。</li>
<li><code>OnModelCreating()</code> 方法允许我们使用 ModelBuilder Fluent API 配置 <strong>模型</strong>。</li>
</ul>
<h3 id="DbContext-的方法"><a class="header-anchor" href="#DbContext-的方法">¶</a><code>DbContext</code> 的方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Add</code></td>
<td style="text-align:center">将一个新实体添加到具有添加状态的 <code>DbContext</code> 中，并开始对其进行跟踪。调用 <code>SaveChanges()</code> 时，会将新的实体数据插入数据库。</td>
</tr>
<tr>
<td style="text-align:center"><code>AddAsync</code></td>
<td style="text-align:center">用于向状态为“已添加”的 <code>DbContext</code> 添加新实体并开始对其进行跟踪的异步方法。调用 <code>SaveChangesAsync()</code> 时，会将新的实体数据插入数据库。</td>
</tr>
<tr>
<td style="text-align:center"><code>AddRange</code></td>
<td style="text-align:center">将具有添加状态的新实体集合添加到 <code>DbContext</code> 并开始对其进行跟踪。调用 <code>SaveChanges()</code> 时，会将新的实体数据插入数据库。</td>
</tr>
<tr>
<td style="text-align:center"><code>AddRangeAsync</code></td>
<td style="text-align:center">用于添加将保存在 <code>SaveChangesAsync()</code> 上的新实体集合的异步方法。</td>
</tr>
<tr>
<td style="text-align:center"><code>Attach</code></td>
<td style="text-align:center">将新的或现有的实体附加到状态不变的 <code>DbContext</code> 并开始跟踪它。</td>
</tr>
<tr>
<td style="text-align:center"><code>AttachRange</code></td>
<td style="text-align:center">将新实体或现有实体的集合以未更改的状态附加到 <code>DbContext</code> 并开始对其进行跟踪。</td>
</tr>
<tr>
<td style="text-align:center"><code>Entry</code></td>
<td style="text-align:center">获取给定实体的 <code>EntityEntry</code>。该条目提供对实体的更改跟踪信息和操作的访问。</td>
</tr>
<tr>
<td style="text-align:center"><code>Find</code></td>
<td style="text-align:center">查找具有给定主键值的实体。</td>
</tr>
<tr>
<td style="text-align:center"><code>FindAsync</code></td>
<td style="text-align:center">用于查找具有给定主键值的实体的异步方法。</td>
</tr>
<tr>
<td style="text-align:center"><code>Remove</code></td>
<td style="text-align:center">移除将删除状态设置为指定的实体，当调用 <code>SaveChanges()</code> 时，该实体将删除数据。</td>
</tr>
<tr>
<td style="text-align:center"><code>RemoveRange</code></td>
<td style="text-align:center">将 <code>Deleted</code> 状态设置为一组实体，这些实体将在调用 <code>SaveChanges()</code> 时在一次数据库往返中删除数据。</td>
</tr>
<tr>
<td style="text-align:center"><code>SaveChanges</code></td>
<td style="text-align:center">对状态为 <code>Added</code>，<code>Modified</code> 或 <code>Removed</code> 的实体执行 <code>INSERT</code>，<code>UPDATE</code> 或 <code>DELETE</code> 命令到数据库。</td>
</tr>
<tr>
<td style="text-align:center"><code>SaveChangesAsync</code></td>
<td style="text-align:center"><code>SaveChanges()</code> 的异步方法</td>
</tr>
<tr>
<td style="text-align:center"><code>Set</code></td>
<td style="text-align:center">创建一个 <code>DbSet&lt;TEntity&gt;</code>，可用于查询和保存 <code>TEntity</code> 的实例。</td>
</tr>
<tr>
<td style="text-align:center"><code>Update</code></td>
<td style="text-align:center">附加状态为 <code>Modified</code> 的断开连接的实体，并开始对其进行跟踪。调用 <code>SaveChagnes()</code> 时将保存数据。</td>
</tr>
<tr>
<td style="text-align:center"><code>UpdateRange</code></td>
<td style="text-align:center">附加状态为 <code>Modified</code> 的断开连接的实体的集合，并开始对其进行跟踪。调用 <code>SaveChagnes()</code> 时将保存数据。</td>
</tr>
<tr>
<td style="text-align:center"><code>OnConfiguring</code></td>
<td style="text-align:center">重写此方法，以配置要用于此上下文的数据库 (和其他选项)。创建的上下文的每个实例都会调用此方法。</td>
</tr>
<tr>
<td style="text-align:center"><code>OnModelCreating</code></td>
<td style="text-align:center">重写此方法，以进一步配置根据约定从派生上下文的 <code>DbSet&lt;TEntity&gt;</code> 属性中公开的实体类型发现的模型。</td>
</tr>
</tbody>
</table>
<h3 id="DbContext-属性"><a class="header-anchor" href="#DbContext-属性">¶</a><code>DbContext</code> 属性</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ChangeTracker</code></td>
<td style="text-align:center">提供对该上下文正在跟踪的实体实例的信息和操作的访问。</td>
</tr>
<tr>
<td style="text-align:center"><code>Database</code></td>
<td style="text-align:center">提供对此上下文的数据库相关信息和操作的访问。</td>
</tr>
<tr>
<td style="text-align:center"><code>Model</code></td>
<td style="text-align:center">返回有关实体的形状，它们之间的关系以及它们如何映射到数据库的元数据。</td>
</tr>
</tbody>
</table>
<h2 id="五、第一个-EF-Core-控制台应用程序"><a class="header-anchor" href="#五、第一个-EF-Core-控制台应用程序">¶</a>五、第一个 EF Core 控制台应用程序</h2>
<h3 id="创建模型"><a class="header-anchor" href="#创建模型">¶</a>创建模型</h3>
<p>EF 模型包括三个部分：</p>
<ul>
<li>概念模型</li>
<li>存储模型</li>
<li>概念模型和存储模型之间的映射。</li>
</ul>
<p>Code-First 方法中，EF 根据您的领域类 (实体类)，上下文类和配置来构建概念模型。 EF Core <strong>根据您使用的提供程序</strong> 构建存储模型和映射。例如，与 DB2 相比，SQL Server 的存储模型将有所不同。</p>
<p>我们需要首先创建实体类和上下文类。以下是学生和课程的简单实体类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public int StudentId &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Course &#123;</span><br><span class="line">    public int CourseId &#123; get; set; &#125;</span><br><span class="line">    public string CourseName &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们需要通过派生 <code>DbContext</code> 来创建上下文类，如上一章所示。以下 <code>SchoolContext</code> 类也称为上下文类。</p>
<h4 id="在上下文类内配置数据库连接"><a class="header-anchor" href="#在上下文类内配置数据库连接">¶</a>在上下文类内配置数据库连接</h4>
<p><code>SchoolContext</code> 类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace EFCoreTutorials &#123;</span><br><span class="line">    public class SchoolContext : DbContext &#123;</span><br><span class="line">        &#x2F;&#x2F; 映射到 Student 表</span><br><span class="line">        public DbSet&lt;Student&gt; Students &#123; get; set; &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 映射到 Course 表</span><br><span class="line">        public DbSet&lt;Course&gt; Courses &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; DbContextOptionsBuilder 的实例用于指定要使用的数据库</span><br><span class="line">        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;</span><br><span class="line">            optionsBuilder.UseSqlServer(@&quot;Server&#x3D;.\SQLEXPRESS;Database&#x3D;SchoolDB;Trusted_Connection&#x3D;True;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用依赖注入的方式配置数据库连接"><a class="header-anchor" href="#用依赖注入的方式配置数据库连接">¶</a>用依赖注入的方式配置数据库连接</h4>
<p><code>SchoolContext</code> 类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace EFCoreTutorials &#123;</span><br><span class="line">    public class SchoolContext : DbContext &#123;</span><br><span class="line">        &#x2F;&#x2F; 映射到 Student 表</span><br><span class="line">        public DbSet&lt;Student&gt; Students &#123; get; set; &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 映射到 Course 表</span><br><span class="line">        public DbSet&lt;Course&gt; Courses &#123; get; set; &#125;</span><br><span class="line">        </span><br><span class="line">        public readonly DbContextOptions _dbContextOptions;</span><br><span class="line">        </span><br><span class="line">        public SchoolContext(DbContextOptions&lt;SchoolContext&gt; options): base(options) &#123;</span><br><span class="line">            _dbContextOptions &#x3D; options;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Startup</code> 类中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace EFCoreTutorials &#123;</span><br><span class="line">    public class Startup &#123;</span><br><span class="line">        private readonly IConfiguration _configuration;</span><br><span class="line"></span><br><span class="line">        public Startup(IConfiguration configuration) &#123;</span><br><span class="line">            _configuration &#x3D; configuration;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public void ConfigureServices(IServiceCollection services) &#123;</span><br><span class="line">            ...</span><br><span class="line">            services.AddDbContextPool&lt;SchoolContext&gt;(options &#x3D;&gt; options.UseSqlServer(_configuration.GetConnectionString(&quot;SchoolDBConnection&quot;)));</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <em>appsettings.json</em> 中：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "ConnectionStrings": &#123;</span><br><span class="line">        <span class="comment">// Trusted_Connection=True、Integrated Security=SSPI、Integrated Security=True 都代表使用 Windows 身份认证</span></span><br><span class="line">        "SchoolDBConnection": "Server=.\SQLEXPRESS;Database=SchoolDB;Trusted_Connection=True;"</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本项目为 Console 项目，无法使用依赖注入。</p>
<h3 id="添加迁移"><a class="header-anchor" href="#添加迁移">¶</a>添加迁移</h3>
<p>此时，尚无 SchoolDB 数据库。因此，我们需要通过添加迁移从模型 (实体和上下文) 创建数据库。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet ef migrations add CreateSchoolDB</span><br></pre></td></tr></table></figure>
<p>这将在项目中创建一个名为 <em>Migrations</em> 的新文件夹，并创建 ModelSnapshot_ (<strong>迁移脚本文件</strong>，此时并未写入数据库) 文件。</p>
<p>创建迁移脚本后，我们需要将更改更新至数据库：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet ef database update</span><br></pre></td></tr></table></figure>
<p>这将使用 <code>UseSqlServer()</code> 方法中的连接字符串中指定的名称和位置创建数据库。它将为每个 <code>DbSet</code> 属性 (学生和课程) 创建一个表。</p>
<p>现在，<strong>无论何时添加或更新域类或配置，我们都需要使用 <code>dotnet ef migrations add</code> 和 <code>dotnet ef database update</code> 命令将数据库与模型同步。</strong></p>
<h3 id="读取或写入数据"><a class="header-anchor" href="#读取或写入数据">¶</a>读取或写入数据</h3>
<p>现在，我们可以使用上下文类来保存和检索数据，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace EFCoreTutorials &#123;</span><br><span class="line">    class Program &#123;</span><br><span class="line">        static void Main(string[] args) &#123;</span><br><span class="line">            using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line"></span><br><span class="line">                var std &#x3D; new Student() &#123;</span><br><span class="line">                     Name &#x3D; &quot;Bill&quot;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                context.Students.Add(std);</span><br><span class="line">                context.SaveChanges();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、Entity-Framework-Core-中的查询"><a class="header-anchor" href="#六、Entity-Framework-Core-中的查询">¶</a>六、Entity Framework Core 中的查询</h2>
<p>Entity Framework Core 允许你在模型中使用导航属性来加载相关实体。有三种常见的 ORM 模式可用于加载关联数据:</p>
<ul>
<li>Eager loading (预先加载)：表示从数据库中加载关联数据，作为初始查询的一部分。</li>
<li>Explicit loading (显式加载)：表示稍后从数据库中显式加载关联数据。</li>
<li>Lazy loading (延迟加载)：表示在访问导航属性时，从数据库中以透明方式加载关联数据。</li>
</ul>
<p>访问 <a href="https://www.entityframeworktutorial.net/querying-entity-graph-in-entity-framework.aspx" target="_blank" rel="noopener">LINQ-to-Entities</a> 一章，以了解有关 Entity Framework 中查询基础的更多信息。</p>
<h3 id="查询中的-C-VB-NET-函数"><a class="header-anchor" href="#查询中的-C-VB-NET-函数">¶</a>查询中的 C# / <a href="http://VB.NET" target="_blank" rel="noopener">VB.NET</a> 函数</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static void Main(string[] args) &#123;</span><br><span class="line">    var context &#x3D; new SchoolContext();</span><br><span class="line">    var studentsWithSameName &#x3D; context.Students</span><br><span class="line">                                      .Where(s &#x3D;&gt; s.FirstName &#x3D;&#x3D; GetName())</span><br><span class="line">                                      .ToList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static string GetName() &#123;</span><br><span class="line">    return &quot;Bill&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将在数据库中执行以下查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec sp_executesql N&#39;SELECT [s].[StudentId], [s].[DoB], [s].[FirstName], </span><br><span class="line">    [s].[GradeId], [s].[LastName], [s].[MiddleName]</span><br><span class="line">FROM [Students] AS [s]</span><br><span class="line">WHERE [s].[FirstName] &#x3D; @__GetName_0&#39;,N&#39;@__GetName_0 nvarchar(4000)&#39;,</span><br><span class="line">    @__GetName_0&#x3D;N&#39;Bill&#39;</span><br><span class="line">Go</span><br></pre></td></tr></table></figure>
<h3 id="Eager-Loading-预先加载"><a class="header-anchor" href="#Eager-Loading-预先加载">¶</a>Eager Loading 预先加载</h3>
<p>Entity Framework Core 支持使用 <code>Include()</code> 扩展方法和投影查询来快速加载相关实体。除此之外，它还提供了 <code>ThenInclude()</code> 扩展方法来加载多个级别的相关实体。</p>
<h4 id="Include"><a class="header-anchor" href="#Include">¶</a><code>Include</code></h4>
<p>我们可以在 <code>Include()</code> 方法中将 lambda 表达式指定为参数，以指定导航属性，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">var studentWithGrade &#x3D; context.Students</span><br><span class="line">                           .Where(s &#x3D;&gt; s.FirstName &#x3D;&#x3D; &quot;Bill&quot;)</span><br><span class="line">                           .Include(s &#x3D;&gt; s.Grade)</span><br><span class="line">                           .FirstOrDefault();</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>.Include(s =&gt; s.Grade)</code> 传递 lambda 表达式 <code>s =&gt; s.Grade</code>，以指定引用属性，该属性将在单个 SQL 查询中与来自数据库的 <code>Student</code> 实体数据一起加载。上面的查询在数据库中执行以下 SQL 查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TOP(1) [s].[StudentId], [s].[DoB], [s].[FirstName], [s].[GradeId],[s].[LastName], </span><br><span class="line">        [s].[MiddleName], [s.Grade].[GradeId], [s.Grade].[GradeName], [s.Grade].[Section]</span><br><span class="line">FROM [Students] AS [s]</span><br><span class="line">LEFT JOIN [Grades] AS [s.Grade] ON [s].[GradeId] &#x3D; [s.Grade].[GradeId]</span><br><span class="line">WHERE [s].[FirstName] &#x3D; N&#39;Bill&#39;</span><br></pre></td></tr></table></figure>
<p>我们还可以在 <code>Include()</code> 方法中将属性名称指定为字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">var studentWithGrade &#x3D; context.Students</span><br><span class="line">                        .Where(s &#x3D;&gt; s.FirstName &#x3D;&#x3D; &quot;Bill&quot;)</span><br><span class="line">                        .Include(&quot;Grade&quot;)</span><br><span class="line">                        .FirstOrDefault();</span><br></pre></td></tr></table></figure>
<p><strong>不建议使用上面的示例，因为如果属性名称拼写错误或不存在，则会抛出运行时异常。</strong> 始终对 lambda 表达式使用 <code>Include()</code> 方法，以便可以在编译时检测到错误。</p>
<p><code>Include()</code> 扩展方法也可以在 <code>FromSql()</code> 方法之后使用，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">var studentWithGrade &#x3D; context.Students</span><br><span class="line">                        .FromSql(&quot;Select * from Students where FirstName &#x3D;&#39;Bill&#39;&quot;)</span><br><span class="line">                        .Include(s &#x3D;&gt; s.Grade)</span><br><span class="line">                        .FirstOrDefault();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p><code>DbSet.Find()</code>方法之后不能使用 <code>Include()</code> 扩展方法。例如。在 EF Core 2.0 中无法使用 <code>context.Students.Find(1).Include()</code>。在将来的版本中这可能是可能的。</p>
</blockquote>
<p>多次使用 <code>Include()</code> 方法来加载同一实体的多个导航属性。例如，以下代码加载与 <code>Student</code> 的 <code>Grade</code> 和 <code>StudentCourses</code> 相关的实体。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">var studentWithGrade &#x3D; context.Students.Where(s &#x3D;&gt; s.FirstName &#x3D;&#x3D; &quot;Bill&quot;)</span><br><span class="line">                        .Include(s &#x3D;&gt; s.Grade)</span><br><span class="line">                        .Include(s &#x3D;&gt; s.StudentCourses)</span><br><span class="line">                        .FirstOrDefault();</span><br></pre></td></tr></table></figure>
<p>上面的查询将在单个数据库往返中执行两个 SQL 查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TOP(1) [s].[StudentId], [s].[DoB], [s].[FirstName], [s].[GradeId], [s].[LastName], </span><br><span class="line">        [s].[MiddleName], [s.Grade].[GradeId], [s.Grade].[GradeName], [s.Grade].[Section]</span><br><span class="line">FROM [Students] AS [s]</span><br><span class="line">LEFT JOIN [Grades] AS [s.Grade] ON [s].[GradeId] &#x3D; [s.Grade].[GradeId]</span><br><span class="line">WHERE [s].[FirstName] &#x3D; N&#39;Bill&#39;</span><br><span class="line">ORDER BY [s].[StudentId]</span><br><span class="line">Go</span><br><span class="line"></span><br><span class="line">SELECT [s.StudentCourses].[StudentId], [s.StudentCourses].[CourseId]</span><br><span class="line">FROM [StudentCourses] AS [s.StudentCourses]</span><br><span class="line">INNER JOIN (</span><br><span class="line">    SELECT DISTINCT [t].*</span><br><span class="line">    FROM (</span><br><span class="line">        SELECT TOP(1) [s0].[StudentId]</span><br><span class="line">        FROM [Students] AS [s0]</span><br><span class="line">        LEFT JOIN [Grades] AS [s.Grade0] ON [s0].[GradeId] &#x3D; [s.Grade0].[GradeId]</span><br><span class="line">        WHERE [s0].[FirstName] &#x3D; N&#39;Bill&#39;</span><br><span class="line">        ORDER BY [s0].[StudentId]</span><br><span class="line">    ) AS [t]</span><br><span class="line">) AS [t0] ON [s.StudentCourses].[StudentId] &#x3D; [t0].[StudentId]</span><br><span class="line">ORDER BY [t0].[StudentId]</span><br><span class="line">Go</span><br></pre></td></tr></table></figure>
<h4 id="ThenInclude"><a class="header-anchor" href="#ThenInclude">¶</a><code>ThenInclude</code></h4>
<p>EF Core 引入了新的 <code>ThenInclude()</code> 扩展方法，以加载多个级别的相关实体。考虑以下示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">var student &#x3D; context.Students.Where(s &#x3D;&gt; s.FirstName &#x3D;&#x3D; &quot;Bill&quot;)</span><br><span class="line">                        .Include(s &#x3D;&gt; s.Grade)</span><br><span class="line">                        .ThenInclude(g &#x3D;&gt; g.Teachers)</span><br><span class="line">                        .FirstOrDefault();</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>.Include(s =&gt; s.Grade)</code> 将加载 <code>Student</code> 实体的 <code>Grade</code> 导航属性。 <code>.ThenInclude(g =&gt; g.Teachers)</code> 将加载 <code>Grade</code> 实体的<code> Teacher</code> 集合属性。必须在 <code>Include</code> 方法之后调用<code> ThenInclude</code> 方法。上面的代码将在数据库中执行以下 SQL 查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TOP(1) [s].[StudentId], [s].[DoB], [s].[FirstName], [s].[GradeId], [s].[LastName],</span><br><span class="line">         [s].[MiddleName], [s.Grade].[GradeId], [s.Grade].[GradeName], [s.Grade].[Section]</span><br><span class="line">FROM [Students] AS [s]</span><br><span class="line">LEFT JOIN [Grades] AS [s.Grade] ON [s].[GradeId] &#x3D; [s.Grade].[GradeId]</span><br><span class="line">WHERE [s].[FirstName] &#x3D; N&#39;Bill&#39;</span><br><span class="line">ORDER BY [s.Grade].[GradeId]</span><br><span class="line">Go</span><br><span class="line"></span><br><span class="line">SELECT [s.Grade.Teachers].[TeacherId], [s.Grade.Teachers].[GradeId], [s.Grade.Teachers].[Name]</span><br><span class="line">FROM [Teachers] AS [s.Grade.Teachers]</span><br><span class="line">INNER JOIN (</span><br><span class="line">    SELECT DISTINCT [t].*</span><br><span class="line">    FROM (</span><br><span class="line">        SELECT TOP(1) [s.Grade0].[GradeId]</span><br><span class="line">        FROM [Students] AS [s0]</span><br><span class="line">        LEFT JOIN [Grades] AS [s.Grade0] ON [s0].[GradeId] &#x3D; [s.Grade0].[GradeId]</span><br><span class="line">        WHERE [s0].[FirstName] &#x3D; N&#39;Bill&#39;</span><br><span class="line">        ORDER BY [s.Grade0].[GradeId]</span><br><span class="line">    ) AS [t]</span><br><span class="line">) AS [t0] ON [s.Grade.Teachers].[GradeId] &#x3D; [t0].[GradeId]</span><br><span class="line">ORDER BY [t0].[GradeId]</span><br><span class="line">Go</span><br></pre></td></tr></table></figure>
<h4 id="Projection-Query-投影查询"><a class="header-anchor" href="#Projection-Query-投影查询">¶</a>Projection Query (投影查询)</h4>
<p>我们还可以通过使用投影查询而不是 <code>Include()</code> 或 <code>ThenInclude()</code> 方法来加载多个相关实体。以下示例演示了用于加载 <code>Student</code>，<code>Grade</code> 和 <code>Teacher</code> 实体的投影查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">var stud &#x3D; context.Students.Where(s &#x3D;&gt; s.FirstName &#x3D;&#x3D; &quot;Bill&quot;)</span><br><span class="line">                        .Select(s &#x3D;&gt; new</span><br><span class="line">                        &#123;</span><br><span class="line">                            Student &#x3D; s,</span><br><span class="line">                            Grade &#x3D; s.Grade,</span><br><span class="line">                            GradeTeachers &#x3D; s.Grade.Teachers</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .FirstOrDefault();</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>.Select</code> 扩展方法用于在结果中包括 <code>Student</code>、 <code>Grade</code> 和 <code>Teacher</code> 实体。这将执行与上述 <code>ThenInclude()</code>  方法相同的 SQL 查询。</p>
<h2 id="七、Entity-Framework-Core-在连接模式下保存数据"><a class="header-anchor" href="#七、Entity-Framework-Core-在连接模式下保存数据">¶</a>七、Entity Framework Core 在连接模式下保存数据</h2>
<p>Entity Framework Core 提供了不同的方法来添加，更新或删除基础数据库中的数据。一个实体的标量属性中包含的数据将根据其 <code>EntityState</code> 插入，更新或删除。<br>
保存实体数据有两种方案：</p>
<ul>
<li>连接模式</li>
<li>断开模式</li>
</ul>
<p>在本章中仅学习有关在连接的场景中保存数据的知识。下图说明了所连接场景中的CUD (创建，更新，删除) 操作。<br>
<img src="/images/efcore/save-data-in-connected-scenario.png" alt="图7-1"><br>
如上图所示，当调用 <code>DbContext.SaveChanges()</code> 方法时，Entity Framework 为其 <code>EntityState</code> 被添加，修改或删除的实体生成并执行 <code>INSERT</code>，<code>UPDATE</code> 或 <code>DELETE</code> 语句。在连接的场景中，<strong><code>DbContext</code> 实例跟踪所有实体，因此每当创建，修改或删除实体时，它都会自动为每个实体设置适当的 <code>EntityState</code>。</strong></p>
<h3 id="插入数据"><a class="header-anchor" href="#插入数据">¶</a>插入数据</h3>
<p><code>DbSet.Add</code> 和 <code>DbContext.Add</code> 方法将新实体添加到上下文 (<code>DbContext</code> 的实例)，当您调用 <code>SaveChanges()</code> 方法时，该实体将在数据库中插入新记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    var std &#x3D; new Student() &#123;</span><br><span class="line">        FirstName &#x3D; &quot;Bill&quot;,</span><br><span class="line">        LastName &#x3D; &quot;Gates&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    context.Students.Add(std);</span><br><span class="line">    &#x2F;&#x2F; or</span><br><span class="line">    &#x2F;&#x2F; context.Add&lt;Student&gt;(std);</span><br><span class="line">    context.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>context.Students.Add(std)</code> 将一个新创建的 <code>Student</code> 实体实例添加到具有 <code>EntityState.Added</code> 的上下文中。 EF Core 引入了新的<code>DbContext.Add</code> 方法，该方法与 <code>DbSet.Add</code> 方法具有相同的作用。此后，<code>SaveChanges()</code> 方法将生成并执行以下对数据库的 <code>INSERT</code> 语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec sp_executesql N&#39;SET NOCOUNT ON;</span><br><span class="line">INSERT INTO [Students] ( [FirstName], [LastName])</span><br><span class="line">VALUES (@p0, @p1);</span><br><span class="line">SELECT [StudentId]</span><br><span class="line">FROM [Students]</span><br><span class="line">WHERE @@ROWCOUNT &#x3D; 1 AND [StudentId] &#x3D; scope_identity();&#39;,N</span><br><span class="line">&#39;@p0 nvarchar(4000), @p1 nvarchar(4000) &#39;,@p0&#x3D;N&#39;Bill&#39;,@p1&#x3D;N&#39;Gates&#39;</span><br><span class="line">Go</span><br></pre></td></tr></table></figure>
<h3 id="更新数据"><a class="header-anchor" href="#更新数据">¶</a>更新数据</h3>
<p>在连接的场景中，EF Core API 跟踪使用上下文检索的所有实体。因此，当您编辑实体数据时，EF 会自动将 <code>EntityState</code> 标记为 <code>Modified</code>，这将在您调用 <code>SaveChanges()</code> 方法时在数据库中产生更新的语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    var std &#x3D; context.Students.First&lt;Student&gt;(); </span><br><span class="line">    std.FirstName &#x3D; &quot;Steve&quot;;</span><br><span class="line">    context.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们使用 <code>context.Students.First&lt;Student&gt;()</code> 从数据库中检索第一个学生。一旦修改了 <code>FirstName</code>，由于在 <code>DbContext</code> 实例 (上下文) 的范围内执行了修改，因此上下文将其 <code>EntityState</code> 设置为 <code>Modified</code>。因此，当我们调用 <code>SaveChanges()</code> 方法时，它将在数据库中生成并执行以下 <code>Update</code> 语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec sp_executesql N&#39;SET NOCOUNT ON;</span><br><span class="line">UPDATE [Students] SET [FirstName] &#x3D; @p0</span><br><span class="line">WHERE [StudentId] &#x3D; @p1;</span><br><span class="line">SELECT @@ROWCOUNT;</span><br><span class="line">&#39;,N&#39;@p1 int,@p0 nvarchar(4000)&#39;,@p1&#x3D;1,@p0&#x3D;N&#39;Steve&#39;</span><br><span class="line">Go</span><br></pre></td></tr></table></figure>
<p>在更新语句中，EF Core API 包括具有修改后值的属性，其余部分将被忽略。在上面的示例中，仅 <code>FirstName</code> 属性被编辑，因此 <code>update</code> 语句仅包含 <code>FirstName</code> 列。</p>
<h3 id="删除数据"><a class="header-anchor" href="#删除数据">¶</a>删除数据</h3>
<p>使用 <code>DbSet.Remove()</code> 或 <code>DbContext.Remove</code> 方法删除数据库表中的记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    var std &#x3D; context.Students.First&lt;Student&gt;();</span><br><span class="line">    context.Students.Remove(std);</span><br><span class="line">    &#x2F;&#x2F; or</span><br><span class="line">    &#x2F;&#x2F; context.Remove&lt;Student&gt;(std);</span><br><span class="line">    context.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>context.Students.Remove(std)</code>  或者 <code>context.Remove&lt;Students&gt;(std)</code> 将 <code>std</code> 实体对象标记为 <code>Deleted</code>。因此，EF Core 将在数据库中生成并执行以下 <code>DELETE</code> 语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec sp_executesql N&#39;SET NOCOUNT ON;</span><br><span class="line">DELETE FROM [Students]</span><br><span class="line">WHERE [StudentId] &#x3D; @p0;</span><br><span class="line">SELECT @@ROWCOUNT;</span><br><span class="line">&#39;,N&#39;@p0 int&#39;,@p0&#x3D;1</span><br><span class="line">Go</span><br></pre></td></tr></table></figure>
<h2 id="八、Entity-Framework-Core-中的约定"><a class="header-anchor" href="#八、Entity-Framework-Core-中的约定">¶</a>八、Entity Framework Core 中的约定</h2>
<p>约定是，使用 Entity Framework 根据您的领域模型 (实体) 类构建模型时的默认规则。</p>
<p>以下示例为应用程序的领域模型 (实体) 和数据库上下文类，它遵循默认约定，无需配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public int StudentId &#123; get; set; &#125;</span><br><span class="line">    public string FirstName &#123; get; set; &#125;</span><br><span class="line">    public string LastName &#123; get; set; &#125;</span><br><span class="line">    public DateTime DateOfBirth &#123; get; set; &#125;</span><br><span class="line">    public byte[] Photo &#123; get; set; &#125;</span><br><span class="line">    public decimal Height &#123; get; set; &#125;</span><br><span class="line">    public float Weight &#123; get; set; &#125;</span><br><span class="line">    public int GradeId &#123; get; set; &#125;</span><br><span class="line">    public Grade Grade &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Grade &#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string GradeName &#123; get; set; &#125;</span><br><span class="line">    public string Section &#123; get; set; &#125;</span><br><span class="line">    public IList&lt;Student&gt; Students &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SchoolContext : DbContext &#123;</span><br><span class="line">    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)</span><br><span class="line">    &#123; </span><br><span class="line">        optionsBuilder.UseSqlServer(@&quot;Server&#x3D;.\SQLEXPRESS;Database&#x3D;SchoolDB;Trusted_Connection&#x3D;True;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DbSet&lt;Student&gt; Students &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Table-表"><a class="header-anchor" href="#Table-表">¶</a>Table (表)</h3>
<p>EF Core 将为上下文类中与属性名称相同的所有 <code>DbSet&lt;TEntity&gt;</code> 属性创建数据库表。<strong>它还将为实体创建表，这些表不包含在 <code>DbSet</code> 属性中，但可以通过其他 <code>DbSet</code> 实体中的引用属性访问。</strong> 对于上面的示例，即使 <code>SchoolContext</code> 类不包含<code>DbSet&lt;Grade&gt;</code> 属性，EF Core 也会在 <code>SchoolContext</code> 类中为 <code>DbSet&lt;Student&gt;</code> 属性创建 <code>Students</code> 表，在 <code>Student</code> 实体类中为 <code>Grade</code> 属性创建 <code>Grade</code> 表。</p>
<p><img src="/images/efcore/20200207213507370.png" alt="图8-1"></p>
<h3 id="Column-列"><a class="header-anchor" href="#Column-列">¶</a>Column (列)</h3>
<p>默认情况下，EF Core 将为实体类的所有基本类型的属性创建与该属性同名的列。它使用引用类属性和集合属性在数据库中相应表之间建立关系。</p>
<p><img src="/images/efcore/20200207213522900.png" alt="图8-2"></p>
<h3 id="列数据类型-Column-Data-Type"><a class="header-anchor" href="#列数据类型-Column-Data-Type">¶</a>列数据类型 (Column Data Type)</h3>
<p>数据库表中列的数据类型取决于数据库提供程序如何将 C# 数据类型映射到所选数据库的数据类型。下表列出了 C# 数据类型到 SQL Server 列数据类型之间的映射。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>C# 数据类型</strong></th>
<th style="text-align:center"><strong>SQL Server数据类型</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center"><code>int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>string</code></td>
<td style="text-align:center"><code>nvarchar(Max)</code></td>
</tr>
<tr>
<td style="text-align:center"><code>decimal</code></td>
<td style="text-align:center"><code>decimal(18,2)</code></td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center"><code>real</code></td>
</tr>
<tr>
<td style="text-align:center"><code>byte[]</code></td>
<td style="text-align:center"><code>varbinary(Max)</code></td>
</tr>
<tr>
<td style="text-align:center"><code>datetime</code></td>
<td style="text-align:center"><code>datetime</code></td>
</tr>
<tr>
<td style="text-align:center"><code>bool</code></td>
<td style="text-align:center"><code>bit</code></td>
</tr>
<tr>
<td style="text-align:center"><code>byte</code></td>
<td style="text-align:center"><code>tinyint</code></td>
</tr>
<tr>
<td style="text-align:center"><code>short</code></td>
<td style="text-align:center"><code>smallint</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:center"><code>bigint</code></td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center"><code>float</code></td>
</tr>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center"><code>sbyte</code></td>
<td style="text-align:center">无 (会抛异常)</td>
</tr>
<tr>
<td style="text-align:center"><code>object</code></td>
<td style="text-align:center">无</td>
</tr>
</tbody>
</table>
<h3 id="Nullable-Column-可空列"><a class="header-anchor" href="#Nullable-Column-可空列">¶</a>Nullable Column (可空列)</h3>
<p>EF Core 为所有引用数据类型和可为空的原始类型属性创建可空列，例如 <code>string</code>、<code>Nullable&lt;int&gt;</code>、<code>decimal?</code> 等</p>
<h3 id="NotNull-Column-非空列"><a class="header-anchor" href="#NotNull-Column-非空列">¶</a>NotNull Column (非空列)</h3>
<p>EF Core 在数据库中为所有主键属性和原始类型属性创建 NotNull 列，例如 <code>int</code>、<code>float</code>、<code>decimal</code>、<code>DateTime</code> 等。</p>
<h3 id="Primary-Key-主键"><a class="header-anchor" href="#Primary-Key-主键">¶</a>Primary Key (主键)</h3>
<p>EF Core 将为名为 <code>Id</code> 或 <code>&lt;实体类名称&gt;Id</code> (不区分大小写) 的属性创建主键列。例如，如果 <code>Student</code> 类包含名为 <code>id</code>、<code>ID</code>、<code>iD</code>、<code>Id</code>、<code>studentid</code>、<code>StudentId</code>、<code>STUDENTID</code> 或 <code>sTUdentID</code> 的属性，则 EF Core 将在 <code>Student</code> 表中创建一列作为 PrimaryKey (主键)。</p>
<p><img src="/images/efcore/20200207213539655.png" alt="图8-3"></p>
<h3 id="Foreign-Key-外键"><a class="header-anchor" href="#Foreign-Key-外键">¶</a>Foreign Key (外键)</h3>
<p>根据外键约定，EF Core API 将使用以下命名模式之一为实体中的每个引用导航属性创建一个外键列：</p>
<ul>
<li>
<p><code>&lt;Reference Navigation Property Name&gt;Id</code></p>
</li>
<li>
<p><code>&lt;Reference Navigation Property Name&gt;</code></p>
</li>
<li>
<p><code>&lt;Principal Primary Key Property Name&gt;</code></p>
</li>
</ul>
<p>在我们的示例 (学生和成绩实体) 中，EF Core 将在 <code>Student</code> 表中创建一个外键列 <code>GradeId</code>，如下图所示。</p>
<p><img src="/images/efcore/20200207213556349.png" alt="图8-4"></p>
<p>下表列出了不同引用属性名称和主键属性名称的外键列名称:</p>
<table>
<thead>
<tr>
<th style="text-align:center">从属实体中的引用属性名称</th>
<th style="text-align:center">从属实体中的外键属性名称</th>
<th style="text-align:center">主体主键属性名称</th>
<th style="text-align:center">数据库中的外键列名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Grade</td>
<td style="text-align:center">GradeId</td>
<td style="text-align:center">GradeId</td>
<td style="text-align:center">GradeId</td>
</tr>
<tr>
<td style="text-align:center">Grade</td>
<td style="text-align:center">-</td>
<td style="text-align:center">GradeId</td>
<td style="text-align:center">GradeId</td>
</tr>
<tr>
<td style="text-align:center">Grade</td>
<td style="text-align:center">-</td>
<td style="text-align:center">Id</td>
<td style="text-align:center">GradeId</td>
</tr>
<tr>
<td style="text-align:center">CurrentGrade</td>
<td style="text-align:center">CurrentGradeId</td>
<td style="text-align:center">GradeId</td>
<td style="text-align:center">CurrentGradeId</td>
</tr>
<tr>
<td style="text-align:center">CurrentGrade</td>
<td style="text-align:center">-</td>
<td style="text-align:center">GradeId</td>
<td style="text-align:center">CurrentGradeGradeId</td>
</tr>
<tr>
<td style="text-align:center">CurrentGrade</td>
<td style="text-align:center">-</td>
<td style="text-align:center">Id</td>
<td style="text-align:center">CurrentGradeId</td>
</tr>
<tr>
<td style="text-align:center">CurrentGrade</td>
<td style="text-align:center">GradeId</td>
<td style="text-align:center">Id</td>
<td style="text-align:center">GradeId</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>笔记</strong>：</p>
<hr>
<p>即：</p>
<ul>
<li>从属实体有外键属性 (即符合上述外键列名称生成条件的属性) 时使用从属实体中的外键属性名称。</li>
<li>从属实体没有外键属性时：
<ul>
<li>第一步，按上述外键列名称生成条件生成一个列名。</li>
<li>第二步，判断主体主键属性名称是否是 <code>Id</code>、<code>ID</code>、<code>iD</code> 或 <code>id</code>。</li>
<li>第三步，如果主体主键是上一步的四个中之一，那么使用生成的外键名；如果不是那么列名 = 生成的外键列名 + 主体主键属性名。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="索引"><a class="header-anchor" href="#索引">¶</a>索引</h3>
<p>默认情况下，EF Core 在主键列上创建聚簇索引，在外键列上创建非聚簇索引。</p>
<h2 id="九、Entity-Framework-Core-中的一对多关系约定"><a class="header-anchor" href="#九、Entity-Framework-Core-中的一对多关系约定">¶</a>九、Entity Framework Core 中的一对多关系约定</h2>
<p>对于一对多关系，Entity Framework Core 遵循与 Entity Framework6.x 相同的约定。唯一的区别是 EF Core 创建的外键列的名称与导航属性名称相同，而不是与<code>&lt;NavigationPropertyName&gt;_&lt;PrimaryKeyPropertyName&gt;</code>。<br>
让我们看一下不同的约定，这些约定会自动在以下 <code>Student</code> 和 <code>Grade</code> 实体之间配置一对多关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public int StudentId &#123; get; set; &#125;</span><br><span class="line">    public string StudentName &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">public class Grade &#123;</span><br><span class="line">    public int GradeId &#123; get; set; &#125;</span><br><span class="line">    public string GradeName &#123; get; set; &#125;</span><br><span class="line">    public string Section &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的实体中应用了一对多关系的约定后，<code>Student</code> 和 <code>Grade</code> 实体的数据库表将如下所示，其中 <code>Student</code> 表包括外键 <code>GradeId</code>。</p>
<p><img src="/images/efcore/20200207214603619.png" alt="图9-1"></p>
<h3 id="约定一"><a class="header-anchor" href="#约定一">¶</a>约定一</h3>
<p>我们希望建立一对多的关系，其中许多学生与一个年级相关。可以通过在从属实体中包含引用导航属性来实现此目的，如下所示 (此处，学生实体是从属实体，而成绩实体是主要实体)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">   </span><br><span class="line">    public Grade Grade &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Grade &#123;</span><br><span class="line">    public int GradeId &#123; get; set; &#125;</span><br><span class="line">    public string GradeName &#123; get; set; &#125;</span><br><span class="line">    public string Section &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，学生实体类包括班级类型的引用导航属性。这使我们可以将同一年级链接到许多不同的学生实体，从而在它们之间建立一对多的关系。这将在数据库的“学生”和“成绩”表之间产生一对多关系，其中“学生”表包含可为空的外键 <code>GradeId</code>，如下所示。 EF Core 将为概念模型中名为 <code>GradeId</code> 的外键创建一个阴影属性，该属性将映射到 <code>Students</code> 表中的 <code>GradeId</code> 外键列。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>引用属性 <code>Grade</code> 是可为空的，因此它将在 <code>Student</code> 表中创建可为空的ForeignKey <code>GradeId</code>。您可以使用 fluent API 配置 NotNull 外键。</p>
</blockquote>
<p><img src="/images/efcore/20200207214616638.png" alt="图9-2"></p>
<h3 id="约定二"><a class="header-anchor" href="#约定二">¶</a>约定二</h3>
<p>另一个约定是在主体实体中包括集合导航属性，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public int StudentId &#123; get; set; &#125;</span><br><span class="line">    public string StudentName &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Grade &#123;</span><br><span class="line">    public int GradeId &#123; get; set; &#125;</span><br><span class="line">    public string GradeName &#123; get; set; &#125;</span><br><span class="line">    public string Section &#123; get; set; &#125;</span><br><span class="line">	&#x2F;&#x2F;集合导航属性</span><br><span class="line">    public ICollection&lt;Student&gt; Students &#123; get; set; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>Grade</code> 实体包括类型为 <code>ICollection&lt;Student&gt;</code> 的集合导航属性。这将使我们能够向班级实体添加多个“学生”实体，从而导致数据库中“学生”和“班级”表之间存在一对多的关系，与约定一的目的相同。</p>
<h3 id="约定三"><a class="header-anchor" href="#约定三">¶</a>约定三</h3>
<p>一对多关系的另一个 EF 约定是在两端都包含导航属性，这也将会时数据表产生一对多关系（约定一 + 约定二）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    &#x2F;&#x2F;引用导航属性</span><br><span class="line">    public Grade Grade &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Grade &#123;</span><br><span class="line">    public int GradeID &#123; get; set; &#125;</span><br><span class="line">    public string GradeName &#123; get; set; &#125;</span><br><span class="line">    &#x2F;&#x2F;集合导航属性</span><br><span class="line">    public ICollection&lt;Student&gt; Students &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，学生实体包括班级类型的引用导航属性，班级实体类包括集合导航属性 <code>ICollection&lt;Student&gt;</code>，这导致相应的数据库表“学生”和“成绩”之间存在一对多关系，与约定一目的相同。</p>
<h3 id="约定四"><a class="header-anchor" href="#约定四">¶</a>约定四</h3>
<p>使用从属实体中的外键属性在两端完全定义该关系会创建一对多关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public int GradeId &#123; get; set; &#125;</span><br><span class="line">    public Grade Grade &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Grade &#123;</span><br><span class="line">    public int GradeId &#123; get; set; &#125;</span><br><span class="line">    public string GradeName &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public ICollection&lt;Student&gt; Students &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>Student</code> 实体包括类型为 <code>int</code> 的外键属性 <code>GradeId</code> 及其引用导航属性 <code>Grade</code>。在另一端，成绩实体还包括一个集合导航属性<code>ICollection&lt;Student&gt;</code>。这将与 <code>Student</code> 表中的 NotNull 外键列建立一对多关系，如下所示：</p>
<p><img src="/images/efcore/20200207214634262.png" alt="图9-3"></p>
<p>如果要将外键 <code>GradeId</code> 设置为可为空，则使用可为 <code>null</code> 的 <code>int</code> 数据类型 (<code>Nullable&lt;int&gt;</code> 或 <code>int?</code>)，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public int? GradeId &#123; get; set; &#125; </span><br><span class="line">    public Grade Grade &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些约定是在相应的数据库表中自动创建一对多关系的约定。如果实体不遵循上述约定，则可以使用 Fluent API 来配置一对多关系。</p>
<h2 id="十、Entity-Framework-Core-一对一关系约定"><a class="header-anchor" href="#十、Entity-Framework-Core-一对一关系约定">¶</a>十、Entity Framework Core 一对一关系约定</h2>
<p>Entity Framework Core 引入了 <strong>默认约定</strong>，该约定自动配置两个实体之间的一对一关系 (EF 6.x或更早版本不支持一对一关系的约定)。<br>
在 EF Core 中，一对一关系在 <strong>两侧都需要参考导航属性</strong>。下列 <code>Student</code> 和 <code>StudentAddress</code> 实体遵循一对一关系的约定:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">       </span><br><span class="line">    public StudentAddress Address &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StudentAddress &#123;</span><br><span class="line">    public int StudentAddressId &#123; get; set; &#125;</span><br><span class="line">    public string Address &#123; get; set; &#125;</span><br><span class="line">    public string City &#123; get; set; &#125;</span><br><span class="line">    public string State &#123; get; set; &#125;</span><br><span class="line">    public string Country &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public int StudentId &#123; get; set; &#125;</span><br><span class="line">    public Student Student &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>Student</code> 实体包括类型为 <code>StudentAddress</code> 的引用导航属性，而 <code>StudentAddress</code> 实体包括外键属性 <code>StudentId</code> 及其对应的引用属性 <code>Student</code> 。这将在数据库中的对应表 <code>Student</code> 和 <code>StudentAddresses</code> 中产生一对一的关系，如下所示：</p>
<p><img src="/images/efcore/20200207215111952.png" alt="图10-1"></p>
<p>EF Core 在 <code>StudentAddresses</code> 表的 NotNull 外键列 <code>StudentId</code> 上创建了唯一索引，如上所示。这样可以确保外键列 <code>StudentId</code> 的值在 <code>StudentAddress</code> 表中必须唯一，这是一对一关系所必需的。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>Entity Framework Core 支持唯一约束，但 EF 6 不支持唯一约束，因此 EF Core 包括一对一关系的约定，但不包括 EF6.x。如果实体不遵循约定，则使用 Fluent API 配置一对一关系。</p>
</blockquote>
<h2 id="十一、Entity-Framework-Core-配置"><a class="header-anchor" href="#十一、Entity-Framework-Core-配置">¶</a>十一、Entity Framework Core 配置</h2>
<p>您已在上一章中了解了 EF Core 中的 <strong>默认约定</strong>。很多时候，我们希望自定义实体到表的映射，并且不想遵循默认约定。 EF Core 允许我们配置领域实体类，以自定义 EF 模型到数据库的映射。此编程模式称为 <strong>约定优于配置</strong>。<br>
有两种方法可以在 EF Core 中配置领域实体类 (与 EF 6 中相同)：</p>
<ul>
<li>通过使用数据注释特性 (Data Annotation)</li>
<li>通过使用 Fluent API</li>
</ul>
<h3 id="数据注释特性-Data-Annotation-Attributes"><a class="header-anchor" href="#数据注释特性-Data-Annotation-Attributes">¶</a>数据注释特性 (Data Annotation Attributes)</h3>
<p>数据注释是一种基于特性的简单配置方法，其中可以将不同的.NET特性应用于领域模型类和属性以配置模型。<br>
数据注释属性不专用于 Entity Framework，因为它们在 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> MVC 中也使用。这就是为什么这些属性包含在单独的命名空间 <code>System.ComponentModel.DataAnnotations</code> 中的原因。<br>
下面的示例演示如何将数据注释特性应用于领域实体类和属性以覆盖约定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Table(&quot;StudentInfo&quot;)] &#x2F;&#x2F;定义映射的表名</span><br><span class="line">public class Student &#123;</span><br><span class="line">    public Student() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    [Key]&#x2F;&#x2F;定义主键</span><br><span class="line">    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]  &#x2F;&#x2F; 自增主键。其中 DatabaseGeneratedOption 的有三个属性：Identity：自增长、None：不处理、Computed：表示这一列是计算列。</span><br><span class="line">    public int SID &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    [Column(&quot;Name&quot;, TypeName&#x3D;&quot;ntext&quot;)]&#x2F;&#x2F;定义列名及类型</span><br><span class="line">    [MaxLength(20)]</span><br><span class="line">    public string StudentName &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    [NotMapped] &#x2F;&#x2F;不在数据库中生成列</span><br><span class="line">    public int? Age &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public int StdId &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    [ForeignKey(&quot;StdId&quot;)] &#x2F;&#x2F;定义外键</span><br><span class="line">    public virtual Standard Standard &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据注释特性在 EF 6 和 EF Core 中相同。有关更多信息，请访问 EF 6 部分中的“数据注释”一章。</p>
<h3 id="Fluent-API"><a class="header-anchor" href="#Fluent-API">¶</a>Fluent API</h3>
<p>配置领域模型类的另一种方法是使用 Entity Framework Fluent API。EF Fluent API 基于 Fluent API 设计模式 (也称为 Fluent 接口)，其中结果通过方法链来表示，下一节我们将介绍。</p>
<h2 id="十二、Entity-Framework-Core-Fluent-API"><a class="header-anchor" href="#十二、Entity-Framework-Core-Fluent-API">¶</a>十二、Entity Framework Core Fluent API</h2>
<p><strong>Entity Framework Core Fluent API 用于配置领域实体类以覆盖约定</strong>。EF Fluent API 基于 Fluent API 设计模式 (也称为 Fluent 接口)，其中结果通过方法链来表示。</p>
<p>在 Entity Framework Core 中，<code>ModelBuilder</code> 类充当 Fluent API。通过使用它，我们可以配置许多不同的东西，因为它提供了比数据注释属性更多的配置选项。<br>
Entity Framework Core Fluent API 配置了模型的以下方面：</p>
<ul>
<li>
<p><strong>模型配置</strong>：将 EF 模型配置为数据库映射。配置默认架构，数据库功能，其他数据注释属性和要从映射中排除的实体。</p>
</li>
<li>
<p><strong>实体配置</strong>：配置实体到表和关系的映射，例如 PrimaryKey、AlternateKey、Index、表名、一对一、一对多、多对多关系等。</p>
</li>
<li>
<p><strong>属性配置</strong>：将属性配置为列映射，例如列名称、默认值、可空性、外键、数据类型、并发列等。</p>
</li>
</ul>
<p>下表列出了每种配置类型的重要方法：</p>
<table>
    <thead>
        <tr>
            <th style="text-align: center">配置</th>
            <th style="text-align: center"><span style="font-wegiht: bold">Fluent API 方法</span></th>
            <th style="text-align: center">用法</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="4" style="text-align: center; vertical-align: middle">模型配置</td>
            <td style="text-align: center"><code>HasDbFunction()</code></td>
            <td style="text-align: center">在定位关系数据库时配置数据库功能</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasDefaultSchema()</code></td>
            <td style="text-align: center">指定数据库架构</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasAnnotation()</code></td>
            <td style="text-align: center">在实体上添加或更新数据注释属性</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasSequence()</code></td>
            <td style="text-align: center">定位关系数据库时配置数据库序列</td>
        </tr>
        <tr>
            <td rowspan="8" style="text-align: center; vertical-align: middle">实体配置</td>
            <td style="text-align: center"><code>HasAlternateKey()</code></td>
            <td style="text-align: center">在 EF 模型中为实体配置备用密钥</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasIndex()</code></td>
            <td style="text-align: center">配置指定属性的索引</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasKey()</code></td>
            <td style="text-align: center">将属性或属性列表配置为主键</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasMany()</code></td>
            <td style="text-align: center">配置关系的“很多”部分，其中实体包含一对多或多对多关系的其他类型的引用集合属性</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasOne()</code></td>
            <td style="text-align: center">配置关系的“一部分”，其中实体包含一对一或一对多关系的其他类型的引用属性</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>Ignore()</code></td>
            <td style="text-align: center">配置不应将类或属性映射到表或列</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>OwnsOne()</code></td>
            <td style="text-align: center">配置关系，其中目标实体由该实体拥有。目标实体键值是从它所属的实体传播的</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>ToTable()</code></td>
            <td style="text-align: center">配置实体映射到的数据库表</td>
        </tr>
        <tr>
            <td rowspan="15" style="text-align: center; vertical-align: middle">属性配置</td>
            <td style="text-align: center"><code>HasColumnName()</code></td>
            <td style="text-align: center">在数据库中为属性配置相应的列名称</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasColumnType()</code></td>
            <td style="text-align: center">为属性配置数据库中相应列的数据类型</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasComputedColumnSql()</code></td>
            <td style="text-align: center">配置属性以在关系数据库为目标时映射到数据库中的计算列</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasDefaultValue()</code></td>
            <td style="text-align: center">为目标关系数据库配置属性映射到的列的默认值</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasDefaultValueSql()</code></td>
            <td style="text-align: center">在定位关系数据库时，为属性映射到的列配置默认值表达式</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasField()</code></td>
            <td style="text-align: center">在指定要与属性一起使用的后备字段</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasMaxLength()</code></td>
            <td style="text-align: center">配置可以存储在属性中的最大数据长度</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>IsConcurrencyToken()</code></td>
            <td style="text-align: center">将属性配置为用作乐观并发令牌</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>IsRequired()</code></td>
            <td style="text-align: center">配置属性的有效值是必需的还是 <code>null</code> 为有效值</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>IsRowVersion()</code></td>
            <td style="text-align: center">配置要在乐观并发检测中使用的属性</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>IsUnicode()</code></td>
            <td style="text-align: center">配置字符串属性，该属性可以包含或不包含 Unicode 字符</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>ValueGeneratedNever()</code></td>
            <td style="text-align: center">配置保存实体时不能具有生成值的属</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>ValueGeneratedOnAdd()</code></td>
            <td style="text-align: center">配置在保存新实体时属性具有生成的值</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>ValueGeneratedOnAddOrUpdate()</code></td>
            <td style="text-align: center">配置保存新实体或现有实体时属性具有生成的值</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>ValueGeneratedOnUpdate()</code></td>
            <td style="text-align: center">配置在保存现有实体时属性具有生成的值</td>
        </tr>
    </tbody>
</table>
<h3 id="Fluent-API-配置"><a class="header-anchor" href="#Fluent-API-配置">¶</a>Fluent API 配置</h3>
<p>重写 <code>OnModelCreating</code> 方法，并使用 <code>ModelBuilder</code> 类型的参数 <code>modelBuilder</code>来配置领域实体类，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SchoolDBContext: DbContext  &#123;</span><br><span class="line">    public DbSet&lt;Student&gt; Students &#123; get; set; &#125;</span><br><span class="line">        </span><br><span class="line">    protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;</span><br><span class="line">        &#x2F;&#x2F;Write Fluent API configurations here</span><br><span class="line">        &#x2F;&#x2F;Property Configurations</span><br><span class="line">        modelBuilder.Entity&lt;Student&gt;()</span><br><span class="line">                .Property(s &#x3D;&gt; s.StudentId)</span><br><span class="line">                .HasColumnName(&quot;Id&quot;)</span><br><span class="line">                .HasDefaultValue(0)</span><br><span class="line">                .IsRequired();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>ModelBuilder</code> Fluent API 实例用于通过调用链中的多个方法来配置属性。它配置 <code>Student</code> 实体的 <code>StudentId</code> 属性；它在单个语句而不是多个语句中使用 <code>HasColumnName</code> 配置名称，使用 <code>HasDefaultValue</code> 配置默认值，并使用 <code>IsRequired</code> 方法配置可空性。与多条语句相比，这提高了可读性，并且花费的时间更少，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Fluent API method chained calls</span><br><span class="line">modelBuilder.Entity&lt;Student&gt;()</span><br><span class="line">        .Property(s &#x3D;&gt; s.StudentId)</span><br><span class="line">        .HasColumnName(&quot;Id&quot;)</span><br><span class="line">        .HasDefaultValue(0)</span><br><span class="line">        .IsRequired();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Separate method calls</span><br><span class="line">modelBuilder.Entity&lt;Student&gt;().Property(s &#x3D;&gt; s.StudentId).HasColumnName(&quot;Id&quot;);</span><br><span class="line">modelBuilder.Entity&lt;Student&gt;().Property(s &#x3D;&gt; s.StudentId).HasDefaultValue(0);</span><br><span class="line">modelBuilder.Entity&lt;Student&gt;().Property(s &#x3D;&gt; s.StudentId).IsRequired();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>Fluent API配置的优先级高于数据注释属性。</p>
</blockquote>
<h2 id="十三、Entity-Framework-Core-Fluent-API-配置一对一关系"><a class="header-anchor" href="#十三、Entity-Framework-Core-Fluent-API-配置一对一关系">¶</a>十三、Entity Framework Core Fluent API 配置一对一关系</h2>
<p>通常，您不需要手动配置一对一关系，因为 EF Core 包含一对一关系的约定。但是，如果键或外键属性不遵循约定，则可以使用数据注释属性或 Fluent API 在两个实体之间配置一对一关系。<br>
让我们在以下不遵循外键约定的 <code>Student</code> 和 <code>StudentAddress</code> 实体之间配置一对一关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">       </span><br><span class="line">    public StudentAddress Address &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StudentAddress &#123;</span><br><span class="line">    public int StudentAddressId &#123; get; set; &#125;</span><br><span class="line">    public string Address &#123; get; set; &#125;</span><br><span class="line">    public string City &#123; get; set; &#125;</span><br><span class="line">    public string State &#123; get; set; &#125;</span><br><span class="line">    public string Country &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public int AddressOfStudentId &#123; get; set; &#125;</span><br><span class="line">    public Student Student &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要在 EF Core 中使用 Fluent API 配置一对一关系，请使用 <code>HasOne</code>、<code>WithOne</code> 和 <code>HasForeignKey</code> 方法，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SchoolContext : DbContext &#123;</span><br><span class="line">    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;</span><br><span class="line">        optionsBuilder.UseSqlServer(&quot;Server&#x3D;.\\SQLEXPRESS;Database&#x3D;EFCore-SchoolDB;Trusted_Connection&#x3D;True&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Student&gt;()</span><br><span class="line">            .HasOne&lt;StudentAddress&gt;(s &#x3D;&gt; s.Address)</span><br><span class="line">            .WithOne(ad &#x3D;&gt; ad.Student)</span><br><span class="line">            .HasForeignKey&lt;StudentAddress&gt;(ad &#x3D;&gt; ad.AddressOfStudentId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DbSet&lt;Student&gt; Students &#123; get; set; &#125;</span><br><span class="line">    public DbSet&lt;StudentAddress&gt; StudentAddresses &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，以下代码片段配置了一对一关系:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Student&gt;()</span><br><span class="line">    .HasOne&lt;StudentAddress&gt;(s &#x3D;&gt; s.Address)</span><br><span class="line">    .WithOne(ad &#x3D;&gt; ad.Student)</span><br><span class="line">    .HasForeignKey&lt;StudentAddress&gt;(ad &#x3D;&gt; ad.AddressOfStudentId);</span><br></pre></td></tr></table></figure>
<p>让我们逐步分析代码:</p>
<ol>
<li><code>modelBuilder.Entity&lt;Student&gt;()</code> 开始配置 <code>Student</code> 实体。</li>
<li><code>.HasOne&lt;StudentAddress&gt;(s =&gt; s.Address)</code> 方法使用 lambda 表达式指定 <code>Student</code> 实体包括一个 <code>StudentAddress</code> 引用属性。</li>
<li><code>.WithOne(ad =&gt; ad.Student)</code> 配置关系的另一端，<code>StudentAddress</code> 实体。它指定 <code>StudentAddress</code> 实体包括 <code>Student</code> 类型的参考导航属性。</li>
<li><code>.HasForeignKey&lt;StudentAddress&gt;(ad =&gt; ad.AddressOfStudentId)</code> 指定外键属性名称。</li>
</ol>
<p>现在，要将其反映在数据库中，请执行迁移命令，<code>add-migration &lt;名称&gt;</code> 和 <code>update-database</code>。该数据库将包括两个具有一对一关系的表，如下所示：</p>
<p><img src="/images/efcore/20200207221956122.png" alt="图13-1"></p>
<p>下图说明了一对一关系的 Fluent API 配置：</p>
<p><img src="/images/efcore/20200207222010325.png" alt="13-2"></p>
<p>您可以按照以下相同的方式开始使用 <code>StudentAddress</code> 实体进行配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modelBuilder.Entity&lt;StudentAddress&gt;()</span><br><span class="line">    .HasOne&lt;Student&gt;(ad &#x3D;&gt; ad.Student)</span><br><span class="line">    .WithOne(s &#x3D;&gt; s.Address)</span><br><span class="line">    .HasForeignKey&lt;StudentAddress&gt;(ad &#x3D;&gt; ad.AddressOfStudentId);</span><br></pre></td></tr></table></figure>
<p>因此，您可以在 Entity Framework Core 中配置一对一关系。</p>
<h2 id="十四、在-Entity-Framework-Core-Fluent-API-配置多对多关系"><a class="header-anchor" href="#十四、在-Entity-Framework-Core-Fluent-API-配置多对多关系">¶</a>十四、在 Entity Framework Core Fluent API 配置多对多关系</h2>
<p>让我们在以下学生和课程实体之间实现多对多关系，其中一个学生可以报名参加许多课程，并且以同样的方式，许多学生可以加入一门课程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public int StudentId &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Course &#123;</span><br><span class="line">    public int CourseId &#123; get; set; &#125;</span><br><span class="line">    public string CourseName &#123; get; set; &#125;</span><br><span class="line">    public string Description &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数据库中的多对多关系由联接表表示，联接表包括两个表的外键。同样，这些外键是复合主键。</strong></p>
<p><img src="/images/efcore/20200207222442650.png" alt="图14-1"></p>
<h3 id="约定"><a class="header-anchor" href="#约定">¶</a>约定</h3>
<p><strong>Entity Framework Core 中没有可用于自动配置多对多关系的默认约定</strong>。您必须使用 Fluent API 对其进行配置。</p>
<h3 id="Fluent-API-v2"><a class="header-anchor" href="#Fluent-API-v2">¶</a>Fluent API</h3>
<p>在 Entity Framework 6.x 或更低版本中，EF API 用于为多对多关系创建联接表。我们不需要为联接表创建联接实体 (但是，我们当然可以在 EF 6 中显式创建联接实体)。</p>
<p>在 Entity Framework Core 中，这尚未实现。<strong>我们必须为联接表创建联接实体类</strong>。上述学生和课程实体的加入实体应包括每个实体的外键属性和参考导航属性。</p>
<p>配置多对多关系的步骤如下:</p>
<ol>
<li>定义一个新的加入实体类，该类包括每个实体的外键属性和引用导航属性。</li>
<li>通过在两侧的实体中包括集合导航属性 (在本例中为“学生”和“课程”)，定义其他两个实体与加入实体之间的一对多关系。</li>
<li>使用 Fluent API 将加入实体中的两个外键都配置为组合键。<br>
因此，首先，定义连接实体 <code>StudentCourse</code>，如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StudentCourse &#123;</span><br><span class="line">    public int StudentId &#123; get; set; &#125;</span><br><span class="line">    public Student Student &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public int CourseId &#123; get; set; &#125;</span><br><span class="line">    public Course Course &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述加入实体 <code>StudentCourse</code> 分别包括引用导航属性 <code>Student</code> 和 <code>Course</code> 以及它们的外键属性 <code>StudentId</code> 和 <code>CourseId</code> (外键属性遵循约定)。<br>
现在，我们还需要在 <code>Student</code> -&gt; <code>StudentCourse</code> 和 <code>Course</code> -&gt; <code>StudentCourse</code> 实体之间配置两个单独的一对多关系。我们可以通过遵循一对多关系的约定来做到这一点，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public int StudentId &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public IList&lt;StudentCourse&gt; StudentCourses &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Course</span><br><span class="line">&#123;</span><br><span class="line">    public int CourseId &#123; get; set; &#125;</span><br><span class="line">    public string CourseName &#123; get; set; &#125;</span><br><span class="line">    public string Description &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public IList&lt;StudentCourse&gt; StudentCourses &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如您在上面所看到的，<code>Student</code> 和 <code>Course</code> 实体现在包括 <code>StudentCourse</code> 类型的集合导航属性。<code>StudentCourse</code> 实体已经包含了 <code>Student</code> 和 <code>Course</code> 的外键属性和导航属性。这使其在 <code>Student</code> 和 <code>StudentCourse</code> 与<code>Course</code> 和 <code>StudentCourse</code> 之间建立了完全定义的一对多关系。<br>
现在，外键必须是联接表中的复合主键。只能使用 Fluent API 进行配置，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SchoolContext : DbContext &#123;</span><br><span class="line">    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;</span><br><span class="line">        optionsBuilder.UseSqlServer(&quot;Server&#x3D;.\\SQLEXPRESS;Database&#x3D;EFCore-SchoolDB;Trusted_Connection&#x3D;True&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;</span><br><span class="line">        modelBuilder.Entity&lt;StudentCourse&gt;().HasKey(sc &#x3D;&gt; new &#123; sc.StudentId, sc.CourseId &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public DbSet&lt;Student&gt; Students &#123; get; set; &#125;</span><br><span class="line">    public DbSet&lt;Course&gt; Courses &#123; get; set; &#125;</span><br><span class="line">    public DbSet&lt;StudentCourse&gt; StudentCourses &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>modelBuilder.Entity&lt;StudentCourse&gt;().HasKey(sc =&gt; new { sc.StudentId, sc.CourseId })</code> 将 <code>StudentId</code> 和<code> CourseId</code> 配置为组合键。<br>
如果实体遵循与加入实体的一对多关系的约定，则可以通过这种方法配置多对多关系。假设外键属性名称不遵循约定 (例如，<code>SID</code> 代替 <code>StudentId</code>，<code>CID</code> 代替 <code>CourseId</code>)，则可以使用 Fluent API 对其进行配置，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modelBuilder.Entity&lt;StudentCourse&gt;().HasKey(sc &#x3D;&gt; new &#123; sc.SId, sc.CId &#125;);</span><br><span class="line"></span><br><span class="line">modelBuilder.Entity&lt;StudentCourse&gt;()</span><br><span class="line">    .HasOne&lt;Student&gt;(sc &#x3D;&gt; sc.Student)</span><br><span class="line">    .WithMany(s &#x3D;&gt; s.StudentCourses)</span><br><span class="line">    .HasForeignKey(sc &#x3D;&gt; sc.SId);</span><br><span class="line"></span><br><span class="line">modelBuilder.Entity&lt;StudentCourse&gt;()</span><br><span class="line">    .HasOne&lt;Course&gt;(sc &#x3D;&gt; sc.Course)</span><br><span class="line">    .WithMany(s &#x3D;&gt; s.StudentCourses)</span><br><span class="line">    .HasForeignKey(sc &#x3D;&gt; sc.CId);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>EF 团队将包含一项功能，将来我们无需为多对多关系创建加入实体。在 GitHub 上跟踪此问题。</p>
</blockquote>
<h2 id="十五、在-Entity-Framework-Core-的断开模式下插入数据"><a class="header-anchor" href="#十五、在-Entity-Framework-Core-的断开模式下插入数据">¶</a>十五、在 Entity Framework Core 的断开模式下插入数据</h2>
<p>在断开连接的方案中保存数据与在连接的方案中保存数据有些不同。在断开连接的情况下，<code>DbContext</code> 不知道断开连接的实体，因为在当前 <code>DbContext</code> 实例的范围之外添加或修改了实体。因此，您需要将断开连接的实体附加到具有适当 <code>EntityState</code> 的上下文，以便对数据库执行 CUD (创建，更新，删除) 操作。<br>
下图说明了断开连接情况下的 CUD 操作：</p>
<p><img src="/images/efcore/20200208105621549.png" alt="图14-1"></p>
<p>根据上图，断开的实体 (<code>DbContext</code> 不会跟踪的实体) 需要使用适当的 <code>EntityState</code> 附加到 <code>DbContext</code>。例如，新实体的已添加状态，已编辑实体的已修改状态和已删除实体的已删除状态，这将在调用 <code>SaveChanges()</code> 方法时在数据库中产生 <code>INSERT</code>，<code>UPDATE</code> 或 <code>DELETE</code> 命令。<br>
为了在断开连接的情况下使用 Entity Framework Core 将记录插入，更新或删除到 <code>DB</code> 表中，必须执行以下步骤：</p>
<ol>
<li>使用适当的 <code>EntityState</code> 将实体附加到 <code>DbContext</code> ，例如添加，修改或删除。</li>
<li>调用 <code>SaveChanges()</code> 方法。</li>
</ol>
<p>下面的示例演示如何使用上述步骤将新记录插入数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Disconnected entity</span><br><span class="line">var std &#x3D; new Student() &#123; Name &#x3D; &quot;Bill&quot; &#125;;</span><br><span class="line"></span><br><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 1. 使用添加的EntityState将实体附加到上下文</span><br><span class="line">    context.Add&lt;Student&gt;(std);</span><br><span class="line">    &#x2F;&#x2F; 或以下内容也有效</span><br><span class="line">    &#x2F;&#x2F; context.Students.Add(std);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; context.Entry&lt;Student&gt;(std).State &#x3D; EntityState.Added;</span><br><span class="line">    &#x2F;&#x2F; context.Attach&lt;Student&gt;(std);</span><br><span class="line">                  </span><br><span class="line">    &#x2F;&#x2F; 2. 调用SaveChanges将新记录插入Student表</span><br><span class="line">    context.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>std</code> 是 <code>Student</code> 实体的断开连接的实例。<code>context.Add&lt;Student&gt;()</code> 方法将 <code>Student</code> 实体附加到具有添加状态的上下文。 <code>SaveChanges()</code> 方法将生成并执行以下 <code>INSERT</code> 语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec sp_executesql N&#39;SET NOCOUNT ON;</span><br><span class="line">INSERT INTO [Students] ([Name])</span><br><span class="line">VALUES (@p0);</span><br><span class="line">SELECT [StudentId]</span><br><span class="line">FROM [Students]</span><br><span class="line">WHERE @@ROWCOUNT &#x3D; 1 AND [StudentId] &#x3D; scope_identity();&#39;,N&#39;@p0 nvarchar(4000), </span><br><span class="line">@p1 nvarchar(4000) &#39;,@p0&#x3D;N&#39;Bill&#39;</span><br><span class="line">Go</span><br></pre></td></tr></table></figure>
<p>EF Core 提供了多种添加状态为 “Added” 的实体的方法。在上面的示例中，<code>context.Students.Add(std);</code>、 <code>context.Entry&lt;Student&gt;(std).State = EntityState.Added;</code> 和 <code>context.Attach&lt;Student&gt;(std);</code> 将导致与上述相同的<code>INSERT</code> 语句。</p>
<p>EF Core 提供了以下 <code>DbContext</code> 和 <code>DbSet</code> 方法，这些方法将断开连接的实体与添加的 <code>EntityState</code> 附加在一起，后者又将在数据库中执行 <code>INSERT</code> 语句。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong><code>DbContext</code> 方法</strong></th>
<th style="text-align:center"><strong><code>DbSet</code> 方法</strong></th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>DbContext.Attach</code></td>
<td style="text-align:center"><code>DbSet.Attach</code></td>
<td style="text-align:center">将实体附加到 <code>DbContext</code>。为其 <code>Key</code> 属性具有值的实体设置“不变”状态，为其 <code>Key</code> 属性为空或数据类型的默认值的实体设置“添加”状态</td>
</tr>
<tr>
<td style="text-align:center"><code>DbContext.Add</code></td>
<td style="text-align:center"><code>DbSet.Add</code></td>
<td style="text-align:center"><code>DbContext.Add</code>、<code>DbSet.Add</code> 将具有附加状态的实体附加到 <code>DbContext</code></td>
</tr>
<tr>
<td style="text-align:center"><code>DbContext.AddRange</code></td>
<td style="text-align:center"><code>DbSet.AddRange</code></td>
<td style="text-align:center"><code>DbContext.AddRange</code>、<code>DbSet.AddRange</code> 将实体集合附加到具有添加状态的 <code>DbContext</code></td>
</tr>
<tr>
<td style="text-align:center"><code>DbContext.Entry</code></td>
<td style="text-align:center">-</td>
<td style="text-align:center"><code>DbContext.Entry</code> - 获取指定实体的 <code>EntityEntry</code>，该实体提供对更改跟踪信息和操作的访问</td>
</tr>
<tr>
<td style="text-align:center"><code>DbContext.AddAsync</code></td>
<td style="text-align:center"><code>DbSet.AddAsync</code></td>
<td style="text-align:center"><code>DbContext.AddAsync</code>、<code>DbSet.AddAsync</code> 异步方法，用于将实体附加到具有“已添加”状态的 <code>DbContext</code>上，如果没有，则开始跟踪它。调用 <code>SaveChangesAsync()</code> 时，数据将插入数据库中</td>
</tr>
<tr>
<td style="text-align:center"><code>DbContext.AddRangeAsync</code></td>
<td style="text-align:center"><code>DbSet.AddRangeAsync</code></td>
<td style="text-align:center"><code>DbContext.AddRangeAsync</code>、<code>DbSet.AddRangeAsync</code> 异步方法，用于一次性将多个实体附加到具有添加状态的 <code>DbContext</code> 上，如果没有，则开始跟踪它们。调用 <code>SaveChangesAsync()</code> 时，数据将插入数据库中</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>上面的 <code>DbContext</code> 方法是在 EF Core 中引入的 (它们在 EF 6 或更早版本中不可用)。 <code>DbContext</code> 和 <code>DbSet</code> 方法都执行相同的操作。您使用哪一种取决于您的编码模式和偏好。</p>
</blockquote>
<h3 id="插入关系数据"><a class="header-anchor" href="#插入关系数据">¶</a>插入关系数据</h3>
<p>在上一章中，我们学习了在两个实体之间创建一对一、一对多和多对多关系。Entity Framework API 会插入相关实体中包含的所有关系数据。<br>
使用 <code>DbContext.Add</code> 或 <code>DbSet.Add</code> 方法将相关实体添加到数据库。 <code>Add</code> 方法将实体附加到上下文，并将“已添加”状态设置为 <code>ID</code> (键) 属性为空，空或数据类型默认值的实体图中的所有实体。考虑以下示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var stdAddress &#x3D; new StudentAddress() &#123;</span><br><span class="line">    City &#x3D; &quot;SFO&quot;,</span><br><span class="line">    State &#x3D; &quot;CA&quot;,</span><br><span class="line">    Country &#x3D; &quot;USA&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var std &#x3D; new Student() &#123;</span><br><span class="line">    Name &#x3D; &quot;Steve&quot;,</span><br><span class="line">    Address &#x3D; stdAddress</span><br><span class="line">&#125;;</span><br><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将实体附加到具有添加状态的 DbContext</span><br><span class="line">    context.Add&lt;Student&gt;(std);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用 SaveChanges 将新记录插入 Student 表</span><br><span class="line">    context.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>context.Add&lt;Student&gt;(std)</code> 添加了 <code>Student</code> 实体的实例。 EF Core API 通过 <code>Student</code> 的引用导航属性到达 <code>StudentAddress</code> 实例，并将两个实体的 <code>EntityState</code> 标记为 <code>Added</code> ，这将在 <code>SaveChanges()</code> 上构建并执行以下两个 <code>INSERT</code> 命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec sp_executesql N&#39;SET NOCOUNT ON;</span><br><span class="line">INSERT INTO [Students] ([Name])</span><br><span class="line">VALUES (@p0);</span><br><span class="line">SELECT [StudentId]</span><br><span class="line">FROM [Students]</span><br><span class="line">WHERE @@ROWCOUNT &#x3D; 1 AND [StudentId] &#x3D; scope_identity();&#39;,N&#39;@p0 nvarchar(4000), </span><br><span class="line">@p1 nvarchar(4000) &#39;,@p0&#x3D;N&#39;Steve&#39;</span><br><span class="line">Go</span><br><span class="line"></span><br><span class="line">exec sp_executesql N&#39;SET NOCOUNT ON;</span><br><span class="line">INSERT INTO [StudentAddresses] ([Address], [City], [Country], [State], [StudentId])</span><br><span class="line">VALUES (@p5, @p6, @p7, @p8, @p9);</span><br><span class="line">SELECT [StudentAddressId]</span><br><span class="line">FROM [StudentAddresses]</span><br><span class="line">WHERE @@ROWCOUNT &#x3D; 1 AND [StudentAddressId] &#x3D; scope_identity();</span><br><span class="line">&#39;,N&#39;@p5 nvarchar(4000),@p6 nvarchar(4000),@p7 nvarchar(4000),@p8 nvarchar(4000),</span><br><span class="line">@p9 int&#39;,@p5&#x3D;NULL,@p6&#x3D;N&#39;SFO&#39;,@p7&#x3D;N&#39;USA&#39;,@p8&#x3D;N&#39;CA&#39;,@p9&#x3D;1</span><br><span class="line">Go</span><br></pre></td></tr></table></figure>
<p>使用 <code>DbContext.AddRange</code> 或 <code>DbSet.AddRange</code> 方法可一次性添加多个实体。您无需多次调用 <code>DbContext.Add</code> 方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>AddRange</code> 方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>void AddRange(IEnumerable&lt;Object&gt; entities)</code></td>
<td style="text-align:center"><code>void AddRange(IEnumerable&lt;Object&gt; entities)</code> 将具有相同或不同类型的实体的列表添加到具有“已添加”状态的 <code>DbContext</code> 中</td>
</tr>
<tr>
<td style="text-align:center"><code>void AddRange(param object[] entities)</code></td>
<td style="text-align:center"><code>void AddRange(param object[] entities)</code> 将具有相同或不同类型的实体的数组添加到具有“Added”状态的 <code>DbContext</code> 中</td>
</tr>
<tr>
<td style="text-align:center"><code>void AddRangeAsync(IEnumerable&lt;Object&gt;, CancellationToken)</code></td>
<td style="text-align:center"><code>void AddRangeAsync(IEnumerable&lt;Object&gt;, CancellationToken)</code> 异步方法，用于将相同或不同类型的实体列表添加到具有添加状态的 <code>DbContext</code> 中</td>
</tr>
</tbody>
</table>
<p>以下示例演示了使用 <code>AddRange</code> 添加学生实体对象列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var studentList &#x3D; new List&lt;Student&gt;() &#123;</span><br><span class="line">    new Student()&#123; Name &#x3D; &quot;Bill&quot; &#125;,</span><br><span class="line">    new Student()&#123; Name &#x3D; &quot;Steve&quot; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    context.AddRange(studentList);</span><br><span class="line">    context.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例将在 <code>Student</code> 表中插入两个新记录。<br>
您还可以添加不同类型的实体的列表，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var std1 &#x3D; new Student()&#123; Name &#x3D; &quot;Bill&quot; &#125;;</span><br><span class="line"></span><br><span class="line">var std2 &#x3D; new Student()&#123; Name &#x3D; &quot;Steve&quot; &#125;;</span><br><span class="line"></span><br><span class="line">var computer &#x3D; new Course() &#123; CourseName &#x3D; &quot;Computer Science&quot; &#125;;</span><br><span class="line"></span><br><span class="line">var entityList &#x3D; new List&lt;Object&gt;() &#123;</span><br><span class="line">    std1,</span><br><span class="line">    std2,</span><br><span class="line">    computer</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">using (var context &#x3D; new SchoolContext()) &#123;                </span><br><span class="line">    context.AddRange(entityList);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; or </span><br><span class="line">    &#x2F;&#x2F; context.AddRange(std1, std2, computer);</span><br><span class="line"></span><br><span class="line">    context.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>entityList</code> 是 <code>List&lt;Object&gt;</code> 的一种。因此，它可以包含任何类型的实体。<code>AddRange()</code> 方法将所有指定的实体添加到上下文中，<code>SaveChanges()</code> 将一次性构建并执行 <code>INSERT</code> 语句。<br>
EF Core 通过在一次数据库往返中对所有上述实体执行 <code>INSERT</code> 语句来提高性能。上面的示例将在数据库中执行以下语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec sp_executesql N&#39;SET NOCOUNT ON;</span><br><span class="line">INSERT INTO [Courses] ([CourseName], [Description])</span><br><span class="line">VALUES (@p0, @p1);</span><br><span class="line">SELECT [CourseId]</span><br><span class="line">FROM [Courses]</span><br><span class="line">WHERE @@ROWCOUNT &#x3D; 1 AND [CourseId] &#x3D; scope_identity();</span><br><span class="line"></span><br><span class="line">DECLARE @inserted1 TABLE ([StudentId] int, [_Position] [int]);</span><br><span class="line">MERGE [Students] USING (</span><br><span class="line">VALUES (@p2, 0),</span><br><span class="line">(@p3, 1)) AS i ([Name], _Position) ON 1&#x3D;0</span><br><span class="line">WHEN NOT MATCHED THEN</span><br><span class="line">INSERT ([Name])</span><br><span class="line">VALUES (i.[Name])</span><br><span class="line">OUTPUT INSERTED.[StudentId], i._Position</span><br><span class="line">INTO @inserted1;</span><br><span class="line"></span><br><span class="line">SELECT [t].[StudentId] FROM [Students] t</span><br><span class="line">INNER JOIN @inserted1 i ON ([t].[StudentId] &#x3D; [i].[StudentId])</span><br><span class="line">ORDER BY [i].[_Position];</span><br><span class="line">&#39;,N&#39;@p0 nvarchar(4000),@p1 nvarchar(4000),@p2 nvarchar(4000),@p3 nvarchar(4000)&#39;,</span><br><span class="line">@p0&#x3D;N&#39;Computer Science&#39;,@p1&#x3D;NULL,@p2&#x3D;N&#39;Steve&#39;,@p3&#x3D;N&#39;Bill&#39;</span><br><span class="line">Go</span><br></pre></td></tr></table></figure>
<h3 id="使用-DbSet-插入数据"><a class="header-anchor" href="#使用-DbSet-插入数据">¶</a>使用 <code>DbSet</code> 插入数据</h3>
<p>如前所述，您可以使用 <code>DbSet</code> 来保存实体的实例，该实例将以与 EF 6.x 相同的方式转换为数据库中的 <code>INSERT</code> / <code>UPDATE</code> / <code>DELETE</code> 命令。<br>
使用 <code>DbSet&lt;TEntity&gt;.Add()</code> 方法附加具有添加状态的实体，或使用 <code>DbSet&lt;TEntity&gt; .AddRange()</code> 方法附加具有添加状态的实体的集合，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var std &#x3D; new Student() &#123;</span><br><span class="line">    Name &#x3D; &quot;Bill&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    context.Students.Add(std);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; or</span><br><span class="line">    &#x2F;&#x2F; context.Students.Attach(std);</span><br><span class="line"></span><br><span class="line">    context.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>context.Students</code> 的类型为 <code>DbSet&lt;Student&gt;</code> 类型。因此，我们只能添加 <code>Student</code> 实体。<code>context.Students.Add(std)</code> 将 <code>Student</code> 实体附加到具有 <code>Added</code> 状态的上下文，当调用 <code>SaveChanges()</code> 方法时，这将导致 <code>INSERT</code> 语句。</p>
<h2 id="十六、Entity-Framework-Core-断开模式下删除数据"><a class="header-anchor" href="#十六、Entity-Framework-Core-断开模式下删除数据">¶</a>十六、Entity Framework Core 断开模式下删除数据</h2>
<p>EF Core API 会为 <code>EntityState</code> 为 <code>Deleted</code> 的实体建立并执行数据库中的 <code>DELETE</code> 语句。在 EF Core 中已连接和已断开连接的场景中删除实体没有什么区别。 EF Core 使得从上下文中删除实体变得容易，而上下文又将使用以下方法删除数据库中的记录。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong><code>DbContext</code> 方法</strong></th>
<th style="text-align:center"><strong><code>DbSet</code> 方法</strong></th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>DbContext.Remove</code></td>
<td style="text-align:center"><code>DbSet.Remove</code></td>
<td style="text-align:center">将指定的实体附加到状态为“已删除”的 <code>DbContext</code> 并开始对其进行跟踪</td>
</tr>
<tr>
<td style="text-align:center"><code>DbContext.RemoveRang</code></td>
<td style="text-align:center"><code>DbSet.RemoveRange</code></td>
<td style="text-align:center">将实体的集合或数组附加到具有 <code>Deleted</code> 状态的 <code>DbContext</code> 并开始跟踪它们</td>
</tr>
</tbody>
</table>
<p>以下示例演示了在断开连接的场景中删除实体的不同方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; entity to be deleted</span><br><span class="line">var student &#x3D; new Student() &#123;</span><br><span class="line">        StudentId &#x3D; 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    context.Remove&lt;Student&gt;(student);</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; or the followings are also valid</span><br><span class="line">    &#x2F;&#x2F; context.RemoveRange(student);</span><br><span class="line">    &#x2F;&#x2F;context.Students.Remove(student);</span><br><span class="line">    &#x2F;&#x2F;context.Students.RemoveRange(student);</span><br><span class="line">    &#x2F;&#x2F;context.Attach&lt;Student&gt;(student).State &#x3D; EntityState.Deleted;</span><br><span class="line">    &#x2F;&#x2F;context.Entry&lt;Student&gt;(student).State &#x3D; EntityState.Deleted;</span><br><span class="line">    </span><br><span class="line">    context.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用 <code>Remove()</code> 或 <code>RemoveRange()</code> 方法从上下文中删除了具有有效 <code>StudentId</code> 的 <code>Studnet</code> 实体。数据将从 <code>SaveChanges()</code> 上的数据库中删除。上面的示例在数据库中执行以下 <code>delete</code> 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec sp_executesql N&#39;SET NOCOUNT ON;</span><br><span class="line">DELETE FROM [Students]</span><br><span class="line">WHERE [StudentId] &#x3D; @p0;</span><br><span class="line">SELECT @@ROWCOUNT;</span><br><span class="line">&#39;,N&#39;@p0 int&#39;,@p0&#x3D;1</span><br><span class="line">Go</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>EF Core 中新引入了 <code>DbContext.Remove()</code> 和 <code>DbContext.RemoveRange()</code> 方法，以简化删除操作。</p>
</blockquote>
<h3 id="异常"><a class="header-anchor" href="#异常">¶</a>异常</h3>
<p>如果相应数据库表中不存在 <code>Remove()</code> 或 <code>RemoveRange()</code> 方法中指定实体中的 <code>Key</code> 值，则 EF Core 将引发异常：以下示例将引发异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var student &#x3D; new Student() &#123;</span><br><span class="line">    StudentId &#x3D; 50</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    context.Remove&lt;Student&gt;(student);</span><br><span class="line">    context.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，数据库中不存在 <code>StudentId = 50</code> 的 <code>Student</code>。因此，EF Core 将引发以下 <code>DbUpdateConcurrencyException</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Database operation expected to affect 1 row(s) but actually affected 0 row(s). Data may have been modified or deleted since entities were loaded.</span><br><span class="line">数据库操作预期会影响1行，但实际上会影响0行。自加载实体以来，数据可能已被修改或删除。</span><br></pre></td></tr></table></figure>
<p>因此，您需要适当地处理以上异常，或者在删除 ID 之前确保数据库中存在具有 ID 的对应数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var student &#x3D; new Student() &#123;</span><br><span class="line">    StudentId &#x3D; 50</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        context.Remove&lt;Student&gt;(deleteStudent);</span><br><span class="line">        context.SaveChanges();</span><br><span class="line">    &#125;    </span><br><span class="line">    catch (DbUpdateConcurrencyException ex) &#123;</span><br><span class="line">        throw new Exception(&quot;数据库中不存在此纪录&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex) &#123;</span><br><span class="line">        throw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除多条记录"><a class="header-anchor" href="#删除多条记录">¶</a>删除多条记录</h3>
<p>您可以使用 <code>DbContext.RemoveRange()</code> 或 <code>DbSet.RemoveRange()</code> 方法一次性删除多个实体。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IList&lt;Student&gt; students &#x3D; new List&lt;Student&gt;() &#123;</span><br><span class="line">    new Student()&#123; StudentId &#x3D; 1 &#125;,</span><br><span class="line">    new Student()&#123; StudentId &#x3D; 2 &#125;,</span><br><span class="line">    new Student()&#123; StudentId &#x3D; 3 &#125;,</span><br><span class="line">    new Student()&#123; StudentId &#x3D; 4 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    context.RemoveRange(students);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; or</span><br><span class="line">    &#x2F;&#x2F; context.Students.RemoveRange(students);</span><br><span class="line">    </span><br><span class="line">    context.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例将在单个数据库行程中从数据库中删除 4 条记录。因此，EF Core 改善了性能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec sp_executesql N&#39;SET NOCOUNT ON;</span><br><span class="line">DELETE FROM [Students]</span><br><span class="line">WHERE [StudentId] &#x3D; @p0;</span><br><span class="line">SELECT @@ROWCOUNT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELETE FROM [Students]</span><br><span class="line">WHERE [StudentId] &#x3D; @p1;</span><br><span class="line">SELECT @@ROWCOUNT;</span><br><span class="line"></span><br><span class="line">DELETE FROM [Students]</span><br><span class="line">WHERE [StudentId] &#x3D; @p2;</span><br><span class="line">SELECT @@ROWCOUNT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELETE FROM [Students]</span><br><span class="line">WHERE [StudentId] &#x3D; @p3;</span><br><span class="line">SELECT @@ROWCOUNT;</span><br><span class="line"></span><br><span class="line">&#39;,N&#39;@p0 int,@p1 int&#39;,@p0&#x3D;1,@p1&#x3D;2,@p2&#x3D;3,@p3&#x3D;4</span><br><span class="line">Go</span><br></pre></td></tr></table></figure>
<h3 id="删除关联数据"><a class="header-anchor" href="#删除关联数据">¶</a>删除关联数据</h3>
<p>如果一个实体与其他实体有一对一或一对多的关系，则在删除根实体时删除相关数据取决于如何配置该关系。<br>
例如，考虑“学生”和“年级”实体之间存在一对多关系。特定的 <code>GradeId</code> 将有许多学生记录。如果我们尝试删除数据库中具有相关学生记录的成绩，EF 将抛出参考完整性错误。要解决此问题，您可以使用 Fluent API 定义引用约束操作选项。例如，您可以为该关系配置一个级联删除选项，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modelBuilder.Entity&lt;Student&gt;()</span><br><span class="line">    .HasOne&lt;Grade&gt;(s &#x3D;&gt; s.Grade)</span><br><span class="line">    .WithMany(g &#x3D;&gt; g.Students)</span><br><span class="line">    .HasForeignKey(s &#x3D;&gt; s.GradeId)</span><br><span class="line">    .OnDelete(DeleteBehavior.Cascade);</span><br></pre></td></tr></table></figure>
<p>现在，如果您删除成绩实体，那么所有相关的学生记录也将在数据库中删除。<br>
EF Core中还有其他引用约束操作选项，例如 <code>SetNull</code>、<code>ClientSetNull</code>和<code>Restrict</code>。</p>
<h2 id="十七、Entity-Framework-Core-中的-ChangeTracker-变更追踪器"><a class="header-anchor" href="#十七、Entity-Framework-Core-中的-ChangeTracker-变更追踪器">¶</a>十七、Entity Framework Core 中的 <code>ChangeTracker</code> (变更追踪器)</h2>
<p>Entity Framework Core 中的 <code>DbContext</code> 在 <code>Microsoft.EntityFrameworkCore.ChangeTracking</code> 命名空间中包含 <code>ChangeTracker</code> 类，该类负责跟踪使用同一 <code>DbContext</code> 实例检索的每个实体的状态。它不打算直接在您的应用程序代码中使用，因为它可能在将来的版本中更改。但是，您可以使用一些方法进行跟踪。</p>
<p>一旦使用 <code>DbContext</code> 检索了所有实体，Entity Framework Core 中的<code>ChangeTracker</code> 类就会开始跟踪所有实体，直到它们超出其范围。 EF 跟踪应用于所有实体及其属性的所有更改，以便它可以为基础数据源生成并执行适当的 DML 语句。</p>
<p>实体在任何时间点都具有以下状态之一，这些状态由 EF Core 中的枚举 <code>Microsoft.EntityFrameworkCore.EntityState</code> 表示。</p>
<ul>
<li><code>Added</code></li>
<li><code>Modified</code></li>
<li><code>Deleted</code></li>
<li><code>Unchanged</code></li>
<li><code>Detached</code></li>
</ul>
<p>让我们看看如何根据对实体执行的操作自动更改 <code>EntityState</code>：</p>
<h3 id="Unchanged-State-不变的状态"><a class="header-anchor" href="#Unchanged-State-不变的状态">¶</a>Unchanged State (不变的状态)</h3>
<p>首先，使用直接 SQL 查询或 LINQ-to-Entities 查询检索的所有实体都将具有“Unchanged”状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void Main() &#123;</span><br><span class="line">    using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">        &#x2F;&#x2F; retrieve entity </span><br><span class="line">        var student &#x3D; context.Students.First();</span><br><span class="line">        DisplayStates(context.ChangeTracker.Entries());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void DisplayStates(IEnumerable&lt;EntityEntry&gt; entries) &#123;</span><br><span class="line">    foreach (var entry in entries) &#123;</span><br><span class="line">        Console.WriteLine($&quot;Entity: &#123;entry.Entity.GetType().Name&#125;,</span><br><span class="line">                             State: &#123;entry.State.ToString()&#125; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entity: Student, State: Unchanged</span><br></pre></td></tr></table></figure>
<h3 id="Added-State-新增状态"><a class="header-anchor" href="#Added-State-新增状态">¶</a>Added State (新增状态)</h3>
<p>使用 <code>Add()</code> 或 <code>Update()</code> 方法在 <code>DbContext</code> 中添加的所有没有键属性值的新实体都将标记为“Added”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using (var context &#x3D; new SchoolContext()) &#123;              </span><br><span class="line">    context.Add(new Student() &#123; FirstName &#x3D; &quot;Bill&quot;, LastName &#x3D; &quot;Gates&quot; &#125;);</span><br><span class="line">    </span><br><span class="line">    DisplayStates(context.ChangeTracker.Entries());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entity: Student, State: Added</span><br></pre></td></tr></table></figure>
<h3 id="Modified-State-修改状态"><a class="header-anchor" href="#Modified-State-修改状态">¶</a>Modified State (修改状态)</h3>
<p>如果实体的任何属性的值在 <code>DbContext</code> 的范围内更改，则它将被标记为 <code>Modified</code> 状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    var student &#x3D; context.Students.First();</span><br><span class="line">    student.LastName &#x3D; &quot;LastName changed&quot;;</span><br><span class="line">              </span><br><span class="line">    DisplayStates(context.ChangeTracker.Entries());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entity: Student, State: Modified</span><br></pre></td></tr></table></figure>
<h3 id="Deleted-State-删除状态"><a class="header-anchor" href="#Deleted-State-删除状态">¶</a>Deleted State (删除状态)</h3>
<p>如果实体的任何属性的值在 <code>DbContext</code> 的范围内更改，则它将被标记为 <code>Modified</code> 状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    var student &#x3D; context.Students.First();</span><br><span class="line">    student.LastName &#x3D; &quot;LastName changed&quot;;</span><br><span class="line">              </span><br><span class="line">    DisplayStates(context.ChangeTracker.Entries());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entity: Student, State: Modified</span><br></pre></td></tr></table></figure>
<h3 id="Deleted-State-删除状态-v2"><a class="header-anchor" href="#Deleted-State-删除状态-v2">¶</a>Deleted State (删除状态)</h3>
<p>如果使用 <code>DbContext.Remove</code> 或 <code>DbSet.Remove</code> 方法从 <code>DbContext</code> 中删除了任何实体，则它将被标记为 <code>Deleted</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    var student &#x3D; context.Students.First();</span><br><span class="line">    context.Students.Remove(student);</span><br><span class="line">    </span><br><span class="line">    DisplayStates(context.ChangeTracker.Entries());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entity: Student, State: Deleted</span><br></pre></td></tr></table></figure>
<h3 id="Detached-State-分离状态"><a class="header-anchor" href="#Detached-State-分离状态">¶</a>Detached State (分离状态)</h3>
<p>在当前 <code>DbContext</code> 实例范围之外创建或检索的所有实体都将处于 <code>Detached</code> 状态。它们也称为断开连接的实体，现有的 <code>DbContext</code> 实例不会对其进行跟踪。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var disconnectedEntity &#x3D; new Student() &#123; StudentId &#x3D; 1, Name &#x3D; &quot;Bill&quot; &#125;;</span><br><span class="line"></span><br><span class="line">using (var context &#x3D; new SchoolContext()) &#123;              </span><br><span class="line">    Console.Write(context.Entry(disconnectedEntity).State);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Detached</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>disconnectedEntity</code> 是在 <code>DbContext</code> 实例 (上下文) 的范围之外创建的。因此，对于上下文，它处于 <code>Detached</code> 状态。</p>
<h2 id="十八、Entity-Framework-Core-的影子属性-Shadow-Property"><a class="header-anchor" href="#十八、Entity-Framework-Core-的影子属性-Shadow-Property">¶</a>十八、Entity Framework Core 的影子属性 (Shadow Property)</h2>
<p>Entity Framework Core 引入了一种新的属性类型，称为“影子”属性，该属性在 EF 6.x 中不存在。<br>
<strong>影子属性是未在 .NET 实体类中直接定义的属性</strong>。相反，您可以为实体数据模型中的特定实体类型配置它。可以在上下文类的 <code>OnModelCreating()</code> 方法中配置它们。<br>
下图说明了影子属性：</p>
<p><img src="/images/efcore/20200208111446921.png" alt="图18-1"></p>
<p>如上图所示，影子属性不属于您的实体类。因此，<strong>您无法在访问实体的其他属性时访问它。只能在构建实体数据模型时为实体类型配置影子属性，并且它们也将映射到数据库列</strong>。影子属性的值和状态仅在更改跟踪器中维护。</p>
<p>让我们了解影子属性的实际方面。假设我们需要维护数据库表中每个记录的创建和更新日期。您学习了如何通过在实体类中定义 <code>CreatedDate</code> 和 <code>UpdatedDate</code> 属性来设置 EF Core 中实体的创建和修改日期。在这里，我们将看到如何通过使用影子属性而不在实体类中包含影子属性来实现相同的结果。</p>
<p>考虑以下学生实体类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    public int StudentID &#123; get; set; &#125;</span><br><span class="line">    public string StudentName &#123; get; set; &#125;</span><br><span class="line">    public DateTime? DateOfBirth &#123; get; set; &#125;</span><br><span class="line">    public decimal Height &#123; get; set; &#125;</span><br><span class="line">    public float Weight &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>Student</code> 类不包含 <code>CreatedDate</code> 和 <code>UpdatedDate</code> 属性来维护创建或更新的时间。我们将它们配置为 <code>Student</code> 实体上的影子属性。</p>
<h3 id="定义影子属性"><a class="header-anchor" href="#定义影子属性">¶</a>定义影子属性</h3>
<p>您可以使用 <code>Property()</code> 方法在 <code>OnModelCreating()</code> 中使用 Fluent API 为实体类型定义影子属性。<br>
以下内容在 <code>Student</code> 实体上配置了两个影子属性 <code>CreatedDate</code> 和 <code>UpdatedDate</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SchoolContext : DbContext &#123;</span><br><span class="line">    public SchoolContext() : base() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;</span><br><span class="line">        modelBuilder.Entity&lt;Student&gt;().Property&lt;DateTime&gt;(&quot;CreatedDate&quot;);</span><br><span class="line">        modelBuilder.Entity&lt;Student&gt;().Property&lt;DateTime&gt;(&quot;UpdatedDate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DbSet&lt;Student&gt; Students &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如您所见，<code>Property()</code> 方法用于配置影子属性。将影子属性的名称指定为字符串，并将类型指定为通用参数。如果在 <code>Property()</code> 方法中指定的名称与现有属性的名称匹配，则 EF Core 将将该现有属性配置为影子属性，而不是引入新的影子属性。</p>
<h3 id="数据库中的影子属性"><a class="header-anchor" href="#数据库中的影子属性">¶</a>数据库中的影子属性</h3>
<p>定义影子属性后，我们需要更新数据库架构，因为影子属性将映射到相应的数据库列。<br>
为此，请使用以下命令添加数据库迁移。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef migrations add addShadowProperty</span><br><span class="line">PM&gt; dotnet ef db update</span><br></pre></td></tr></table></figure>
<p>现在，<code>Student</code> 表将包括两列，SQL Server 中的 <code>CreatedDate</code> 和 <code>UpdatedDate</code>，如下所示。</p>
<p><img src="/images/efcore/shadow-property-in-db.png" alt="图18-2"></p>
<p>因此，<strong>即使我们没有在 <code>Student</code> 类中包含这些属性并将其配置为影子属性，数据库也将具有相应的列</strong>。</p>
<h3 id="访问影子属性"><a class="header-anchor" href="#访问影子属性">¶</a>访问影子属性</h3>
<p>您可以使用 <code>EntityEntry</code> 的 <code>Property()</code> 方法获取或设置影子属性的值。以下代码访问影子属性的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    var std &#x3D; new Student() &#123; StudentName &#x3D; &quot;Bill&quot;  &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; sets the value to the shadow property</span><br><span class="line">    context.Entry(std).Property(&quot;CreatedDate&quot;).CurrentValue &#x3D; DateTime.Now;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; gets the value of the shadow property</span><br><span class="line">    var createdDate &#x3D; context.Entry(std).Property(&quot;CreatedDate&quot;).CurrentValue; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，在我们的方案中，我们想在 <code>SaveChanges()</code> 方法上自动将值设置为这些影子属性，这样就不必在每个实体对象上手动设置它们。因此，请在上下文类中重写<code>SaveChanges()</code> 方法，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public override int SaveChanges() &#123;</span><br><span class="line">    var entries &#x3D; ChangeTracker</span><br><span class="line">        .Entries()</span><br><span class="line">        .Where(e &#x3D;&gt;</span><br><span class="line">                e.State &#x3D;&#x3D; EntityState.Added</span><br><span class="line">                || e.State &#x3D;&#x3D; EntityState.Modified);</span><br><span class="line"></span><br><span class="line">    foreach (var entityEntry in entries) &#123;</span><br><span class="line">        entityEntry.Property(&quot;UpdatedDate&quot;).CurrentValue &#x3D; DateTime.Now;</span><br><span class="line"></span><br><span class="line">        if (entityEntry.State &#x3D;&#x3D; EntityState.Added) &#123;</span><br><span class="line">            entityEntry.Property(&quot;CreatedDate&quot;).CurrentValue &#x3D; DateTime.Now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return base.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将自动将值设置为 <code>CreatedDate</code> 和 <code>UpdatedDate</code> 影子属性。<br>
现在，执行以下代码并检查数据库中的记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    var std &#x3D; new Student()&#123; StudentName &#x3D; &quot;Bill&quot;  &#125;;</span><br><span class="line">    context.Add(std);</span><br><span class="line">    context.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码将在 <code>Student</code> 表中插入带有 <code>CreatedDate</code> 和 <code>UpdatedDate</code> 的以下记录。</p>
<p><img src="/images/efcore/db-record.png" alt="图18-3"></p>
<p>因此，通过配置影子属性，我们不必将它们包括在实体类中。</p>
<h3 id="在所有实体上配置阴影属性"><a class="header-anchor" href="#在所有实体上配置阴影属性">¶</a>在所有实体上配置阴影属性</h3>
<p>您可以一次在所有实体上配置影子属性，而不是为所有实体手动配置它们。<br>
例如，我们可以一次在所有实体上配置 <code>CreatedDate</code> 和 <code>UpdatedDate</code>，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;</span><br><span class="line">    var allEntities &#x3D; modelBuilder.Model.GetEntityTypes();</span><br><span class="line"></span><br><span class="line">    foreach (var entity in allEntities) &#123;</span><br><span class="line">        entity.AddProperty(&quot;CreatedDate&quot;,typeof(DateTime));</span><br><span class="line">        entity.AddProperty(&quot;UpdatedDate&quot;,typeof(DateTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="何时使用影子属性？"><a class="header-anchor" href="#何时使用影子属性？">¶</a>何时使用影子属性？</h3>
<p>影子属性可以在两种情况下使用：</p>
<ol>
<li>当您不想在映射的实体上公开数据库列时，例如上面讨论的方案。</li>
<li>当您不想公开外键属性而只想使用导航属性来管理关系时。外键属性将是影子属性并映射到数据库列，但不会作为实体的属性公开。(在 EF Core 中，如果您未在实体类中定义外键属性，则它将自动为此生成影子属性。您无需手动配置外键属性。)</li>
</ol>
<h2 id="十九、Entity-Framework-Core-使用断开模式的实体图-Entity-Graph"><a class="header-anchor" href="#十九、Entity-Framework-Core-使用断开模式的实体图-Entity-Graph">¶</a>十九、Entity Framework Core 使用断开模式的实体图 (Entity Graph)</h2>
<p>在这里，您将了解 Entity Framework Core 中断开连接的实体图的根实体和子实体上不同方法的行为。</p>
<p>实体框架核心提供了以下不同方法，<strong>这些方法不仅将实体附加到上下文，而且还更改了断开连接的实体图中每个实体的 <code>EntityState</code></strong>：</p>
<ul>
<li><code>Attach()</code></li>
<li><code>Entry()</code></li>
<li><code>Add()</code></li>
<li><code>Update()</code></li>
<li><code>Remove()</code></li>
</ul>
<h3 id="Attach"><a class="header-anchor" href="#Attach">¶</a><code>Attach()</code></h3>
<p><code>DbContext.Attach()</code> 和 <code>DbSet.Attach()</code> 方法将附加指定的断开连接的实体图并开始对其进行跟踪。它们返回 <code>EntityEntry</code> 的实例，该实例用于分配适当的 <code>EntityState</code>。</p>
<p>下面的示例演示 <code>DbContext.Attach()</code> 方法在图形中每个实体的 <code>EntityState</code> 上的行为。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void Main() &#123;</span><br><span class="line">    var stud &#x3D; new Student() &#123; &#x2F;&#x2F;Root entity (empty key)</span><br><span class="line">        Name &#x3D; &quot;Bill&quot;,</span><br><span class="line">        Address &#x3D; new StudentAddress() &#123;  &#x2F;&#x2F;Child entity (with key value)</span><br><span class="line">             StudentAddressId &#x3D; 1,</span><br><span class="line">            City &#x3D; &quot;Seattle&quot;,</span><br><span class="line">            Country &#x3D; &quot;USA&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        StudentCourses &#x3D; new List&lt;StudentCourse&gt;() &#123;</span><br><span class="line">            new StudentCourse()&#123;  Course &#x3D; new Course()&#123; CourseName &#x3D; &quot;Machine Language&quot; &#125; &#125;,&#x2F;&#x2F;Child entity (empty key)</span><br><span class="line">            new StudentCourse()&#123;  Course &#x3D; new Course()&#123;  CourseId &#x3D; 2 &#125; &#125; &#x2F;&#x2F;Child entity (with key value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var context &#x3D; new SchoolContext();</span><br><span class="line">    context.Attach(stud).State &#x3D; EntityState.Added;  </span><br><span class="line"></span><br><span class="line">    DisplayStates(context.ChangeTracker.Entries());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void DisplayStates(IEnumerable&lt;EntityEntry&gt; entries) &#123;</span><br><span class="line">    foreach (var entry in entries) &#123;</span><br><span class="line">        Console.WriteLine($&quot;Entity: &#123;entry.Entity.GetType().Name&#125;,</span><br><span class="line">                             State: &#123;entry.State.ToString()&#125; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entity: Student, State: Added</span><br><span class="line">Entity: StudentAddress, State: Unchanged</span><br><span class="line">Entity: StudentCourse, State: Added</span><br><span class="line">Entity: Course, State: Added</span><br><span class="line">Entity: StudentCourse, State: Added</span><br><span class="line">Entity: Course, State: Unchanged</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>stud</code> 是学生实体图的实例，其中包括对 <code>StudentAddress</code> 和 <code>StudentCourse</code> 实体的引用。<code>context.Attach(stud).State = EntityState.Added</code> 会将图钉实体图附加到上下文，并为其设置 <code>Added</code> 状态。<br>
<code>Attach()</code> 方法将添加的 <code>EntityState</code> 设置为根实体 (在本例中为 <code>Student</code> )，无论其是否包含 <code>Key</code> 值。如果子实体包含键值，则它将被标记为“不变”，否则将被标记为“已添加”。上面示例的输出显示，学生实体具有 <code>Added EntityState</code> ，具有非空键值的子实体具有 <code>Unchanged</code> <code>EntityState</code>，而具有空键值的子实体具有 <code>Added</code> 状态。<br>
下表列出了在为断开连接的实体图设置其他 <code>EntityStat</code> e时，<code>Attach()</code> 方法的行为：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>Attach()</code></th>
<th style="text-align:center">具有键值的根实体</th>
<th style="text-align:center">具有空值或 CLR 默认值的根实体</th>
<th style="text-align:center">具有键值的子实体</th>
<th style="text-align:center">空实体或 CLR 默认值的子实体</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>context.Attach(entityGraph).State = EntityState.Added</code></td>
<td style="text-align:center"><code>Added</code></td>
<td style="text-align:center"><code>Added</code></td>
<td style="text-align:center"><code>Unchanged</code></td>
<td style="text-align:center"><code>Added</code></td>
</tr>
<tr>
<td style="text-align:center"><code>context.Attach(entityGraph).State = EntityState.Modified</code></td>
<td style="text-align:center"><code>Modified</code></td>
<td style="text-align:center"><code>Exception</code></td>
<td style="text-align:center"><code>Unchanged</code></td>
<td style="text-align:center"><code>Added</code></td>
</tr>
<tr>
<td style="text-align:center"><code>context.Attach(entityGraph).State = EntityState.Deleted</code></td>
<td style="text-align:center"><code>Deleted</code></td>
<td style="text-align:center"><code>Exception</code></td>
<td style="text-align:center"><code>Unchanged</code></td>
<td style="text-align:center"><code>Added</code></td>
</tr>
</tbody>
</table>
<h3 id="Entry"><a class="header-anchor" href="#Entry">¶</a><code>Entry()</code></h3>
<p>与以前的 EF 6.x 相比，<code>DbContext.Entry()</code> 方法在 Entity Framework Core 中的行为有所不同。考虑以下示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var student &#x3D; new Student() &#123; &#x2F;&#x2F;Root entity (empty key)</span><br><span class="line">    Name &#x3D; &quot;Bill&quot;,</span><br><span class="line">    Address &#x3D; new StudentAddress() &#123; &#x2F;&#x2F;Child entity (with key value)</span><br><span class="line">        StudentAddressId &#x3D; 1,</span><br><span class="line">        City &#x3D; &quot;Seattle&quot;,</span><br><span class="line">        Country &#x3D; &quot;USA&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    StudentCourses &#x3D; new List&lt;StudentCourse&gt;() &#123;</span><br><span class="line">            new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseName&#x3D;&quot;Machine Language&quot; &#125; &#125;,&#x2F;&#x2F;Child entity (empty key)</span><br><span class="line">            new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseId&#x3D;2 &#125; &#125; &#x2F;&#x2F;Child entity (with key value)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">context.Entry(student).State &#x3D; EntityState.Modified;</span><br><span class="line"></span><br><span class="line">DisplayStates(context.ChangeTracker.Entries());</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entity: Student, State: Modified</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>context.Entry(student).State = EntityState.Modified</code> 将实体附加到上下文，并将指定的 <code>EntityState</code> (在本例中为 <code>Modified</code>) 应用于根实体，而不管其是否包含 <code>Key</code> 属性值或不。它会忽略图中的所有子实体，并且不会附加或设置其 <code>EntityState</code>。<br>
下表列出了 <code>DbContext.Entry()</code> 方法的不同行为。</p>
<table>
<thead>
<tr>
<th style="text-align:center">使用 <code>Entry()</code> 设置 <code>EntityState</code></th>
<th style="text-align:center">具有键值的根实体</th>
<th style="text-align:center">具有空值或 CLR 默认值的根实体</th>
<th style="text-align:center">有/没有键值的子实体</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>context.Entry(entityGraph).State = EntityState.Added</code></td>
<td style="text-align:center"><code>Added</code></td>
<td style="text-align:center"><code>Added</code></td>
<td style="text-align:center"><code>Ignored</code></td>
</tr>
<tr>
<td style="text-align:center"><code>context.Entry(entityGraph).State = EntityState.Modified</code></td>
<td style="text-align:center"><code>Modified</code></td>
<td style="text-align:center"><code>Modified</code></td>
<td style="text-align:center"><code>Ignored</code></td>
</tr>
<tr>
<td style="text-align:center"><code>context.Entry(entityGraph).State = EntityState.Deleted</code></td>
<td style="text-align:center"><code>Deleted</code></td>
<td style="text-align:center"><code>Deleted</code></td>
<td style="text-align:center"><code>Ignored</code></td>
</tr>
</tbody>
</table>
<h3 id="Add"><a class="header-anchor" href="#Add">¶</a><code>Add()</code></h3>
<p><code>DbContext.Add</code> 和 <code>DbSet.Add</code> 方法将实体图附加到上下文，并将“Added EntityState”设置为根和子实体，而不管它们是否具有键值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var student &#x3D; new Student() &#123; &#x2F;&#x2F;Root entity (with key value)</span><br><span class="line">    StudentId &#x3D; 1,</span><br><span class="line">    Name &#x3D; &quot;Bill&quot;,</span><br><span class="line">    Address &#x3D; new StudentAddress() &#123; &#x2F;&#x2F;Child entity (with key value)</span><br><span class="line">        StudentAddressId &#x3D; 1,</span><br><span class="line">        City &#x3D; &quot;Seattle&quot;,</span><br><span class="line">        Country &#x3D; &quot;USA&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    StudentCourses &#x3D; new List&lt;StudentCourse&gt;() &#123;</span><br><span class="line">            new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseName&#x3D;&quot;Machine Language&quot; &#125; &#125;,&#x2F;&#x2F;Child entity (empty key)</span><br><span class="line">            new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseId&#x3D;2 &#125; &#125; &#x2F;&#x2F;Child entity (with key value)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">context.Students.Add(student);</span><br><span class="line"></span><br><span class="line">DisplayStates(context.ChangeTracker.Entries());</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entity: Student, State: Added</span><br><span class="line">Entity: StudentAddress, State: Added</span><br><span class="line">Entity: StudentCourse, State: Added</span><br><span class="line">Entity: Course, State: Added</span><br><span class="line">Entity: StudentCourse, State: Added</span><br><span class="line">Entity: Course, State: Added</span><br></pre></td></tr></table></figure>
<p>下表列出了使用 <code>DbContext.Add</code> 或 <code>DbSet.Add</code> 方法的图形中每个实体的可能 <code>EntityState</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">具有/不具有键值的根实体</th>
<th style="text-align:center">有/没有键值的子实体</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>DbContext.Add(entityGraph)</code> 或 <code>DbSet.Add(entityGraph)</code></td>
<td style="text-align:center"><code>Added</code></td>
<td style="text-align:center"><code>Added</code></td>
</tr>
</tbody>
</table>
<h3 id="Update"><a class="header-anchor" href="#Update">¶</a><code>Update()</code></h3>
<p><code>DbContext.Update</code> (和 <code>DbSet.Update</code>) 方法将实体图附加到上下文，并根据图中是否包含键属性值来设置图中每个实体的 <code>EntityState</code>。考虑以下示例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var student &#x3D; new Student() &#123; &#x2F;&#x2F;Root entity (with key value)</span><br><span class="line">    StudentId &#x3D; 1,</span><br><span class="line">    Name &#x3D; &quot;Bill&quot;,</span><br><span class="line">    Address &#x3D; new StudentAddress()  &#x2F;&#x2F;Child entity (with key value)</span><br><span class="line">    &#123;</span><br><span class="line">        StudentAddressId &#x3D; 1,</span><br><span class="line">        City &#x3D; &quot;Seattle&quot;,</span><br><span class="line">        Country &#x3D; &quot;USA&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    StudentCourses &#x3D; new List&lt;StudentCourse&gt;() &#123;</span><br><span class="line">        new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseName&#x3D;&quot;Machine Language&quot; &#125; &#125;,&#x2F;&#x2F;Child entity (empty key)</span><br><span class="line">        new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseId&#x3D;2 &#125; &#125; &#x2F;&#x2F;Child entity (with key value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">context.Update(student);</span><br><span class="line"></span><br><span class="line">DisplayStates(context.ChangeTracker.Entries());</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entity: Student, State: Modified</span><br><span class="line">Entity: StudentAddress, State: Modified</span><br><span class="line">Entity: StudentCourse, State: Added</span><br><span class="line">Entity: Course, State: Added</span><br><span class="line">Entity: StudentCourse, State: Added</span><br><span class="line">Entity: Course, State: Modified</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>Update()</code> 方法将 <code>Modified</code> 状态应用于包含非空键属性值的实体，并将 <code>Added</code> 状态应用于包含空或默认 CLR 键值的实体，而不管它们是根实体还是子实体。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>Update()</code></th>
<th style="text-align:center">具有键值的根实体</th>
<th style="text-align:center">具有空值或 CLR 默认值的根实体</th>
<th style="text-align:center">具有键值的子实体</th>
<th style="text-align:center">空键值的子实体</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>DbContext.Update(entityGraph)</code> 或 <code>DbSet.Update(entityGraph)</code></td>
<td style="text-align:center"><code>Modified</code></td>
<td style="text-align:center"><code>Added</code></td>
<td style="text-align:center"><code>Modified</code></td>
<td style="text-align:center"><code>Added</code></td>
</tr>
</tbody>
</table>
<h3 id="Remove"><a class="header-anchor" href="#Remove">¶</a><code>Remove()</code></h3>
<p><code>DbContext.Remove()</code> 和 <code>DbSet.Remove()</code> 方法将 <code>Deleted</code> <code>EntityState</code> 设置为根实体。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var student &#x3D; new Student() &#123; &#x2F;&#x2F;Root entity (with key value)</span><br><span class="line">    StudentId &#x3D; 1,</span><br><span class="line">    Name &#x3D; &quot;Bill&quot;,</span><br><span class="line">    Address &#x3D; new StudentAddress() &#123; &#x2F;&#x2F;Child entity (with key value)</span><br><span class="line">        StudentAddressId &#x3D; 1,</span><br><span class="line">        City &#x3D; &quot;Seattle&quot;,</span><br><span class="line">        Country &#x3D; &quot;USA&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    StudentCourses &#x3D; new List&lt;StudentCourse&gt;() &#123;</span><br><span class="line">        new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseName&#x3D;&quot;Machine Language&quot; &#125; &#125;,&#x2F;&#x2F;Child entity (empty key)</span><br><span class="line">        new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseId&#x3D;2 &#125; &#125; &#x2F;&#x2F;Child entity (with key value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">context.Remove(student);</span><br><span class="line"></span><br><span class="line">DisplayStates(context.ChangeTracker.Entries());</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entity: Student, State: Deleted</span><br><span class="line">Entity: StudentAddress, State: Unchanged</span><br><span class="line">Entity: StudentCourse, State: Added</span><br><span class="line">Entity: Course, State: Added</span><br><span class="line">Entity: StudentCourse, State: Added</span><br><span class="line">Entity: Course, State: Unchanged</span><br></pre></td></tr></table></figure>
<p>下表列出了每个实体的 <code>EntityState</code> 上 <code>Remove()</code> 方法的行为。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>Remove()</code></th>
<th style="text-align:center">具有键值的根实体</th>
<th style="text-align:center">具有空值或 CLR 默认值的根实体</th>
<th style="text-align:center">具有键值的子实体</th>
<th style="text-align:center">空键值的子实体</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>DbContext.Remove(entityGraph)</code> 或 <code>DbSet.Remove(entityGraph)</code></td>
<td style="text-align:center"><code>Deleted</code></td>
<td style="text-align:center"><code>Exception</code></td>
<td style="text-align:center"><code>Unchanged</code></td>
<td style="text-align:center"><code>Added</code></td>
</tr>
</tbody>
</table>
<p>因此，在 EF Core 中使用上述方法时要小心。</p>
<h2 id="二十、Entity-Framework-Core-中的-ChangeTracker-TrackGraph"><a class="header-anchor" href="#二十、Entity-Framework-Core-中的-ChangeTracker-TrackGraph">¶</a>二十、Entity Framework Core 中的 <code>ChangeTracker.TrackGraph()</code></h2>
<p>在这里，您将学习如何跟踪实体图并为图中的每个单个实体设置适当的 <code>EntityState</code>。<br>
Entity Framework Core 中引入了 <code>ChangeTracker.TrackGraph()</code> 方法，以跟踪整个实体图并将自定义实体状态设置为图中的每个实体。<br>
方法签名：<code>public virtual void TrackGraph(object rootEntity, Action&lt;EntityEntryGraphNode&gt; callback)</code><br>
<code>ChangeTracker.TrackGraph()</code> 方法开始跟踪实体以及通过遍历其导航属性可到达的任何实体。为每个发现的实体调用指定的回调，并且必须为每个实体设置适当的 <code>EntityState</code>。回调函数使我们可以实现自定义逻辑来设置适当的状态。如果未设置任何状态，则实体保持未跟踪状态。<br>
下面的示例演示 <code>TrackGraph</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var student &#x3D; new Student() &#123; &#x2F;&#x2F;Root entity (with key value)</span><br><span class="line">    StudentId &#x3D; 1,</span><br><span class="line">    Name &#x3D; &quot;Bill&quot;,</span><br><span class="line">    Address &#x3D; new StudentAddress() &#123; &#x2F;&#x2F;Child entity (with key value)</span><br><span class="line">        StudentAddressId &#x3D; 1,</span><br><span class="line">        City &#x3D; &quot;Seattle&quot;,</span><br><span class="line">        Country &#x3D; &quot;USA&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    StudentCourses &#x3D; new List&lt;StudentCourse&gt;() &#123;</span><br><span class="line">        new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseName&#x3D;&quot;Machine Language&quot; &#125; &#125;,&#x2F;&#x2F;Child entity (empty key)</span><br><span class="line">        new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseId&#x3D;2 &#125; &#125; &#x2F;&#x2F;Child entity (with key value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">            </span><br><span class="line">context.ChangeTracker.TrackGraph(student, e &#x3D;&gt; &#123;</span><br><span class="line">                                                if (e.Entry.IsKeySet) &#123;</span><br><span class="line">                                                    e.Entry.State &#x3D; EntityState.Unchanged;</span><br><span class="line">                                                &#125; else &#123;</span><br><span class="line">                                                    e.Entry.State &#x3D; EntityState.Added;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;);</span><br><span class="line"></span><br><span class="line">foreach (var entry in context.ChangeTracker.Entries()) &#123;</span><br><span class="line">    Console.WriteLine($&quot;Entity: &#123;entry.Entity.GetType().Name&#125;, </span><br><span class="line">                        State: &#123;entry.State.ToString()&#125; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entity: Student, State: Added</span><br><span class="line">Entity: StudentAddress, State: Unchanged</span><br><span class="line">Entity: StudentCourse, State: Added</span><br><span class="line">Entity: Course, State: Added</span><br><span class="line">Entity: StudentCourse, State: Added</span><br><span class="line">Entity: Course, State: Unchanged</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>ChangeTracker.TrackGraph()</code> 方法用于为学生实体图中的每个实体设置状态。第一个参数是实体图，第二个参数是设置每个实体状态的函数。我们使用 lambda 表达式为具有有效键值的实体设置了“不变”状态，为具有空键值的实体设置了“添加”状态。当实体具有有效的键属性值时，<code>IsKeySet</code> 变为 <code>true</code>。<br>
因此，我们可以使用 <code>ChangeTracker.TrackGraph()</code> 方法为图中的每个实体设置不同的 <code>EntityState</code>。</p>
<h2 id="二十一、在-Entity-Framework-Core-中执行原生-SQL-查询"><a class="header-anchor" href="#二十一、在-Entity-Framework-Core-中执行原生-SQL-查询">¶</a>二十一、在 Entity Framework Core 中执行原生 SQL 查询</h2>
<p>Entity Framework Core 提供了 <code>DbSet.FromSql()</code> 方法来对基础数据库执行原始 SQL 查询，并将结果作为实体对象获取。<br>
下面的示例演示如何对 MS SQL Server 数据库执行原始 SQL 查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">var students &#x3D; context.Students</span><br><span class="line">                  .FromSql(&quot;Select * from Students where Name &#x3D; &#39;Bill&#39;&quot;)</span><br><span class="line">                  .ToList();</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，在 <code>Student</code> 实体集 (<code>DbSet&lt;Student&gt;</code>) 之后使用 <code>FromSql()</code> 方法，因此指定的 SQL 查询必须从 <code>Student</code> 表返回记录，该记录将在 <code>Student</code> 实体中进行转换。 Entity Framework Core 将执行对数据库的指定查询，即在上面的示例中，从 <strong><code>Name ='Bill'</code> 的 <code>Student</code> 中选择</strong>。</p>
<h3 id="Parameterized-Query-参数化查询"><a class="header-anchor" href="#Parameterized-Query-参数化查询">¶</a>Parameterized Query (参数化查询)</h3>
<p><code>FromSql</code>方法允许使用 C# 中的字符串插值语法进行参数化查询，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string name &#x3D; &quot;Bill&quot;;</span><br><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">var students &#x3D; context.Students</span><br><span class="line">                    .FromSql($&quot;Select * from Students where Name &#x3D; &#39;&#123;name&#125;&#39;&quot;)</span><br><span class="line">                    .ToList();</span><br><span class="line"></span><br><span class="line">The following is also valid.</span><br><span class="line">string name &#x3D; &quot;Bill&quot;;</span><br><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">var students &#x3D; context.Students</span><br><span class="line">                    .FromSql(&quot;Select * from Students where Name &#x3D; &#39;&#123;0&#125;&#39;&quot;, name)</span><br><span class="line">                    .ToList();</span><br></pre></td></tr></table></figure>
<p>上面的示例将对 SQL Server 数据库执行以下 SQL 查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec sp_executesql N&#39;Select * from Students where Name &#x3D; &#39;&#39;@p0&#39;&#39;</span><br><span class="line">&#39;,N&#39;@p0 nvarchar(4000)&#39;,@p0&#x3D;N&#39;Bill&#39;</span><br><span class="line">Go</span><br></pre></td></tr></table></figure>
<h3 id="LINQ-运算符"><a class="header-anchor" href="#LINQ-运算符">¶</a>LINQ 运算符</h3>
<p>您还可以在使用 <code>FromSql</code> 方法的原始查询之后使用 LINQ 运算符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string name &#x3D; &quot;Bill&quot;;</span><br><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">var students &#x3D; context.Students</span><br><span class="line">                    .FromSql(&quot;Select * from Students where Name &#x3D; &#39;&#123;0&#125;&#39;&quot;, name)</span><br><span class="line">                    .OrderBy(s &#x3D;&gt; s.StudentId)</span><br><span class="line">                    .ToList();</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，EF Core 通过将 <code>FromSql</code> 方法和 <code>OrderBy</code> 运算符结合在一起执行以下查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec sp_executesql N&#39;SELECT [s].[StudentId], [s].[Name]</span><br><span class="line">FROM (</span><br><span class="line">    Select * from Students where Name &#x3D; &#39;&#39;@p0&#39;&#39;</span><br><span class="line">) AS [s]</span><br><span class="line">ORDER BY [s].[StudentId]&#39;,N&#39;@p0 nvarchar(4000)&#39;,@p0&#x3D;N&#39;Bill&#39;</span><br><span class="line">Go</span><br></pre></td></tr></table></figure>
<h3 id="FromSql-的局限性"><a class="header-anchor" href="#FromSql-的局限性">¶</a><code>FromSql</code> 的局限性</h3>
<p>SQL 查询必须返回与 <code>DbSet&lt;T&gt;</code> 类型相同类型的实体。例如如果在学生之后使用 <code>FromSql</code>，则指定的查询无法返回课程实体。从 <code>FromSql()</code> 方法返回临时类型在待办事项列表中。<br>
SQL 查询必须返回表的所有列。例如 <code>context.Students.FromSql(&quot;select StudentId，LastName from Students).ToList()</code> 将引发异常。<br>
<strong>SQL 查询不能包含 <code>JOIN</code> 查询以获取相关数据。在 <code>FromSql()</code> 方法之后，使用 <code>Include</code> 方法加载相关实体</strong>。</p>
<h2 id="二十二、在-Entity-Framework-Core-中使用存储过程"><a class="header-anchor" href="#二十二、在-Entity-Framework-Core-中使用存储过程">¶</a>二十二、在 Entity Framework Core 中使用存储过程</h2>
<p>在这里，您将学习如何在 Entity Framework Core 中执行数据库存储过程。<br>
EF Core 提供了以下方法来执行存储过程：</p>
<ol>
<li><code>DbSet&lt;TEntity&gt;.FromSql()</code></li>
<li><code>DbContext.Database.ExecuteSqlCommand()</code></li>
</ol>
<p>在 EF Core 2.x 中使用 <code>FromSql</code> 或 <code>ExecuteSqlCommand</code> 方法执行数据库存储过程存在一些限制：</p>
<ul>
<li>结果必须是实体类型。这意味着存储过程必须返回实体对应表的所有列。</li>
<li>结果不能包含相关数据。这意味着存储过程无法执行 <code>JOIN</code> 来表示结果。</li>
<li>插入，更新和删除过程无法与该实体映射，因此 <code>SaveChanges</code> 方法无法为 CUD 操作调用存储过程。</li>
</ul>
<p>在 EF Core 中执行存储过程之前，让我们在 MS SQL Server 中创建存储过程。<br>
如果遵循 database-first 方法，则在本地 SQL Server 数据库中执行以下脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE [SchoolDB]</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">SET ANSI_NULLS ON</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">SET QUOTED_IDENTIFIER ON</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE [dbo].[GetStudents]</span><br><span class="line">            @FirstName varchar(50)</span><br><span class="line">        AS</span><br><span class="line">        BEGIN</span><br><span class="line">            SET NOCOUNT ON;</span><br><span class="line">            select * from Students where FirstName like @FirstName +&#39;%&#39;</span><br><span class="line">        END</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>
<p>如果您遵循 code-first 方法，请按照以下步骤操作：</p>
<ol>
<li>
<p>执行以下命令来添加空迁移：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef migrations add</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 <code>&lt;DateTime&gt; _sp-GetStudents.cs</code> 中的空迁移类的 <code>Up</code> 方法中编写以下代码：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public partial class spGetStudents : Migration &#123;</span><br><span class="line">    protected override void Up(MigrationBuilder migrationBuilder) &#123;</span><br><span class="line">        var sp &#x3D; @&quot;CREATE PROCEDURE [dbo].[GetStudents]</span><br><span class="line">                    @FirstName varchar(50)</span><br><span class="line">                AS</span><br><span class="line">                BEGIN</span><br><span class="line">                    SET NOCOUNT ON;</span><br><span class="line">                    select * from Students where FirstName like @FirstName +&#39;%&#39;</span><br><span class="line">                END&quot;;</span><br><span class="line"></span><br><span class="line">        migrationBuilder.Sql(sp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override void Down(MigrationBuilder migrationBuilder) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在控制台中执行以下命令，在数据库中创建以上存储过程：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef db update</span><br></pre></td></tr></table></figure>
<p>这将在 SQL Server 数据库中创建 <code>GetStudents</code> 存储过程。</p>
</li>
</ol>
<h3 id="使用-FromSql-执行存储过程"><a class="header-anchor" href="#使用-FromSql-执行存储过程">¶</a>使用 <code>FromSql</code> 执行存储过程</h3>
<p>如上一章所述，<code>DbSet</code> 的 <code>FromSql</code> 方法可用于对基础数据库执行原始 SQL 查询。同样，它可用于执行返回实体数据的存储过程，但有一些限制。<br>
在数据库中，我们可以使用如下INPUT参数值执行GetStudents存储过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetStudents &quot;Bill&quot;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec GetStudents &quot;Bill&quot;</span><br></pre></td></tr></table></figure>
<p>您可以按照与上述相同的方式在 EF Core 中使用 <code>FromSql</code> 方法执行 SP，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var context &#x3D; new SchoolContext(); </span><br><span class="line">var students &#x3D; context.Students.FromSql(&quot;GetStudents &#39;Bill&#39;&quot;).ToList();</span><br></pre></td></tr></table></figure>
<p>您还可以使用 C# 字符串插值语法传递参数值，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &quot;Bill&quot;;</span><br><span class="line"></span><br><span class="line">var context &#x3D; new SchoolContext(); </span><br><span class="line">var students &#x3D; context.Students</span><br><span class="line">                      .FromSql($&quot;GetStudents &#123;name&#125;&quot;)</span><br><span class="line">                      .ToList();</span><br><span class="line">&#x2F;&#x2F;or</span><br><span class="line">&#x2F;&#x2F;var students &#x3D; context.Students.FromSql($&quot;exec GetStudents &#123;name&#125;&quot;).ToList();</span><br></pre></td></tr></table></figure>
<p>使用 <code>SqlParameter</code> 实例指定 <code>in</code> 或 <code>out</code> 参数的值，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var context &#x3D; new SchoolContext(); </span><br><span class="line">var param &#x3D; new SqlParameter(&quot;@FirstName&quot;, &quot;Bill&quot;);</span><br><span class="line">&#x2F;&#x2F;or</span><br><span class="line">&#x2F;*var param &#x3D; new SqlParameter() &#123;</span><br><span class="line">                    ParameterName &#x3D; &quot;@FirstName&quot;,</span><br><span class="line">                    SqlDbType &#x3D;  System.Data.SqlDbType.VarChar,</span><br><span class="line">                    Direction &#x3D; System.Data.ParameterDirection.Input,</span><br><span class="line">                    Size &#x3D; 50,</span><br><span class="line">                    Value &#x3D; &quot;Bill&quot;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line"></span><br><span class="line">var students &#x3D; context.Students.FromSql(&quot;GetStudents @FirstName&quot;, param).ToList();</span><br></pre></td></tr></table></figure>
<p>您还可以为第一个参数指定 <code>@p0</code>，为第二个参数指定 <code>@p1</code>，依此类推。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var context &#x3D; new SchoolContext(); </span><br><span class="line">var students &#x3D; context.Students.FromSql(&quot;GetStudents @p0&quot;,&quot;Bill&quot;).ToList();</span><br></pre></td></tr></table></figure>
<p>在以上示例中，<code>@p0</code> 用于第一个参数，因为 EF Core 中尚不支持命名参数。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>默认情况下，<code>DbContext</code> 将跟踪结果中的所有实体。如果您多次使用相同的参数执行相同的存储过程，则它将每次执行相同的 SQL 语句，但只会跟踪一个结果集。例如，以下示例将执行 <code>GetStudents</code> 存储过程 3 次，但将仅缓存和跟踪结果的一个副本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var context &#x3D; new SchoolContext(); </span><br><span class="line">var list1 &#x3D; context.Students.FromSql(&quot;GetStudents &#39;Bill&#39;&quot;).ToList();</span><br><span class="line">var list2 &#x3D; context.Students.FromSql(&quot;GetStudents &#39;Bill&#39;&quot;).ToList();</span><br><span class="line">var list3 &#x3D; context.Students.FromSql(&quot;GetStudents &#39;Bill&#39;&quot;).ToList();</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="使用-ExecuteSqlCommand-执行存储过程"><a class="header-anchor" href="#使用-ExecuteSqlCommand-执行存储过程">¶</a>使用 <code>ExecuteSqlCommand()</code> 执行存储过程</h3>
<p><code>ExecuteSqlCommand()</code> 方法用于以字符串形式执行数据库命令。对于受指定命令影响的行数，它返回一个整数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var context &#x3D; new SchoolContext();</span><br><span class="line">var rowsAffected &#x3D; context.Database.ExecuteSqlCommand(&quot;Update Students set FirstName &#x3D; &#39;Bill&#39; where StudentId &#x3D; 1;&quot;);</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>update</code> 命令在 <code>ExecuteSqlCommand</code> 方法中传递。  <code>rowsAffected</code>  的值将为 <code>1</code>，因为只有 1 行受指定的 <code>update</code> 命令影响。<br>
同样，我们可以执行存储过程来创建，更新和删除命令。考虑以下存储过程，该存储过程将一条记录插入数据库的<code> Student</code> 表中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE CreateStudent</span><br><span class="line">    @FirstName Varchar(50),</span><br><span class="line">    @LastName Varchar(50)</span><br><span class="line">AS</span><br><span class="line">BEGIN</span><br><span class="line">    SET NOCOUNT ON;</span><br><span class="line">    Insert into Students(</span><br><span class="line">           [FirstName]</span><br><span class="line">           ,[LastName]</span><br><span class="line">           )</span><br><span class="line"> Values (@FirstName, @LastName)</span><br><span class="line">END</span><br><span class="line">Go</span><br></pre></td></tr></table></figure>
<p>现在，您可以执行上面的存储过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var context &#x3D; new SchoolContext(); </span><br><span class="line">context.Database.ExecuteSqlCommand(&quot;CreateStudents @p0, @p1&quot;, parameters: new[] &#123; &quot;Bill&quot;, &quot;Gates&quot; &#125;);</span><br></pre></td></tr></table></figure>
<p>以相同的方式，您可以执行 <code>Update</code> 和 <code>Delete</code> 命令的存储过程。</p>
<h2 id="二十三、Entity-Framework-Core-日志"><a class="header-anchor" href="#二十三、Entity-Framework-Core-日志">¶</a>二十三、Entity Framework Core 日志</h2>
<p>我们经常需要在 EF Core 中记录 SQL 并更改跟踪信息以进行调试。<br>
EF Core 日志记录自动与 .NET Core 的日志记录机制集成。因此，在隐含使用 EF Core 的日志记录之前，了解有关 .NET Core 日志记录的基础知识。<br>
Entity Framework Core 与 .NET Core 日志记录集成在一起，以记录 SQL 并将跟踪信息更改为各种输出目标。首先，安装您选择的日志记录提供程序的 Nuget 程序包，然后将 <code>DbContext</code> 绑定到 <code>ILoggerFactory</code>。<br>
让我们安装日志记录提供程序的NuGet软件包。在这里，我们将在控制台上显示日志，因此从 NuGet 程序包管理器安装 <code>Microsoft.Extensions.Logging.Console NuGet</code> 程序包，或在程序包管理器控制台中执行以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet add package Microsoft.Extensions.Logging.Console</span><br></pre></td></tr></table></figure>
<p>下图说明了 <code>DbContext</code> 如何与日志记录API和控制台日志记录提供程序一起使用。<br>
<img src="/images/efcore/logging-in-efcore.png" alt="图22-1"></p>
<p>在安装控制台记录器提供程序之后，您需要创建 <code>LoggerFactory</code> 的静态/单个实例，然后将其与 <code>DbContext</code> 绑定，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SchoolContext : DbContext &#123;</span><br><span class="line">    &#x2F;&#x2F;static LoggerFactory object</span><br><span class="line">    public static readonly ILoggerFactory loggerFactory &#x3D; new LoggerFactory(new[] &#123;</span><br><span class="line">        new ConsoleLoggerProvider((_, __) &#x3D;&gt; true, true)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;or</span><br><span class="line">    &#x2F;&#x2F; public static readonly ILoggerFactory loggerFactory  &#x3D; new LoggerFactory().AddConsole((_,___) &#x3D;&gt; true);</span><br><span class="line">    </span><br><span class="line">    public SchoolContext() : base() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;</span><br><span class="line">        optionsBuilder.UseLoggerFactory(loggerFactory)  &#x2F;&#x2F;tie-up DbContext with LoggerFactory object</span><br><span class="line">            .EnableSensitiveDataLogging()  </span><br><span class="line">            .UseSqlServer(@&quot;Server&#x3D;.\SQLEXPRESS;Database&#x3D;SchoolDB;Trusted_Connection&#x3D;True;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DbSet&lt;Student&gt; Students &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了 <code>LoggerFactory</code> 类的对象，并将其分配给 <code>ILoggerFactory</code> 类型的静态变量。然后，我们在 <code>OnConfiguring()</code> 方法的 <code>optionsBuilder.UseLoggerFactory()</code> 方法中传递了此对象。这将使 <code>DbContext</code> 与 <code>loggerFactory</code> 对象共享信息，该对象又将在控制台上显示所有日志记录信息。<br>
默认情况下，EF Core 将不记录敏感数据，例如过滤器参数值。因此，调用 <code>EnableSensitiveDataLogging()</code> 记录敏感数据。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>EF 团队建议在应用程序生存期内，将同一个 logger 工厂对象与 <code>DbContext</code> 类的所有实例一起使用。否则，可能会导致内存泄漏和性能下降。您还可以创建一个单独的工厂类，为您提供 <code>LoggerFactory</code> 类的单例对象，以与 <code>DbContext</code> 一起使用。</p>
</blockquote>
<p>让我们详细了解上面的示例。<br>
首先，我们创建了 <code>LoggerFactory</code> 类的对象，并将其分配给 <code>ILoggerFactory</code> 类型的静态变量，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static readonly ILoggerFactory loggerFactory &#x3D; new LoggerFactory(</span><br><span class="line">    new[] &#123; new ConsoleLoggerProvider ((_, __) &#x3D;&gt; true, true) &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>LoggerFactory</code> 可以包含一个或多个日志记录提供程序，可用于同时记录到多个介质。<code> LoggerFactory</code> 的构造函数接受一系列不同的记录器提供程序对象作为 <code>new [] {}</code>。我们希望在控制台上显示日志，因此创建控制台记录器提供程序 <code>ConsoleLoggerProvider</code> 的对象。<br>
<code>ConsoleLoggerProvider</code> 有四个构造函数。使用允许 lambda 表达式 (<code>Func &lt;&gt;</code>) 进行日志过滤的方法，并使用 <code>includeScope</code> 布尔值，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new ConsoleLoggerProvider((_, __) &#x3D;&gt; true, true)</span><br></pre></td></tr></table></figure>
<p>在这里，我们不想过滤任何信息，因此 lambda 表达式将始终返回 <code>true (_, __) =&gt; true</code>。</p>
<p>创建 <code>ILoggerFactory</code> 对象之后，使用 <code>DbContextOptionsBuilder</code> 在 <code>OnConfiguring()</code> 方法中将 <code>DbContext</code> 与 <code>ILoggerFactory</code> 绑定在一起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optionsBuilder.UseLoggerFactory(loggerFactory)</span><br></pre></td></tr></table></figure>
<p>因此，我们将<code>DbContext</code> 与包括控制台记录器提供程序的 <code>LoggerFactory</code> 绑定在一起。现在，每当 <code>DbContext</code> 实例执行任何操作时，我们都可以在控制台上看到所有日志。<br>
考虑以下示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using (var context &#x3D; new SchoolContext()) &#123;</span><br><span class="line">    var std &#x3D; new Student()&#123; StudentName &#x3D; &quot;Steve&quot; &#125;;</span><br><span class="line">    context.Add(std);</span><br><span class="line">                </span><br><span class="line">    context.SaveChanges();</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例将在控制台上显示以下日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dbug: Microsoft.EntityFrameworkCore.Infrastructure[100401]</span><br><span class="line">An &#39;IServiceProvider&#39; was created for internal use by Entity Framework.</span><br><span class="line">info: Microsoft.EntityFrameworkCore.Infrastructure[100403]</span><br><span class="line">Entity Framework Core 2.0.0-rtm-26452 initialized &#39;SchoolContext&#39; using pr</span><br><span class="line">ovider &#39;Microsoft.EntityFrameworkCore.SqlServer&#39; with options: SensitiveDataLoggingEnabled</span><br><span class="line">dbug: Microsoft.EntityFrameworkCore.Database.Connection[200000]</span><br><span class="line">Opening connection to database &#39;SchoolDB&#39; on server &#39;.\SQLEXPRESS&#39;.</span><br><span class="line"></span><br><span class="line">dbug: Microsoft.EntityFrameworkCore.Database.Connection[200001]</span><br><span class="line">Opened connection to database &#39;SchoolDB&#39; on server &#39;.\SQLEXPRESS&#39;.</span><br><span class="line">dbug: Microsoft.EntityFrameworkCore.Database.Transaction[200200]</span><br><span class="line">Beginning transaction with isolation level &#39;ReadCommitted&#39;.</span><br><span class="line">warn: Microsoft.EntityFrameworkCore.Database.Command[100400]</span><br><span class="line">Sensitive data logging is enabled. Log entries and exception messages may</span><br><span class="line">include sensitive application data, this mode should only be enabled during development.</span><br><span class="line">dbug: Microsoft.EntityFrameworkCore.Database.Command[200100]</span><br><span class="line">Executing DbCommand [Parameters&#x3D;[@p0&#x3D;&#39;&#39; (DbType &#x3D; DateTime2), @p1&#x3D;&#39;&#39; (DbTy</span><br><span class="line">pe &#x3D; Int32), @p2&#x3D;&#39;0&#39;, @p3&#x3D;&#39;&#39; (Size &#x3D; 8000) (DbType &#x3D; Binary), @p4&#x3D;&#39;Steve&#39; (Size &#x3D; 4000), @p5&#x3D;&#39;0&#39;], CommandType&#x3D;&#39;Text&#39;, CommandTimeout&#x3D;&#39;30&#39;]</span><br><span class="line">SET NOCOUNT ON;</span><br><span class="line">INSERT INTO [Students] ([DateOfBirth], [GradeId], [Height], [Photo], [Stud</span><br><span class="line">entName], [Weight])</span><br><span class="line">VALUES (@p0, @p1, @p2, @p3, @p4, @p5);</span><br><span class="line">SELECT [StudentID]</span><br><span class="line">FROM [Students]</span><br><span class="line">WHERE @@ROWCOUNT &#x3D; 1 AND [StudentID] &#x3D; scope_identity();</span><br><span class="line">info: Microsoft.EntityFrameworkCore.Database.Command[200101]</span><br><span class="line">Executed DbCommand (68ms) [Parameters&#x3D;[@p0&#x3D;&#39;&#39; (DbType &#x3D; DateTime2), @p1&#x3D;&#39;&#39;</span><br><span class="line">(DbType &#x3D; Int32), @p2&#x3D;&#39;0&#39;, @p3&#x3D;&#39;&#39; (Size &#x3D; 8000) (DbType &#x3D; Binary), @p4&#x3D;&#39;Steve&#39;</span><br><span class="line">(Size &#x3D; 4000), @p5&#x3D;&#39;0&#39;], CommandType&#x3D;&#39;Text&#39;, CommandTimeout&#x3D;&#39;30&#39;]</span><br><span class="line">SET NOCOUNT ON;</span><br><span class="line">INSERT INTO [Students] ([DateOfBirth], [GradeId], [Height], [Photo], [Stud</span><br><span class="line">entName], [Weight])</span><br><span class="line">VALUES (@p0, @p1, @p2, @p3, @p4, @p5);</span><br><span class="line">SELECT [StudentID]</span><br><span class="line">FROM [Students]</span><br><span class="line">WHERE @@ROWCOUNT &#x3D; 1 AND [StudentID] &#x3D; scope_identity();</span><br><span class="line">dbug: Microsoft.EntityFrameworkCore.Database.Command[200300]</span><br><span class="line">A data reader was disposed.</span><br><span class="line">dbug: Microsoft.EntityFrameworkCore.Database.Transaction[200202]</span><br><span class="line">Committing transaction.</span><br><span class="line">dbug: Microsoft.EntityFrameworkCore.Database.Connection[200002]</span><br><span class="line">Closing connection to database &#39;SchoolDB&#39; on server &#39;.\SQLEXPRESS&#39;.</span><br><span class="line"></span><br><span class="line">dbug: Microsoft.EntityFrameworkCore.Database.Connection[200003]</span><br><span class="line">Closed connection to database &#39;SchoolDB&#39; on server &#39;.\SQLEXPRESS&#39;.</span><br><span class="line">dbug: Microsoft.EntityFrameworkCore.Database.Transaction[200204]</span><br><span class="line">Disposing transaction.、</span><br></pre></td></tr></table></figure>
<p>如您所见，它记录了所有信息。</p>
<h3 id="过滤日志"><a class="header-anchor" href="#过滤日志">¶</a>过滤日志</h3>
<p>在上面的示例中，<code>DbContext</code> 在保存实体时记录了所有信息。有时您不想记录所有信息并过滤一些不需要的日志。在 EF Core 中，您可以通过指定记录器类别和日志级别来过滤日志。</p>
<h3 id="日志分类"><a class="header-anchor" href="#日志分类">¶</a>日志分类</h3>
<p>EF Core 2.x 包含 <code>DbLoggerCategory</code> 类，以使用其 <code>Name</code> 属性获取 Entity Framework Core 记录器类别。下表列出了不同的记录器类别。</p>
<table>
<thead>
<tr>
<th style="text-align:center">日志类别类</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Database.Command</code></td>
<td style="text-align:center">命令执行的记录器类别，包括发送到数据库的SQL。</td>
</tr>
<tr>
<td style="text-align:center"><code>Database.Connection</code></td>
<td style="text-align:center">数据库连接操作的记录器类别。</td>
</tr>
<tr>
<td style="text-align:center"><code>Database.Transaction</code></td>
<td style="text-align:center">数据库事务的记录器类别。</td>
</tr>
<tr>
<td style="text-align:center"><code>Infrastructure</code></td>
<td style="text-align:center">EF 基础结构的其他消息的记录器类别。</td>
</tr>
<tr>
<td style="text-align:center"><code>Migration</code></td>
<td style="text-align:center">迁移的记录器类别。</td>
</tr>
<tr>
<td style="text-align:center"><code>Model</code></td>
<td style="text-align:center">用于模型构建和元数据的记录器类别。</td>
</tr>
<tr>
<td style="text-align:center"><code>Query</code></td>
<td style="text-align:center">查询的记录器类别 (不包括生成的 SQL)。</td>
</tr>
<tr>
<td style="text-align:center"><code>Scaffolding</code></td>
<td style="text-align:center">脚手架和逆向工程的记录仪类别。</td>
</tr>
<tr>
<td style="text-align:center"><code>Update</code></td>
<td style="text-align:center"><code>DbContext.SaveChanges()</code> 消息的记录器类别。</td>
</tr>
</tbody>
</table>
<h3 id="记录-SQL-查询"><a class="header-anchor" href="#记录-SQL-查询">¶</a>记录 SQL 查询</h3>
<p>要仅记录 SQL 查询，请在 <code>ConsoleLoggerProvider</code> 的构造函数的 lambda 表达式中指定 <code>DbLoggerCategory.Database.Command</code> 类别和 <code>LogLevel.Information</code>，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static readonly ILoggerFactory consoleLoggerFactory  </span><br><span class="line">            &#x3D; new LoggerFactory(new[] &#123;</span><br><span class="line">                  new ConsoleLoggerProvider((category, level) &#x3D;&gt;</span><br><span class="line">                    category &#x3D;&#x3D; DbLoggerCategory.Database.Command.Name &amp;&amp;</span><br><span class="line">                    level &#x3D;&#x3D; LogLevel.Information, true)</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
<p>或者，默认情况下，只需在 <code>LoggerFactory</code> 上调用 <code>AddConsole()</code> 方法即可记录 SQL 查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static readonly ILoggerFactory consoleLoggerFactory</span><br><span class="line">         &#x3D; new LoggerFactory().AddConsole();</span><br></pre></td></tr></table></figure>
<p>现在，这将记录以下查询信息，这些查询信息使用 <code>DbContext</code> 保存一个实体：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info: Microsoft.EntityFrameworkCore.Database.Command[200101]</span><br><span class="line">Executed DbCommand (73ms) [Parameters&#x3D;[@p0&#x3D;&#39;&#39; (DbType &#x3D; DateTime2), @p1&#x3D;&#39;&#39;</span><br><span class="line">(DbType &#x3D; Int32), @p2&#x3D;&#39;0&#39;, @p3&#x3D;&#39;&#39; (Size &#x3D; 8000) (DbType &#x3D; Binary), @p4&#x3D;&#39;Steve&#39;</span><br><span class="line">(Size &#x3D; 4000), @p5&#x3D;&#39;0&#39;], CommandType&#x3D;&#39;Text&#39;, CommandTimeout&#x3D;&#39;30&#39;]</span><br><span class="line">SET NOCOUNT ON;</span><br><span class="line">INSERT INTO [Students] ([DateOfBirth], [GradeId], [Height], [Photo], [Stud</span><br><span class="line">entName], [Weight])</span><br><span class="line">VALUES (@p0, @p1, @p2, @p3, @p4, @p5);</span><br><span class="line">SELECT [StudentID]</span><br><span class="line">FROM [Students]</span><br><span class="line">WHERE @@ROWCOUNT &#x3D; 1 AND [StudentID] &#x3D; scope_identity();</span><br></pre></td></tr></table></figure>
<h2 id="二十四、Entity-Framework-Core-数据迁移"><a class="header-anchor" href="#二十四、Entity-Framework-Core-数据迁移">¶</a>二十四、Entity Framework Core 数据迁移</h2>
<p>迁移是一种通过保留数据来使数据库架构与 EF Core 模型保持同步的方法。</p>
<p><img src="/images/efcore/20200208203737156.png" alt="图24-1"></p>
<p>如上图所示，EF Core API 从域 (实体) 类构建 EF Core 模型，并且 EF Core 迁移将基于 EF Core 模型创建或更新数据库架构。每当更改域类时，都需要运行迁移以使数据库架构保持最新。<br>
EF Core 迁移是一组命令，您可以在 NuGet 软件包管理器控制台或 dotnet 命令行界面 (CLI) 中执行。<br>
下表列出了 EF Core 中的重要迁移命令。</p>
<table>
<thead>
<tr>
<th style="text-align:center">程序包管理器控制台命令</th>
<th style="text-align:center">dotnet 命令行命令</th>
<th style="text-align:center">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>add-migration &lt;migration name&gt;</code></td>
<td style="text-align:center"><code>dotnet ef migrations add &lt;migration name&gt;</code></td>
<td style="text-align:center">通过添加迁移快照来创建迁移</td>
</tr>
<tr>
<td style="text-align:center"><code>Remove-migration</code></td>
<td style="text-align:center"><code>dotnet ef migrations remove</code></td>
<td style="text-align:center">删除最后一个迁移快照</td>
</tr>
<tr>
<td style="text-align:center"><code>Update-database</code></td>
<td style="text-align:center"><code>dotnet ef db update</code></td>
<td style="text-align:center">根据上一个迁移快照更新数据库架构</td>
</tr>
<tr>
<td style="text-align:center"><code>Script-migration</code></td>
<td style="text-align:center"><code>dotnet ef migrations script</code></td>
<td style="text-align:center">使用所有迁移快照生成 SQL 脚本</td>
</tr>
</tbody>
</table>
<h3 id="添加迁移-v2"><a class="header-anchor" href="#添加迁移-v2">¶</a>添加迁移</h3>
<p>第一次，您定义了初始领域类。此时，您的应用程序没有数据库可以存储您的域类中的数据。因此，首先，您需要创建一个迁移。</p>
<p>从 Visual Studio 中的工具-&gt; NuGet 软件包管理器-&gt;软件包管理器控制台中打开软件包管理器控制台，然后执行以下命令以添加迁移。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; <span class="built_in">add-migration</span> MyFirstMigration</span><br></pre></td></tr></table></figure>
<p>如果使用的是 dotnet 命令行界面，请执行以下命令。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef migrations add MyFirstMigration</span><br></pre></td></tr></table></figure>
<p>在以上命令中，<code>MyFirstMigration</code> 是迁移的名称。这将在项目的“迁移”文件夹中创建三个文件，如下所示。<br>
<img src="/images/efcore/20200208203750920.png" alt="图24-2"></p>
<ol>
<li><code>&lt;timestamp&gt;_&lt;迁移名称&gt;.cs</code>：主迁移文件，其中包含 <code>Up()</code> 和 <code>Down()</code> 方法中的迁移操作。 <code>Up()</code> 方法包括用于创建数据库对象的代码，而<code>Down()</code> 方法包括用于删除数据库对象的代码。</li>
<li><code>&lt;时间戳&gt;_&lt;迁移名称&gt;.Designer.cs</code>：迁移元数据文件，其中包含 EF Core 使用的信息。</li>
<li><code>&lt;contextclassname&gt; ModelSnapshot.cs</code>：当前模型的快照。这用于确定在创建下一个迁移时所做的更改。</li>
</ol>
<p>现在，在创建迁移快照之后，该创建数据库了。</p>
<h3 id="创建或更新数据库"><a class="header-anchor" href="#创建或更新数据库">¶</a>创建或更新数据库</h3>
<p>使用以下命令创建或更新数据库架构。</p>
<ol>
<li>
<p>程序包管理器控制台</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; <span class="built_in">Update-Database</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>dotnet 命令行</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef database update</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>Update</code> 命令将基于上下文和域类以及迁移快照创建数据库，这些快照是使用 <code>add-migration</code> 或 <code>add</code> 命令创建的。<br>
如果这是第一次迁移，则还将创建一个名为 <code>__EFMigrationsHistory</code> 的表，该表将存储所有迁移的名称以及何时将它们应用于数据库。</p>
<p><img src="/images/efcore/20200208203805157.png" alt="图24-3"></p>
<h3 id="删除迁移"><a class="header-anchor" href="#删除迁移">¶</a>删除迁移</h3>
<p>如果上一次迁移未应用到数据库，则可以将其删除。使用以下 <code>remove</code> 命令删除上一次创建的迁移文件并还原模型快照。</p>
<ol>
<li>
<p>程序包管理器控制台</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; <span class="built_in">remove-migration</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>dotnet 命令行</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef migrations remove</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的命令将删除上一次迁移，并将模型快照还原为之前的迁移。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>如果已将迁移应用于数据库，则它将引发以下异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">迁移 &#96;&lt;迁移名称&gt;&#96; 已被应用于数据库。还原它，然后再试一次。如果已将迁移应用于其他数据库，请考虑使用新迁移来还原其更改。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="还原迁移"><a class="header-anchor" href="#还原迁移">¶</a>还原迁移</h3>
<p>假设您更改了域类，并使用 <code>add-migration</code> 命令创建了名为 <code>MySecondMigration</code> 的第二个迁移，并使用 <code>Update</code> 命令将该迁移应用于数据库。但是，由于某种原因，您想将数据库还原到以前的状态。在这种情况下，请使用 <code>update-database &lt;迁移名称&gt;</code> 命令将数据库还原到指定的先前迁移快照。</p>
<ol>
<li>
<p>程序包管理器控制台</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; <span class="built_in">Update-database</span> MyFirstMigration</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>dotnet 命令行</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef database update MyFirstMigration</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的命令将基于名为 <code>MyFirstMigration</code> 的迁移还原数据库，并删除应用于名为 <code>MySecondMigration</code> 的第二个迁移的所有更改。这还将从数据库的 <code>__EFMigrationsHistory</code> 表中删除 <code>MySecondMigration</code> 条目。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>这不会删除与 <code>MySecondMigration</code> 相关的迁移文件。使用 <code>remove</code> 命令将其从项目中删除。</p>
</blockquote>
<h3 id="生成-SQL-脚本"><a class="header-anchor" href="#生成-SQL-脚本">¶</a>生成 SQL 脚本</h3>
<p>使用以下命令为数据库生成 SQL 脚本。</p>
<ol>
<li>
<p>程序包管理器控制台</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; script<span class="literal">-migration</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>dotnet 命令行</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef migrations script</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的脚本命令默认将包含所有迁移的脚本。您可以使用 <code>-to</code> 和 <code>-from</code> 选项来指定迁移范围。</p>
<h3 id="程序包管理器控制台命令进行迁移"><a class="header-anchor" href="#程序包管理器控制台命令进行迁移">¶</a>程序包管理器控制台命令进行迁移</h3>
<p>可以使用 Visual Studio 中的程序包管理器控制台执行 Entity Framework Core 中的迁移命令。从 Visual Studio 中的工具-&gt; NuGet软件包管理器-&gt;软件包管理器控制台中打开软件包管理器控制台，以执行以下命令：</p>
<table>
<thead>
<tr>
<th style="text-align:center">程序包管理器控制台</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#get-help" target="_blank" rel="noopener">Get-Help EntityFramework</a></td>
<td style="text-align:center">获取帮助 Entity Framework 显示有关实体框架命令的信息</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#add-migration" target="_blank" rel="noopener">Add-Migration</a></td>
<td style="text-align:center"><code>&lt;迁移名称&gt;</code> 通过添加迁移快照来创建迁移</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#remove-migration" target="_blank" rel="noopener">Remove-Migration</a></td>
<td style="text-align:center">删除最后一个迁移快照</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#update-database" target="_blank" rel="noopener">Update-Database</a></td>
<td style="text-align:center">根据上一个迁移快照更新数据库架构</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#script-migration" target="_blank" rel="noopener">Script-Migration</a></td>
<td style="text-align:center">使用所有迁移快照生成 SQL 脚本</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#scaffold-dbcontext" target="_blank" rel="noopener">Scaffold-DbContext</a></td>
<td style="text-align:center">为指定的数据库生成 <code>DbContext</code> 和实体类型类。这称为逆向工程</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#get-dbcontext" target="_blank" rel="noopener">Get-DbContext</a></td>
<td style="text-align:center">获取有关 <code>DbContext</code> 类型的信息</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#drop-database" target="_blank" rel="noopener">Drop-Database</a></td>
<td style="text-align:center">删除数据库</td>
</tr>
</tbody>
</table>
<h3 id="Get-Help-获取帮助"><a class="header-anchor" href="#Get-Help-获取帮助">¶</a><code>Get-Help</code> 获取帮助</h3>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PM&gt; <span class="built_in">get-help</span> entityframework</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                     _&#x2F;\__</span><br><span class="line">               ---&#x3D;&#x3D;&#x2F;    \\</span><br><span class="line">         ___  ___   |.    \|\</span><br><span class="line">        | __|| __|  |  )   \\\</span><br><span class="line">        | _| | _|   \_&#x2F; |  &#x2F;&#x2F;|\\</span><br><span class="line">        |___||_|       &#x2F;   \\\&#x2F;\\</span><br><span class="line"></span><br><span class="line">TOPIC</span><br><span class="line">    about_EntityFrameworkCore</span><br><span class="line"></span><br><span class="line">SHORT DESCRIPTION</span><br><span class="line">    Provides information about the Entity Framework Core Package Manager Console Tools.</span><br><span class="line"></span><br><span class="line">LONG DESCRIPTION</span><br><span class="line">    This topic describes the Entity Framework Core Package Manager Console Tools. </span><br><span class="line">    See https:&#x2F;&#x2F;docs.efproject.net for information on Entity Framework Core.</span><br><span class="line"></span><br><span class="line">    The following Entity Framework Core commands are available.</span><br><span class="line"></span><br><span class="line">        Cmdlet                      Description</span><br><span class="line">        --------------------------  ---------------------------------------------------</span><br><span class="line">        Add-Migration               Adds a new migration.</span><br><span class="line"></span><br><span class="line">        Drop-Database               Drops the database.</span><br><span class="line"></span><br><span class="line">        Get-DbContext               Gets information about a DbContext type.</span><br><span class="line"></span><br><span class="line">        Remove-Migration            Removes the last migration.</span><br><span class="line"></span><br><span class="line">        Scaffold-DbContext          Scaffolds a DbContext and entity types for a database.</span><br><span class="line"></span><br><span class="line">        Script-Migration            Generates a SQL script from migrations.</span><br><span class="line"></span><br><span class="line">        Update-Database             Updates the database to a specified migration.</span><br><span class="line"></span><br><span class="line">SEE ALSO</span><br><span class="line">    Add-Migration</span><br><span class="line">    Drop-Database</span><br><span class="line">    Get-DbContext</span><br><span class="line">    Remove-Migration</span><br><span class="line">    Scaffold-DbContext</span><br><span class="line">    Script-Migration</span><br><span class="line">    Update-Database</span><br></pre></td></tr></table></figure>
<h3 id="Add-Migration-添加迁移"><a class="header-anchor" href="#Add-Migration-添加迁移">¶</a><code>Add-Migration</code> 添加迁移</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">    Add-Migration</span><br><span class="line">    </span><br><span class="line">SYNOPSIS</span><br><span class="line">    Adds a new migration.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">SYNTAX</span><br><span class="line">    Add-Migration [-Name] &lt;String&gt; [-OutputDir &lt;String&gt;] [-Context &lt;String&gt;] [-Project &lt;String&gt;] </span><br><span class="line">                    [-StartupProject &lt;String&gt;] [&lt;CommonParameters&gt;]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">DESCRIPTION</span><br><span class="line">    Adds a new migration.</span><br><span class="line"></span><br><span class="line">REMARKS</span><br><span class="line">    To see the examples, type: &quot;get-help Add-Migration -examples&quot;.</span><br><span class="line">    For more information, type: &quot;get-help Add-Migration -detailed&quot;.</span><br><span class="line">    For technical information, type: &quot;get-help Add-Migration -full&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="Remove-Migration-删除迁移"><a class="header-anchor" href="#Remove-Migration-删除迁移">¶</a><code>Remove-Migration</code> 删除迁移</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">    Remove-Migration</span><br><span class="line">    </span><br><span class="line">SYNOPSIS</span><br><span class="line">    Removes the last migration.</span><br><span class="line">    </span><br><span class="line">SYNTAX</span><br><span class="line">    Remove-Migration [-Force] [-Context &lt;String&gt;] [-Project &lt;String&gt;] [-StartupProject &lt;String&gt;] </span><br><span class="line">                        [&lt;CommonParameters&gt;]</span><br><span class="line">    </span><br><span class="line">DESCRIPTION</span><br><span class="line">    Removes the last migration.</span><br><span class="line"></span><br><span class="line">RELATED LINKS</span><br><span class="line">    Add-Migration</span><br><span class="line">    about_EntityFrameworkCore </span><br><span class="line"></span><br><span class="line">REMARKS</span><br><span class="line">    To see the examples, type: &quot;get-help Remove-Migration -examples&quot;.</span><br><span class="line">    For more information, type: &quot;get-help Remove-Migration -detailed&quot;.</span><br><span class="line">    For technical information, type: &quot;get-help Remove-Migration -full&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="Update-Database-更新数据库"><a class="header-anchor" href="#Update-Database-更新数据库">¶</a><code>Update-Database</code> 更新数据库</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">    Update-Database</span><br><span class="line">    </span><br><span class="line">SYNOPSIS</span><br><span class="line">    Updates the database to a specified migration.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">SYNTAX</span><br><span class="line">    Update-Database [[-Migration] &lt;String&gt;] [-Context &lt;String&gt;] [-Project &lt;String&gt;] </span><br><span class="line">                        [-StartupProject &lt;String&gt;] [&lt;CommonParameters&gt;]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">DESCRIPTION</span><br><span class="line">    Updates the database to a specified migration.</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">RELATED LINKS</span><br><span class="line">    Script-Migration</span><br><span class="line">    about_EntityFrameworkCore </span><br><span class="line"></span><br><span class="line">REMARKS</span><br><span class="line">    To see the examples, type: &quot;get-help Update-Database -examples&quot;.</span><br><span class="line">    For more information, type: &quot;get-help Update-Database -detailed&quot;.</span><br><span class="line">    For technical information, type: &quot;get-help Update-Database -full&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="Script-migration-脚本迁移"><a class="header-anchor" href="#Script-migration-脚本迁移">¶</a><code>Script-migration</code> 脚本迁移</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">    Script-Migration</span><br><span class="line">    </span><br><span class="line">SYNOPSIS</span><br><span class="line">    Generates a SQL script from migrations.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">SYNTAX</span><br><span class="line">    Script-Migration [-From] &lt;String&gt; [-To] &lt;String&gt; [-Idempotent] [-Output &lt;String&gt;] </span><br><span class="line">                        [-Context &lt;String&gt;] [-Project &lt;String&gt;] [-StartupProject &lt;String&gt;] </span><br><span class="line">                        [&lt;CommonParameters&gt;]</span><br><span class="line">    </span><br><span class="line">    Script-Migration [[-From] &lt;String&gt;] [-Idempotent] [-Output &lt;String&gt;] [-Context &lt;String&gt;] </span><br><span class="line">                        [-Project &lt;String&gt;] [-StartupProject &lt;String&gt;] [&lt;CommonParameters&gt;]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">DESCRIPTION</span><br><span class="line">    Generates a SQL script from migrations.</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">RELATED LINKS</span><br><span class="line">    Update-Database</span><br><span class="line">    about_EntityFrameworkCore </span><br><span class="line"></span><br><span class="line">REMARKS</span><br><span class="line">    To see the examples, type: &quot;get-help Script-Migration -examples&quot;.</span><br><span class="line">    For more information, type: &quot;get-help Script-Migration -detailed&quot;.</span><br><span class="line">    For technical information, type: &quot;get-help Script-Migration -full&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="scaffold-dbcontext-支架数据库上下文"><a class="header-anchor" href="#scaffold-dbcontext-支架数据库上下文">¶</a><code>scaffold-dbcontext</code> 支架数据库上下文</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">    Scaffold-DbContext</span><br><span class="line">    </span><br><span class="line">SYNOPSIS</span><br><span class="line">    Scaffolds a DbContext and entity types for a database.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">SYNTAX</span><br><span class="line">    Scaffold-DbContext [-Connection] &lt;String&gt; [-Provider] &lt;String&gt; [-OutputDir &lt;String&gt;] </span><br><span class="line">                        [-Context &lt;String&gt;] [-Schemas &lt;String[]&gt;] [-Tables &lt;String[]&gt;] </span><br><span class="line">                        [-DataAnnotations] [-Force] [-Project &lt;String&gt;] [-StartupProject &lt;String&gt;] </span><br><span class="line">                        [&lt;CommonParameters&gt;]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">DESCRIPTION</span><br><span class="line">    Scaffolds a DbContext and entity types for a database.</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">RELATED LINKS</span><br><span class="line">    about_EntityFrameworkCore </span><br><span class="line"></span><br><span class="line">REMARKS</span><br><span class="line">    To see the examples, type: &quot;get-help Scaffold-DbContext -examples&quot;.</span><br><span class="line">    For more information, type: &quot;get-help Scaffold-DbContext -detailed&quot;.</span><br><span class="line">    For technical information, type: &quot;get-help Scaffold-DbContext -full&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="Get-DbContext"><a class="header-anchor" href="#Get-DbContext">¶</a><code>Get-DbContext</code></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">    Get-DbContext</span><br><span class="line">    </span><br><span class="line">SYNOPSIS</span><br><span class="line">    Gets information about a DbContext type.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">SYNTAX</span><br><span class="line">    Get-DbContext [-Context &lt;String&gt;] [-Project &lt;String&gt;] [-StartupProject &lt;String&gt;] </span><br><span class="line">                    [&lt;CommonParameters&gt;]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">DESCRIPTION</span><br><span class="line">    Gets information about a DbContext type.</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">RELATED LINKS</span><br><span class="line">    about_EntityFrameworkCore </span><br><span class="line"></span><br><span class="line">REMARKS</span><br><span class="line">    To see the examples, type: &quot;get-help Get-DbContext -examples&quot;.</span><br><span class="line">    For more information, type: &quot;get-help Get-DbContext -detailed&quot;.</span><br><span class="line">    For technical information, type: &quot;get-help Get-DbContext -full&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="Drop-Database-删除数据库"><a class="header-anchor" href="#Drop-Database-删除数据库">¶</a><code>Drop-Database</code> 删除数据库</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">    Drop-Database</span><br><span class="line">    </span><br><span class="line">SYNOPSIS</span><br><span class="line">    Drops the database.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">SYNTAX</span><br><span class="line">    Drop-Database [-Context &lt;String&gt;] [-Project &lt;String&gt;] [-StartupProject &lt;String&gt;] </span><br><span class="line">                    [-WhatIf] [-Confirm] [&lt;CommonParameters&gt;]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">DESCRIPTION</span><br><span class="line">    Drops the database.</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">RELATED LINKS</span><br><span class="line">    Update-Database</span><br><span class="line">    about_EntityFrameworkCore </span><br><span class="line"></span><br><span class="line">REMARKS</span><br><span class="line">    To see the examples, type: &quot;get-help Drop-Database -examples&quot;.</span><br><span class="line">    For more information, type: &quot;get-help Drop-Database -detailed&quot;.</span><br><span class="line">    For technical information, type: &quot;get-help Drop-Database -full&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="用于迁移的命令行界面命令"><a class="header-anchor" href="#用于迁移的命令行界面命令">¶</a>用于迁移的命令行界面命令</h3>
<p>使用 .NET Core Command List Interface 执行实体框架核心命令。要使用 .NET CLI，请通过编辑 .NET Core 项目的 .csproj 文件，在 <code>&lt;ItemGroup&gt;</code> 节点下添加<code>&lt;DotNetCliToolReference Include=&quot;Microsoft.EntityFrameworkCore.Tools.DotNet&quot; Version =&quot;2.0.0&quot; /&gt;</code>。<br>
打开命令提示符，然后导航到项目的根文件夹，然后输入 <code>dotnet ef --help</code> 列出 EF Core 命令，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef --help</span><br><span class="line">Entity Framework Core .NET Command Line Tools 2.0.0-rtm-26452</span><br><span class="line"></span><br><span class="line">Usage: dotnet ef [options] [command]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --version        Show version information</span><br><span class="line">  -h|--help        Show help information</span><br><span class="line">  -v|--verbose     Show verbose output.</span><br><span class="line">  --no-color       Don&#39;t colorize output.</span><br><span class="line">  --prefix-output  Prefix output with level.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  database    Commands to manage the database.</span><br><span class="line">  dbcontext   Commands to manage DbContext types.</span><br><span class="line">  migrations  Commands to manage migrations.</span><br><span class="line"></span><br><span class="line">Use &quot;dotnet ef [command] --help&quot; for more information about a command.</span><br></pre></td></tr></table></figure>
<p>正如您在上面看到的，有三个主要的 EF 命令可用：<code>database</code>，<code>dbcontext</code> 和 <code>migrations</code>。下表列出了所有 EF 命令和子命令。</p>
<table>
    <thead>
        <tr>
            <th style="text-align: center">命令</th>
            <th style="text-align: center">子命令</th>
            <th style="text-align: center">用法</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="2" style="text-align: center; vertical-align: middle">
                <code>dotnet ef database</code>
            </td>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#database-drop" target="_blank" rel="noopener"><code>drop</code></a>
            </td>
            <td style="text-align: center">删除数据库</td>
        </tr>
        <tr>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#database-update" target="_blank" rel="noopener"><code>update</code></a>
            </td>
            <td style="text-align: center">将数据库更新为指定的迁移</td>
        </tr>
        <tr>
            <td rowspan="3" style="text-align: center; vertical-align: middle">
                <code>dotnet ef dbcontext</code>
            </td>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#dbcontext-info" target="_blank" rel="noopener"><code>info</code></a>
            </td>
            <td style="text-align: center">获取有关 <code>DbContext</code> 类型的信息</td>
        </tr>
        <tr>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#dbcontext-list" target="_blank" rel="noopener"><code>list</code></a>
            </td>
            <td style="text-align: center">列出可用的 <code>DbContext</code> 类型</td>
        </tr>
        <tr>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#dbcontext-scaffold" target="_blank" rel="noopener"><code>scaffold</code></a>
            </td>
            <td style="text-align: center">为数据库提供 <code>DbContext</code> 和实体类型</td>
        </tr>
        <tr>
            <td rowspan="4" style="text-align: center; vertical-align: middle">
                <code>dotnet ef migrations</code>
            </td>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#migrations-add" target="_blank" rel="noopener"><code>add</code></a>
            </td>
            <td style="text-align: center">添加新的迁移</td>
        </tr>
        <tr>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#migrations-list" target="_blank" rel="noopener"><code>list</code></a>
            </td>
            <td style="text-align: center">列出可用的迁移</td>
        </tr>
        <tr>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#migrations-remove" target="_blank" rel="noopener"><code>remove</code></a>
            </td>
            <td style="text-align: center">删除上一次迁移</td>
        </tr>
        <tr>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#migrations-script" target="_blank" rel="noopener"><code>script</code></a>
            </td>
            <td style="text-align: center">从迁移生成 SQL 脚本</td>
        </tr>
    </tbody>
</table>
<p>让我们看看每个命令的可用选项。</p>
<h3 id="dotnet-ef-database-drop"><a class="header-anchor" href="#dotnet-ef-database-drop">¶</a><code>dotnet ef database drop</code></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef database drop</span><br><span class="line">Usage: dotnet ef database drop [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f|--force                             Don&#39;t confirm.</span><br><span class="line">  --dry-run                              Show which database would be dropped, but don&#39;t drop it.</span><br><span class="line">  -c|--context &lt;DBCONTEXT&gt;               The DbContext to use.</span><br><span class="line">  -p|--project &lt;PROJECT&gt;                 The project to use.</span><br><span class="line">  -s|--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br><span class="line">  --framework &lt;FRAMEWORK&gt;                The target framework.</span><br><span class="line">  --configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br><span class="line">  --runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br><span class="line">  --msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to &quot;obj&quot;.</span><br><span class="line">  --no-build                             Don&#39;t build the project. Only use this when </span><br><span class="line">                                         the build is up-to-date.</span><br></pre></td></tr></table></figure>
<h3 id="dotnet-ef-database-update"><a class="header-anchor" href="#dotnet-ef-database-update">¶</a><code>dotnet ef database update</code></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef database update</span><br><span class="line">Usage: dotnet ef database update [arguments] [options]</span><br><span class="line"></span><br><span class="line">Arguments:</span><br><span class="line">  &lt;MIGRATION&gt;  The target migration. If &#39;0&#39;, all migrations will be reverted. De</span><br><span class="line">faults to the last migration.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -c|--context &lt;DBCONTEXT&gt;               The DbContext to use.</span><br><span class="line">  -p|--project &lt;PROJECT&gt;                 The project to use.</span><br><span class="line">  -s|--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br><span class="line">  --framework &lt;FRAMEWORK&gt;                The target framework.</span><br><span class="line">  --configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br><span class="line">  --runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br><span class="line">  --msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to &quot;obj&quot;.</span><br><span class="line">  --no-build                             Don&#39;t build the project. Only use this when</span><br><span class="line">                                         the build is up-to-date.</span><br></pre></td></tr></table></figure>
<h3 id="dotnet-ef-dbcontext-info"><a class="header-anchor" href="#dotnet-ef-dbcontext-info">¶</a><code>dotnet ef dbcontext info</code></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef dbcontext info</span><br><span class="line"></span><br><span class="line">Usage: dotnet ef dbcontext info [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --json                                 Show JSON output.</span><br><span class="line">  -c|--context &lt;DBCONTEXT&gt;               The DbContext to use.</span><br><span class="line">  -p|--project &lt;PROJECT&gt;                 The project to use.</span><br><span class="line">  -s|--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br><span class="line">  --framework &lt;FRAMEWORK&gt;                The target framework.</span><br><span class="line">  --configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br><span class="line">  --runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br><span class="line">  --msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to &quot;obj&quot;.</span><br><span class="line">  --no-build                             Don&#39;t build the project. Only use this </span><br><span class="line">                                         when the build is up-to-date.</span><br></pre></td></tr></table></figure>
<h3 id="dotnet-ef-dbcontext-scaffold"><a class="header-anchor" href="#dotnet-ef-dbcontext-scaffold">¶</a><code>dotnet ef dbcontext scaffold</code></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef dbcontext scaffold</span><br><span class="line"></span><br><span class="line">Usage: dotnet ef dbcontext scaffold [arguments] [options]</span><br><span class="line"></span><br><span class="line">Arguments:</span><br><span class="line">  &lt;CONNECTION&gt;  The connection string to the database.</span><br><span class="line">  &lt;PROVIDER&gt;    The provider to use. (E.g. Microsoft.EntityFrameworkCore.SqlServ</span><br><span class="line">er)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -d|--data-annotations                  Use attributes to configure the model (</span><br><span class="line">where possible). If omitted, only the fluent API is used.</span><br><span class="line">  -c|--context &lt;NAME&gt;                    The name of the DbContext.</span><br><span class="line">  -f|--force                             Overwrite existing files.</span><br><span class="line">  -o|--output-dir &lt;PATH&gt;                 The directory to put files in. Paths ar</span><br><span class="line">e relative to the project directory.</span><br><span class="line">  --schema &lt;SCHEMA_NAME&gt;...              The schemas of tables to generate entit</span><br><span class="line">y types for.</span><br><span class="line">  -t|--table &gt;TABLE_NAME&lt;...             The tables to generate entity types for.</span><br><span class="line">  --use-database-names                   Use table and column names directly from the database.</span><br><span class="line">  --json                                 Show JSON output.</span><br><span class="line">  -p|--project &lt;PROJECT&gt;                 The project to use.</span><br><span class="line">  -s|--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br><span class="line">  --framework &lt;FRAMEWORK&gt;                The target framework.</span><br><span class="line">  --configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br><span class="line">  --runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br><span class="line">  --msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to &quot;obj&quot;.</span><br><span class="line">  --no-build                             Don&#39;t build the project. Only use this </span><br><span class="line">                                         when the build is up-to-date.</span><br></pre></td></tr></table></figure>
<h3 id="dotnet-ef-migrations-add"><a class="header-anchor" href="#dotnet-ef-migrations-add">¶</a><code>dotnet ef migrations add</code></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef migrations add</span><br><span class="line"></span><br><span class="line">Usage: dotnet ef migrations add [arguments] [options]</span><br><span class="line"></span><br><span class="line">Arguments:</span><br><span class="line">  &lt;NAME&gt;  The name of the migration.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -o|--output-dir &lt;PATH&gt;                 The directory (and sub-namespace) to us</span><br><span class="line">e. Paths are relative to the project directory. Defaults to &quot;Migrations&quot;.</span><br><span class="line">  --json                                 Show JSON output.</span><br><span class="line">  -c|--context &lt;DBCONTEXT&gt;               The DbContext to use.</span><br><span class="line">  -p|--project &lt;PROJECT&gt;                 The project to use.</span><br><span class="line">  -s|--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br><span class="line">  --framework &lt;FRAMEWORK&gt;                The target framework.</span><br><span class="line">  --configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br><span class="line">  --runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br><span class="line">  --msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to &quot;obj&quot;.</span><br><span class="line">  --no-build                             Don&#39;t build the project. Only use this </span><br><span class="line">                                         when the build is up-to-date.</span><br></pre></td></tr></table></figure>
<h3 id="dotnet-ef-migrations-list"><a class="header-anchor" href="#dotnet-ef-migrations-list">¶</a><code>dotnet ef migrations list</code></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef migrations list</span><br><span class="line"></span><br><span class="line">Usage: dotnet ef migrations list [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --json                                 Show JSON output.</span><br><span class="line">  -c|--context &lt;DBCONTEXT&gt;               The DbContext to use.</span><br><span class="line">  -p|--project &lt;PROJECT&gt;                 The project to use.</span><br><span class="line">  -s|--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br><span class="line">  --framework &lt;FRAMEWORK&gt;                The target framework.</span><br><span class="line">  --configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br><span class="line">  --runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br><span class="line">  --msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to &quot;obj&quot;.</span><br><span class="line">  --no-build                             Don&#39;t build the project. Only use this </span><br><span class="line">                                         when the build is up-to-date.</span><br></pre></td></tr></table></figure>
<h3 id="dotnet-ef-migrations-remove"><a class="header-anchor" href="#dotnet-ef-migrations-remove">¶</a><code>dotnet ef migrations remove</code></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef migrations remove</span><br><span class="line"></span><br><span class="line">Usage: dotnet ef migrations remove [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f|--force                             Don&#39;t check to see if the migration has</span><br><span class="line"> been applied to the database.</span><br><span class="line">  --json                                 Show JSON output.</span><br><span class="line">  -c|--context &lt;DBCONTEXT&gt;               The DbContext to use.</span><br><span class="line">  -p|--project &lt;PROJECT&gt;                 The project to use.</span><br><span class="line">  -s|--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br><span class="line">  --framework &lt;FRAMEWORK&gt;                The target framework.</span><br><span class="line">  --configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br><span class="line">  --runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br><span class="line">  --msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to &quot;obj&quot;.</span><br><span class="line">  --no-build                             Don&#39;t build the project. Only use this </span><br><span class="line">                                         when the build is up-to-date.</span><br></pre></td></tr></table></figure>
<h3 id="dotnet-ef-migrations-script"><a class="header-anchor" href="#dotnet-ef-migrations-script">¶</a><code>dotnet ef migrations script</code></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PM&gt; dotnet ef migrations script</span><br><span class="line"></span><br><span class="line">Usage: dotnet ef migrations script [arguments] [options]</span><br><span class="line"></span><br><span class="line">Arguments:</span><br><span class="line">  &lt;FROM&gt;  The starting migration. Defaults to &#39;0&#39; (the initial database).</span><br><span class="line">  &lt;TO&gt;    The ending migration. Defaults to the last migration.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -o|--output &lt;FILE&gt;                     The file to write the result to.</span><br><span class="line">  -i|--idempotent                        Generate a script that can be used on a</span><br><span class="line"> database at any migration.</span><br><span class="line">  -c|--context &lt;DBCONTEXT&gt;               The DbContext to use.</span><br><span class="line">  -p|--project &lt;PROJECT&gt;                 The project to use.</span><br><span class="line">  -s|--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br><span class="line">  --framework &lt;FRAMEWORK&gt;                The target framework.</span><br><span class="line">  --configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br><span class="line">  --runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br><span class="line">  --msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to &quot;obj&quot;.</span><br><span class="line">  --no-build                             Don&#39;t build the project. Only use this </span><br><span class="line">                                         when the build is up-to-date.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>.NET Core</tag>
        <tag>ORM</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
