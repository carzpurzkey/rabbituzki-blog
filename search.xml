<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>解决 PowerShell 7 在脱机状态下启动耗时长的问题</title>
    <url>/2022/04/23/%E8%A7%A3%E5%86%B3-PowerShell-7-%E5%9C%A8%E8%84%B1%E6%9C%BA%E7%8A%B6%E6%80%81%E4%B8%8B%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%E9%95%BF%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1>解决 PowerShell 7 在脱机状态下启动耗时长的问题</h1>
<hr>
<h2 id="测试"><a class="header-anchor" href="#测试">¶</a>测试</h2>
<p>在使用 <code>pwsh -nop -noni</code> 启动 PowerShell 7 后立即执行：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">measure-command</span> &#123; ipmo Microsoft.PowerShell.Management &#125;<br></code></pre></div></td></tr></table></figure>
<p>观察输出结果。然后使用命令 <code>pwsh -nop -noni</code> 重新启动 PowerShell 7 后立即执行：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">measure-command</span> &#123; ipmo PSReadLine &#125;<br></code></pre></div></td></tr></table></figure>
<p>发现导入 PSReadLine 时共用时 15 秒。</p>
<h2 id="解决方案："><a class="header-anchor" href="#解决方案：">¶</a>解决方案：</h2>
<p>修改以下注册表键值会降低 Windows 获取“证书吊销列表”(Certificate Revocation List) 时的等待时间。同时会影响到那些需要验证证书的链接 (如使用 SSL 进行连接时)。修改这些键值后会提高 PowerShell 7 的启动速度。</p>
<blockquote>
<p><strong>注意</strong><br>
尽量只在你的机器没有互联网或没有无法访问“证书吊销列表”时进行如下设置！谨记，由于不同应用或不用服务器间对于证书吊销列表的检查方式不同，所以这并不见得是一个全局的解决方案！同时你需要考虑将来如何维护服务器的根证书和如何更新你的证书吊销列表。</p>
</blockquote>
<p>以下注册表键值将会把上述超时时间控制在 1 秒内。</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># Create the keys if missing </span><br><span class="hljs-keyword">If</span>((<span class="hljs-built_in">Test-Path</span> <span class="hljs-string">'HKLM:\SOFTWARE\Policies\Microsoft\SystemCertificates\ChainEngine'</span>) <span class="hljs-operator">-eq</span> <span class="hljs-variable">$false</span> ) &#123; <span class="hljs-built_in">New-Item</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">'HKLM:\SOFTWARE\Policies\Microsoft\SystemCertificates\ChainEngine'</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ErrorAction</span> SilentlyContinue &#125;<br><span class="hljs-keyword">If</span>((<span class="hljs-built_in">Test-Path</span> <span class="hljs-string">'HKLM:\SOFTWARE\Policies\Microsoft\SystemCertificates\ChainEngine\Config'</span>) <span class="hljs-operator">-eq</span> <span class="hljs-variable">$false</span> ) &#123; <span class="hljs-built_in">New-Item</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">'HKLM:\SOFTWARE\Policies\Microsoft\SystemCertificates\ChainEngine\Config'</span> <span class="hljs-literal">-Force</span> <span class="hljs-literal">-ErrorAction</span> SilentlyContinue &#125;<br><br><span class="hljs-comment"># Set Timeout values to 1 second (1000 ms)</span><br><span class="hljs-built_in">New-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">"HKLM:\SOFTWARE\Policies\Microsoft\SystemCertificates\ChainEngine\Config"</span> <span class="hljs-literal">-Name</span> ChainUrlRetrievalTimeoutMilliseconds <span class="hljs-literal">-Value</span> <span class="hljs-number">1000</span> <span class="hljs-literal">-PropertyType</span> DWORD <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">New-ItemProperty</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">"HKLM:\SOFTWARE\Policies\Microsoft\SystemCertificates\ChainEngine\Config"</span> <span class="hljs-literal">-Name</span> ChainRevAccumulativeUrlRetrievalTimeoutMilliseconds <span class="hljs-literal">-Value</span> <span class="hljs-number">1000</span> <span class="hljs-literal">-PropertyType</span> DWORD <span class="hljs-literal">-Force</span><br></code></pre></div></td></tr></table></figure>
<p>你也可以使用“域组策略编辑器”或“本地组策略编辑器” (gpedit.msc) 更改这些设置</p>
<p><img src="images/screenshot-20220423.png" alt="screenshot"></p>
<blockquote>
<p><a href="https://github.com/PowerShell/PowerShell/issues/10983#issuecomment-779819256" target="_blank" rel="noopener">Github原贴</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>疑难</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Windows</tag>
        <tag>PowerShell</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NET Core 认证与授权</title>
    <url>/2022/02/09/ASP.NET-Core-%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h1><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 认证与授权</h1>
<h2 id="基于声明的认证"><a class="header-anchor" href="#基于声明的认证">¶</a>基于声明的认证</h2>
<p>Claim 通常被翻译成声明，但是感觉过于生硬，还是使用 <strong>Claim</strong> 来称呼更加自然一些。Claim 是关于一个人或组织的某个主题的陈述，比如：一个人的名称，角色，个人喜好，种族，特权，社团，能力等等。它本质上就是一个键值对，是一种非常通用的保存用户信息的方式，可以很容易的将认证和授权分离开来，前者用来表示用户是/不是什么，后者用来表示用户能/不能做什么。</p>
<h2 id="ASP-NET-Core-中的用户身份"><a class="header-anchor" href="#ASP-NET-Core-中的用户身份">¶</a><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 中的用户身份</h2>
<h3 id="Claim"><a class="header-anchor" href="#Claim">¶</a>Claim</h3>
<p>在 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 中，使用 <code>Claim</code> 类来表示用户身份中的一项信息，它由核心的 <code>Type</code> 和 <code>Value</code> 属性构成：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Claim</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">string</span> _type;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">string</span> _value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Claim</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> type, <span class="hljs-keyword">string</span> <span class="hljs-keyword">value</span></span>)</span><br><span class="hljs-function">        : <span class="hljs-title">this</span>(<span class="hljs-params">type, <span class="hljs-keyword">value</span>, ClaimValueTypes.String, ClaimsIdentity.DefaultIssuer, ClaimsIdentity.DefaultIssuer, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span></span>)</span><br><span class="hljs-function"></span>    &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-title">Claim</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> type, <span class="hljs-keyword">string</span> <span class="hljs-keyword">value</span>, <span class="hljs-keyword">string</span> valueType, <span class="hljs-keyword">string</span> issuer, <span class="hljs-keyword">string</span> originalIssuer, ClaimsIdentity subject, <span class="hljs-keyword">string</span> propertyKey, <span class="hljs-keyword">string</span> propertyValue</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Type =&gt; _type;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Value =&gt; _value;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>一个 Claim 可以是“用户的姓名”，“邮箱地址”，“电话”，等等，而多个 Claim 构成一个用户的身份，使用 <code>ClaimsIdentity</code> 类来表示：</p>
<h3 id="ClaimsIdentity"><a class="header-anchor" href="#ClaimsIdentity">¶</a>ClaimsIdentity</h3>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClaimsIdentity</span> : <span class="hljs-title">IIdentity</span><br>&#123;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> IEnumerable&lt;Claim&gt; Claims &#123;<span class="hljs-keyword">get</span>;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">string</span> AuthenticationType =&gt; _authenticationType;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> IsAuthenticated =&gt; !<span class="hljs-keyword">string</span>.IsNullOrEmpty(_authenticationType);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            Claim claim = FindFirst(_nameClaimType);<br>            <span class="hljs-keyword">if</span> (claim != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> claim.Value;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如上，其 <code>Name</code> 属性用来查找 Claims 中，<strong>第一个 Type 为我们创建 <code>ClaimsIdentity</code> 时指定的 NameClaimType 的 Claim 的值，若未指定Type时则使用默认的 <code>ClaimTypes.Name</code></strong>。而 <code>IsAuthenticated</code> 只是判断 <code>_authenticationType</code> 是否为空。<code>_authenticationType</code> 对应 Scheme <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="¶ClaimsPrincipal
">[1]</span></a></sup></p>
<p>下面，我们演示一下用户身份的创建：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// 创建一个用户身份，注意需要指定AuthenticationType，否则IsAuthenticated将为false。</span><br><span class="hljs-keyword">var</span> claimIdentity = <span class="hljs-keyword">new</span> ClaimsIdentity(<span class="hljs-string">"myAuthenticationType"</span>);<br><span class="hljs-comment">// 添加几个Claim</span><br>claimIdentity.AddClaim(<span class="hljs-keyword">new</span> Claim(ClaimTypes.Name, <span class="hljs-string">"bob"</span>));<br>claimIdentity.AddClaim(<span class="hljs-keyword">new</span> Claim(ClaimTypes.Email, <span class="hljs-string">"bob@gmail.com"</span>));<br>claimIdentity.AddClaim(<span class="hljs-keyword">new</span> Claim(ClaimTypes.MobilePhone, <span class="hljs-string">"18888888888"</span>));<br></code></pre></div></td></tr></table></figure>
<p>如上，我们可以根据需要添加任意个的 Claim，最后我们还需要再将用户身份放到 <code>ClaimsPrincipal</code> 对象中。</p>
<blockquote></blockquote>
<p>在 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 中，HttpContext 直接使用的就是 <code>ClaimsPrincipal</code> 代表用户：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HttpContext</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ClaimsPrincipal User &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在 ClaimsPrincipal 中，可以包含多个用户身份 (ClaimsIdentity)，除了对用户身份的操作，还提供了针对 Claims 的查询：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClaimsPrincipal</span> : <span class="hljs-title">IPrincipal</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> List&lt;ClaimsIdentity&gt; _identities = <span class="hljs-keyword">new</span> List&lt;ClaimsIdentity&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClaimsPrincipal</span>(<span class="hljs-params">IEnumerable&lt;ClaimsIdentity&gt; identities</span>) </span><br><span class="hljs-function"></span>    &#123;<br>        _identities.AddRange(identities);<br>    &#125;<br><br>    <span class="hljs-comment">// 默认从_identities中查找第一个不为空的ClaimsIdentity，也可以自定义查找方式。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> System.Security.Principal.IIdentity Identity &#123;&#125;<br><br>    <span class="hljs-comment">// 查找_identities中是否包含类型为RoleClaimType(在创建ClaimsIdentity时指定，或者默认的ClaimTypes.Role)的Claim。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IsInRole</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> role</span>)</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 获取所有身份的Claim集合</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> IEnumerable&lt;Claim&gt; Claims<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">foreach</span> (ClaimsIdentity identity <span class="hljs-keyword">in</span> Identities)<br>            &#123;<br>                <span class="hljs-keyword">foreach</span> (Claim claim <span class="hljs-keyword">in</span> identity.Claims)<br>                &#123;<br>                    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> claim;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>IPrincipal</code> 来源于 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> 4.x：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPrincipal</span><br>&#123;<br>    IIdentity Identity &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsInRole</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> role</span>)</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</blockquote>
<p>ClaimsPrincipal 的创建非常简单，只需传入我们上面创建的用户身份即可：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> principal = <span class="hljs-keyword">new</span> ClaimsPrincipal(claimIdentity);<br></code></pre></div></td></tr></table></figure>
<p>由于 HTTP 是无状态的，我们通常使用 Cookie，请求头或请求参数等方式来附加用户的信息，在网络上进行传输，这就涉及到序列化和安全方面的问题。因此，还需要将 ClaimPrincipal 对象包装成 <code>AuthenticationTicket</code> 对象。</p>
<h3 id="AuthenticationTicket"><a class="header-anchor" href="#AuthenticationTicket">¶</a>AuthenticationTicket</h3>
<p>当我们创建完 <code>ClaimsPrincipal</code> 对象后，需要将它生成一个用户票据并颁发给用户，然后用户拿着这个票据，便可以访问受保持的资源，而在 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 中，用户票据用 <code>AuthenticationTicket</code> 来表示，如在Cookie认证中，其认证后的Cookie值便是对该对象序列化后的结果，它的定义如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthenticationTicket</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AuthenticationTicket</span>(<span class="hljs-params">ClaimsPrincipal principal, AuthenticationProperties properties, <span class="hljs-keyword">string</span> authenticationScheme</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        AuthenticationScheme = authenticationScheme;<br>        Principal = principal;<br>        Properties = properties ?? <span class="hljs-keyword">new</span> AuthenticationProperties();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AuthenticationTicket</span>(<span class="hljs-params">ClaimsPrincipal principal, <span class="hljs-keyword">string</span> authenticationScheme</span>) </span><br><span class="hljs-function">        : <span class="hljs-title">this</span>(<span class="hljs-params">principal, properties: <span class="hljs-literal">null</span>, authenticationScheme: authenticationScheme</span>)</span> &#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> AuthenticationScheme &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> ClaimsPrincipal Principal &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> AuthenticationProperties Properties &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>用户票据除了包含上面创建的 ClaimPrincipal 对象外，还需要指定一个 <code>AuthenticationScheme</code> (通常在授权中用来验证 Scheme)，并且 <strong>还包含一个 <code>AuthenticationProperties</code> 对象，它主要是一些用户票据安全方面的一些配置，如过期时间，是否持久等</strong>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> properties = <span class="hljs-keyword">new</span> AuthenticationProperties();<br><span class="hljs-keyword">var</span> ticket = <span class="hljs-keyword">new</span> AuthenticationTicket(principal, properties, <span class="hljs-string">"myScheme"</span>);<br><span class="hljs-comment">// 加密 序列化</span><br><span class="hljs-keyword">var</span> token = Protect(ticket);<br></code></pre></div></td></tr></table></figure>
<p>最后，我们可以将票据<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="即 Token。
">[2]</span></a></sup> 写入到 Cookie 中，或是也可以以 JSON 的形式返回让客户端自行保存，由于我们对票据进行了加密，可以保证在网络中安全的传输而不会被篡改。</p>
<blockquote></blockquote>
<p>最终身份令牌的结构大概是这样的：</p>
<p><img src="/images/ASP.NETCORE-AUTH/1.png" alt="TOKEN_LAYOUT"></p>
<h2 id="ASP-NET-Core-中的身份认证-Microsoft-AspNetCore-Authentication"><a class="header-anchor" href="#ASP-NET-Core-中的身份认证-Microsoft-AspNetCore-Authentication">¶</a><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 中的身份认证 <code>Microsoft.AspNetCore.Authentication</code></h2>
<p><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 中的认证系统具体实现在 <a href="https://github.com/aspnet/Security" target="_blank" rel="noopener">Security</a> 项目中，它包含 <code>Cookie</code>, <code>JwtBearer</code>, <code>OAuth</code>, <code>OpenIdConnect</code> 等：</p>
<p><img src="/images/ASP.NETCORE-AUTH/2.png" alt="Microsoft.AspNetCore.Authentication"></p>
<p>认证系统提供了非常灵活的扩展，可以让我们<strong>很容易的实现自定义认证方式</strong>。</p>
<p>而对于认证系统的配置，分为两步，也是我们所熟悉的注册服务和配置中间件：</p>
<ol>
<li>
<p>在 DI 中注册服务认证所需的服务：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureServices</span>(<span class="hljs-params">IServiceCollection services</span>)</span> &#123;<br>    services.AddAuthentication(options =&gt;<br>    &#123;<br>        options.DefaultAuthenticateScheme = CookieAuthenticationDefaults.AuthenticationScheme;<br>        options.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;<br>        options.DefaultChallengeScheme = OpenIdConnectDefaults.AuthenticationScheme;<br>    &#125;)<br>    .AddCookie()<br>    .AddOpenIdConnect(o =&gt;<br>    &#123;<br>        o.ClientId = <span class="hljs-string">"server.hybrid"</span>;<br>        o.ClientSecret = <span class="hljs-string">"secret"</span>;<br>        o.Authority = <span class="hljs-string">"https://demo.identityserver.io/"</span>;<br>        o.ResponseType = OpenIdConnectResponseType.CodeIdToken;<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><br><span class="hljs-number">2.</span> 注册认证中间件：<br>   <br>   ```csharp<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> Configure(IApplicationBuilder app)<br>   &#123;<br>       app.UseAuthentication();<br>   &#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<p>如上，我们的系统便支持了<code>Cookie</code>和<code>JwtBearer</code>两种认证方式，在我们的应用程序中使用认证系统时，只需要调用 <code>HttpContext</code> <sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Microsoft.AspNetCore.Authentication，是所有认证实现的公共抽象类，它定义了实现认证Handler的规范，并包含一些共用的方法，如令牌加密，序列化等，AddAuthentication 便是其提供的统一的注册认证服务的扩展方法：
">[3]</span></a></sup> 中认证相关的扩展方法即可。</p>
<blockquote></blockquote>
<h3 id="AddAuthentication"><a class="header-anchor" href="#AddAuthentication">¶</a>AddAuthentication</h3>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AuthenticationBuilder <span class="hljs-title">AddAuthentication</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IServiceCollection services</span>)</span><br><span class="hljs-function"></span>&#123;<br>    services.AddAuthenticationCore();<br>    services.AddDataProtection();<br>    services.AddWebEncoders();<br>    services.TryAddSingleton&lt;ISystemClock, SystemClock&gt;();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AuthenticationBuilder(services);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AuthenticationBuilder <span class="hljs-title">AddAuthentication</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IServiceCollection services, Action&lt;AuthenticationOptions&gt; configureOptions</span>) </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">var</span> builder = services.AddAuthentication();<br>    services.Configure(configureOptions);<br>    <span class="hljs-keyword">return</span> builder;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如上，它首先会调用 <code>AddAuthenticationCore</code> [^4] 方法，然后注册了<code>DataProtection</code>和<code>WebEncoders</code>两个服务。而对 <code>AuthenticationOptions</code> 我们在介绍<code>IAuthenticationSchemeProvider</code> [^5] 时会介绍到，它用来配置 Scheme。</p>
<h3 id="AddScheme"><a class="header-anchor" href="#AddScheme">¶</a>AddScheme</h3>
<p>在上面的 <code>AddAuthentication</code> 中返回的是一个 <code>AuthenticationBuilder</code> 类型，所有认证 Handler 的注册都是以它的扩展形式来实现的，它同时也提供了 <code>AddScheme</code> 扩展方法，使我们可以更加方便的来配置 Scheme：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthenticationBuilder</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AuthenticationBuilder</span>(<span class="hljs-params">IServiceCollection services</span>)</span><br><span class="hljs-function"></span>        =&gt; Services = services;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> IServiceCollection Services &#123; <span class="hljs-keyword">get</span>; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> AuthenticationBuilder AddScheme&lt;TOptions, THandler&gt;(<span class="hljs-keyword">string</span> authenticationScheme, Action&lt;TOptions&gt; configureOptions)        <span class="hljs-keyword">where</span> TOptions : AuthenticationSchemeOptions, <span class="hljs-keyword">new</span>()        <span class="hljs-keyword">where</span> THandler : AuthenticationHandler&lt;TOptions&gt;<br>        =&gt; AddScheme&lt;TOptions, THandler&gt;(authenticationScheme, displayName: <span class="hljs-literal">null</span>, configureOptions: configureOptions);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> AuthenticationBuilder AddScheme&lt;TOptions, THandler&gt;(<span class="hljs-keyword">string</span> authenticationScheme, <span class="hljs-keyword">string</span> displayName, Action&lt;TOptions&gt; configureOptions)        <span class="hljs-keyword">where</span> TOptions : AuthenticationSchemeOptions, <span class="hljs-keyword">new</span>()        <span class="hljs-keyword">where</span> THandler : AuthenticationHandler&lt;TOptions&gt;<br>    &#123;<br>        Services.Configure&lt;AuthenticationOptions&gt;(o =&gt;<br>        &#123;<br>            o.AddScheme(authenticationScheme, scheme =&gt; &#123;<br>                scheme.HandlerType = <span class="hljs-keyword">typeof</span>(THandler);<br>                scheme.DisplayName = displayName;<br>            &#125;);<br>        &#125;);<br>        <span class="hljs-keyword">if</span> (configureOptions != <span class="hljs-literal">null</span>)<br>        &#123;<br>            Services.Configure(authenticationScheme, configureOptions);<br>        &#125;<br>        Services.AddTransient&lt;THandler&gt;();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在这里的 <code>AddScheme</code> 扩展方法只是封装了对 <code>AuthenticationOptions</code> 中 <code>AddScheme</code> 的调用，如上面示例中的 <code>AddCookie</code> 便是调用该扩展方法来实现的。</p>
<h3 id="AddRemoteScheme"><a class="header-anchor" href="#AddRemoteScheme">¶</a>AddRemoteScheme</h3>
<p>看到 “Remote” 我们应该就可以猜到它是一种远程验证方式，先看一下它的定义：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthenticationBuilder</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> AuthenticationBuilder AddRemoteScheme&lt;TOptions, THandler&gt;(<span class="hljs-keyword">string</span> authenticationScheme, <span class="hljs-keyword">string</span> displayName, Action&lt;TOptions&gt; configureOptions)        <span class="hljs-keyword">where</span> TOptions : RemoteAuthenticationOptions, <span class="hljs-keyword">new</span>()        <span class="hljs-keyword">where</span> THandler : RemoteAuthenticationHandler&lt;TOptions&gt;<br>    &#123;<br>        Services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IPostConfigureOptions&lt;TOptions&gt;, EnsureSignInScheme&lt;TOptions&gt;&gt;());<br>        <span class="hljs-keyword">return</span> AddScheme&lt;TOptions, THandler&gt;(authenticationScheme, displayName, configureOptions: configureOptions);<br>    &#125;<br><br>    private class EnsureSignInScheme&lt;TOptions&gt; : IPostConfigureOptions&lt;TOptions&gt; where TOptions : RemoteAuthenticationOptions<br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> AuthenticationOptions _authOptions;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EnsureSignInScheme</span>(<span class="hljs-params">IOptions&lt;AuthenticationOptions&gt; authOptions</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            _authOptions = authOptions.Value;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PostConfigure</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> name, TOptions options</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            options.SignInScheme = options.SignInScheme ?? _authOptions.DefaultSignInScheme ?? _authOptions.DefaultScheme;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">string</span>.Equals(options.SignInScheme, name, StringComparison.Ordinal))<br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(Resources.Exception_RemoteSignInSchemeCannotBeSelf);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>首先使用 PostConfigure 模式（参见：<a href="http://www.cnblogs.com/RainingNight/p/strongly-typed-options-configure-in-asp-net-core.html#postconfigure%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">Options[1]:Configure</a>），对 <code>RemoteAuthenticationOptions</code> 进行验证，要求远程验证中指定的 <code>SignInScheme</code> 不能为自身，这是为什么呢？后文再来解释。然后便是直接调用上面介绍的 <code>AddScheme</code> 方法。</p>
<blockquote>
<p>关于远程验证相对比较复杂，在本章中并不会太过深入的来介绍，在后续其它文章中会逐渐深入。</p>
</blockquote>
<h3 id="UseAuthentication"><a class="header-anchor" href="#UseAuthentication">¶</a>UseAuthentication</h3>
<p>在上面，注册认证中间件时，我们只需调用一个 <code>UseAuthentication</code> 扩展方法，因为它会执行我们注册的所有认证 Handler：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IApplicationBuilder <span class="hljs-title">UseAuthentication</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IApplicationBuilder app</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> app.UseMiddleware&lt;AuthenticationMiddleware&gt;();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>咦，它的代码好简单，只是注册了一个 <code>AuthenticationMiddleware</code> 而已，迫不及待的想看看它的实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthenticationMiddleware</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> RequestDelegate _next;<br>    <span class="hljs-keyword">public</span> IAuthenticationSchemeProvider Schemes &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Invoke</span>(<span class="hljs-params">HttpContext context</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        context.Features.Set&lt;IAuthenticationFeature&gt;(<span class="hljs-keyword">new</span> AuthenticationFeature<br>        &#123;<br>            OriginalPath = context.Request.Path,<br>            OriginalPathBase = context.Request.PathBase<br>        &#125;);<br><br>        <span class="hljs-keyword">var</span> handlers = context.RequestServices.GetRequiredService&lt;IAuthenticationHandlerProvider&gt;();<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> scheme <span class="hljs-keyword">in</span> <span class="hljs-keyword">await</span> Schemes.GetRequestHandlerSchemesAsync())<br>        &#123;<br>            <span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">await</span> handlers.GetHandlerAsync(context, scheme.Name) <span class="hljs-keyword">as</span> IAuthenticationRequestHandler;<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">await</span> handler.HandleRequestAsync())<br>            &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">var</span> defaultAuthenticate = <span class="hljs-keyword">await</span> Schemes.GetDefaultAuthenticateSchemeAsync();<br>        <span class="hljs-keyword">if</span> (defaultAuthenticate != <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> context.AuthenticateAsync(defaultAuthenticate.Name);<br>            <span class="hljs-keyword">if</span> (result?.Principal != <span class="hljs-literal">null</span>)<br>            &#123;<br>                context.User = result.Principal;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">await</span> _next(context);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>很简单，但是很强大，不管我们是使用 Cookie 认证，还是 Bearer 认证，等等，都只需要这一个中间件，因为它会解析所有的 Handler 来执行。</p>
<p>不过，在这里，这会先判断是否具体实现了 <code>IAuthenticationRequestHandler</code> 的 Handler，优先来执行，这个是什么鬼?</p>
<p>查了一下，发现 <code>IAuthenticationRequestHandler</code> 是在 <a href="https://github.com/aspnet/HttpAbstractions" target="_blank" rel="noopener"><code>HttpAbstractions</code></a> 中定义的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IAuthenticationRequestHandler</span> : <span class="hljs-title">IAuthenticationHandler</span><br>&#123;<br>    <span class="hljs-function">Task&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">HandleRequestAsync</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>它多了一个 <code>HandleRequestAsync</code> 方法，那么它存在的意义是什么呢？其实<strong>在 Cookie 认证中并没有用到它，它通常在远程认证（如：OAuth、 OIDC 等）中使用</strong>，<a href="#HandleRequestAsync">下文再来介绍</a>。</p>
<h2 id="认证Handler"><a class="header-anchor" href="#认证Handler">¶</a>认证Handler</h2>
<p>上文中多次提到认证 Handler，它由统一的 <code>AuthenticationMiddleware</code> 来调用，负责具体的认证实现，并分为本地认证与远程认证两种方式。</p>
<p>在本地验证中，身份令牌的发放与认证通常是由同一个服务器来完成，这也是我们比较熟悉的场景，对于 Cookie、JwtBearer 等认证来说，都属于是本地验证。而当我们使用 OAuth、OIDC 等验证方式时，身份令牌的发放则是由独立的服务或是第三方（QQ、Weibo 等）认证来提供，此时在我们的应用程序中获取身份令牌时需要请求远程服务器，因此称之为远程验证。</p>
<h3 id="AuthenticationHandler"><a class="header-anchor" href="#AuthenticationHandler">¶</a>AuthenticationHandler</h3>
<p><code>AuthenticationHandler</code> 是所有认证 Handler 的抽象基类，<strong>对于<span style="color: black; text-decoration-line: underline; text-decoration-style: double">本地</span>认证直接实现该类即可</strong>，定义如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">public abstract class AuthenticationHandler&lt;TOptions&gt; : IAuthenticationHandler where TOptions : AuthenticationSchemeOptions, new()<br>&#123;<br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">InitializeAsync</span>(<span class="hljs-params">AuthenticationScheme scheme, HttpContext context</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        ...<br><br>        <span class="hljs-keyword">await</span> InitializeEventsAsync();<br>        <span class="hljs-keyword">await</span> InitializeHandlerAsync();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">InitializeEventsAsync</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> Task&lt;<span class="hljs-keyword">object</span>&gt; <span class="hljs-title">CreateEventsAsync</span>(<span class="hljs-params"></span>)</span> =&gt; Task.FromResult(<span class="hljs-keyword">new</span> <span class="hljs-keyword">object</span>());<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> Task <span class="hljs-title">InitializeHandlerAsync</span>(<span class="hljs-params"></span>)</span> =&gt; Task.CompletedTask;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;AuthenticateResult&gt; <span class="hljs-title">AuthenticateAsync</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> HandleAuthenticateOnceAsync();<br><br>        ...<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Task&lt;AuthenticateResult&gt; <span class="hljs-title">HandleAuthenticateOnceAsync</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (_authenticateTask == <span class="hljs-literal">null</span>)<br>        &#123;<br>            _authenticateTask = HandleAuthenticateAsync();<br>        &#125;<br>        <span class="hljs-keyword">return</span> _authenticateTask;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Task&lt;AuthenticateResult&gt; <span class="hljs-title">HandleAuthenticateAsync</span>(<span class="hljs-params"></span>)</span>;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> Task <span class="hljs-title">HandleForbiddenAsync</span>(<span class="hljs-params">AuthenticationProperties properties</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Response.StatusCode = <span class="hljs-number">403</span>;<br>        <span class="hljs-keyword">return</span> Task.CompletedTask;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> Task <span class="hljs-title">HandleChallengeAsync</span>(<span class="hljs-params">AuthenticationProperties properties</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Response.StatusCode = <span class="hljs-number">401</span>;<br>        <span class="hljs-keyword">return</span> Task.CompletedTask;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如上，它定义一个抽象方法 <code>HandleAuthenticateAsync</code>，并使用 <code>HandleAuthenticateOnceAsync</code> 方法来保证其在每次认证只执行一次。而 <code>HandleAuthenticateAsync</code> 是认证的核心，交给具体的认证Handler负责实现。而对于 <code>ChallengeAsync</code>、 <code>ForbidAsync</code> 等方法也提供了默认的实现。</p>
<p>而对于 <code>HandleAuthenticateAsync</code> 的实现，大致的逻辑就是从请求中获取上面发放的身份令牌，然后解析成 <code>AuthenticationTicket</code>，并经过一系列的验证，最终返回 <code>ClaimsPrincipal</code> 对象。</p>
<h3 id="RemoteAuthenticationHandler"><a class="header-anchor" href="#RemoteAuthenticationHandler">¶</a>RemoteAuthenticationHandler</h3>
<p><code>RemoteAuthenticationHandler</code> 便是所有<strong>远程</strong>认证的抽象基类了，它继承自 <code>AuthenticationHandler</code>，并实现了 <code>IAuthenticationRequestHandler</code> 接口：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">public abstract class RemoteAuthenticationHandler&lt;TOptions&gt; : AuthenticationHandler&lt;TOptions&gt;, IAuthenticationRequestHandler<br>    <span class="hljs-keyword">where</span> TOptions : RemoteAuthenticationOptions, <span class="hljs-keyword">new</span>()<br>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Task&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">ShouldHandleRequestAsync</span>(<span class="hljs-params"></span>)</span> =&gt; Task.FromResult(Options.CallbackPath == Request.Path);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">HandleRequestAsync</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">await</span> ShouldHandleRequestAsync())<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">var</span> authResult = <span class="hljs-keyword">await</span> HandleRemoteAuthenticateAsync();<br><br>        ...<br><br>        <span class="hljs-keyword">await</span> Context.SignInAsync(SignInScheme, ticketContext.Principal, ticketContext.Properties);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">string</span>.IsNullOrEmpty(ticketContext.ReturnUri)) ticketContext.ReturnUri = <span class="hljs-string">"/"</span>;<br>        Response.Redirect(ticketContext.ReturnUri);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Task&lt;HandleRequestResult&gt; <span class="hljs-title">HandleRemoteAuthenticateAsync</span>(<span class="hljs-params"></span>)</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">async</span> Task&lt;AuthenticateResult&gt; <span class="hljs-title">HandleAuthenticateAsync</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> Context.AuthenticateAsync(SignInScheme);<br><br>        ...<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">HandleForbiddenAsync</span>(<span class="hljs-params">AuthenticationProperties properties</span>)</span><br><span class="hljs-function"></span>        =&gt; Context.ForbidAsync(SignInScheme);<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GenerateCorrelationId</span>(<span class="hljs-params">AuthenticationProperties properties</span>)</span> &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ValidateCorrelationId</span>(<span class="hljs-params">AuthenticationProperties properties</span>)</span> &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><span name="HandleRequestAsync">在上面介绍的 <code>AuthenticationMiddleware</code> 中，提到它会先执行实现了 <code>IAuthenticationRequestHandler</code> 接口的 Handler（远程认证），之后（若未完成认证）再执行本地认证 Handler</span>。</p>
<p>而<code>RemoteAuthenticationHandler</code>中核心的认证逻辑便是 <code>HandleRequestAsync</code> 方法，它主要包含2个步骤：</p>
<ol>
<li>
<p>首先执行一个抽象方法 <code>HandleRemoteAuthenticateAsync</code>，由具体的 Handler 来实现，该方法返回的 <code>HandleRequestResult</code> 对象包含验证的结果（跳过、失败和成功等），在成功时会包含一个 ticket 对象。</p>
</li>
<li>
<p>若上一步验证成功，则根据返回的 ticket，获取到 <code>ClaimsPrincipal</code> 对象，并调用其它认证 Handler 的 <code>Context.SignInAsync</code> 方法。</p>
</li>
</ol>
<p>也就是说，远程 Handler 会在用户未登录时，指引用户跳转到认证服务器，登录成功后，解析认证服务器传回的凭证，最终依赖于本地 Handler 来保存身份令牌。当用户再次访问则无需经过远程 Handler，直接交给本地 Handler 来处理。</p>
<p>由此也可以知道，<strong>远程认证中本身并不具备 SignIn 的能力，所以必须通过指定其它 <code>SignInScheme</code> 交给本地认证来完成 SignIn</strong>。</p>
<p>对于其父类的<code>HandleAuthenticateAsync</code>抽象方法则定义了一个默认实现：“直接转交给本地验证来处理”。当我们需要定义自己的远程认证方式时，通常只需实现 <code>HandleRemoteAuthenticateAsync</code> 即可，而不用再去处理 <code>HandleAuthenticateAsync</code>。</p>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><h3 id="ClaimsPrincipal"><a class="header-anchor" href="#ClaimsPrincipal">¶</a>ClaimsPrincipal</h3>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>即 Token。
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://github.com/aspnet/Security/tree/dev/src/Microsoft.AspNetCore.Authentication" target="_blank" rel="noopener"><code>Microsoft.AspNetCore.Authentication</code></a>，是所有认证实现的公共抽象类，它定义了实现认证Handler的规范，并包含一些共用的方法，如令牌加密，序列化等，<code>AddAuthentication</code> 便是其提供的统一的注册认证服务的扩展方法：
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>.NETCore</tag>
        <tag>Microsoft</tag>
        <tag>认证</tag>
        <tag>授权</tag>
        <tag>IdentityServer</tag>
      </tags>
  </entry>
  <entry>
    <title>LINQ 教程</title>
    <url>/2022/02/09/LINQ-%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1>LINQ 教程</h1>
<p><a href="https://www.cainiaojc.com/linq/linq-quantifier-operators.html" target="_blank" rel="noopener">原文</a></p>
<h2 id="一、查询运算符"><a class="header-anchor" href="#一、查询运算符">¶</a>一、查询运算符</h2>
<h3 id="1-投影运算"><a class="header-anchor" href="#1-投影运算">¶</a>1. 投影运算</h3>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>LINQ 查询可以以 <code>GroupBy</code> 或 <code>Select</code> 子句结尾。</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>查询语法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Select</code></td>
<td>操作转换函数的基础项目值</td>
<td><code>select</code></td>
</tr>
<tr>
<td><code>SelectMany</code></td>
<td>操作项目的值是根据上的转换函数，以及拼合成一个单一的序列的序列</td>
<td>使用多个 <code>from</code> 子句</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><code>Select</code></p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> words = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;<br>&#123;<br>   <span class="hljs-string">"an"</span>, <span class="hljs-string">"apple"</span>, <span class="hljs-string">"a"</span>, <span class="hljs-string">"day"</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> query = words.Select(w =&gt; w.Substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<br><span class="hljs-comment">// 查询语法：</span><br><span class="hljs-comment">// var query = from w in words select w.Substring(0, 1);</span><br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> s <span class="hljs-keyword">in</span> query)<br>&#123;<br>    Console.WriteLine(s);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span><br><span class="hljs-keyword">a</span><br><span class="hljs-keyword">a</span><br>d<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>SelectMany</code></p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">    <span class="hljs-keyword">var</span> phrases = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <span class="hljs-string">"an apple a day"</span>, <span class="hljs-string">"the quick brown fox"</span> &#125;;<br><br>    <span class="hljs-keyword">var</span> query = phrases.SelectMany(p =&gt; p.Split(<span class="hljs-string">' '</span>));<br>    <span class="hljs-comment">// 查询语法</span><br>    <span class="hljs-comment">/*var query = from phrase in phrases</span><br><span class="hljs-comment">                from word in phrase.Split(' ')</span><br><span class="hljs-comment">                select word;*/</span><br><br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">string</span> s <span class="hljs-keyword">in</span> query)<br>        Console.WriteLine(s);<br><br>Console.ReadLine();<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">an</span><br>apple<br><span class="hljs-keyword">a</span><br>day<br><span class="hljs-keyword">the</span><br>quick<br>brown<br>fox<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h3 id="2-过滤运算"><a class="header-anchor" href="#2-过滤运算">¶</a>2. 过滤运算</h3>
<table>
<thead>
<tr>
<th>筛选运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Where</code></td>
<td>根据谓词函数从集合中返回值。</td>
</tr>
<tr>
<td><code>OfType</code></td>
<td>根据指定类型返回集合中的值。 然而，它取决于它们是否能够向指定类型转换。</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><code>Where</code></p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">13</span>&#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Moin"</span>,  Age = <span class="hljs-number">21</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">18</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span>&#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">15</span> &#125; <br>    &#125;;<br><br><span class="hljs-keyword">var</span> filteredResult = studentList.Where(s =&gt; s.Age &gt; <span class="hljs-number">12</span> &amp;&amp; s.Age &lt; <span class="hljs-number">20</span>);<br><span class="hljs-comment">// 查询语法</span><br><span class="hljs-comment">/*var filteredResult = from s in studentList</span><br><span class="hljs-comment">                    where s.Age &gt; 12 &amp;&amp; s.Age &lt; 20</span><br><span class="hljs-comment">                    select s.StudentName;*/</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">John</span><br><span class="hljs-keyword">Bill</span><br><span class="hljs-keyword">Ron</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>OfType</code></p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> mixedList = <span class="hljs-keyword">new</span> ArrayList();<br>mixedList.Add(<span class="hljs-number">0</span>);<br>mixedList.Add(<span class="hljs-string">"One"</span>);<br>mixedList.Add(<span class="hljs-string">"Two"</span>);<br>mixedList.Add(<span class="hljs-number">3</span>);<br>mixedList.Add(<span class="hljs-keyword">new</span> Student &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"Bill"</span> &#125;);<br><br><span class="hljs-keyword">var</span> stringResult = mixedList.OfType&lt;<span class="hljs-keyword">string</span>&gt;();<br><span class="hljs-comment">// 查询语法</span><br><span class="hljs-comment">/*var stringResult = from s in mixedList.OfType&lt;string&gt;()</span><br><span class="hljs-comment">    select s;  select s;*/</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">One</span><br><span class="hljs-keyword">Two</span><br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h3 id="3-排序运算"><a class="header-anchor" href="#3-排序运算">¶</a>3. 排序运算</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OrderBy</code></td>
<td>根据指定的字段按升序或降序对集合中的元素进行排序。</td>
</tr>
<tr>
<td><code>OrderByDescending</code></td>
<td>根据指定的字段按降序对集合进行排序。仅在方法语法中有效。</td>
</tr>
<tr>
<td><code>ThenBy</code></td>
<td>仅在方法语法中有效。用于按升序进行二次排序。</td>
</tr>
<tr>
<td><code>ThenByDescending</code></td>
<td>仅在方法语法中有效。用于按降序进行二次排序。</td>
</tr>
<tr>
<td><code>Reverse</code></td>
<td>仅在方法语法中有效。按相反顺序对集合排序。</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><code>OrderBy</code></p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">15</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">19</span> &#125; <br>&#125;;<br><br><span class="hljs-comment">// 正序</span><br><span class="hljs-keyword">var</span> studentsInAscOrder = studentList.OrderBy(s =&gt; s.StudentName);<br><span class="hljs-comment">// 逆序</span><br><span class="hljs-keyword">var</span> studentsInAscOrder = studentList.OrderByDecending(s =&gt; s.StudentName);<br><span class="hljs-comment">// 查询语法</span><br><span class="hljs-comment">/*var orderByResult = from s in studentList</span><br><span class="hljs-comment">                   orderby s.StudentName </span><br><span class="hljs-comment">                   select s;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">var orderByDescendingResult = from s in studentList</span><br><span class="hljs-comment">                   orderby s.StudentName descending</span><br><span class="hljs-comment">                   select s;*/</span><br></code></pre></div></td></tr></table></figure>
<p>输出：<br>
正序：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Bill</span><br><span class="hljs-keyword">John</span><br><span class="hljs-keyword">Ram</span><br><span class="hljs-keyword">Ron</span><br><span class="hljs-keyword">Steve</span><br></code></pre></div></td></tr></table></figure>
<p>逆序：</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">Steve<br>Ron<br>Ram<br>John<br>Bill<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>多重排序</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">15</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">19</span> &#125;, <br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">6</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">18</span> &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> orderByResult = <span class="hljs-keyword">from</span> s <span class="hljs-keyword">in</span> studentList<br>                   <span class="hljs-keyword">orderby</span> s.StudentName, s.Age <br>                   <span class="hljs-keyword">select</span> <span class="hljs-keyword">new</span> &#123; s.StudentName, s.Age &#125;;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Bill,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">25</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">John,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Ram,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Ram,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">20</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Ron,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">19</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Steve,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">15</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>方法语法中的多重排序的工作方式不同。使用 ThenBy 或 ThenByDecenting 扩展方法进行二次排序。</p>
</blockquote>
</li>
<li>
<p><code>ThenBy</code> 和 <code>ThenByDescending</code></p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">15</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">19</span> &#125;, <br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">6</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">18</span> &#125;<br>&#125;;<br><span class="hljs-keyword">var</span> thenByResult = studentList.OrderBy(s =&gt; s.StudentName).ThenBy(s =&gt; s.Age);<br><br><span class="hljs-keyword">var</span> thenByDescResult = studentList.OrderBy(s =&gt; s.StudentName).ThenByDescending(s =&gt; s.Age);<br></code></pre></div></td></tr></table></figure>
<p>输出：<br>
<code>thenByResult</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Bill,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">25</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">John,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Ram,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Ram,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">20</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Ron,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">19</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Steve,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">15</span><br></code></pre></div></td></tr></table></figure>
<p><code>thenByDescResult</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Bill,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">25</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">John,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Ram,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">20</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Ram,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Ron,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">19</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Steve,</span> <span class="hljs-attr">Age:</span> <span class="hljs-number">15</span><br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h3 id="4-分组运算"><a class="header-anchor" href="#4-分组运算">¶</a>4. 分组运算</h3>
<table>
<thead>
<tr>
<th>分组运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GroupBy</code></td>
<td><code>GroupBy</code> 操作符根据某个键值返回元素组。每个组由 <code>IGrouping&lt;TKey，TElement&gt;</code> 对象表示。</td>
</tr>
<tr>
<td><code>ToLookup</code></td>
<td><code>ToLookup</code> 与 <code>GroupBy</code> 相同; 唯一的区别是 <code>GroupBy</code> 的执行被延迟，而 <code>ToLookup</code> 的执行是立即的。</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><code>GroupBy</code></p>
<p><code>GroupBy</code> 运算符的结果是组的集合。例如，<code>GroupBy</code> 从 <code>Student</code> 集合返回 <code>IEnumerable &lt;IGrouping &lt;TKey，Student&gt;&gt;</code>：</p>
<p><img src="/images/LINQ/GroupBy-1.png" alt="GroupBy-01"></p>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>LINQ 查询可以以 <code>GroupBy</code> 或 <code>Select</code> 子句结尾。</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">21</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">18</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Abram"</span> , Age = <span class="hljs-number">21</span> &#125; <br>    &#125;;<br><br><span class="hljs-keyword">var</span> groupedResult = studentList.GroupBy(s =&gt; s.Age);<br><span class="hljs-comment">// 查询语法</span><br><span class="hljs-comment">/*var groupedResult = from s in studentList</span><br><span class="hljs-comment">                    group s by s.Age;*/</span><br><br><span class="hljs-comment">//遍历每组        </span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> ageGroup <span class="hljs-keyword">in</span> groupedResult)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">"Age Group: &#123;0&#125;"</span>, ageGroup .Key); <span class="hljs-comment">//每组都有一个钥匙 </span><br><br>    <span class="hljs-keyword">foreach</span>(Student s <span class="hljs-keyword">in</span> ageGroup) <span class="hljs-comment">// 每组都有内部收藏</span><br>        Console.WriteLine(<span class="hljs-string">"Student Name: &#123;0&#125;"</span>, s.StudentName);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">AgeGroup:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">John</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Bill</span><br><span class="hljs-attr">AgeGroup:</span> <span class="hljs-number">21</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Steve</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Abram</span><br><span class="hljs-attr">AgeGroup:</span> <span class="hljs-number">20</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Ram</span><br></code></pre></div></td></tr></table></figure>
<p>如上例所示，您可以使用 <code>foreach</code> 循环对组进行迭代，其中每个组都包含一个键和内部集合。下图显示了调试视图中的结果：</p>
<p><img src="/images/LINQ/GroupBy-2.png" alt="GroupBy-02"></p>
</li>
<li>
<p><code>ToLookup</code></p>
<p><code>ToLookup</code> 与 <code>GroupBy</code> 相同；唯一的区别是 <code>GroupBy</code> 执行被推迟，而 <code>ToLookup</code> 执行是立即执行。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">21</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">18</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Abram"</span> , Age = <span class="hljs-number">21</span> &#125; <br>    &#125;;<br><br><span class="hljs-keyword">var</span> lookupResult = studentList.ToLookup(s =&gt; s.age);<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">in</span> lookupResult)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">"Age Group: &#123;0&#125;"</span>, <span class="hljs-keyword">group</span>.Key);  <span class="hljs-comment">//每组都有一个键 </span><br><br>    <span class="hljs-keyword">foreach</span>(Student s <span class="hljs-keyword">in</span> <span class="hljs-keyword">group</span>)  <span class="hljs-comment">//每个组都有一个内部集合  </span><br>        Console.WriteLine(<span class="hljs-string">"Student Name: &#123;0&#125;"</span>, s.StudentName);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">AgeGroup:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">John</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Bill</span><br><span class="hljs-attr">AgeGroup:</span> <span class="hljs-number">21</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Steve</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Abram</span><br><span class="hljs-attr">AgeGroup:</span> <span class="hljs-number">20</span><br><span class="hljs-attr">StudentName:</span> <span class="hljs-string">Ram</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>查询语法不支持 <code>ToLookup</code>。</p>
</blockquote>
</li>
</ol>
<h3 id="5-联接运算"><a class="header-anchor" href="#5-联接运算">¶</a>5. 联接运算</h3>
<table>
<thead>
<tr>
<th>联接运算符</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Join</code></td>
<td><code>Join</code> 运算符根据一个键连接两个序列(集合)并返回结果序列。</td>
</tr>
<tr>
<td><code>GroupJoin</code></td>
<td><code>GroupJoin</code> 运算符根据键连接两个序列并返回序列组。它类似于 SQL 的左外联接。</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><code>Join</code></p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> StudentID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> StudentName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> StandardID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Standard</span>&#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> StandardID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> StandardName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br>IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, StandardID =<span class="hljs-number">1</span> &#125;,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Moin"</span>, StandardID =<span class="hljs-number">1</span> &#125;,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>, StandardID =<span class="hljs-number">2</span> &#125;,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , StandardID =<span class="hljs-number">2</span> &#125;,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span>  &#125; <br>&#125;;<br><br>IList&lt;Standard&gt; standardList = <span class="hljs-keyword">new</span> List&lt;Standard&gt;() &#123; <br>    <span class="hljs-keyword">new</span> Standard()&#123; StandardID = <span class="hljs-number">1</span>, StandardName=<span class="hljs-string">"Standard 1"</span>&#125;,<br>    <span class="hljs-keyword">new</span> Standard()&#123; StandardID = <span class="hljs-number">2</span>, StandardName=<span class="hljs-string">"Standard 2"</span>&#125;,<br>    <span class="hljs-keyword">new</span> Standard()&#123; StandardID = <span class="hljs-number">3</span>, StandardName=<span class="hljs-string">"Standard 3"</span>&#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> innerJoin = studentList.Join(<span class="hljs-comment">// 外序列 </span><br>                      standardList,  <span class="hljs-comment">// 内部序列 </span><br>                      student =&gt; student.StandardID,    <span class="hljs-comment">// externalKeySelector</span><br>                      standard =&gt; standard.StandardID,  <span class="hljs-comment">// innerKeySelector</span><br>                      (student, standard) =&gt; <span class="hljs-keyword">new</span>  <span class="hljs-comment">// 结果选择器</span><br>                                    &#123;<br>                                        StudentName = student.StudentName,<br>                                        StandardName = standard.StandardName<br>                                    &#125;);<br><span class="hljs-comment">// 查询语法</span><br><span class="hljs-comment">/*var innerJoin = from s in studentList // 外序列</span><br><span class="hljs-comment">                      join st in standardList //内部序列 </span><br><span class="hljs-comment">                      on s.StandardID equals st.StandardID // 键选择器 </span><br><span class="hljs-comment">                      select new &#123; // 结果选择器 </span><br><span class="hljs-comment">                                    StudentName = s.StudentName, </span><br><span class="hljs-comment">                                    StandardName = st.StandardName </span><br><span class="hljs-comment">                                &#125;;*/</span><br></code></pre></div></td></tr></table></figure>
<p>输出</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">John - Standard <span class="hljs-number">1</span><br>Moin - Standard <span class="hljs-number">1</span><br>Bill - Standard <span class="hljs-number">2</span><br>Ram - Standard <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure>
<p>下图说明了上面示例中的 <code>Join</code> 运算符的各个部分：</p>
<p><img src="/images/LINQ/Join-1.png" alt="Join-01"></p>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>两个序列（集合）的 <code>StandardID</code> 键必须匹配，否则该项将不包括在结果中。例如，Ron 不与任何标准关联，因此 Ron 不包含在结果集合中。</p>
</blockquote>
</li>
<li>
<p><code>GroupJoin</code></p>
<p><code>GroupJoin</code> 运算符执行与 <code>Join</code> 运算符相同的任务，不同之处在于 <code>GroupJoin</code> 根据指定的组键在组中返回结果。<code>GroupJoin</code> 运算符基于键联接两个序列，并通过匹配键将结果分组，然后返回分组的结果和键的集合。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>&#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> StudentID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> StudentName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> StandardID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Standard</span>&#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> StandardID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> StandardName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br>IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, StandardID =<span class="hljs-number">1</span> &#125;,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Moin"</span>, StandardID =<span class="hljs-number">1</span> &#125;,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>, StandardID =<span class="hljs-number">2</span> &#125;,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span>,  StandardID =<span class="hljs-number">2</span> &#125;,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> &#125; <br>&#125;;<br><br>IList&lt;Standard&gt; standardList = <span class="hljs-keyword">new</span> List&lt;Standard&gt;() &#123; <br>    <span class="hljs-keyword">new</span> Standard()&#123; StandardID = <span class="hljs-number">1</span>, StandardName=<span class="hljs-string">"Standard 1"</span>&#125;,<br>    <span class="hljs-keyword">new</span> Standard()&#123; StandardID = <span class="hljs-number">2</span>, StandardName=<span class="hljs-string">"Standard 2"</span>&#125;,<br>    <span class="hljs-keyword">new</span> Standard()&#123; StandardID = <span class="hljs-number">3</span>, StandardName=<span class="hljs-string">"Standard 3"</span>&#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> groupJoin = standardList.GroupJoin(studentList,  <span class="hljs-comment">//内部序列</span><br>                                std =&gt; std.StandardID, <span class="hljs-comment">//outerKeySelector </span><br>                                s =&gt; s.StandardID,     <span class="hljs-comment">//innerKeySelector</span><br>                                (std, studentsGroup) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-comment">// resultSelector </span><br>                                &#123;<br>                                    Students = studentsGroup,<br>                                    StandarFulldName = std.StandardName<br>                                &#125;);<br><span class="hljs-comment">// 查询语法</span><br><span class="hljs-comment">/*var groupJoin = from std in standardList </span><br><span class="hljs-comment">                    join s in studentList </span><br><span class="hljs-comment">                    on std.StandardID equals s.StandardID</span><br><span class="hljs-comment">                    into studentGroup</span><br><span class="hljs-comment">                    select new &#123; </span><br><span class="hljs-comment">                              Students = studentGroup , </span><br><span class="hljs-comment">                              StandardName = std.StandardName</span><br><span class="hljs-comment">                    &#125;;*/</span><br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> groupJoin)<br>&#123; <br>    Console.WriteLine(item.StandarFulldName );<br><br>    <span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">var</span> stud <span class="hljs-keyword">in</span> item.Students)<br>        Console.WriteLine(stud.StudentName);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ag-0-1fqfscs9qag-1-1fqfscs9q">Standard 1:<br>John,<br>Moin,<br>Standard 2:<br>Bill,<br>Ram,<br>Standard 3:<br></code></pre></div></td></tr></table></figure>
<p>在上面的 <code>GroupJoin</code> 查询示例中，<code>standardList</code> 是外部序列，因为查询是从外部序列开始的。<code>GroupJoin</code> 方法中的第一个参数是指定内部序列，在上面的示例中为 <code>studentList</code>。该方法的第二和第三个参数 <code>GroupJoin()</code> 是指定一个字段，该字段的值应使用 lambda 表达式进行匹配，以便在结果中包含元素。外部序列的键选择器 <code>standard =&gt; standard.StandardID</code> 指示 <code>standardList</code> 中每个元素的 <code>StandardID</code> 字段应与内部序列 <code>studentList</code> 的键匹配 <code>student =&gt; student.StandardID</code>。如果两个键字段的值都匹配，则将该元素包括到分组集合 <code>studentsGroup</code> 中，其中键为 <code>StandardID</code>。<br>
<code>Join</code> 方法中的最后一个参数是用于表达结果的表达式。在上面的示例中，结果选择器包括分组的集合 <code>studentGroup</code> 和 <code>StandardName</code>。<br>
下图说明了将内部序列分组到 <code>studentsGroup</code> 集合中以匹配 <code>StandardID</code> 键，并且可以使用分组的集合来表示结果：</p>
<p><img src="/images/LINQ/GroupJoin-1.png" alt="GroupJoin-01"></p>
<p>结果集将包含具有 <code>Students</code> 和 <code>StandardFullName</code> 属性的匿名对象。学生属性将是其 <code>StandardID</code> 与 <code>Standard.StandardID</code> 匹配的 <code>Student</code> 的集合：</p>
<p><img src="/images/LINQ/GroupJoin-2.png" alt="GroupJoin-02"></p>
</li>
</ol>
<h3 id="6-限定运算"><a class="header-anchor" href="#6-限定运算">¶</a>6. 限定运算</h3>
<p>限定运算符在某些条件下评估序列的元素，然后返回布尔值以指示某些或所有元素都满足条件。</p>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>C# 查询语法不支持限定运算符。</p>
</blockquote>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>All</code></td>
<td>检查序列中的所有元素是否满足指定的条件</td>
</tr>
<tr>
<td><code>Any</code></td>
<td>检查序列中是否有任一元素满足指定条件</td>
</tr>
<tr>
<td><code>Contains</code></td>
<td>检查序列是否包含特定元素</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><code>All</code></p>
<p><code>All</code> 运算符在指定条件下评估给定集合中的每个元素，如果所有元素均满足条件，则返回 <code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharpa">   IList&lt;Student&gt; studentList &#x3D; new List&lt;Student&gt;() &#123; <br>        new Student() &#123; StudentID &#x3D; 1, StudentName &#x3D; &quot;John&quot;, Age &#x3D; 18 &#125; ,<br>        new Student() &#123; StudentID &#x3D; 2, StudentName &#x3D; &quot;Steve&quot;,  Age &#x3D; 15 &#125; ,<br>        new Student() &#123; StudentID &#x3D; 3, StudentName &#x3D; &quot;Bill&quot;,  Age &#x3D; 25 &#125; ,<br>        new Student() &#123; StudentID &#x3D; 4, StudentName &#x3D; &quot;Ram&quot; , Age &#x3D; 20 &#125; ,<br>        new Student() &#123; StudentID &#x3D; 5, StudentName &#x3D; &quot;Ron&quot; , Age &#x3D; 19 &#125; <br>    &#125;;<br><br>&#x2F;&#x2F; 检查所有学生是否都是青少年    <br>bool areAllStudentsTeenAger &#x3D; studentList.All(s &#x3D;&gt; s.Age &gt; 12 &amp;&amp; s.Age &lt; 20);<br><br>Console.WriteLine(areAllStudentsTeenAger);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>Any</code></p>
<p><code>Any</code> 检查元素是否满足给定条件。在以下示例中，<code>Any</code> 操作用于检查是否有任何学生是青少年。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">bool</span> isAnyStudentTeenAger = studentList.Any(s =&gt; s.age &gt; <span class="hljs-number">12</span> &amp;&amp; s.age &lt; <span class="hljs-number">20</span>);<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>Contains</code></p>
<p><code>Contains</code> 方法用来确定序列是否包含满足指定条件的元素。如果有返回 <code>true</code>，否则返回 <code>false</code>。以下代码使用默认的 String 比较器来判断序列中是否含有指定的字符串：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">string</span>[] source1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span>[] &#123; <span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>, <span class="hljs-string">"F"</span> &#125;;<br>Console.WriteLine(source1.Contains(<span class="hljs-string">"A"</span>)); <span class="hljs-comment">//输出 "true"</span><br>Console.WriteLine(source1.Contains(<span class="hljs-string">"G"</span>)); <span class="hljs-comment">//输出  "false"</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>上面的示例适用于原始数据类型。但是，它不适用于自定义类。</p>
</blockquote>
<p>看以下示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">15</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">19</span> &#125; <br>    &#125;;<br><br>Student std = <span class="hljs-keyword">new</span> Student()&#123; StudentID =<span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>&#125;;<br><span class="hljs-keyword">bool</span> result = studentList.Contains(std); <span class="hljs-comment">//returns false</span><br></code></pre></div></td></tr></table></figure>
<p>正如您在上面的示例中看到的，<code>Contains</code> 返回 <code>false</code>，即使s <code>tudentList</code> 中存在“Bill”。这是因为<code>Contains</code> 扩展方法只比较对象的引用，而不比较对象的实际值。所以要比较 <code>student</code> 对象的值，需要通过实现 <code>IEqualityComparer</code> 接口创建一个类，该接口比较两个 <code>student</code> 对象的值并返回 boolean。</p>
<p>以下是 <code>StudentComparer</code> 类，它实现 <code>IEqualityComparer&lt;Student&gt;</code> 接口来比较两个 <code>Students</code> 对象的值：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">class StudentComparer : IEqualityComparer&lt;Student&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">Student x, Student y</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (x.StudentID == y.StudentID &amp;&amp; <br>                   x.StudentName.ToLower() == y.StudentName.ToLower())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetHashCode</span>(<span class="hljs-params">Student obj</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">return</span> obj.GetHashCode();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>现在，你可以在 <code>Contains</code> 扩展方法的第二个重载方法中使用上面的 <code>StudentComparer</code> 类，该方法接受第二个参数为 <code>IEqualityComparer</code> 类型，如下所示:</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">15</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">19</span> &#125; <br>    &#125;;<br><br>Student std = <span class="hljs-keyword">new</span> Student()&#123; StudentID =<span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>&#125;;<br><span class="hljs-keyword">bool</span> result = studentList.Contains(std, <span class="hljs-keyword">new</span> StudentComparer()); <span class="hljs-comment">//returns true</span><br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h3 id="7-聚合运算"><a class="header-anchor" href="#7-聚合运算">¶</a>7. 聚合运算</h3>
<p>聚合运算符对集合中元素的数值属性执行数学运算，如 <code>Average</code>、<code>Aggregate</code>、<code>Count</code>、<code>Max</code>、<code>Min</code> 和 <code>Sum</code>。</p>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>C# 或 <a href="http://VB.Net" target="_blank" rel="noopener">VB.Net</a> 中的查询语法不支持聚合运算符。</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Aggregate</code></td>
<td>对集合中的值执行自定义聚合操作。</td>
</tr>
<tr>
<td><code>Average</code></td>
<td>计算集合中数字项的平均值。</td>
</tr>
<tr>
<td><code>Count</code></td>
<td>统计集合中的元素。</td>
</tr>
<tr>
<td><code>LongCount</code></td>
<td>统计集合中的元素。</td>
</tr>
<tr>
<td><code>Max</code></td>
<td>查找集合中的最大值。</td>
</tr>
<tr>
<td><code>Min</code></td>
<td>查找集合中的最小值。</td>
</tr>
<tr>
<td><code>Sum</code></td>
<td>计算集合中值的总和。</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><code>Aggregate</code></p>
<p>聚合方法执行累加操作。</p>
<p>下面的示例演示了 <code>Aggregate</code> 方法，该方法返回字符串列表中逗号分隔的元素：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;String&gt; strList = <span class="hljs-keyword">new</span> List&lt;String&gt;() &#123; <span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Five"</span>&#125;;<br><br><span class="hljs-keyword">var</span> commaSeperatedString = strList.Aggregate((s1, s2) =&gt; s1 + <span class="hljs-string">", "</span> + s2);<br><br>Console.WriteLine(commaSeperatedString);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">One</span>, <span class="hljs-keyword">Two</span>, Three, Four, Five<br></code></pre></div></td></tr></table></figure>
<p>下图说明了以上示例中执行的整个聚合操作：</p>
<p><img src="/images/LINQ/Aggregate-1.png" alt="Aggregate-01"></p>
</li>
<li>
<p>带种子值的 <code>Aggregate</code> 方法</p>
<p><code>Aggregate</code> 的第二个重载方法需要第一个参数来累积种子值。第二个参数是 <code>Func</code> 类型的委托：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; func);<br></code></pre></div></td></tr></table></figure>
<p>下面的示例在 <code>Aggregate</code> 扩展方法中将字符串用作种子值：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// 学生集合</span><br>IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;&gt;() &#123; <br>     <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">13</span>&#125; ,<br>     <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Moin"</span>,  Age = <span class="hljs-number">21</span> &#125; ,<br>     <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">18</span> &#125; ,<br>     <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span>&#125; ,<br>     <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">15</span> &#125; <br>&#125;;<br><br><span class="hljs-keyword">string</span> commaSeparatedStudentNames = studentList.Aggregate&lt;Student, <span class="hljs-keyword">string</span>&gt;(<br>                                     <span class="hljs-string">"Student Names: "</span>,  <span class="hljs-comment">// 种子价值</span><br>                                     (str, s) =&gt; str += s.StudentName + <span class="hljs-string">","</span> ); <br><br>Console.WriteLine(commaSeparatedStudentNames);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">Student Names: <span class="hljs-keyword">John, </span>Moin, <span class="hljs-keyword">Bill, </span>Ram, Ron,<br></code></pre></div></td></tr></table></figure>
<p>下面的示例使用 <code>Aggregate</code> 运算符添加所有学生的年龄：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// 学生集合</span><br>IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>         <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">13</span>&#125; ,<br>         <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Moin"</span>,  Age = <span class="hljs-number">21</span> &#125; ,<br>         <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">18</span> &#125; ,<br>         <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span>&#125; ,<br>         <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">15</span> &#125; <br>&#125;;<br><br><span class="hljs-keyword">int</span> SumOfStudentsAge = studentList.Aggregate&lt;Student, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>,                                                   (totalAge, s) =&gt; totalAge += s.Age);<br>Console.WriteLine(studentList);<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>带有结果选择器的 <code>Aggregate</code> 方法</p>
<p>现在，让我们看看第三个重载方法，它需要 <code>Func</code> 委托表达式的第三个参数作为结果选择器，这样您就可以公式化结果：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(<span class="hljs-keyword">this</span> IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; func, Func&lt;TAccumulate, TResult&gt; resultSelector);<br></code></pre></div></td></tr></table></figure>
<p>使用结果选择器进行聚合：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;&gt;() &#123; <br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">13</span>&#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Moin"</span>,  Age = <span class="hljs-number">21</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">18</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span>&#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">15</span> &#125; <br>   &#125;;<br><br><span class="hljs-keyword">string</span> commaSeparatedStudentNames = studentList.Aggregate&lt;Student, <span class="hljs-keyword">string</span>,<span class="hljs-keyword">string</span>&gt;(String.Empty, <span class="hljs-comment">// 种子值</span><br>                                            (str, s) =&gt; str += s.StudentName + <span class="hljs-string">","</span>, <span class="hljs-comment">// 使用种子值返回结果，String.Empty以str的形式进入lambda表达式</span><br>                                            str =&gt; str.Substring(<span class="hljs-number">0</span>,str.Length - <span class="hljs-number">1</span> )); <span class="hljs-comment">// 删除最后一个逗号的结果选择器</span><br><br>Console.WriteLine(commaSeparatedStudentNames);<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，我们指定了一个 lambda 表达式 <code>str =&gt; str.Substring(0,str.Length - 1)</code>，该表达式将删除字符串结果中的最后一个逗号。</p>
<p>输出：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">John, </span>Moin, <span class="hljs-keyword">Bill, </span>Ram, Ron<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>Average</code></p>
<p><code>Average</code> 扩展方法计算集合中数值项的平均值。<code>Average</code> 方法返回可空或不可空的十进制值、双值或浮点值：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;&gt;() &#123; <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span> &#125;;<br><br><span class="hljs-keyword">var</span> avg = intList.Average();<br><br>Console.WriteLine(<span class="hljs-string">"Average: &#123;0&#125;"</span>, avg);<br></code></pre></div></td></tr></table></figure>
<p>您可以将类的 <code>int</code>、 <code>decimal</code>、 <code>double</code> 或 <code>float</code> 属性指定为 lambda 表达式，希望获得其平均值。下面的示例演示复杂类型上的 <code>Average</code> 方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;&gt;() &#123; <br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">13</span>&#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Moin"</span>,  Age = <span class="hljs-number">21</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">18</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span>&#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">15</span> &#125; <br>   &#125;;<br><br><span class="hljs-keyword">var</span> avgAge = studentList.Average(s =&gt; s.Age);<br><br>Console.WriteLine(<span class="hljs-string">"Average Age of Student: &#123;0&#125;"</span>, avgAge);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Average Age of Student:</span> <span class="hljs-number">17.4</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>Count</code></p>
<p><code>Count</code> 运算符返回集合中的元素数或满足给定条件的元素数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;() &#123; <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">30</span>, <span class="hljs-number">45</span>, <span class="hljs-number">50</span> &#125;;<br><br><span class="hljs-keyword">var</span> totalElements = intList.Count();<br><br>Console.WriteLine(<span class="hljs-string">"元素总数: &#123;0&#125;"</span>, totalElements);<br><br><span class="hljs-keyword">var</span> evenElements = intList.Count(i =&gt; i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br><br>Console.WriteLine(<span class="hljs-string">"偶数元素: &#123;0&#125;"</span>, evenElements);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">元素总数：<span class="hljs-number">5</span><br>偶数元素：<span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>Max</code></p>
<p><code>Max</code> 方法返回集合中最大的数值元素：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;() &#123; <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">30</span>, <span class="hljs-number">45</span>, <span class="hljs-number">50</span>, <span class="hljs-number">87</span> &#125;;<br><br><span class="hljs-keyword">var</span> largest = intList.Max();<br><br>Console.WriteLine(<span class="hljs-string">"最大元素: &#123;0&#125;"</span>, largest);<br><br><span class="hljs-keyword">var</span> largestEvenElements = intList.Max(i =&gt; &#123;<br>                                 <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                                     <span class="hljs-keyword">return</span> i;<br><br>                                 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                             &#125;);<br><br>Console.WriteLine(<span class="hljs-string">"最大偶数: &#123;0&#125;"</span>, largestEvenElements );<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">最大元素：<span class="hljs-number">87</span><br>最大偶数：<span class="hljs-number">50</span><br></code></pre></div></td></tr></table></figure>
<p>下面的示例演示复杂类型集合上的 <code>Max</code> 方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;&gt;() &#123; <br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">13</span>&#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Moin"</span>,  Age = <span class="hljs-number">21</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">18</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span>&#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">15</span> &#125; <br>   &#125;;<br><br><span class="hljs-keyword">var</span> oldest = studentList.Max(s =&gt; s.Age);<br><br>Console.WriteLine(<span class="hljs-string">"Oldest Student Age: &#123;0&#125;"</span>, oldest);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">最大的学生年龄：<span class="hljs-number">21</span><br></code></pre></div></td></tr></table></figure>
<p>以下示例显示了如何找到集合中名称最长的学生：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">public class Student : IComparable&lt;Student&gt; <br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> StudentID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> StudentName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> StandardID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">CompareTo</span>(<span class="hljs-params">Student other</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.StudentName.Length &gt;= other.StudentName.Length)<br>             <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span> &#123;<br>        <span class="hljs-comment">// 学生集合</span><br>        IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;&gt;() &#123; <br>             <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">13</span>&#125;,<br>             <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Moin"</span>,  Age = <span class="hljs-number">21</span> &#125;,<br>             <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">18</span> &#125;,<br>             <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span>&#125;,<br>             <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Steve"</span> , Age = <span class="hljs-number">15</span> &#125; <br>        &#125;;<br>    <br>        <span class="hljs-keyword">var</span> studentWithLongName = studentList.Max();<br>    <br>        Console.WriteLine(<span class="hljs-string">"Student ID: &#123;0&#125;, Student Name: &#123;1&#125;"</span>, <br>                                     studentWithLongName.StudentID, studentWithLongName.StudentName);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">Student ID：<span class="hljs-number">5</span>，StudentName ：Steve<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>您可以使用与 <code>Max</code> 相同的方式使用 <code>Min</code> 扩展方法/运算符。</p>
</blockquote>
<p>根据上面的实例，要找到名字最长的学生，需要实现I <code>Comparable&lt;T&gt;</code> 接口，并在 <code>CompareTo</code> 方法中比较学生名字的长度。现在，您可以使用 <code>Max</code> 方法，它将使用 <code>CompareTo</code> 方法来返回适当的结果。</p>
<ol start="7">
<li>
<p><code>Sum</code></p>
<p><code>Sum</code> 方法计算集合中数字项的总和：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;() &#123; <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">30</span>, <span class="hljs-number">45</span>, <span class="hljs-number">50</span>, <span class="hljs-number">87</span> &#125;;<br><br><span class="hljs-keyword">var</span> total = intList.Sum();<br><br>Console.WriteLine(<span class="hljs-string">"总计: &#123;0&#125;"</span>, total);<br><br><span class="hljs-keyword">var</span> sumOfEvenElements = intList.Sum(i =&gt; &#123;<br>                             <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                                 <span class="hljs-keyword">return</span> i;<br><br>                             <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                         &#125;);<br><br>Console.WriteLine(<span class="hljs-string">"偶数元素的总计: &#123;0&#125;"</span>, sumOfEvenElements );<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">总计：<span class="hljs-number">243</span><br>偶数元素的总计：<span class="hljs-number">90</span><br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h3 id="8-元素运算"><a class="header-anchor" href="#8-元素运算">¶</a>8. 元素运算</h3>
<table>
<thead>
<tr>
<th>元素运算符（方法）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ElementAt</code></td>
<td>返回集合中指定索引处的元素</td>
</tr>
<tr>
<td><code>ElementAtOrDefault</code></td>
<td>返回集合中指定索引处的元素；如果索引超出范围，则返回默认值。</td>
</tr>
<tr>
<td><code>First</code></td>
<td>返回集合的第一个元素，或满足条件的第一个元素。</td>
</tr>
<tr>
<td><code>FirstOrDefault</code></td>
<td>返回集合的第一个元素，或满足条件的第一个元素。如果索引超出范围，则返回默认值。</td>
</tr>
<tr>
<td><code>Last</code></td>
<td>返回集合中的最后一个元素，或满足条件的最后一个元素</td>
</tr>
<tr>
<td><code>LastOrDefault</code></td>
<td>返回集合中的最后一个元素，或满足条件的最后一个元素。如果不存在这样的元素，则返回默认值。</td>
</tr>
<tr>
<td><code>Single</code></td>
<td>返回集合中的唯一元素，或唯一满足条件的元素。如果 <code>Single</code> 在集合中未找到任何元素或一个以上的元素，则抛出 <code>InvalidOperationException</code> 。</td>
</tr>
<tr>
<td><code>SingleOrDefault</code></td>
<td>与 <code>Single</code> 相同，不同之处在于它返回指定泛型类型的默认值，而不是在找不到指定条件的元素时抛出异常。但是，如果在集合中为指定条件找到了多个元素，它将抛出 <code>InvalidOperationException</code>。</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><code>ElementAt</code> 和 <code>ElementAtOrDefault</code></p>
<p><code>ElementAt</code> 方法从给定集合返回指定索引中的元素。如果指定的索引超出集合的范围，则它将抛出“索引超出范围（Index out of range exception）”异常。请注意，索引是从零开始的索引。</p>
<p><code>ElementAtOrDefault</code> 方法还从协作中返回指定索引中的元素，如果指定索引不在集合的范围内，则它将返回数据类型的默认值，而不是引发错误。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;() &#123; <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">30</span>, <span class="hljs-number">45</span>, <span class="hljs-number">50</span>, <span class="hljs-number">87</span> &#125;;<br>IList&lt;<span class="hljs-keyword">string</span>&gt; strList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Five"</span> &#125;;<br><br>Console.WriteLine(<span class="hljs-string">"intList中的第一个元素: &#123;0&#125;"</span>, intList.ElementAt(<span class="hljs-number">0</span>));<br>Console.WriteLine(<span class="hljs-string">"strList中的第一个元素: &#123;0&#125;"</span>, strList.ElementAt(<span class="hljs-number">0</span>));<br><br>Console.WriteLine(<span class="hljs-string">"intList中的第二个元素: &#123;0&#125;"</span>, intList.ElementAt(<span class="hljs-number">1</span>));<br>Console.WriteLine(<span class="hljs-string">"strList中的第二个元素: &#123;0&#125;"</span>, strList.ElementAt(<span class="hljs-number">1</span>));<br><br>Console.WriteLine(<span class="hljs-string">"intList中的第三个元素: &#123;0&#125;"</span>, intList.ElementAtOrDefault(<span class="hljs-number">2</span>));<br>Console.WriteLine(<span class="hljs-string">"strList中的第三个元素: &#123;0&#125;"</span>, strList.ElementAtOrDefault(<span class="hljs-number">2</span>));<br><br>Console.WriteLine(<span class="hljs-string">"intList中的第10个元素: &#123;0&#125; - 默认int值"</span>, <br>             intList.ElementAtOrDefault(<span class="hljs-number">9</span>));        <br>Console.WriteLine(<span class="hljs-string">"strList中的第十个元素: &#123;0&#125; - 默认字符串值(null)"</span>,<br>              strList.ElementAtOrDefault(<span class="hljs-number">9</span>));<br>Console.WriteLine(<span class="hljs-string">"intList. ElementAt (9)抛出异常: 索引超出范围"</span>);<br>Console.WriteLine(<span class="hljs-string">"-------------------------------------------------------------"</span>);<br>Console.WriteLine(intList.ElementAt(<span class="hljs-number">9</span>));<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>List中的第一个元素：<span class="hljs-number">10</span> <br>strList中的第一个元素：<br><span class="hljs-built_in">int</span>List中的第二元素：<span class="hljs-number">21</span> <br>strList中的第二个元素：   <br><span class="hljs-built_in">int</span>List中的第三个元素：<span class="hljs-number">30</span> <br>strList中的第三个元素：<br><br><span class="hljs-built_in">int</span>List中的第十个元素：<span class="hljs-number">0</span> - 默认<span class="hljs-built_in">int</span>值<br>strList中的第十个元素：- 默认字符串值(<span class="hljs-literal">null</span>)<br><br>----------------------------- --------------------------------<br><br><span class="hljs-built_in">int</span>List.ElementAt(<span class="hljs-number">9</span>) 抛出异常: 索引超出范围<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>First</code> 和 <code>FirstOrDefault</code></p>
<p><code>First</code> 方法使用 lambda 表达式或 <code>Func</code> 委托返回集合的第一个元素，或满足指定条件的第一个元素。如果给定的集合为空或不包含任何满足条件的元素，则它将抛出 InvalidOperation 异常。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;() &#123; <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">30</span>, <span class="hljs-number">45</span>, <span class="hljs-number">50</span>, <span class="hljs-number">87</span> &#125;;<br>IList&lt;<span class="hljs-keyword">string</span>&gt; strList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <span class="hljs-literal">null</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Five"</span> &#125;;<br>IList&lt;<span class="hljs-keyword">string</span>&gt; emptyList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;();<br><br>Console.WriteLine(<span class="hljs-string">"intList中的第一个元素: &#123;0&#125;"</span>, intList.First());<br>Console.WriteLine(<span class="hljs-string">"intList中的第一个偶数元素: &#123;0&#125;"</span>, intList.First(i =&gt; i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>));<br><br>Console.WriteLine(<span class="hljs-string">"strList中的第一个元素： &#123;0&#125;"</span>, strList.First());<br><br>Console.WriteLine(<span class="hljs-string">"emptyList.First()抛出InvalidOperationException"</span>);<br>Console.WriteLine(<span class="hljs-string">"-------------------------------------------------------------"</span>);<br>Console.WriteLine(emptyList.First());<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>List中的第一个元素：<span class="hljs-number">7</span> <br><span class="hljs-built_in">int</span>List中的第一个偶数元素：<span class="hljs-number">10</span> <br>strList中的第一个元素：<br>emptyList.First()抛出InvalidOperationException<br>----------------------------------------------- --------------<br>运行时异常：序列不包含任何元素...<br></code></pre></div></td></tr></table></figure>
<p><code>FirstOrDefault</code> 方法与 <code>First</code> 方法具有相同的作用。唯一的区别是，如果集合为空或找不到满足条件的任何元素，它将返回集合数据类型的默认值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;() &#123; <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">30</span>, <span class="hljs-number">45</span>, <span class="hljs-number">50</span>, <span class="hljs-number">87</span> &#125;;<br>IList&lt;<span class="hljs-keyword">string</span>&gt; strList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <span class="hljs-literal">null</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Five"</span> &#125;;<br>IList&lt;<span class="hljs-keyword">string</span>&gt; emptyList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;();<br><br>Console.WriteLine(<span class="hljs-string">"intList中的第一个元素: &#123;0&#125;"</span>, intList.FirstOrDefault());<br>Console.WriteLine(<span class="hljs-string">"intList中的第一个偶数元素: &#123;0&#125;"</span>,intList.FirstOrDefault(i =&gt; i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>));<br>Console.WriteLine(<span class="hljs-string">"strList中的第一个元素: &#123;0&#125;"</span>, strList.FirstOrDefault());<br>Console.WriteLine(<span class="hljs-string">"emptyList中的第一个元素: &#123;0&#125;"</span>, emptyList.FirstOrDefault());<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>List中的第一个元素：<span class="hljs-number">7</span> <br><span class="hljs-built_in">int</span>List中的第一个偶数元素：<span class="hljs-number">10</span> <br>strList中的第一个元素：<br>emptyList中的第一个元素：<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<ul>
<li>在 <code>First</code> 或 <code>FirstOrDefault</code> 中指定条件时要小心。如果集合不包含任何满足指定条件的元素或包含 <code>null</code> 元素，则 <code>First</code> 将抛出异常。</li>
<li>如果集合包含空元素，则 <code>FirstOrDefault</code> 在计算指定条件时抛出异常。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;() &#123; <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">30</span>, <span class="hljs-number">45</span>, <span class="hljs-number">50</span>, <span class="hljs-number">87</span> &#125;;<br>IList&lt;<span class="hljs-keyword">string</span>&gt; strList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <span class="hljs-literal">null</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Five"</span> &#125;;<br><br>Console.WriteLine(<span class="hljs-string">"intList中大于250的第一个元素: &#123;0&#125;"</span>, intList.First( i &gt; <span class="hljs-number">250</span>));<br><br>Console.WriteLine(<span class="hljs-string">"在 intList 中的第一个偶数元素: &#123;0&#125;"</span>, strList.FirstOrDefault(s =&gt; s.Contains(<span class="hljs-string">"T"</span>)));<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">Run-<span class="hljs-type">time</span> <span class="hljs-keyword">exception</span>: <span class="hljs-keyword">Sequence</span> contains <span class="hljs-keyword">no</span> matching element<br></code></pre></div></td></tr></table></figure>
</blockquote>
</li>
</ol>
<blockquote>
<p>提示</p>
<hr>
<p><code>Last</code> 和 <code>LastOrDefault</code> 与 <code>First</code> 和 <code>FirstOrDefault</code> 类似。</p>
</blockquote>
<ol start="3">
<li>
<p><code>Single</code> 和 <code>SingleOrDefault</code></p>
<p><code>Single</code> 返回集合中的唯一元素，或唯一满足指定条件的元素。如果给定的集合不包含任何元素或包含多个元素，则 <code>Single</code> 抛出 <code>InvalidOperationException</code>。</p>
<p><code>SingleOrDefault</code> 方法与 <code>Single</code> 方法具有相同的作用。唯一的区别是，如果集合为空，不包含一个以上元素或对于指定条件不包含一个或多个元素，则它返回集合数据类型的默认值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">int</span>&gt; oneElementList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;() &#123; <span class="hljs-number">7</span> &#125;;<br>IList&lt;<span class="hljs-keyword">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;() &#123; <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">30</span>, <span class="hljs-number">45</span>, <span class="hljs-number">50</span>, <span class="hljs-number">87</span> &#125;;<br>IList&lt;<span class="hljs-keyword">string</span>&gt; strList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <span class="hljs-literal">null</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Five"</span> &#125;;<br>IList&lt;<span class="hljs-keyword">string</span>&gt; emptyList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;();<br><br>Console.WriteLine(<span class="hljs-string">"oneElementList 中的唯一元素: &#123;0&#125;"</span>, oneElementList.Single());<br>Console.WriteLine(<span class="hljs-string">"oneElementList 中的唯一元素: &#123;0&#125;"</span>,oneElementList.SingleOrDefault());<br><br>Console.WriteLine(<span class="hljs-string">"emptyList中的元素: &#123;0&#125;"</span>, emptyList.SingleOrDefault());<br>Console.WriteLine(<span class="hljs-string">"intList中唯一小于10的元素: &#123;0&#125;"</span>,intList.Single(i =&gt; i &lt; <span class="hljs-number">10</span>));<br><br><span class="hljs-comment">//下面抛出一个异常</span><br><span class="hljs-comment">//Console.WriteLine("intList中唯一的元素: &#123;0&#125;", intList.Single());</span><br><span class="hljs-comment">//Console.WriteLine("intList中唯一的元素: &#123;0&#125;", intList.SingleOrDefault());</span><br><span class="hljs-comment">//Console.WriteLine("emptyList中唯一的元素: &#123;0&#125;", emptyList.Single());</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">oneElementList中的唯一元素：<span class="hljs-number">7</span> <br>oneElementList中的唯一元素：<span class="hljs-number">7</span> <br>emptyList中的元素：<span class="hljs-number">0</span> <br><span class="hljs-built_in">int</span>List中唯一小于<span class="hljs-number">10</span>的元素：<span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure>
<p>以下示例代码将引发异常，因为 <code>Single</code> 或 <code>SingleOrDefault</code> 对于指定条件不返回任何元素或返回多个元素。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">int</span>&gt; oneElementList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;() &#123; <span class="hljs-number">7</span> &#125;;<br>IList&lt;<span class="hljs-keyword">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;() &#123; <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">30</span>, <span class="hljs-number">45</span>, <span class="hljs-number">50</span>, <span class="hljs-number">87</span> &#125;;<br>IList&lt;<span class="hljs-keyword">string</span>&gt; strList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <span class="hljs-literal">null</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Five"</span> &#125;;<br>IList&lt;<span class="hljs-keyword">string</span>&gt; emptyList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;();<br><br><span class="hljs-comment">//下面抛出错误，因为列表包含多个小于100的元素</span><br>Console.WriteLine(<span class="hljs-string">"intList中小于100的元素: &#123;0&#125;"</span>, intList.Single(i =&gt; i &lt; <span class="hljs-number">100</span>));<br><br><span class="hljs-comment">//下面抛出错误，因为列表包含多个小于100的元素</span><br>Console.WriteLine(<span class="hljs-string">"intList中小于100的元素: &#123;0&#125;"</span>, intList.SingleOrDefault(i =&gt; i &lt; <span class="hljs-number">100</span>));<br><br><span class="hljs-comment">//由于列表包含多个元素，下面抛出错误</span><br>Console.WriteLine(<span class="hljs-string">"intList中唯一的元素: &#123;0&#125;"</span>, intList.Single());<br><br><span class="hljs-comment">//由于列表包含多个元素，下面抛出错误</span><br>Console.WriteLine(<span class="hljs-string">"intList中唯一的元素: &#123;0&#125;"</span>, intList.SingleOrDefault());<br><br><span class="hljs-comment">//下面抛出错误，因为列表不包含任何元素</span><br>Console.WriteLine(<span class="hljs-string">"emptyList 中的唯一元素: &#123;0&#125;"</span>, emptyList.Single());<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<ol>
<li><code>Single</code> 要求集合中只有一个元素。</li>
<li><code>Single</code> 当集合中没有任何元素或一个以上元素时，抛出异常。</li>
<li>如果在 <code>Single</code> 中指定了一个条件，并且结果不包含任何元素或包含多个元素，则会引发异常。</li>
<li>如果集合或指定条件中没有元素，<code>SingleOrDefault</code> 将返回泛型集合的数据类型的默认值。</li>
<li>如果集合或指定条件中有多个元素，<code>SingleOrDefault</code> 将引发异常。</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="9-相等运算"><a class="header-anchor" href="#9-相等运算">¶</a>9. 相等运算</h3>
<p>只有一个相等运算符：<code>SequenceEqual</code>。<code>SequenceEqual</code> 方法检查两个集合中的元素数量，每个元素的值和元素的顺序是否相等。<br>
如果集合包含原始数据类型的元素，则它将比较元素的值和数量，而具有复杂类型元素的集合将检查对象的引用。因此，如果对象具有相同的引用，则将它们视为相等，否则将其视为不相等。<br>
下面的示例演示了带有原始数据类型集合的 <code>SequenceEqual</code> 方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">string</span>&gt; strList1 = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;()&#123;<span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Three"</span>&#125;;<br><br>IList&lt;<span class="hljs-keyword">string</span>&gt; strList2 = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;()&#123;<span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Three"</span>&#125;;<br><br><span class="hljs-keyword">bool</span> isEqual = strList1.SequenceEqual(strList2); <span class="hljs-comment">// 返回true</span><br>Console.WriteLine(isEqual);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure>
<p>如果元素的顺序不同，则 <code>SequenceEqual</code> 方法返回 <code>false</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">string</span>&gt; strList1 = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;()&#123;<span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Three"</span>&#125;;<br><br>IList&lt;<span class="hljs-keyword">string</span>&gt; strList2 = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;()&#123; <span class="hljs-string">"Two"</span>, <span class="hljs-string">"One"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Three"</span>&#125;;<br><br><span class="hljs-keyword">bool</span> isEqual = strList1.SequenceEqual(strList2); <span class="hljs-comment">// 返回false</span><br>Console.WriteLine(isEqual);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure>
<p><code>SequenceEqual</code> 扩展方法检查两个对象的引用，以确定两个序列是否相等。这可能会给出错误的结果。看以下示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">Student std = <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"Bill"</span> &#125;;<br><br>IList&lt;Student&gt; studentList1 = <span class="hljs-keyword">new</span> List&lt;Student&gt;()&#123; std &#125;;<br><br>IList&lt;Student&gt; studentList2 = <span class="hljs-keyword">new</span> List&lt;Student&gt;()&#123; std &#125;;<br><br><span class="hljs-keyword">bool</span> isEqual = studentList1.SequenceEqual(studentList2); <span class="hljs-comment">// 返回true</span><br><br>Student std1 = <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"Bill"</span> &#125;;<br>Student std2 = <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"Bill"</span> &#125;;<br><br>IList&lt;Student&gt; studentList3 = <span class="hljs-keyword">new</span> List&lt;Student&gt;()&#123; std1&#125;;<br><br>IList&lt;Student&gt; studentList4 = <span class="hljs-keyword">new</span> List&lt;Student&gt;()&#123; std2 &#125;;<br><br>isEqual = studentList3.SequenceEqual(studentList4);<span class="hljs-comment">// 返回false</span><br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>studentList1</code> 和 <code>studentList2</code> 包含相同的学生对象  <code>std</code>。因此<code>studentList1.SequenceEqual(studentList2)</code> 返回 <code>true</code>。但是，<code>stdList1</code> 和 <code>stdList2</code> 包含两个单独的学生对象 <code>std1</code> 和 <code>std2</code>。所以现在，即使 <code>std1</code> 和 <code>std2</code> 包含相同的值，<code>stdList1.SequenceEqual(stdList2)</code> 也将返回 <code>false</code>。<br>
要比较两个复杂类型（引用类型或对象）集合的值，需要实现 <code>IEqualityComperar&lt;T&gt;</code> 接口，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">class StudentComparer : IEqualityComparer&lt;Student&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">Student x, Student y</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (x.StudentID == y.StudentID &amp;&amp; x.StudentName.ToLower() == y.StudentName.ToLower())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetHashCode</span>(<span class="hljs-params">Student obj</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">return</span> obj.GetHashCode();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>现在，您可以使用 <code>SequenceEqual</code> 扩展方法中的上述 <code>StudentComparer</code> 类作为第二个参数来比较值：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList1 = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">15</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">19</span> &#125; <br>    &#125;;<br><br>IList&lt;Student&gt; studentList2 = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">15</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span> &#125; ,<br>        <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">19</span> &#125; <br>    &#125;;<br><span class="hljs-comment">// 以下返回true</span><br><span class="hljs-keyword">bool</span> isEqual = studentList1.SequenceEqual(studentList2, <span class="hljs-keyword">new</span> StudentComparer());<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<ol>
<li><code>SequenceEqual</code> 方法比较项目数及其原始数据类型的值。</li>
<li><code>SequenceEqual</code> 方法比较对象对复杂数据类型的引用。</li>
<li>使用 <code>IEqualityComparer</code> 类可通过 <code>SequenceEqual</code> 方法比较两个复杂类型的集合。</li>
</ol>
</blockquote>
<h3 id="10-串联运算"><a class="header-anchor" href="#10-串联运算">¶</a>10. 串联运算</h3>
<p><code>Concat</code> 方法附加两个相同类型的序列，并返回一个新序列（集合）：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">string</span>&gt; collection1 = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span> &#125;;<br>IList&lt;<span class="hljs-keyword">string</span>&gt; collection2 = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <span class="hljs-string">"Five"</span>, <span class="hljs-string">"Six"</span>&#125;;<br><br><span class="hljs-keyword">var</span> collection3 = collection1.Concat(collection2);<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">string</span> str <span class="hljs-keyword">in</span> collection3)<br>    Console.WriteLine(str);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">One</span><br><span class="hljs-keyword">Two</span><br>Three<br>Five<br>Six<br></code></pre></div></td></tr></table></figure>
<h3 id="11-生成运算"><a class="header-anchor" href="#11-生成运算">¶</a>11. 生成运算</h3>
<table>
<thead>
<tr>
<th>生成运算符（方法）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DefaultIfEmpty</code></td>
<td>如果调用 <code>DefaultIfEmpty</code> 的给定集合为空，则 <code>DefaultIfEmpty</code> 方法将返回一个具有默认值的新集合。</td>
</tr>
<tr>
<td><code>Empty</code></td>
<td>返回一个空集合</td>
</tr>
<tr>
<td><code>Range</code></td>
<td>从第一个元素开始，使用指定数量的具有顺序值的元素生成 <code>IEnumerable&lt;T&gt;</code> 类型的集合。</td>
</tr>
<tr>
<td><code>Repeat</code></td>
<td>生成具有指定元素数的 <code>IEnumerable&lt;T&gt;</code> 类型的集合，并且每个元素包含相同的指定值。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p><code>Empty</code>、<code>Range</code> 和 <code>Repeat</code> 方法不是 <code>IEnumerable</code> 或 <code>IQueryable</code> 的扩展方法，而只是在静态类 <code>Enumerable</code> 中定义的静态方法。</p>
</blockquote>
<ol>
<li>
<p><code>DefaultIfEmpty</code></p>
<p>如果调用 <code>DefaultIfEmpty</code> 的给定集合为空，则 <code>DefaultIfEmpty</code> 方法将返回一个具有默认值的新集合。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">string</span>&gt; emptyList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;();<br><br><span class="hljs-keyword">var</span> newList1 = emptyList.DefaultIfEmpty(); <br><span class="hljs-keyword">var</span> newList2 = emptyList.DefaultIfEmpty(<span class="hljs-string">"None"</span>); <br><br>Console.WriteLine(<span class="hljs-string">"Count: &#123;0&#125;"</span> , newList1.Count());<br>Console.WriteLine(<span class="hljs-string">"Value: &#123;0&#125;"</span> , newList1.ElementAt(<span class="hljs-number">0</span>));<br><br>Console.WriteLine(<span class="hljs-string">"Count: &#123;0&#125;"</span> , newList2.Count());<br>Console.WriteLine(<span class="hljs-string">"Value: &#123;0&#125;"</span> , newList2.ElementAt(<span class="hljs-number">0</span>));<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Count:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">Value:</span><br><span class="hljs-attr">Count:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">Value:</span> <span class="hljs-string">None</span><br></code></pre></div></td></tr></table></figure>
<p>下面的示例演示复杂类型集合的 <code>DefaultIfEmpty</code> 方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; emptyStudentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;();<br><br><span class="hljs-keyword">var</span> newStudentList1 = studentList.DefaultIfEmpty(<span class="hljs-keyword">new</span> Student());<br><br><span class="hljs-keyword">var</span> newStudentList2 = studentList.DefaultIfEmpty(<span class="hljs-keyword">new</span> Student()&#123; <br>               StudentID = <span class="hljs-number">0</span>, <br>               StudentName = <span class="hljs-string">""</span> &#125;);<br><br>Console.WriteLine(<span class="hljs-string">"Count: &#123;0&#125; "</span>, newStudentList1.Count());<br>Console.WriteLine(<span class="hljs-string">"Student ID: &#123;0&#125; "</span>, newStudentList1.ElementAt(<span class="hljs-number">0</span>));<br><br>Console.WriteLine(<span class="hljs-string">"Count: &#123;0&#125; "</span>, newStudentList2.Count());<br>Console.WriteLine(<span class="hljs-string">"Student ID: &#123;0&#125; "</span>, newStudentList2.ElementAt(<span class="hljs-number">0</span>).StudentID);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Count:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">Student ID:</span><br><span class="hljs-attr">Count:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">Student ID:</span> <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>Empty</code></p>
<p><code>Empty</code> 方法返回指定类型的空集合：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> emptyCollection1 = Enumerable.Empty&lt;<span class="hljs-keyword">string</span>&gt;();<br><span class="hljs-keyword">var</span> emptyCollection2 = Enumerable.Empty&lt;Student&gt;();<br><br>Console.WriteLine(<span class="hljs-string">"Count: &#123;0&#125; "</span>, emptyCollection1.Count());<br>Console.WriteLine(<span class="hljs-string">"Type: &#123;0&#125; "</span>, emptyCollection1.GetType().Name );<br><br>Console.WriteLine(<span class="hljs-string">"Count: &#123;0&#125; "</span>,emptyCollection2.Count());<br>Console.WriteLine(<span class="hljs-string">"Type: &#123;0&#125; "</span>, emptyCollection2.GetType().Name );<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Type:</span> <span class="hljs-string">String[]</span><br><span class="hljs-attr">Count:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">Type:</span> <span class="hljs-string">Student[]</span><br><span class="hljs-attr">Count:</span> <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>Range</code></p>
<p><code>Range</code> 方法返回 <code>IEnumerable&lt;T&gt;</code> 类型的集合，该集合具有指定数量的元素和从第一个元素开始的顺序值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> intCollection = Enumerable.Range(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>Console.WriteLine(<span class="hljs-string">"总计数: &#123;0&#125; "</span>, intCollection.Count());<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intCollection.Count(); i++)<br>   Console.WriteLine(<span class="hljs-string">"值，索引位置为 &#123;0&#125; : &#123;1&#125;"</span>, i, intCollection.ElementAt(i));<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">总计数: <span class="hljs-number">10</span><br>值，索引位置为 <span class="hljs-number">0</span> : <span class="hljs-number">10</span><br>值，索引位置为 <span class="hljs-number">1</span> : <span class="hljs-number">11</span><br>值，索引位置为 <span class="hljs-number">2</span> : <span class="hljs-number">12</span><br>值，索引位置为 <span class="hljs-number">3</span> : <span class="hljs-number">13</span><br>值，索引位置为 <span class="hljs-number">4</span> : <span class="hljs-number">14</span><br>值，索引位置为 <span class="hljs-number">5</span> : <span class="hljs-number">15</span><br>值，索引位置为 <span class="hljs-number">6</span> : <span class="hljs-number">16</span><br>值，索引位置为 <span class="hljs-number">7</span> : <span class="hljs-number">17</span><br>值，索引位置为 <span class="hljs-number">8</span> : <span class="hljs-number">18</span><br>值，索引位置为 <span class="hljs-number">9</span> : <span class="hljs-number">19</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>Repeat</code></p>
<p><code>Repeat</code> 方法使用指定数量的元素生成 <code>IEnumerable&lt;T&gt;</code> 类型的集合，每个元素包含相同的指定值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> intCollection = Enumerable.Repeat&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>Console.WriteLine(<span class="hljs-string">"总数: &#123;0&#125; "</span>, intCollection.Count());<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intCollection.Count(); i++)<br>   Console.WriteLine(<span class="hljs-string">"值，索引位置为 &#123;0&#125; : &#123;1&#125;"</span>, i, intCollection.ElementAt(i));<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">总数：<span class="hljs-number">10</span><br>值，索引位置为 <span class="hljs-number">0</span>: <span class="hljs-number">10</span><br>值，索引位置为 <span class="hljs-number">1</span>: <span class="hljs-number">10</span><br>值，索引位置为 <span class="hljs-number">2</span>: <span class="hljs-number">10</span><br>值，索引位置为 <span class="hljs-number">3</span>: <span class="hljs-number">10</span><br>值，索引位置为 <span class="hljs-number">4</span>: <span class="hljs-number">10</span><br>值，索引位置为 <span class="hljs-number">5</span>: <span class="hljs-number">10</span><br>值，索引位置为 <span class="hljs-number">6</span>: <span class="hljs-number">10</span><br>值，索引位置为 <span class="hljs-number">7</span>: <span class="hljs-number">10</span><br>值，索引位置为 <span class="hljs-number">8</span>: <span class="hljs-number">10</span><br>值，索引位置为 <span class="hljs-number">9</span>: <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h3 id="12-集合运算"><a class="header-anchor" href="#12-集合运算">¶</a>12. 集合运算</h3>
<table>
<thead>
<tr>
<th>集合运算符</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Distinct</code></td>
<td>返回集合中的非重复值。</td>
</tr>
<tr>
<td><code>Except</code></td>
<td>返回两个序列之间的差，这意味着一个集合中的元素不出现在第二个集合中。</td>
</tr>
<tr>
<td><code>Intersect</code></td>
<td>返回两个序列的交集，即同时出现在两个集合中的元素。</td>
</tr>
<tr>
<td><code>Union</code></td>
<td>返回两个序列中的唯一元素，这意味着出现在两个序列中的唯一元素。</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><code>Distinct</code></p>
<p><code>Distinct</code> 扩展方法从给定集合返回一个新的唯一元素集合。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">string</span>&gt; strList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;()&#123; <span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span> &#125;;<br><br>IList&lt;<span class="hljs-keyword">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;()&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span> &#125;;<br><br><span class="hljs-keyword">var</span> distinctList1 = strList.Distinct();<br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">var</span> str <span class="hljs-keyword">in</span> distinctList1)<br>   Console.WriteLine(str);<br><br><span class="hljs-keyword">var</span> distinctList2 = intList.Distinct();<br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> distinctList2)<br>   Console.WriteLine(i);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">One<br>Two<br>Three<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure>
<p><code>Distinct</code> 扩展方法不比较复杂类型对象的值。为了比较复杂类型的值，需要实现 <code>IEqualityComparer&lt;T&gt;</code> 接口。在下面的示例中，<code>StudentComparer</code> 类实现 <code>IEqualityComparer&lt;Student&gt;</code> 来比较 <code>Student</code> 对象：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> StudentID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> StudentName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br>class StudentComparer : IEqualityComparer&lt;Student&gt;<br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">Student x, Student y</span>)</span><br><span class="hljs-function"></span>   &#123;<br>      <span class="hljs-keyword">if</span> (x.StudentID == y.StudentID <br>               &amp;&amp; x.StudentName.ToLower() == y.StudentName.ToLower())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetHashCode</span>(<span class="hljs-params">Student obj</span>)</span><br><span class="hljs-function"></span>   &#123;<br>      <span class="hljs-keyword">return</span> obj.StudentID.GetHashCode();<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>现在，您可以在 <code>Distinct</code> 方法中传递上述 <code>StudentComparer</code> 类的对象作为参数来比较 <code>Student</code> 对象，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">15</span> &#125; ,<br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">19</span> &#125; <br>   &#125;;<br><br><span class="hljs-keyword">var</span> distinctStudents = studentList.Distinct(<span class="hljs-keyword">new</span> StudentComparer()); <br><br><span class="hljs-keyword">foreach</span>(Student std <span class="hljs-keyword">in</span> distinctStudents)<br>   Console.WriteLine(std.StudentName);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">John</span><br><span class="hljs-keyword">Steve</span><br><span class="hljs-keyword">Bill</span><br><span class="hljs-keyword">Ron</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>C# 查询语法不支持 <code>Distinct</code> 运算符。但是，您可以使用 <code>Distinct</code> 方法查询变量或将整个查询包装到括号中，然后调用 <code>Distinct</code>。</p>
</blockquote>
</li>
<li>
<p><code>Except</code></p>
<p><code>Except</code> 方法需要两个集合。它返回一个新集合，其中包含来自第一个集合的元素，该元素在第二个集合（参数集合）中不存在。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">string</span>&gt; strList1 = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;()&#123;<span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Five"</span> &#125;;<br>IList&lt;<span class="hljs-keyword">string</span>&gt; strList2 = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;()&#123;<span class="hljs-string">"Four"</span>, <span class="hljs-string">"Five"</span>, <span class="hljs-string">"Six"</span>, <span class="hljs-string">"Seven"</span>, <span class="hljs-string">"Eight"</span>&#125;;<br><br><span class="hljs-keyword">var</span> result = strList1.Except(strList2);<br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">string</span> str <span class="hljs-keyword">in</span> result)<br>      Console.WriteLine(str);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">One</span><br><span class="hljs-keyword">Two</span><br>Three<br></code></pre></div></td></tr></table></figure>
<p><code>Except</code> 扩展方法不返回复杂类型集合的正确结果。您需要实现 <code>IEqualityComparer&lt;T&gt;</code> 接口，以便从 <code>Except</code> 方法获得正确的结果。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> StudentID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> StudentName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br>class StudentComparer : IEqualityComparer&lt;Student&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">Student x, Student y</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (x.StudentID == y.StudentID &amp;&amp; x.StudentName.ToLower() == y.StudentName.ToLower())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetHashCode</span>(<span class="hljs-params">Student obj</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">return</span> obj.StudentID.GetHashCode();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>现在，您可以在 <code>Except</code> 扩展方法中通过 <code>StudentComparer</code> 类，以获取正确的结果：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList1 = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">15</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">19</span> &#125; <br>&#125;;<br><br>IList&lt;Student&gt; studentList2 = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>    <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">19</span> &#125; <br>&#125;;<br><br><span class="hljs-keyword">var</span> resultedCol = studentList1.Except(studentList2,<span class="hljs-keyword">new</span> StudentComparer()); <br><br><span class="hljs-keyword">foreach</span>(Student std <span class="hljs-keyword">in</span> resultedCol)<br>    Console.WriteLine(std.StudentName);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">John</span><br><span class="hljs-attribute">Steve</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>C# 和 <a href="http://VB.Net" target="_blank" rel="noopener">VB.Net</a> 查询语法不支持 <code>Except</code> 运算符。但是，您可以对查询变量使用 <code>Except</code> 方法，或者将整个查询包装到括号中，然后调用 <code>Except</code>。</p>
</blockquote>
</li>
<li>
<p><code>Intersect</code></p>
<p><code>Intersect</code> 扩展方法需要两个集合。它返回一个新集合，其中包含两个集合中都存在的公共元素：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">string</span>&gt; strList1 = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Five"</span> &#125;;<br>IList&lt;<span class="hljs-keyword">string</span>&gt; strList2 = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Five"</span>, <span class="hljs-string">"Six"</span>, <span class="hljs-string">"Seven"</span>, <span class="hljs-string">"Eight"</span>&#125;;<br><br><span class="hljs-keyword">var</span> result = strList1.Intersect(strList2);<br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">string</span> str <span class="hljs-keyword">in</span> result)<br>      Console.WriteLine(str);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">Four</span><br><span class="hljs-attribute">Five</span><br></code></pre></div></td></tr></table></figure>
<p><code>Intersect</code> 扩展方法不返回复杂类型集合的正确结果。为了从 <code>Intersect</code> 方法中得到正确的结果，需要实现 <code>IEqualityComparer&lt;T&gt;</code> 接口：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> StudentID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> StudentName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br>class StudentComparer : IEqualityComparer&lt;Student&gt;<br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">Student x, Student y</span>)</span><br><span class="hljs-function"></span>   &#123;<br>      <span class="hljs-keyword">if</span> (x.StudentID == y.StudentID &amp;&amp; <br>                        x.StudentName.ToLower() == y.StudentName.ToLower())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetHashCode</span>(<span class="hljs-params">Student obj</span>)</span><br><span class="hljs-function"></span>   &#123;<br>      <span class="hljs-keyword">return</span> obj.StudentID.GetHashCode();<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>现在，您可以在 <code>Intersect</code> 扩展方法中通过 <code>StudentComparer</code> 类，以获取正确的结果：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList1 = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">15</span> &#125; ,<br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">19</span> &#125; <br>   &#125;;<br><br>IList&lt;Student&gt; studentList2 = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">19</span> &#125; <br>   &#125;;<br><br><span class="hljs-keyword">var</span> resultedCol = studentList1.Intersect(studentList2, <span class="hljs-keyword">new</span> StudentComparer()); <br><br><span class="hljs-keyword">foreach</span>(Student std <span class="hljs-keyword">in</span> resultedCol)<br>   Console.WriteLine(std.StudentName);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">Bill<br>Ron<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>Union</code></p>
<p><code>Union</code> 扩展方法需要两个集合，并返回一个新集合，其中包含两个集合中不同的元素。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">string</span>&gt; strList1 = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"Four"</span> &#125;;<br>IList&lt;<span class="hljs-keyword">string</span>&gt; strList2 = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <span class="hljs-string">"Two"</span>, <span class="hljs-string">"THREE"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Five"</span> &#125;;<br><br><span class="hljs-keyword">var</span> result = strList1.Union(strList2);<br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">string</span> str <span class="hljs-keyword">in</span> result)<br>      Console.WriteLine(str);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">One<br>Two<br><span class="hljs-literal">three</span><br><span class="hljs-literal">THREE</span><br>Four<br>Five<br></code></pre></div></td></tr></table></figure>
<p><code>Union</code> 扩展方法不能为复杂类型的集合返回正确的结果。您需要实现 <code>IEqualityComparer&lt;T&gt;</code> 接口，以便从 <code>Union</code> 方法中获取正确的结果。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> StudentID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> StudentName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br>class StudentComparer : IEqualityComparer&lt;Student&gt;<br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">Student x, Student y</span>)</span><br><span class="hljs-function"></span>   &#123;<br>      <span class="hljs-keyword">if</span> (x.StudentID == y.StudentID &amp;&amp; x.StudentName.ToLower() == y.StudentName.ToLower())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetHashCode</span>(<span class="hljs-params">Student obj</span>)</span><br><span class="hljs-function"></span>   &#123;<br>      <span class="hljs-keyword">return</span> obj.StudentID.GetHashCode();<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>现在，您可以在 <code>Union</code> 扩展方法中传递上述 <code>StudentComparer</code> 类以获得正确的结果：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList1 = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">15</span> &#125; ,<br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">19</span> &#125; <br>   &#125;;<br><br>IList&lt;Student&gt; studentList2 = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>      <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">19</span> &#125; <br>   &#125;;<br><br><span class="hljs-keyword">var</span> resultedCol = studentList1.Union(studentList2, <span class="hljs-keyword">new</span> StudentComparer()); <br><br><span class="hljs-keyword">foreach</span>(Student std <span class="hljs-keyword">in</span> resultedCol)<br>   Console.WriteLine(std.StudentName);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">John</span><br><span class="hljs-keyword">Steve</span><br><span class="hljs-keyword">Bill</span><br><span class="hljs-keyword">Ron</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>C# 和 <a href="http://VB.Net" target="_blank" rel="noopener">VB.Net</a> 查询语法不支持联合运算符。但是，您可以对查询变量使用 <code>Union</code> 方法，或者将整个查询包装到方括号中，然后调用 <code>Union</code>。</p>
</blockquote>
</li>
</ol>
<h3 id="13-分区运算"><a class="header-anchor" href="#13-分区运算">¶</a>13. 分区运算</h3>
<p>分区运算符将序列（集合）分为两部分，并返回其中一部分。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Skip</code></td>
<td>从序列中的第一个元素开始，将元素跳到指定的位置。</td>
</tr>
<tr>
<td><code>SkipWhile</code></td>
<td>根据条件跳过元素，直到元素不满足条件为止。如果第一个元素本身不满足条件，那么它将跳过0个元素并返回序列中的所有元素。</td>
</tr>
<tr>
<td><code>Take</code></td>
<td>从序列中的第一个元素开始，将元素带到指定的位置。</td>
</tr>
<tr>
<td><code>TakeWhile</code></td>
<td>从第一个元素返回元素，直到元素不满足条件为止。如果第一个元素本身不满足条件，则返回一个空集合。</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><code>Skip</code></p>
<p><code>Skip</code> 方法从第一个元素开始跳过指定数量的元素，并返回其余元素。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">string</span>&gt; strList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;()&#123; <span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Five"</span> &#125;;<br><br><span class="hljs-keyword">var</span> newList = strList.Skip(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">var</span> str <span class="hljs-keyword">in</span> newList)<br>   Console.WriteLine(str);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">Three</span><br><span class="hljs-attribute">Four</span><br><span class="hljs-attribute">Five</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>SkipWhile</code></p>
<p>顾名思义，LINQ 中的 <code>SkipWhile</code> 扩展方法将跳过集合中的元素，直到指定的条件为 <code>true</code>。一旦任何元素的指定条件变为 <code>false</code>，它将返回一个包含所有剩余元素的新集合。<br>
<code>SkipWhile</code> 方法有两种重载方法：</p>
<ul>
<li>
<p>接受 <code>Func&lt;TSource, bool&gt;</code> 类型的谓词：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (<span class="hljs-keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,<span class="hljs-keyword">bool</span>&gt; predicate);<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>接受 <code>Func&lt;TSource, int, bool&gt;</code> 通过元素索引的谓词类型：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (<span class="hljs-keyword">this</span> System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">bool</span>&gt; predicate);<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<p>在下面的示例中，<code>SkipWhile</code> 方法跳过所有元素，直到找到长度等于或大于 4 个字符的字符串：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">string</span>&gt; strList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <br>                                          <span class="hljs-string">"One"</span>, <br>                                          <span class="hljs-string">"Two"</span>, <br>                                          <span class="hljs-string">"Three"</span>, <br>                                          <span class="hljs-string">"Four"</span>, <br>                                          <span class="hljs-string">"Five"</span>, <br>                                          <span class="hljs-string">"Six"</span>  &#125;;<br><br><span class="hljs-keyword">var</span> resultList = strList.SkipWhile(s =&gt; s.Length &lt; <span class="hljs-number">4</span>);<br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">string</span> str <span class="hljs-keyword">in</span> resultList)<br>      Console.WriteLine(str);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">Three</span><br><span class="hljs-attribute">Four</span><br><span class="hljs-attribute">Five</span><br><span class="hljs-attribute">Six</span><br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，由于前两个元素的长度小于 3，所以 <code>SkipWhile</code> 跳过前两个元素，并找到长度等于或大于 4 的第三个元素。一旦找到长度等于或大于 4 个字符的任何元素，它将不跳过其他任何元素元素，即使小于 4 个字符。<br>
现在，看以下示例，该示例中，其中 <code>SkipWhile</code> 不会跳过任何元素，因为第一个元素的指定条件为 <code>false</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">string</span>&gt; strList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <br>                                          <span class="hljs-string">"Three"</span>, <br>                                          <span class="hljs-string">"One"</span>, <br>                                          <span class="hljs-string">"Two"</span>, <br>                                          <span class="hljs-string">"Four"</span>, <br>                                          <span class="hljs-string">"Five"</span>, <br>                                          <span class="hljs-string">"Six"</span>  &#125;;<br><br><span class="hljs-keyword">var</span> resultList = strList.SkipWhile(s =&gt; s.Length &lt; <span class="hljs-number">4</span>);<br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">string</span> str <span class="hljs-keyword">in</span> resultList)<br>      Console.WriteLine(str);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">Three<br><span class="hljs-keyword">One</span><br><span class="hljs-keyword">Two</span><br>Four<br>Five<br>Six<br></code></pre></div></td></tr></table></figure>
<p><code>SkipWhile</code> 的第二个重载传递每个元素的索引：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">string</span>&gt; strList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <br>                                          <span class="hljs-string">"One"</span>, <br>                                          <span class="hljs-string">"Two"</span>, <br>                                          <span class="hljs-string">"Three"</span>, <br>                                          <span class="hljs-string">"Four"</span>, <br>                                          <span class="hljs-string">"Five"</span>, <br>                                          <span class="hljs-string">"Six"</span>  &#125;;<br><br><span class="hljs-keyword">var</span> result = strList.SkipWhile((s, i) =&gt; s.Length &gt; i);<br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">string</span> str <span class="hljs-keyword">in</span> result)<br>   Console.WriteLine(str);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">Five</span><br><span class="hljs-attribute">Six</span><br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，lambda 表达式包括元素和元素的索引作为参数。它会跳过所有元素，直到字符串元素的长度大于其索引。</p>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>C# 查询语法不支持 <code>Skip</code> 和 <code>SkipWhile</code> 运算符。但是，您可以对查询变量使用 <code>Skip</code>/<code>SkipWhile</code> 方法，或者将整个查询包装到括号中，然后调用 <code>Skip</code>/<code>SkipWhile</code>。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>提示</strong></p>
<hr>
<p><code>Take</code> 和 <code>TakeWhile</code> 与 <code>Skip</code> 和 <code>SkipWhile</code> 用法相同，但作用相反。</p>
</blockquote>
<h2 id="二、转换运算符"><a class="header-anchor" href="#二、转换运算符">¶</a>二、转换运算符</h2>
<p>LINQ 中的 转换运算符可用于转换序列（集合）中元素的类型。转换运算符分为三种：As 运算符（<code>AsEnumerable</code> 和 <code>AsQueryable</code>），To 运算符（<code>ToArray</code>、<code>ToDictionary</code>、<code>ToList</code> 和 <code>ToLookup</code>）和转换运算符（<code>Cast</code> 和 <code>OfType</code>）。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AsEnumerable</code></td>
<td>将输入序列作为 <code>IEnumerable&lt;T&gt;</code> 返回</td>
</tr>
<tr>
<td><code>AsQueryable</code></td>
<td>将 <code>IEnumerable</code> 转换为 <code>IQueryable</code>，以模拟远程查询提供程序</td>
</tr>
<tr>
<td><code>Cast</code></td>
<td>将非泛型集合转换为泛型集合（<code>IEnumerable</code> 到 <code>IEnumerable</code>）</td>
</tr>
<tr>
<td><code>OfType</code></td>
<td>基于指定类型筛选集合</td>
</tr>
<tr>
<td><code>ToArray</code></td>
<td>将集合转换为数组</td>
</tr>
<tr>
<td><code>ToDictionary</code></td>
<td>根据键选择器函数将元素放入字典中</td>
</tr>
<tr>
<td><code>ToList</code></td>
<td>将集合转换为 List</td>
</tr>
<tr>
<td><code>ToLookup</code></td>
<td>将元素分组到 <code>Lookup&lt;TKey,TElement&gt;</code></td>
</tr>
</tbody>
</table>
<ol>
<li>
<p><code>AsEnumerable</code> 和 <code>AsQueryable</code></p>
<p><code>AsEnumerable</code> 和 <code>AsQueryable</code> 方法分别将源对象转换或转换为 <code>IEnumerable&lt;T&gt;</code> 或 <code>IQueryable&lt;T&gt;</code>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> ReportTypeProperties&lt;T&gt;(T obj)<br>   &#123;<br>      Console.WriteLine(<span class="hljs-string">"Compile-time type: &#123;0&#125;"</span>, <span class="hljs-keyword">typeof</span>(T).Name);<br>      Console.WriteLine(<span class="hljs-string">"Actual type: &#123;0&#125;"</span>, obj.GetType().Name);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span><br><span class="hljs-function"></span>   &#123;<br>      Student[] studentArray = &#123; <br>               <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>               <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">21</span> &#125; ,<br>               <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>               <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span> &#125; ,<br>               <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">31</span> &#125; ,<br>            &#125;;   <br><br>      ReportTypeProperties( studentArray);<br>      ReportTypeProperties(studentArray.AsEnumerable());<br>      ReportTypeProperties(studentArray.AsQueryable());   <br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight elm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elm"><span class="hljs-type">Compile</span>-time <span class="hljs-keyword">type</span>: <span class="hljs-type">Student</span>[]<br><span class="hljs-type">Actual</span> <span class="hljs-keyword">type</span>: <span class="hljs-type">Student</span>[]<br><span class="hljs-type">Compile</span>-time <span class="hljs-keyword">type</span>: <span class="hljs-type">IEnumerable</span>`1<br><span class="hljs-type">Actual</span> <span class="hljs-keyword">type</span>: <span class="hljs-type">Student</span>[]<br><span class="hljs-type">Compile</span>-time <span class="hljs-keyword">type</span>: <span class="hljs-type">IQueryable</span>`1<br><span class="hljs-type">Actual</span> <span class="hljs-keyword">type</span>: <span class="hljs-type">EnumerableQuery</span>`1<br></code></pre></div></td></tr></table></figure>
<p>如上例所示，<code>AsEnumerable</code> 和 <code>AsQueryable</code> 方法分别将编译时类型转换为 <code>IEnumerable</code> 和 <code>IQueryable</code>。</p>
</li>
<li>
<p><code>Cast</code></p>
<p><code>Cast</code> 的作用与 <code>AsEnumerable&lt;T&gt;</code> 相同。它将源对象强制转换为 <code>IEnumerable&lt;T&gt;</code>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> ReportTypeProperties&lt;T&gt;(T obj)<br>   &#123;<br>      Console.WriteLine(<span class="hljs-string">"Compile-time type: &#123;0&#125;"</span>, <span class="hljs-keyword">typeof</span>(T).Name);<br>      Console.WriteLine(<span class="hljs-string">"Actual type: &#123;0&#125;"</span>, obj.GetType().Name);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span><br><span class="hljs-function"></span>   &#123;<br>      Student[] studentArray = &#123; <br>               <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, Age = <span class="hljs-number">18</span> &#125; ,<br>               <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  Age = <span class="hljs-number">21</span> &#125; ,<br>               <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  Age = <span class="hljs-number">25</span> &#125; ,<br>               <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , Age = <span class="hljs-number">20</span> &#125; ,<br>               <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , Age = <span class="hljs-number">31</span> &#125; ,<br>            &#125;;   <br><br>      ReportTypeProperties( studentArray);<br>      ReportTypeProperties(studentArray.Cast&lt;Student&gt;());<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight elm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elm"><span class="hljs-type">Compile</span>-time <span class="hljs-keyword">type</span>: <span class="hljs-type">Student</span>[]<br><span class="hljs-type">Actual</span> <span class="hljs-keyword">type</span>: <span class="hljs-type">Student</span>[]<br><span class="hljs-type">Compile</span>-time <span class="hljs-keyword">type</span>: <span class="hljs-type">IEnumerable</span>`1<br><span class="hljs-type">Actual</span> <span class="hljs-keyword">type</span>: <span class="hljs-type">Student</span>[]<br><span class="hljs-type">Compile</span>-time <span class="hljs-keyword">type</span>: <span class="hljs-type">IEnumerable</span>`1<br><span class="hljs-type">Actual</span> <span class="hljs-keyword">type</span>: <span class="hljs-type">Student</span>[]<br><span class="hljs-type">Compile</span>-time <span class="hljs-keyword">type</span>: <span class="hljs-type">IEnumerable</span>`1<br><span class="hljs-type">Actual</span> <span class="hljs-keyword">type</span>: <span class="hljs-type">Student</span>[]<br></code></pre></div></td></tr></table></figure>
<p><code>studentArray.Cast&lt;Student&gt;</code> 与 <code>(IEnumerable&lt;Student&gt;) studentArray</code> 相同，但是 <code>Cast&lt;Student&gt;</code> 可读性更好。</p>
</li>
<li>
<p><code>ToArray</code>、<code>ToList</code> 和 <code>ToDictionary</code></p>
<p>顾名思义，<code>ToArray</code>、<code>ToList</code> 和 <code>ToDictionary</code> 方法的源对象转换分别为一个数组，列表或字典。<br>
To 运算符强制执行查询。它强制远程查询提供者执行查询并从底层数据源（如SQL Server数据库）获取结果。</p>
<ul>
<li>
<p><code>ToArray</code> 和 <code>ToList</code></p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;<span class="hljs-keyword">string</span>&gt; strList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;() &#123; <br>                                          <span class="hljs-string">"One"</span>, <br>                                          <span class="hljs-string">"Two"</span>, <br>                                          <span class="hljs-string">"Three"</span>, <br>                                          <span class="hljs-string">"Four"</span>, <br>                                          <span class="hljs-string">"Three"</span> <br>                                          &#125;;<br><br><span class="hljs-keyword">string</span>[] strArray = strList.ToArray&lt;<span class="hljs-keyword">string</span>&gt;();<span class="hljs-comment">// 将列表转换为数组</span><br><br>IList&lt;<span class="hljs-keyword">string</span>&gt; list = strArray.ToList&lt;<span class="hljs-keyword">string</span>&gt;(); <span class="hljs-comment">// converts array into list</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>ToDictionary</code><br>
将泛型列表转换为泛型词典：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">IList&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> List&lt;Student&gt;() &#123; <br>                  <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"John"</span>, age = <span class="hljs-number">18</span> &#125; ,<br>                  <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">2</span>, StudentName = <span class="hljs-string">"Steve"</span>,  age = <span class="hljs-number">21</span> &#125; ,<br>                  <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">3</span>, StudentName = <span class="hljs-string">"Bill"</span>,  age = <span class="hljs-number">18</span> &#125; ,<br>                  <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">4</span>, StudentName = <span class="hljs-string">"Ram"</span> , age = <span class="hljs-number">20</span> &#125; ,<br>                  <span class="hljs-keyword">new</span> Student() &#123; StudentID = <span class="hljs-number">5</span>, StudentName = <span class="hljs-string">"Ron"</span> , age = <span class="hljs-number">21</span> &#125; <br>               &#125;;<br><br><span class="hljs-comment">//以下将列表转换成字典，其中StudentId是键</span><br>IDictionary&lt;<span class="hljs-keyword">int</span>, Student&gt; studentDict = <br>                              studentList.ToDictionary&lt;Student, <span class="hljs-keyword">int</span>&gt;(s =&gt; s.StudentID); <br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> studentDict.Keys)<br>    Console.WriteLine(<span class="hljs-string">"Key: &#123;0&#125;, Value: &#123;1&#125;"</span>, <br>                              key, (studentDict[key] <span class="hljs-keyword">as</span> Student).StudentName);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">Key:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">John</span><br><span class="hljs-attr">Key:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Steve</span><br><span class="hljs-attr">Key:</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Bill</span><br><span class="hljs-attr">Key:</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Ram</span><br><span class="hljs-attr">Key:</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Ron</span><br></code></pre></div></td></tr></table></figure>
<p>下图显示了上面示例中的 <code>studentDict</code> 如何包含一个 key-value 对，其中 key 是 <code>StudentID</code>，value 是 <code>Student</code> 对象。</p>
<p><img src="/images/LINQ/ToDictionary-1.png" alt="ToDictionary-01"></p>
</li>
</ul>
</li>
</ol>
<h2 id="三、表达式（Expression）"><a class="header-anchor" href="#三、表达式（Expression）">¶</a>三、表达式（Expression）</h2>
<h3 id="1-表达式基础"><a class="header-anchor" href="#1-表达式基础">¶</a>1. 表达式基础</h3>
<p>可以将 lambda 表达式分配给 <code>Func</code> 或 <code>Action</code> 类型委托，以处理内存中的集合。.NET 编译器在编译时将分配给 <code>Func</code> 或 <code>Action</code> 类型委托的 lambda 表达式转换为可执行代码。<br>
LINQ 引入了一种名为表达式的新类型，该类型代表强类型的 lambda 表达式。这意味着 lambda 表达式也可以分配给 <code>Expression&lt;TDelegate&gt;</code> 类型。.NET编译器将分配给 <code>Expression&lt;TDelegate&gt;</code> 的 lambda 表达式转换为 <strong>表达式树</strong>，而不是可执行代码。远程 LINQ 查询提供程序使用此表达式树作为数据结构，以其构建运行时查询（例如 LINQ-to-SQL，EntityFramework或实现 <code>IQueryable&lt;T&gt;</code> 接口的任何其他 LINQ 查询提供程序）。</p>
<p>下图说明了将 lambda 表达式分配给 <code>Func</code> 或 <code>Action</code> 委托与 LINQ 中的 <code>Expression</code> 时的区别：</p>
<p><img src="/images/LINQ/Expression-1.png" alt="Expression-01"></p>
<h4 id="定义表达式"><a class="header-anchor" href="#定义表达式">¶</a>定义表达式</h4>
<p>引用 <code>System.Linq.Expressions</code> 命名空间，并使用 <code>Expression&lt;TDelegate&gt;</code> 类定义一个表达式。<code>Expression&lt;TDelegate&gt;</code> 需要委托类型 <code>Func</code> 或 <code>Action</code>。</p>
<p>例如，你可以将 lambda 表达式赋给 <code>Func</code> 类型委托的 <code>isTeenAger</code> 变量，如下所示:</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> StudentID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> StudentName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br>Func&lt;Student, <span class="hljs-keyword">bool</span>&gt; isTeenAger = s =&gt; s.Age &gt; <span class="hljs-number">12</span> &amp;&amp; s.Age &lt; <span class="hljs-number">20</span>;<br></code></pre></div></td></tr></table></figure>
<p>现在，您可以使用表达式包装 <code>Func</code> 委托，将上述 <code>Func</code> 类型委托转换为表达式：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">Expression&lt;Func&lt;Student, <span class="hljs-keyword">bool</span>&gt;&gt; isTeenAgerExpr = s =&gt; s.Age &gt; <span class="hljs-number">12</span> &amp;&amp; s.Age &lt; <span class="hljs-number">20</span>;<br></code></pre></div></td></tr></table></figure>
<p>以相同的方式，如果您不从委托返回值，则还可以用表达式包装 <code>Action&lt;T&gt;</code> 类型委托。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">Expression&lt;Action&lt;Student&gt;&gt; printStudentName = s =&gt; Console.WriteLine(s.StudentName);<br></code></pre></div></td></tr></table></figure>
<p>至此，您已经定义了 <code>Expression&lt;TDelegate&gt;</code> 类型。现在，让我们看看如何调用由 <code>Expression&lt;TDelegate&gt;</code> 包装的委托。</p>
<h4 id="调用表达式"><a class="header-anchor" href="#调用表达式">¶</a>调用表达式</h4>
<p>您可以用与委托相同的方式调用由表达式包裹的委托，但是首先需要使用 <code>Compile</code> 方法进行编译。<code>Compile</code> 返回 <code>Func</code> 或  <code>Action</code> 类型的委托，以便您可以像委托一样调用它。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">Expression&lt;Func&lt;Student, <span class="hljs-keyword">bool</span>&gt;&gt; isTeenAgerExpr = s =&gt; s.Age &gt; <span class="hljs-number">12</span> &amp;&amp; s.Age &lt; <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">//使用Compile方法编译Expression以将其作为委托调用</span><br>Func&lt;Student, <span class="hljs-keyword">bool</span>&gt;  isTeenAger = isTeenAgerExpr.Compile();<br><br><span class="hljs-comment">//Invoke</span><br><span class="hljs-keyword">bool</span> result = isTeenAger(<span class="hljs-keyword">new</span> Student()&#123; StudentID = <span class="hljs-number">1</span>, StudentName = <span class="hljs-string">"Steve"</span>, Age = <span class="hljs-number">20</span>&#125;);<br></code></pre></div></td></tr></table></figure>
<h3 id="2-表达式树"><a class="header-anchor" href="#2-表达式树">¶</a>2. 表达式树</h3>
<p>顾名思义，表达式树不过是按树状数据结构排列的表达式。表达式树中的每个节点都是一个表达式。例如，表达式树可用于表示数学公式 <code>x &lt; y</code>，其中 <code>x</code>、<code>&lt;</code> 和 <code>y</code> 将表示为表达式，并排列在树状结构中。<br>
表达式树是 lambda 表达式的内存表示形式。它保存查询的实际元素，而不是查询的结果。<br>
表达式树使 lambda 表达式的结构透明和显式。您可以与表达式树中的数据进行交互，就像与其他任何数据结构一样。<br>
例如，看以下 <code>isTeenAgerExpr</code> 表达式：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">Expression&lt;Func&lt;Student, <span class="hljs-keyword">bool</span>&gt;&gt; isTeenAgerExpr = s =&gt; s.age &gt; <span class="hljs-number">12</span> &amp;&amp; s.age &lt; <span class="hljs-number">20</span>;<br></code></pre></div></td></tr></table></figure>
<p>编译器会将上面的表达式转换为以下表达式树：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">Expression.Lambda&lt;Func&lt;Student, <span class="hljs-keyword">bool</span>&gt;&gt;(<br>                Expression.AndAlso(<br>                    Expression.GreaterThan(Expression.Property(pe, <span class="hljs-string">"Age"</span>), Expression.Constant(<span class="hljs-number">12</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">int</span>))),<br>                    Expression.LessThan(Expression.Property(pe, <span class="hljs-string">"Age"</span>), Expression.Constant(<span class="hljs-number">20</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">int</span>)))),<br>                        <span class="hljs-keyword">new</span>[] &#123; pe &#125;);<br></code></pre></div></td></tr></table></figure>
<p>您也可以手动构建表达式树。让我们看看如何为以下简单的 lambda 表达式构建表达式树：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">Func&lt;Student, <span class="hljs-keyword">bool</span>&gt; isAdult = s =&gt; s.age &gt;= <span class="hljs-number">18</span>;<br></code></pre></div></td></tr></table></figure>
<p>此 <code>Func</code> 类型委托将被视为以下方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">function</span>(<span class="hljs-params">Student s</span>)</span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> s.Age &gt; <span class="hljs-number">18</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="创建表达式树"><a class="header-anchor" href="#创建表达式树">¶</a>创建表达式树</h4>
<p>要创建表达式树，首先，创建一个参数表达式，其中 <code>Student</code> 是参数的类型，“s” 是参数的名称，如下所示：</p>
<ul>
<li>
<p>步骤一：在 C# 中创建参数表达式</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">ParameterExpression pe = Expression.Parameter(<span class="hljs-keyword">typeof</span>(Student), <span class="hljs-string">"s"</span>);<br></code></pre></div></td></tr></table></figure>
<p>现在，使用 <code>Expression.Property()</code> 创建 <code>s.Age</code> 表达式，其中 <code>s</code> 是参数，<code>Age</code> 是 <code>Student</code> 的属性名称。（<code>Expression</code> 是一个抽象类，其中包含用于手动创建表达式树的静态帮助器方法。）</p>
</li>
<li>
<p>步骤二：在 C# 中创建属性表达式</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">MemberExpression me = Expression.Property(pe, <span class="hljs-string">"Age"</span>);<br></code></pre></div></td></tr></table></figure>
<p>现在，为 <code>18</code> 创建一个常量表达式：</p>
</li>
<li>
<p>步骤三：在 C# 中创建常量表达式</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">ConstantExpression constant = Expression.Constant(<span class="hljs-number">18</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">int</span>));<br></code></pre></div></td></tr></table></figure>
<p>到目前为止，我们已经为 <code>s.Age</code>（成员表达式）和 <code>18</code>（常量表达式）构建了表达式树。现在，我们需要检查成员表达式是否大于常量表达式。为此，请使用 <code>Expression.GreaterThanOrEqual</code> 方法，并将成员表达式和常量表达式作为参数传递：</p>
</li>
<li>
<p>步骤四：在 C# 中创建二进制表达式</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">BinaryExpression body = Expression.GreaterThanOrEqual(me, constant);<br></code></pre></div></td></tr></table></figure>
<p>至此，我们为 lambda 表达式主体 <code>s.Age&gt;= 18</code> 构建了一个表达式树。我们现在需要将参数表达式和主体表达式连接起来。使用 <code>Expression.Lambda(body,parameters array)</code> 连接 lambda 表达式 <code>s =&gt; s.age &gt;= 18</code> 的 body（主体）和 parameter（参数）部分：</p>
</li>
<li>
<p>步骤五：在 C# 中创建 Lambda 表达式</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> isAdultExprTree = Expression.Lambda&lt;Func&lt;Student, <span class="hljs-keyword">bool</span>&gt;&gt;(body, <span class="hljs-keyword">new</span>[] &#123; pe &#125;);<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<p>这样，您可以为带有 lambda 表达式的简单 <code>Func</code> 委托构建表达式树。</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">ParameterExpression pe = Expression.Parameter(<span class="hljs-keyword">typeof</span>(Student), <span class="hljs-string">"s"</span>);<br><br>MemberExpression me = Expression.Property(pe, <span class="hljs-string">"Age"</span>);<br><br>ConstantExpression constant = Expression.Constant(<span class="hljs-number">18</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">int</span>));<br><br>BinaryExpression body = Expression.GreaterThanOrEqual(me, constant);<br><br><span class="hljs-keyword">var</span> ExpressionTree = Expression.Lambda&lt;Func&lt;Student, <span class="hljs-keyword">bool</span>&gt;&gt;(body, <span class="hljs-keyword">new</span>[] &#123; pe &#125;);<br><br>Console.WriteLine(<span class="hljs-string">"表达式树: &#123;0&#125;"</span>, ExpressionTree);<br><br>Console.WriteLine(<span class="hljs-string">"表达式树体: &#123;0&#125;"</span>, ExpressionTree.Body);<br><br>Console.WriteLine(<span class="hljs-string">"表达式树中的参数个数: &#123;0&#125;"</span>, <br>                                ExpressionTree.Parameters.Count);<br><br>Console.WriteLine(<span class="hljs-string">"表达式树中的参数: &#123;0&#125;"</span>, ExpressionTree.Parameters[<span class="hljs-number">0</span>]);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">表达式树: s =&gt; (s.Age &gt;= 18)</span><br><span class="hljs-section">表达式树体: (s.Age &gt;= 18)</span><br><span class="hljs-section">表达式树中的参数个数: 1</span><br><span class="hljs-section">表达式树中的参数: s</span><br></code></pre></div></td></tr></table></figure>
<p>下图说明了创建表达式树的整个过程：</p>
<p><img src="/images/LINQ/Expression-2.png" alt="Express-02"></p>
<h4 id="为什么使用表达树？"><a class="header-anchor" href="#为什么使用表达树？">¶</a>为什么使用表达树？</h4>
<p>在上一节中，我们已经看到分配给 lambda 表达式 <code>Func&lt;T&gt;</code> 编译为可执行代码，分配给 lambda 表达式 <code>Expression&lt;TDelegate&gt;</code> 类型编译为表达式树。<br>
可执行代码在同一个应用程序域中执行，以处理内存中的集合。可枚举的静态类包含用于实现 <code>IEnumerable&lt;T&gt;</code> 接口的内存中集合的扩展方法，例如 <code>List&lt;T&gt;</code>、<code>Dictionary &lt;T&gt;</code> 等。<code>Enumerable</code> 类中的扩展方法接受 <code>Func</code> 类型委托的谓词参数。例如，<code>Where</code> 扩展方法接受 <code>Func&lt;TSource，bool&gt;</code> 谓词。然后，将其编译为 IL（中间语言）以处理同一 AppDomain 中的内存中集合。<br>
下图显示了 <code>Enumerable</code> 类中的 <code>Where</code> 扩展方法包括 <code>Func</code> 委托作为参数的情况：</p>
<p><img src="/images/LINQ/Expression-3.png" alt="Expression-03"></p>
<p><code>Func</code> 委托是原始的可执行代码，因此，如果调试代码，则会发现 <code>Func</code> 委托将表示为不透明代码。您无法看到其参数，返回类型和主体：</p>
<p><img src="/images/LINQ/Expression-4.png" alt="Expression-04"></p>
<p><code>Func </code>委托用于内存中的集合，因为它将在同一个 AppDomain 中进行处理，但是诸如 LINQ-to-SQL，EntityFramework 或其他提供 LINQ 功能的第三方产品的远程 LINQ 查询提供者呢？他们将如何解析已编译为原始可执行代码的 lambda 表达式，以了解参数，lambda 表达式的返回类型以及构建运行时查询以进一步处理？答案是表达树。<br>
<code>Expression&lt;TDelegate&gt;</code> 被编译成称为表达式树的数据结构。<br>
如果调试代码，则表达式代表将如下所示：</p>
<p><img src="/images/LINQ/Expression-5.png" alt="Expression-05"></p>
<p>现在您可以看到普通委托和表达式之间的区别。表达式树是透明的。您可以从表达式中检索参数，返回类型和主体表达式信息：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">Expression&lt;Func&lt;Student, <span class="hljs-keyword">bool</span>&gt;&gt; isTeenAgerExpr = s =&gt; s.Age &gt; <span class="hljs-number">12</span> &amp;&amp; s.Age &lt; <span class="hljs-number">20</span>;<br><br>Console.WriteLine(<span class="hljs-string">"Expression: &#123;0&#125;"</span>, isTeenAgerExpr );<br><br>Console.WriteLine(<span class="hljs-string">"表达式类型: &#123;0&#125;"</span>, isTeenAgerExpr.NodeType);<br><br><span class="hljs-keyword">var</span> parameters = isTeenAgerExpr.Parameters;<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> param <span class="hljs-keyword">in</span> parameters)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">"参数名称: &#123;0&#125;"</span>, param.Name);<br>    Console.WriteLine(<span class="hljs-string">"参数类型: &#123;0&#125;"</span>, param.Type.Name );<br>&#125;<br><span class="hljs-keyword">var</span> bodyExpr = isTeenAgerExpr.Body <span class="hljs-keyword">as</span> BinaryExpression;<br><br>Console.WriteLine(<span class="hljs-string">"表达式主体左侧: &#123;0&#125;"</span>, bodyExpr.Left);<br>Console.WriteLine(<span class="hljs-string">"二进制表达式类型: &#123;0&#125;"</span>, bodyExpr.NodeType);<br>Console.WriteLine(<span class="hljs-string">"表达式主体右侧: &#123;0&#125;"</span>, bodyExpr.Right);<br>Console.WriteLine(<span class="hljs-string">"返回类型: &#123;0&#125;"</span>, isTeenAgerExpr.ReturnType);<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">Expression: s =&gt; ((s.Age &gt; 12) AndAlso (s.Age &lt; 20))</span><br><span class="hljs-section">表达式类型: Lambda</span><br><span class="hljs-section">参数名称: s</span><br><span class="hljs-section">参数类型: Student</span><br><span class="hljs-section">表达式主体左侧: (s.Age &gt; 12)</span><br><span class="hljs-section">二进制表达式类型: AndAlso</span><br><span class="hljs-section">表达式主体右侧: (s.Age &lt; 20)</span><br><span class="hljs-section">返回类型: System.Boolean</span><br></code></pre></div></td></tr></table></figure>
<p>不在同一应用程序域中执行针对 LINQ-to-SQL 或 Entity Framework 的 LINQ 查询。例如，对于 Entity Framework 的以下 LINQ 查询永远不会在程序内部实际执行：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> query = <span class="hljs-keyword">from</span> s <span class="hljs-keyword">in</span> dbContext.Students<br>            <span class="hljs-keyword">where</span> s.Age &gt;= <span class="hljs-number">18</span><br>            <span class="hljs-keyword">select</span> s;<br></code></pre></div></td></tr></table></figure>
<p>首先将其转换为 SQL 语句，然后在数据库服务器上执行。<br>
在查询表达式中找到的代码必须转换为 SQL 查询，该查询可以作为字符串发送到另一个进程。对于 LINQ-to-SQL 或 Entity Framework，该过程恰好是 SQL Server 数据库。将数据结构（如表达式树）转换为 SQL 显然比将原始IL或可执行代码转换为 SQL 容易得多，因为正如您看到的，从表达式中检索信息很容易。<br>
创建表达式树的目的是将诸如查询表达式之类的代码转换为可以传递给其他进程并在此处执行的字符串。<br>
可查询的静态类包括接受表达式类型的谓词参数的扩展方法。将该谓词表达式转换为表达式树，然后将其作为数据结构传递到远程 LINQ 提供程序，以便提供程序可以从表达式树构建适当的查询并执行查询。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>编程语言</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux I/O 模式及 select、poll 和 epoll 详解</title>
    <url>/2021/04/10/Linux-IO/</url>
    <content><![CDATA[<p>同步 I/O 和异步 I/O，阻塞 I/O 和非阻塞 I/O 分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。</p>
<blockquote>
<p>注意：</p>
<hr>
<p>本文讨论的背景是 Linux 环境下的网络 I/O。</p>
</blockquote>
<h2 id="一、概念说明"><a class="header-anchor" href="#一、概念说明">¶</a>一、概念说明</h2>
<p>在进行解释之前，首先要说明几个概念：</p>
<ul>
<li>用户空间和内核空间</li>
<li>进程切换</li>
<li>进程的阻塞</li>
<li>文件描述符</li>
<li>缓存 I/O</li>
</ul>
<h3 id="1-用户空间与内核空间"><a class="header-anchor" href="#1-用户空间与内核空间">¶</a>1. 用户空间与内核空间</h3>
<p>现在操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对 Linux 操作系统而言，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，而将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<h3 id="2-进程切换"><a class="header-anchor" href="#2-进程切换">¶</a>2. 进程切换</h3>
<p>为了控制进程的执行，内核必须有能力挂起正在 CPU 上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新 PCB 信息。</li>
<li>把进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其 PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理机上下文。</li>
</ol>
<blockquote>
<p>注：总而言之就是很耗资源，具体的可以参考这篇文章：<a href="http://guojing.me/linux-kernel-architecture/posts/process-switch/" target="_blank" rel="noopener">进程切换</a>。</p>
</blockquote>
<h3 id="3-进程的阻塞"><a class="header-anchor" href="#3-进程的阻塞">¶</a>3. 进程的阻塞</h3>
<p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语（block），使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<strong>当进程进入阻塞状态，是不占用CPU资源的</strong>。</p>
<h3 id="4-文件描述符-fd"><a class="header-anchor" href="#4-文件描述符-fd">¶</a>4. 文件描述符 <code>fd</code></h3>
<p>文件描述符（file descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。<br>
文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</p>
<h3 id="5-缓存-I-O"><a class="header-anchor" href="#5-缓存-I-O">¶</a>5. 缓存 I/O</h3>
<p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（page cache）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<blockquote>
<p>缓存 I/O 的缺点：</p>
<hr>
<p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
</blockquote>
<h2 id="二、I-O-模式"><a class="header-anchor" href="#二、I-O-模式">¶</a>二、I/O 模式</h2>
<p>刚才说了，对于一次 I/O 访问（以 <code>read</code> 举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个 <code>read</code> 操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p>正式因为这两个阶段，Linux 系统产生了下面五种网络模式的方案。</p>
<ul>
<li>阻塞 I/O（blocking I/O）</li>
<li>非阻塞 I/O（nonblocking I/O）</li>
<li>I/O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I/O（ signal driven I/O）</li>
<li>异步 I/O（asynchronous I/O）</li>
</ul>
<blockquote>
<p>注：由于 signal driven I/O 在实际中并不常用，所以我这只提及剩下的四种 I/O 模式。</p>
</blockquote>
<h3 id="1-阻塞-I-O（blocking-IO）"><a class="header-anchor" href="#1-阻塞-I-O（blocking-IO）">¶</a>1. 阻塞 I/O（blocking IO）</h3>
<p>在 Linux 中，默认情况下所有的 socket 都是阻塞的，一个典型的读操作流程大概是这样：</p>
<p><img src="https://blog-1255671825.cos.ap-beijing-fsi.myqcloud.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/Linux-IO/1.png" alt="2.1"></p>
<p>当用户进程调用了 <code>recvfrom</code> 这个系统调用，内核就开始了 I/O 的第一个阶段：准备数据（对于网络 I/O 来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的 UDP 包。这个时候内核就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当内核一直等到数据准备好了，它就会将数据从内核中拷贝到用户内存，然后内核返回结果，用户进程才解除阻塞的状态，重新运行起来。</p>
<blockquote>
<p>所以，阻塞 I/O 的特点就是在 I/O 执行的两个阶段都被阻塞了。</p>
</blockquote>
<h3 id="2-非阻塞-I-O（nonblocking-IO）"><a class="header-anchor" href="#2-非阻塞-I-O（nonblocking-IO）">¶</a>2. 非阻塞 I/O（nonblocking IO）</h3>
<p>Linux 下，可以通过设置 socket 使其变为非阻塞的。当对一个非阻塞 socket 执行读操作时，流程是这个样子：</p>
<p><img src="https://blog-1255671825.cos.ap-beijing-fsi.myqcloud.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/Linux-IO/2.png" alt="2.2"></p>
<p>当用户进程发出 <code>read</code> 操作时，如果内核中的数据还没有准备好，那么它并不会阻塞用户进程，而是立刻返回一个 error。从用户进程角度讲 ，它发起一个 <code>read</code> 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 <code>read</code> 操作。一旦内核中的数据准备好了，并且又再次收到了用户进程的系统调用，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<blockquote>
<p>所以，非阻塞 I/O 的特点是用户进程需要<strong>不断的主动询问</strong>内核数据好了没有。</p>
</blockquote>
<h3 id="3-I-O-多路复用（I-O-multiplexing）"><a class="header-anchor" href="#3-I-O-多路复用（I-O-multiplexing）">¶</a>3. I/O 多路复用（I/O multiplexing）</h3>
<p>I/O 多路复用就是我们说的 <code>select</code>、<code>poll</code> 和 <code>epoll</code>，有些地方也称这种 I/O 方式为事件驱动 I/O（event driven I/O）。<code>select</code>/<code>epoll</code> 的好处就在于单个进程就可以同时处理多个网络连接的 I/O。它的基本原理就是 <code>select</code><br>
<code>poll</code> 和 <code>epoll</code> 这三个函数会不断的轮询所负责的所有 socket，当某 个socket 有数据到达了，就通知用户进程。</p>
<p><img src="https://blog-1255671825.cos.ap-beijing-fsi.myqcloud.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/Linux-IO/3.png" alt="2.3"></p>
<p><strong>当用户进程调用了 <code>select</code>，那么整个进程会被阻塞</strong>，而同时，内核会“监视”所有 <code>select</code> 负责的 socket，当任何一个 socket 中的数据准备好了，<code>select</code> 就会返回。这个时候用户进程再调用 <code>read</code> 操作，将数据从内核拷贝到用户进程。</p>
<blockquote>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，<code>select()</code> 函数就可以返回。</p>
</blockquote>
<p>这个图和阻塞 I/O 的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个系统调用（<code>select</code> 和 <code>recvfrom</code>），而阻塞 I/O 只调用了一个系统调用（<code>recvfrom</code>）。但是，用 <code>select</code> 的优势在于它可以同时处理多个连接。</p>
<p>所以，如果处理的连接数不是很高的话，使用 <code>select</code>/<code>epoll</code> 的 Web 服务器不一定比使用多线程 + 阻塞 I/O 的 Web 服务器性能更好，可能延迟还更大。<code>select</code>/<code>epoll</code> 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
<p>在 I/O 多路复用模式中，实际中，对于每一个 socket，一般都设置成为非阻塞的，但是，如上图所示，整个用户的进程其实是一直被阻塞的。只不过进程是被 <code>select</code> 这个函数阻塞，而不是被 socket I/O 给阻塞的。</p>
<h3 id="4-异步-I-O（asynchronous-IO）"><a class="header-anchor" href="#4-异步-I-O（asynchronous-IO）">¶</a>4. 异步 I/O（asynchronous IO）</h3>
<p>Linux下的异步 I/O 其实用得很少。先看一下它的流程：</p>
<p><img src="https://blog-1255671825.cos.ap-beijing-fsi.myqcloud.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/Linux-IO/4.png" alt="2.4"></p>
<p>用户进程发起 <code>read</code> 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个异步 <code>read</code> 之后，首先它会立刻返回，所以不会对用户进程产生任何阻塞。然后，内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个信号量，告诉它 <code>read</code> 操作完成了。</p>
<h3 id="5-总结"><a class="header-anchor" href="#5-总结">¶</a>5. 总结</h3>
<h4 id="阻塞和非阻塞的区别"><a class="header-anchor" href="#阻塞和非阻塞的区别">¶</a>阻塞和非阻塞的区别</h4>
<p>调用阻塞 I/O 会一直阻塞住对应的进程直到操作完成，而非阻塞 I/O 在内核还准备数据的情况下会立刻返回。</p>
<h4 id="同步-I-O-和异步-IO-的区别"><a class="header-anchor" href="#同步-I-O-和异步-IO-的区别">¶</a>同步 I/O 和异步 IO 的区别</h4>
<p>在说明同步 I/O 和异步 I/O 的区别之前，需要先给出两者的定义。POSIX 的定义是这样子的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked;</li>
</ul>
<p>两者的区别就在于同步 I/O 做“I/O operation”的时候会将进程阻塞。按照这个定义，之前所述的阻塞 I/O，非阻塞 I/O，I/O 多路复用都属于同步 I/O。<br>
有人会说，非阻塞 I/O 并没有被阻塞啊。这里有个非常“狡猾”的地方，定义中所指的“I/O operation”是指真实的 I/O 操作，就是例子中的 <code>recvfrom</code> 这个系统调用。非阻塞 I/O 在执行 <code>recvfrom</code> 这系统调用的时候，如果内核的数据没有准备好，这时候不会阻塞进程。但是，当内核中数据准备好的时候，<code>recvfrom</code> 会将数据从内核拷贝到用户内存中，这个时候进程是被阻塞了，在这段时间内，进程是被阻塞的。<br>
而异步 I/O 则不一样，当进程发起 I/O 操作之后，就直接返回再也不理睬了，直到内核发送一个信号，告诉进程说 I/O 完成。在这整个过程中，进程完全没有被阻塞。<br>
各个 I/O 模式的比较如图所示：</p>
<p><img src="https://blog-1255671825.cos.ap-beijing-fsi.myqcloud.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/Linux-IO/5.png" alt="2.5.2"></p>
<p>通过上面的图片，可以发现非阻塞 I/O 和异步 I/O 的区别还是很明显的。在非阻塞 I/O 中，虽然进程大部分时间都不会被阻塞，但是它仍然要求进程去主动地检查 I/O 状态，并且当数据准备完成以后，也需要进程主动的再次调用 <code>recvfrom</code> 来将数据拷贝到用户内存。而异步 I/O 则完全不同。它就像是用户进程将整个 I/O 操作交给了他人（内核）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查 I/O 操作的状态，也不需要主动的去拷贝数据。</p>
<h2 id="三、I-O-多路复用之-select、poll-及-epoll-详解"><a class="header-anchor" href="#三、I-O-多路复用之-select、poll-及-epoll-详解">¶</a>三、I/O 多路复用之 <code>select</code>、<code>poll</code> 及 <code>epoll</code> 详解</h2>
<p><code>select</code>、<code>poll</code> 和 <code>epoll</code> 都是 I/O 多路复用的机制。I/O 多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但 <code>select</code>、<code>poll</code> 和 <code>epoll</code> 本质上都是同步 I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I/O 则无需自己负责进行读写，异步 I/O 的实现会负责把数据从内核拷贝到用户空间。（这里啰嗦下）</p>
<h3 id="1-select"><a class="header-anchor" href="#1-select">¶</a>1. <code>select</code></h3>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p><code>select</code> 函数监视的文件描述符分3类，分别是 <code>writefds</code>、<code>readfds</code>、和 <code>exceptfds</code>。调用后 <code>select</code> 函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有 <code>except</code>），或者超时（<code>timeout</code> 指定等待时间，如果立即返回设为 <code>NULL</code> 即可），函数返回。当 <code>select</code> 函数返回后，可以 通过遍历 <code>fdset</code>，来找到就绪的描述符。</p>
<p><code>select</code> 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。<code>select</code> 的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 <code>1024</code>，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p>
<h3 id="2-poll"><a class="header-anchor" href="#2-poll">¶</a>2. <code>poll</code></h3>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">poll</span> <span class="hljs-params">(struct pollfd *fds, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nfds, <span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>不同于 <code>select</code> 使用三个位图来表示三个 <code>fdset</code> 的方式，<code>poll</code> 使用一个 <code>pollfd</code> 的指针实现。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span><br>    <span class="hljs-keyword">int</span> fd; <span class="hljs-comment">/* file descriptor */</span><br>    short events; <span class="hljs-comment">/* requested events to watch */</span><br>    short revents; <span class="hljs-comment">/* returned events witnessed */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><code>pollfd</code> 结构包含了要监视的 <code>event</code> 和发生的 <code>event</code>，不再使用 <code>select</code> “参数-值”传递的方式。同时，<code>pollfd</code> 并没有最大数量限制（但是数量过大后性能也是会下降）。 和 <code>select</code> 函数一样，<code>poll</code> 返回后，需要轮询 <code>pollfd</code> 来获取就绪的描述符。</p>
<blockquote>
<p>从上面看，<code>select</code> 和 <code>poll</code> 都需要在返回后，<strong>通过遍历文件描述符来获取已经就绪的 socket</strong>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
</blockquote>
<h3 id="3-epoll"><a class="header-anchor" href="#3-epoll">¶</a>3. <code>epoll</code></h3>
<p><code>epoll</code> 是在 2.6 内核中提出的，是之前的 <code>select</code> 和 <code>poll</code> 的增强版本。相对于 <code>select</code> 和 <code>poll</code> 来说，<code>epoll</code> 更加灵活，没有描述符限制。<code>epoll</code> 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的拷贝只需一次。</p>
<h4 id="epoll-操作过程"><a class="header-anchor" href="#epoll-操作过程">¶</a><code>epoll</code> 操作过程</h4>
<p><code>epoll</code> 操作过程需要三个接口，分别如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大<br>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, struct epoll_event * events, <span class="hljs-keyword">int</span> maxevents, <span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></div></td></tr></table></figure>
<ol>
<li><code>int epoll_create(int size);</code><br>
创建一个 <code>epoll</code> 的句柄，<code>size</code> 用来告诉内核这个监听的数目一共有多大，这个参数不同于 <code>select()</code> 中的第一个参数，给出最大监听的 <code>fd</code> + 1 的值。</li>
</ol>
<blockquote>
<p>注意：</p>
<hr>
<p><strong>参数 <code>size</code> 并不是限制了 <code>epoll</code> 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</strong></p>
</blockquote>
<p>当创建好 <code>epoll</code> 句柄后，它就会占用一个 <code>fd</code> 值，在 linux 下如果查看 <em>/proc/进程id/fd/</em>，是能够看到这个 <code>fd</code> 的，所以在使用完 <code>epoll</code> 后，必须调用 <code>close()</code> 关闭，否则可能导致 <code>fd</code> 被耗尽。</p>
<ol start="2">
<li>
<p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code><br>
函数是对指定描述符 <code>fd</code> 执行 <code>op</code> 操作。</p>
<ul>
<li><code>epfd</code>：是 <code>epoll_create()</code> 的返回值。</li>
<li><code>op</code>：表示操作，用三个宏来表示：添加 <code>EPOLL_CTL_ADD</code>，删除 <code>EPOLL_CTL_DEL</code>，修改 <code>EPOLL_CTL_MOD</code>。分别添加、删除和修改对 <code>fd</code> 的监听事件。</li>
<li><code>fd</code>：是需要监听的 <code>fd</code>（文件描述符）</li>
<li><code>epoll_event</code>：是告诉内核需要监听什么事，<code>struct epoll_event</code> 结构如下：</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span><br>  <span class="hljs-keyword">__uint32_t</span> events;  <span class="hljs-comment">/* Epoll events */</span><br>  <span class="hljs-keyword">epoll_data_t</span> data;  <span class="hljs-comment">/* User data variable */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><code>events</code> 可以是以下几个宏的集合：</p>
<ul>
<li><code>EPOLLIN</code>：表示对应的文件描述符可以读（包括对端 socket 正常关闭）；</li>
<li><code>EPOLLOUT</code>：表示对应的文件描述符可以写；</li>
<li><code>EPOLLPRI</code>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li>
<li><code>EPOLLERR</code>：表示对应的文件描述符发生错误；</li>
<li><code>EPOLLHUP</code>：表示对应的文件描述符被挂断；</li>
<li><code>EPOLLET</code>： 将 <code>epoll</code> 设为边缘触发（Edge Triggered）模式，这是相对于水平触发（Level Triggered）来说的。</li>
<li><code>EPOLLONESHOT</code>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到 <code>epoll</code> 队列里。</li>
</ul>
</li>
<li>
<p><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code><br>
等待 <code>epfd</code> 上的 IO 事件，最多返回 <code>maxevents</code> 个事件。<br>
参数 <code>events</code> 用来从内核得到事件的集合，<code>maxevents</code> 告之内核这个 <code>events</code> 有多大，这个 <code>maxevents</code> 的值不能大于创建 <code>epoll_create()</code> 时的 <code>size</code>，参数<code> timeout</code> 是超时时间（毫秒，<code>0</code> 会立即返回，<code>-1</code> 将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回 <code>0</code> 表示已超时。</p>
</li>
</ol>
<h4 id="工作模式"><a class="header-anchor" href="#工作模式">¶</a>工作模式</h4>
<p><code>epoll</code> 对文件描述符的操作有两种模式：LT（level trigger）和 ET（edge trigger）。LT 模式是默认模式，LT 模式与 ET 模式的区别如下：</p>
<ul>
<li>LT模式：当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序可以不立即处理该事件</strong>。下次调用 <code>epoll_wait</code> 时，会再次响应应用程序并通知此事件。</li>
<li>ET模式：当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序必须立即处理该事件</strong>。如果不处理，下次调用 <code>epoll_wait</code> 时，不会再次响应应用程序并通知此事件。</li>
</ul>
<h5 id="1-LT模式"><a class="header-anchor" href="#1-LT模式">¶</a>1. LT模式</h5>
<p>LT（level triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 <code>fd</code> 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<h5 id="2-ET模式"><a class="header-anchor" href="#2-ET模式">¶</a>2. ET模式</h5>
<p>ET（edge-triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过 <code>epoll</code> 告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了（比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个 <code>EWOULDBLOCK</code> 错误）。但是请注意，如果一直不对这个 <code>fd</code> 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。</p>
<p>ET 模式在很大程度上减少了 <code>epoll</code> 事件被重复触发的次数，因此效率要比 LT 模式高。<code>epoll</code> 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h5 id="3-总结"><a class="header-anchor" href="#3-总结">¶</a>3. 总结</h5>
<p>假如有这样一个例子：</p>
<ol>
<li>我们已经把一个用来从管道中读取数据的文件句柄（RFD）添加到 <code>epoll</code> 描述符</li>
<li>这个时候从管道的另一端被写入了 2KB 的数据</li>
<li>调用 <code>epoll_wait(2)</code>，并且它会返回 RFD，说明它已经准备好读取操作</li>
<li>然后我们读取了 1KB 的数据</li>
<li>调用 <code>epoll_wait(2)</code>…</li>
</ol>
<p>LT 模式：<br>
如果是 LT 模式，那么在第 5 步调用 <code>epoll_wait(2)</code> 之后，仍然能受到通知。</p>
<p>ET 模式：<br>
如果我们在第 1 步将 RFD 添加到 <code>epoll</code> 描述符的时候使用了 <code>EPOLLET</code> 标志，那么在第 5 步调用 <code>epoll_wait(2)</code> 之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第 5 步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p>
<p>当使用 <code>epoll</code> 的 ET 模型来工作时，当产生了一个 <code>EPOLLIN</code> 事件后，<br>
读数据的时候需要考虑的是当 <code>recv()</code> 返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">while</span>(rs)&#123;<br>  buflen = recv(activeevents[i].data.fd, buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span>(buflen &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</span><br>    <span class="hljs-comment">// 在这里就当作是该次事件已处理处.</span><br>    <span class="hljs-keyword">if</span>(errno == EAGAIN)&#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(buflen == <span class="hljs-number">0</span>)&#123;<br>     <span class="hljs-comment">// 这里表示对端的socket已正常关闭.</span><br>  &#125;<br><br> <span class="hljs-keyword">if</span>(buflen == <span class="hljs-keyword">sizeof</span>(buf)&#123;<br>      rs = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 需要再次读取</span><br> &#125;<br> <span class="hljs-keyword">else</span>&#123;<br>      rs = <span class="hljs-number">0</span>;<br> &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>Linux 中的 <code>EAGAIN</code> 含义</p>
<p>Linux 环境下开发经常会碰到很多错误（设置 <code>errno</code>），其中 <code>EAGAIN</code> 是其中比较常见的一个错误（比如用在非阻塞操作中）。<br>
从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞（non-blocking）操作（对文件或 socket）的时候。</p>
<p>例如，以 <code>O_NONBLOCK</code> 的标志打开文件/socket/FIFO，如果你连续做 <code>read</code> 操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，<code>read</code> 函数会返回一个错误 <code>EAGAIN</code>，提示你的应用程序现在没有数据可读请稍后再试。<br>
又例如，当一个系统调用（比如 <code>fork</code>）因为没有足够的资源（比如虚拟内存）而执行失败，返回 <code>EAGAIN</code> 提示其再调用一次（也许下次就能成功）。</p>
<h4 id="代码演示"><a class="header-anchor" href="#代码演示">¶</a>代码演示</h4>
<p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IPADDRESS   <span class="hljs-meta-string">"127.0.0.1"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PORT        8787</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE     1024</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LISTENQ     5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FDSIZE      1000</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPOLLEVENTS 100</span><br><br>listenfd = socket_bind(IPADDRESS,PORT);<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">events</span>[<span class="hljs-title">EPOLLEVENTS</span>];</span><br><br><span class="hljs-comment">//创建一个描述符</span><br>epollfd = epoll_create(FDSIZE);<br><br><span class="hljs-comment">//添加监听描述符事件</span><br>add_event(epollfd,listenfd,EPOLLIN);<br><br><span class="hljs-comment">//循环等待</span><br><span class="hljs-keyword">for</span> ( ; ; )&#123;<br>    <span class="hljs-comment">//该函数返回已经准备好的描述符事件数目</span><br>    ret = epoll_wait(epollfd,events,EPOLLEVENTS,<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//处理接收到的连接</span><br>    handle_events(epollfd,events,ret,listenfd,buf);<br>&#125;<br><br><span class="hljs-comment">//事件处理函数</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle_events</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,struct epoll_event *events,<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">int</span> listenfd,<span class="hljs-keyword">char</span> *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-keyword">int</span> i;<br>     <span class="hljs-keyword">int</span> fd;<br>     <span class="hljs-comment">//进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。</span><br>     <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; num;i++)<br>     &#123;<br>         fd = events[i].data.fd;<br>        <span class="hljs-comment">//根据描述符的类型和事件类型进行处理</span><br>         <span class="hljs-keyword">if</span> ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))<br>            handle_accpet(epollfd,listenfd);<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN)<br>            do_read(epollfd,fd,buf);<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLOUT)<br>            do_write(epollfd,fd,buf);<br>     &#125;<br>&#125;<br><br><span class="hljs-comment">//添加事件</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add_event</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">int</span> state)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>;</span><br>    ev.events = state;<br>    ev.data.fd = fd;<br>    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);<br>&#125;<br><br><span class="hljs-comment">//处理接收到的连接</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle_accpet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,<span class="hljs-keyword">int</span> listenfd)</span></span>&#123;<br>     <span class="hljs-keyword">int</span> clifd;     <br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">cliaddr</span>;</span>     <br>     <span class="hljs-keyword">socklen_t</span>  cliaddrlen;     <br>     clifd = accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);     <br>     <span class="hljs-keyword">if</span> (clifd == <span class="hljs-number">-1</span>)         <br>     perror(<span class="hljs-string">"accpet error:"</span>);     <br>     <span class="hljs-keyword">else</span> &#123;         <br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"accept a new client: %s:%d\n"</span>,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);                       <span class="hljs-comment">//添加一个客户描述符和事件         </span><br>         add_event(epollfd,clifd,EPOLLIN);     <br>     &#125; <br>&#125;<br><br><span class="hljs-comment">//读处理</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">do_read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">char</span> *buf)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> nread;<br>    nread = <span class="hljs-built_in">read</span>(fd,buf,MAXSIZE);<br>    <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">-1</span>)     &#123;         <br>        perror(<span class="hljs-string">"read error:"</span>);         <br>        <span class="hljs-built_in">close</span>(fd); <span class="hljs-comment">//记住close fd        </span><br>        delete_event(epollfd,fd,EPOLLIN); <span class="hljs-comment">//删除监听 </span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)     &#123;         <br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"client close.\n"</span>);<br>        <span class="hljs-built_in">close</span>(fd); <span class="hljs-comment">//记住close fd       </span><br>        delete_event(epollfd,fd,EPOLLIN); <span class="hljs-comment">//删除监听 </span><br>    &#125;     <br>    <span class="hljs-keyword">else</span> &#123;         <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"read message is : %s"</span>,buf);        <br>        <span class="hljs-comment">//修改描述符对应的事件，由读改为写         </span><br>        modify_event(epollfd,fd,EPOLLOUT);     <br>    &#125; <br>&#125;<br><br><span class="hljs-comment">//写处理</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">do_write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">char</span> *buf)</span> </span>&#123;     <br>    <span class="hljs-keyword">int</span> nwrite;     <br>    nwrite = <span class="hljs-built_in">write</span>(fd,buf,<span class="hljs-built_in">strlen</span>(buf));     <br>    <span class="hljs-keyword">if</span> (nwrite == <span class="hljs-number">-1</span>)&#123;         <br>        perror(<span class="hljs-string">"write error:"</span>);        <br>        <span class="hljs-built_in">close</span>(fd);   <span class="hljs-comment">//记住close fd       </span><br>        delete_event(epollfd,fd,EPOLLOUT);  <span class="hljs-comment">//删除监听    </span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        modify_event(epollfd,fd,EPOLLIN); <br>    &#125;    <br>    <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,MAXSIZE); <br>&#125;<br><br><span class="hljs-comment">//删除事件</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete_event</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">int</span> state)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>;</span><br>    ev.events = state;<br>    ev.data.fd = fd;<br>    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);<br>&#125;<br><br><span class="hljs-comment">//修改事件</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modify_event</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">int</span> state)</span></span>&#123;     <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>;</span><br>    ev.events = state;<br>    ev.data.fd = fd;<br>    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);<br>&#125;<br><br><span class="hljs-comment">//注：另外一端我就省了</span><br></code></pre></div></td></tr></table></figure>
<h2 id="四、epoll-总结"><a class="header-anchor" href="#四、epoll-总结">¶</a>四、<code>epoll</code> 总结</h2>
<p>在 <code>select</code>/<code>poll</code> 中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而 <code>epoll</code> 事先通过 <code>epoll_ctl()</code> 来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似回调的机制，迅速激活这个文件描述符，当进程调用 <code>epoll_wait()</code> 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是 <code>epoll</code> 的魅力所在。)</p>
<p><code>epoll</code> 的优点主要是一下几个方面：</p>
<ol>
<li>
<p>监视的描述符数量不受限制，它所支持的 <code>fd</code> 上限是最大可以打开文件的数目，这个数字一般远大于 2048,举个例子,在 1GB 内存的机器上大约是 10 万左右，具体数目可以<code>cat /proc/sys/fs/file-max</code>察看,一般来说这个数目和系统内存关系很大。<code>select</code> 的最大缺点就是进程打开的 <code>fd</code> 是有数量限制的。这对于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案（Apache就是这样实现的），不过虽然 linux 上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</p>
</li>
<li>
<p>IO 的效率不会随着监视 <code>fd</code> 的数量的增长而下降。<code>epoll</code> 不同于 <code>select</code> 和 <code>poll</code>轮询的方式，而是通过每个 <code>fd</code> 定义的回调函数来实现的。只有就绪的 <code>fd</code> 才会执行回调函数。</p>
</li>
</ol>
<blockquote>
<p>注意：</p>
<hr>
<p>如果没有大量的 idle-connection 或者 dead-connection，<code>epoll</code> 的效率并不会比 <code>select</code>/<code>poll</code> 高很多，但是当遇到大量的 idle-connection，就会发现 <code>epoll</code> 的效率大大高于 <code>select</code>/<code>poll</code>。</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NET Core 3.1 学习笔记（一）</title>
    <url>/2021/04/10/ASP.NET-Core-3.1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 3.1 学习笔记（一）</h1>
<p><a href="http://www.zyiz.net/tutorial/xilie-293.html" target="_blank" rel="noopener">教程</a></p>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="ASP-NET-Core-3-1-入门"><a class="header-anchor" href="#ASP-NET-Core-3-1-入门">¶</a><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 3.1 入门</h2>
<h3 id="一、-NET-通用主机"><a class="header-anchor" href="#一、-NET-通用主机">¶</a>一、.NET 通用主机</h3>
<h4 id="什么是主机？"><a class="header-anchor" href="#什么是主机？">¶</a>什么是主机？</h4>
<p>主机是封装应用资源的对象，例如 ：</p>
<ul>
<li>依赖关系注入 (DI)</li>
<li>Logging</li>
<li>配置</li>
<li><code>IHostedService</code><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 实现</li>
</ul>
<blockquote></blockquote>
<p>主机启动：</p>
<ol>
<li>通用主机启动时，它对它在 DI 容器中找到的 <code>IHostedService</code> 的每个实现调用 <code>IHostedService.StartAsync</code>。</li>
<li>承载 HTTP 工作负荷的主机中，其中一个 <code>IHostedService</code> 实现是启动 HTTP 服务器实现的 Web 服务。</li>
</ol>
<h4 id="设置主机"><a class="header-anchor" href="#设置主机">¶</a>设置主机</h4>
<p>主机通常由 <code>Program</code> 类中的代码配置、生成和运行。 <code>Main</code> 方法：</p>
<ul>
<li>调用 <code>CreateHostBuilder</code> 方法以创建和配置生成器对象。</li>
<li>对生成器对象调用 <code>Build</code> 和 <code>Run</code> 方法。</li>
</ul>
<p>以下是用于非 HTTP 工作负荷的 <em>Program.cs</em> 代码，其中单个 <code>IHostedService</code> 实现添加到 DI 容器。</p>
<div name="IHostedServiceExample"></div>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Program<br>&#123;<br>    public static void Main(string[] args)<br>    &#123;<br>        CreateHostBuilder(args).Build().Run();<br>    &#125;<br><br>    public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;<br>        Host.CreateDefaultBuilder(args)<br>            .ConfigureServices((hostContext, services) &#x3D;&gt;<br>            &#123;<br>               services.AddHostedService&lt;Worker&gt;();<br>            &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对于 HTTP 工作负荷，<code>Main</code> 方法相同，但 <code>CreateHostBuilder</code> 调用 <code>ConfigureWebHostDefaults</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;<br>    Host.CreateDefaultBuilder(args)<br>        .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;<br>        &#123;<br>            webBuilder.UseStartup&lt;Startup&gt;();<br>        &#125;);<br></code></pre></div></td></tr></table></figure>
<p>如果应用使用 Entity Framework Core，不要更改 <code>CreateHostBuilder</code> 方法的名称或签名。Entity Framework Core 工具应查找一个无需运行应用即可配置主机的 <code>CreateHostBuilder</code> 方法。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/ef/core/miscellaneous/cli/dbcontext-creation" target="_blank" rel="noopener">设计时 DbContext 创建</a>。</p>
<h4 id="默认生成器设置"><a class="header-anchor" href="#默认生成器设置">¶</a>默认生成器设置</h4>
<ol>
<li>
<p><code>CreateDefaultBuilder</code> 方法：</p>
<ul>
<li>将<a href="http://www.zyiz.net/tutorial/detail-4541.html#content-root" target="_blank" rel="noopener">内容根目录</a>设置为由 <code>GetCurrentDirectory</code> 返回的路径。</li>
<li>通过以下项加载<strong>主机配置</strong>：
<ul>
<li>前缀为 <code>DOTNET_</code> 的环境变量。</li>
<li>命令行参数。</li>
</ul>
</li>
<li>通过以下对象加载<strong>应用配置</strong>：
<ul>
<li><em>appsettings.json</em> 。</li>
<li><em>appsettings.{Environment}.json</em> 。</li>
<li><a href="http://www.zyiz.net/tutorial/detail-4865.html" target="_blank" rel="noopener">密钥管理器</a> 当应用在 <code>Development</code> 环境中运行时。</li>
<li>环境变量。</li>
<li>命令行参数。</li>
</ul>
</li>
<li>添加以下<a href="http://www.zyiz.net/tutorial/detail-4550.html" target="_blank" rel="noopener">日志记录</a>提供程序：
<ul>
<li>控制台</li>
<li>调试</li>
<li>EventSource</li>
<li>EventLog（仅当在 Windows 上运行时）</li>
</ul>
</li>
<li>当环境为 <code>Development</code> 时，启用<a href="http://www.zyiz.net/tutorial/detail-4542.html#scope-validation" target="_blank" rel="noopener">范围验证</a>和<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.serviceprovideroptions.validateonbuild#Microsoft_Extensions_DependencyInjection_ServiceProviderOptions_ValidateOnBuild" target="_blank" rel="noopener">依赖关系验证</a>。</li>
</ul>
</li>
<li>
<p><code>ConfigureWebHostDefaults</code> 方法：</p>
<ul>
<li>
<p>从前缀为 <code>ASPNETCORE_</code> 的环境变量加载主机配置。</p>
</li>
<li>
<p>使用应用的托管配置提供程序将 <a href="http://www.zyiz.net/tutorial/detail-4761.html" target="_blank" rel="noopener">Kestrel</a> 服务器设置为 Web 服务器并对其进行配置。 有关 Kestrel 服务器默认选项，请参阅 <a href="http://www.zyiz.net/tutorial/detail-4761.html#kestrel-options" target="_blank" rel="noopener">ASP.NET Core 中的 Kestrel Web 服务器实现</a>。</p>
</li>
<li>
<p>添加<a href="http://www.zyiz.net/tutorial/detail-4761.html#host-filtering" target="_blank" rel="noopener">主机筛选中间件</a>。</p>
</li>
<li>
<p>如果 <code>ASPNETCORE_FORWARDEDHEADERS_ENABLED=true</code>，请添加<a href="http://www.zyiz.net/tutorial/detail-4766.html#forwarded-headers" target="_blank" rel="noopener">转发标头中间件</a>。</p>
</li>
<li>
<p>支持 IIS 集成。 有关 IIS 默认选项，请参阅 <a href="http://www.zyiz.net/tutorial/detail-4772.html#iis-options" target="_blank" rel="noopener">使用 IIS 在 Windows 上托管 ASP.NET Core</a>。</p>
<p>本文中后面的<a href="http://www.zyiz.net/tutorial/detail-4544.html#settings-for-all-app-types" target="_blank" rel="noopener">所有应用类型的设置</a>和<a href="http://www.zyiz.net/tutorial/detail-4544.html#settings-for-web-apps" target="_blank" rel="noopener"> web 应用的设置</a>部分介绍如何替代默认生成器设置。</p>
</li>
</ul>
</li>
</ol>
<h4 id="框架提供的服务"><a class="header-anchor" href="#框架提供的服务">¶</a>框架提供的服务</h4>
<p>自动注册的服务包括：</p>
<ul>
<li><a href="#IHostApplicationLifetime_1_1"><code>IHostApplicationLifetime</code></a></li>
<li><a href="#IHostLifetime_1_2"><code>IHostLifetime</code></a></li>
<li><a href="#IHostEnvironment_1_3"><code>IHostEnvironment</code> / <code>IWebHostEnvironment</code></a></li>
</ul>
<p>有关框架提供的服务的详细信息，请参阅 <a href="http://www.zyiz.net/tutorial/detail-4542.html#framework-provided-services" target="_blank" rel="noopener">在 ASP.NET Core 依赖注入</a>。</p>
<h4 id="span-name-IHostApplicationLifetime-1-1-IHostApplicationLifetime-span"><a class="header-anchor" href="#span-name-IHostApplicationLifetime-1-1-IHostApplicationLifetime-span">¶</a><span name="IHostApplicationLifetime_1_1"><code>IHostApplicationLifetime</code></span></h4>
<p>将 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.ihostapplicationlifetime" target="_blank" rel="noopener"><code>IHostApplicationLifetime</code></a>（以前称为 <code>IApplicationLifetime</code>）服务注入任何类<strong>以处理启动后和正常关闭任务</strong>。 接口上的三个属性是用于注册应用启动和应用停止事件处理程序方法的取消令牌。</p>
<p>以下示例是注册 <code>IHostApplicationLifetime</code> 事件的 <code>IHostedService</code> 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">internal class LifetimeEventsHostedService : IHostedService<br>&#123;<br>    private readonly ILogger _logger;<br>    private readonly IHostApplicationLifetime _appLifetime;<br><br>    public LifetimeEventsHostedService(<br>        ILogger&lt;LifetimeEventsHostedService&gt; logger,<br>        IHostApplicationLifetime appLifetime)<br>    &#123;<br>        _logger &#x3D; logger;<br>        _appLifetime &#x3D; appLifetime;<br>    &#125;<br><br>    public Task StartAsync(CancellationToken cancellationToken)<br>    &#123;<br>        _appLifetime.ApplicationStarted.Register(OnStarted);<br>        _appLifetime.ApplicationStopping.Register(OnStopping);<br>        _appLifetime.ApplicationStopped.Register(OnStopped);<br><br>        return Task.CompletedTask;<br>    &#125;<br><br>    public Task StopAsync(CancellationToken cancellationToken)<br>    &#123;<br>        return Task.CompletedTask;<br>    &#125;<br><br>    private void OnStarted()<br>    &#123;<br>        _logger.LogInformation(&quot;OnStarted has been called.&quot;);<br><br>        &#x2F;&#x2F; Perform post-startup activities here<br>    &#125;<br><br>    private void OnStopping()<br>    &#123;<br>        _logger.LogInformation(&quot;OnStopping has been called.&quot;);<br><br>        &#x2F;&#x2F; Perform on-stopping activities here<br>    &#125;<br><br>    private void OnStopped()<br>    &#123;<br>        _logger.LogInformation(&quot;OnStopped has been called.&quot;);<br><br>        &#x2F;&#x2F; Perform post-stopped activities here<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="span-name-IHostLifetime-1-2-IHostLifetime-span"><a class="header-anchor" href="#span-name-IHostLifetime-1-2-IHostLifetime-span">¶</a><span name="IHostLifetime_1_2"><code>IHostLifetime</code></span></h4>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.ihostlifetime" target="_blank" rel="noopener"><code>IHostLifetime</code></a> <strong>实现控制主机何时启动和何时停止</strong>。 使用了已注册的最后一个实现。</p>
<p><code>Microsoft.Extensions.Hosting.Internal.ConsoleLifetime</code> 是默认的 <code>IHostLifetime</code> 实现。 <code>ConsoleLifetime</code>：</p>
<ul>
<li>侦听 Ctrl+C/SIGINT 或 SIGTERM 并调用 <code>StopApplication</code><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 来启动关闭进程。</li>
<li>解除阻止 <a href="http://www.zyiz.net/tutorial/detail-4544.html#runasync" target="_blank" rel="noopener"><code>RunAsync</code></a> 和 <a href="http://www.zyiz.net/tutorial/detail-4544.html#waitforshutdownasync" target="_blank" rel="noopener"><code>WaitForShutdownAsync</code></a> 等扩展。</li>
</ul>
<blockquote></blockquote>
<h4 id="span-name-IHostEnvironment-1-3-IHostEnvironment-span"><a class="header-anchor" href="#span-name-IHostEnvironment-1-3-IHostEnvironment-span">¶</a><span name="IHostEnvironment_1_3"><code>IHostEnvironment</code></span></h4>
<p>将 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.ihostenvironment" target="_blank" rel="noopener"><code>IHostEnvironment</code></a> 服务注册到一个类，获取关于以下项的信息：</p>
<ul>
<li><a href="http://www.zyiz.net/tutorial/detail-4544.html#applicationname" target="_blank" rel="noopener"><code>ApplicationName</code></a></li>
<li><a href="http://www.zyiz.net/tutorial/detail-4544.html#environmentname" target="_blank" rel="noopener"><code>EnvironmentName</code></a></li>
<li><a href="http://www.zyiz.net/tutorial/detail-4544.html#contentrootpath" target="_blank" rel="noopener"><code>ContentRootPath</code></a></li>
</ul>
<p>Web 应用实现 <code>IWebHostEnvironment</code> 接口，该接口继承 <code>IHostEnvironment</code> 并添加 <a href="http://www.zyiz.net/tutorial/detail-4544.html#webroot" target="_blank" rel="noopener"><code>WebRootPath</code></a>。</p>
<h4 id="主机配置"><a class="header-anchor" href="#主机配置">¶</a>主机配置</h4>
<p>主机配置用于 <a href="#IHostEnvironment_1_3"><code>IHostEnvironment</code></a> 实现的属性。</p>
<p>主机配置可以从 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.hostbuilder.configureappconfiguration" target="_blank" rel="noopener"><code>ConfigureAppConfiguration</code></a> 内的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.hostbuildercontext.configuration#Microsoft_Extensions_Hosting_HostBuilderContext_Configuration" target="_blank" rel="noopener"><code>HostBuilderContext.Configuration</code></a> 获取。 在 <code>ConfigureAppConfiguration</code> 后，<code>HostBuilderContext.Configuration</code> 被替换为应用配置。</p>
<p>若要添加主机配置，请对 <code>IHostBuilder</code> 调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.hostbuilder.configurehostconfiguration" target="_blank" rel="noopener"><code>ConfigureHostConfiguration</code></a>。 可多次调用 <code>ConfigureHostConfiguration</code>，并得到累计结果。 主机使用上一次在一个给定键上设置值的选项。</p>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<ul>
<li>在 <code>ConfigureHostConfiguration</code> 中可以<strong>添加</strong>主机配置、<strong>设置配置文件基目录</strong>，如内存配置、JSON 文件配置、XML 文件配置等。<strong>并且可以多次调用累积结果</strong>。</li>
<li>在 <code>ConfigureAppConfiguration</code> 中可以<strong>获取</strong> <code>ConfigureHostConfiguration</code> 添加的主机配置内容。</li>
<li>由于 <code>ConfigureHostConfiguration</code> 中添加的配置会与 <code>ConfigureAppConfiguration</code> 中的配置合并，所以也可以使用 <code>HostBuilderContext.Configuration</code> 对象获取，但可能会被 <code>ConfigureAppConfiguration</code> 中的配置覆盖。</li>
</ul>
</blockquote>
<p><code>CreateDefaultBuilder</code> 包含前缀为 <code>DOTNET_</code> 的环境变量提供程序和命令行参数。 对于 Web 应用程序，添加前缀为 <code>ASPNETCORE_</code> 的环境变量提供程序。 当系统读取环境变量时，便会删除前缀。 例如，<code>ASPNETCORE_ENVIRONMENT</code> 的环境变量值就变成 <code>environment</code> 密钥<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>的主机配置值。</p>
<p>以下示例创建主机配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">&#x2F;&#x2F; using Microsoft.Extensions.Configuration;<br><br>Host.CreateDefaultBuilder(args)<br>    .ConfigureHostConfiguration(configHost &#x3D;&gt;<br>    &#123;<br>        configHost.SetBasePath(Directory.GetCurrentDirectory());<br>        configHost.AddJsonFile(&quot;hostsettings.json&quot;, optional: true);<br>        configHost.AddEnvironmentVariables(prefix: &quot;PREFIX_&quot;);<br>        configHost.AddCommandLine(args);<br>    &#125;);<br></code></pre></div></td></tr></table></figure>
<blockquote></blockquote>
<h4 id="应用配置"><a class="header-anchor" href="#应用配置">¶</a>应用配置</h4>
<p>通过对 <code>IHostBuilder</code> 调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.hostbuilder.configureappconfiguration" target="_blank" rel="noopener"><code>ConfigureAppConfiguration</code></a> 创建应用配置。 可多次调用 <code>ConfigureAppConfiguration</code>，并得到累计结果。 应用使用上一次在一个给定键上设置值的选项。</p>
<p>由 <code>ConfigureAppConfiguration</code> 创建的配置可以通过 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.hostbuildercontext.configuration" target="_blank" rel="noopener"><code>HostBuilderContext.Configuration</code></a> 获取以用于后续操作，<strong>也可以通过 DI 作为服务获取</strong>。 主机配置也会添加到应用配置。</p>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<ul>
<li>同 <code>ConfigureHostConfiguration</code>，<code>ConfigureAppConfiguration</code> 可以多次调用并累积结果。</li>
<li><code>ConfigureAppConfiguration</code> 包含着 <code>ConfigureHostConfiguration</code> 添加的配置。</li>
<li><code>ConfigurationAppConfiguration</code> 添加的配置可以使用 <code>HostBuilderContext.Configuration</code> 获取。</li>
</ul>
</blockquote>
<p>有关详细信息，请参阅 <a href="http://www.zyiz.net/tutorial/detail-4547.html#configureappconfiguration" target="_blank" rel="noopener">ASP.NET Core 中的配置</a>。</p>
<h4 id="适用于所有应用类型的设置"><a class="header-anchor" href="#适用于所有应用类型的设置">¶</a>适用于所有应用类型的设置</h4>
<p>本部分列出了适用于 HTTP 和非 HTTP 工作负荷的主机设置。</p>
<p><strong>默认情况下，用来配置这些设置的环境变量可以具有 <code>DOTNET_</code> 或 <code>ASPNETCORE_</code> 前缀。</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">命令行键名</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">默认值</th>
<th style="text-align:left">描述</th>
<th style="text-align:center">对应的环境变量</th>
<th style="text-align:center">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>contentRoot</code></td>
<td style="text-align:center">string</td>
<td style="text-align:center">应用程序集所在的文件夹</td>
<td style="text-align:left"><code>IHostEnvironment.ContentRootPath</code> 属性决定主机从什么位置开始搜索内容文件。 如果路径不存在，主机将无法启动。</td>
<td style="text-align:center"><code>&lt;PREFIX_&gt;CONTENTROOT</code></td>
<td style="text-align:center"><a href="#Set_contentRoot_Example_1_4">若要设置此值，请使用环境变量或对 <code>IHostBuilder</code> 调用 <code>UseContentRoot</code></a></td>
</tr>
<tr>
<td style="text-align:center"><code>applicationName</code></td>
<td style="text-align:center">string</td>
<td style="text-align:center">包含应用入口点的程序集的名称</td>
<td style="text-align:left"><code>IHostEnvironment.ApplicationName</code> 属性是在主机构造期间通过主机配置设定的。</td>
<td style="text-align:center"><code>&lt;PREFIX_&gt;APPLICATIONNAME</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>environment</code></td>
<td style="text-align:center">string</td>
<td style="text-align:center"><code>Production</code></td>
<td style="text-align:left"><code>IHostEnvironment.EnvironmentName</code> 属性可以设置为任何值。 框架定义的值包括 <code>Development</code>、<code>Staging</code> 和 <code>Production</code>。 值不区分大小写。</td>
<td style="text-align:center"><code>&lt;PREFIX_&gt;ENVIRONMENT</code></td>
<td style="text-align:center"><a href="#Set_EnvironmentName_Example_1_5">若要设置此值，请使用环境变量或对 <code>IHostBuilder</code> 调用 <code>UseEnvironment</code></a></td>
</tr>
<tr>
<td style="text-align:center"><code>shutdownTimeoutSeconds</code></td>
<td style="text-align:center">int</td>
<td style="text-align:center"><code>5</code></td>
<td style="text-align:left"><code>HostOptions.ShutdownTimeout</code> 设置 <code>StopAsync</code> 的超时。 默认值为 5 秒。 在超时时间段中，主机：<br />(1) 触发 <code>IHostApplicationLifetime.ApplicationStopping</code>。<br />(2) 尝试停止托管服务，对服务停止失败的错误进行日志记录。<br />如果在所有托管服务停止之前就达到了超时时间，则会在应用关闭时会终止剩余的所有活动的服务。 即使没有完成处理工作，服务也会停止。 如果停止服务需要额外的时间，请增加超时时间。</td>
<td style="text-align:center"><code>&lt;PREFIX_&gt;SHUTDOWNTIMEOUTSECONDS</code></td>
<td style="text-align:center"><a href="#Set_ShutdownTimeoutSeconds_Example_1_6">若要设置此值，请使用环境变量或配置 <code>HostOptions</code></a></td>
</tr>
</tbody>
</table>
<p>通用主机设置使用示例：</p>
<ol>
<li>
<p><span name="Set_contentRoot_Example_1_4">ContentRoot 设置示例</span></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">Host.CreateDefaultBuilder(args)<br>    .UseContentRoot(&quot;c:\\content-root&quot;)<br>    &#x2F;&#x2F;...<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><span name="Set_EnvironmentName_Example_1_5">EnvironmentName 设置示例</span></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">Host.CreateDefaultBuilder(args)<br>    .UseEnvironment(&quot;Development&quot;)<br>    &#x2F;&#x2F;...<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><span name="Set_ShutdownTimeoutSeconds_Example_1_6">ShutdownTimeoutSeconds 设置示例</span>，以下示例将超时设置为 20 秒：</p>
<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp">Host.CreateDefaultBuilder(args)<br> .ConfigureServices((hostContext, services) =&gt;<br> &#123;<br>     services.Configure&lt;HostOptions&gt;(option =&gt;<br>     &#123;<br>         option.ShutdownTimeout = System.TimeSpan.FromSeconds(<span class="hljs-number">20</span>);<br>     &#125;);<br> &#125;);<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h4 id="适用于-Web-应用的设置"><a class="header-anchor" href="#适用于-Web-应用的设置">¶</a>适用于 Web 应用的设置</h4>
<p>一些主机设置仅适用于 HTTP 工作负荷。 默认情况下，用来配置这些设置的环境变量可以具有 <code>DOTNET_</code> 或 <code>ASPNETCORE_</code> 前缀。</p>
<p><strong><code>IWebHostBuilder</code> 上的扩展方法适用于这些设置</strong>。 显示如何调用扩展方法的示例代码假定 <code>webBuilder</code> 是 <code>IWebHostBuilder</code> 的实例，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;<br>    Host.CreateDefaultBuilder(args)<br>        .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;<br>        &#123;<br>            webBuilder.CaptureStartupErrors(true);<br>            webBuilder.UseStartup&lt;Startup&gt;();<br>        &#125;);<br></code></pre></div></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">命令行键名</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">默认值</th>
<th style="text-align:left">描述</th>
<th style="text-align:center">对应的环境变量</th>
<th style="text-align:center">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>captureStartupErrors</code></td>
<td style="text-align:center">bool（<code>true</code>、<code>false</code> 或 <code>1</code>、<code>0</code>）</td>
<td style="text-align:center">默认为 <code>false</code>，除非应用使用 Kestrel 在 IIS 后方运行，其中默认值是 <code>true</code></td>
<td style="text-align:left">当 <code>false</code> 时，启动期间出错导致主机退出。 当 <code>true</code> 时，主机在启动期间捕获异常并尝试启动服务器。</td>
<td style="text-align:center"><code>&lt;PREFIX_&gt;CAPTURESTARTUPERRORS</code></td>
<td style="text-align:center"><a href="#Set_CaptureStartupErrors_Example_1_7">若要设置此值，使用配置或调用 <code>CaptureStartupErrors</code></a></td>
</tr>
<tr>
<td style="text-align:center"><code>detailedErrors</code></td>
<td style="text-align:center">bool（<code>true</code>、<code>false</code> 或 <code>1</code>、<code>0</code>）</td>
<td style="text-align:center"><code>false</code></td>
<td style="text-align:left">如果启用，<strong>或</strong>环境为 Development，应用会捕获详细错误。</td>
<td style="text-align:center"><code>&lt;PREFIX_&gt;_DETAILEDERRORS</code></td>
<td style="text-align:center"><a href="#Set_DetailedErrors_Example_1_8">要设置此值，使用配置或调用 <code>UseSetting</code></a></td>
</tr>
<tr>
<td style="text-align:center"><code>hostingStartupAssemblies</code></td>
<td style="text-align:center">string</td>
<td style="text-align:center">空字符串</td>
<td style="text-align:left">承载启动程序集的以分号分隔的字符串在启动时加载。**虽然配置值默认为空字符串，但是承载启动程序集会始终包含应用的程序集。**提供承载启动程序集时，当应用在启动过程中生成其公用服务时将它们添加到应用的程序集加载。</td>
<td style="text-align:center"><code>&lt;PREFIX_&gt;_HOSTINGSTARTUPASSEMBLIE</code></td>
<td style="text-align:center"><a href="#Set_HostingStartupAssemblies_Example_1_9">要设置此值，使用配置或调用 <code>UseSetting</code></a></td>
</tr>
<tr>
<td style="text-align:center"><code>hostingStartupExcludeAssemblies</code></td>
<td style="text-align:center">string</td>
<td style="text-align:center">空字符串</td>
<td style="text-align:left">承载启动程序集的以分号分隔的字符串在启动时排除。</td>
<td style="text-align:center"><code>&lt;PREFIX_&gt;_HOSTINGSTARTUPEXCLUDEASSEMBLIES</code></td>
<td style="text-align:center"><a href="#Set_HostingStartupExcludeAssemblies_Example_1_10">要设置此值，使用配置或调用 <code>UseSetting</code></a></td>
</tr>
<tr>
<td style="text-align:center"><code>https_port</code></td>
<td style="text-align:center">string</td>
<td style="text-align:center">未设置默认值</td>
<td style="text-align:left">HTTPS 重定向端口。 用于强制实施 HTTPS</td>
<td style="text-align:center"><code>&lt;PREFIX_&gt;HTTPS_PORT</code></td>
<td style="text-align:center"><a href="#Set_HTTPS_PORT_Example_1_11">要设置此值，使用配置或调用 <code>UseSetting</code></a></td>
</tr>
<tr>
<td style="text-align:center"><code>preferHostingUrls</code></td>
<td style="text-align:center">bool（<code>true</code>、<code>false</code> 或 <code>1</code>、<code>0</code>）</td>
<td style="text-align:center"><code>true</code></td>
<td style="text-align:left">指示主机是否应该侦听使用 <code>IWebHostBuilder</code> 配置的 URL，而不是使用 <code>IServer</code> 实现配置的 URL</td>
<td style="text-align:center"><code>&lt;PREFIX_&gt;_PREFERHOSTINGURLS</code></td>
<td style="text-align:center"><a href="#Set_PreferHostingUrls_Example_1_12">若要设置此值，请使用环境变量或调用 <code>PreferHostingUrls</code></a></td>
</tr>
<tr>
<td style="text-align:center"><code>preventHostingStartup</code></td>
<td style="text-align:center">bool（<code>true</code>、<code>false</code> 或 <code>1</code>、<code>0</code>）</td>
<td style="text-align:center"><code>false</code></td>
<td style="text-align:left">阻止承载启动程序集自动加载，包括应用的程序集所配置的承载启动程序集</td>
<td style="text-align:center"><code>&lt;PREFIX_&gt;_PREVENTHOSTINGSTARTUP</code></td>
<td style="text-align:center"><a href="#Set_Prevent_Hosting_Startup_Example_1_13">若要设置此值，请使用环境变量或调用 <code>UseSetting</code></a></td>
</tr>
<tr>
<td style="text-align:center"><code>startupAssembly</code></td>
<td style="text-align:center">string</td>
<td style="text-align:center">应用的程序集</td>
<td style="text-align:left">要搜索 <code>Startup</code> 类的程序集</td>
<td style="text-align:center"><code>&lt;PREFIX_&gt;STARTUPASSEMBLY</code></td>
<td style="text-align:center"><a href="#Set_StartupAssembly_Example_1_14">若要设置此值，请使用环境变量或调用 <code>UseStartup</code>。 <code>UseStartup</code> 可以采用程序集名称 (string) 或类型 (<code>TStartup</code>)。 如果调用多个 <code>UseStartup</code> 方法，优先选择最后一个方法。</a></td>
</tr>
<tr>
<td style="text-align:center"><code>urls</code></td>
<td style="text-align:center">string</td>
<td style="text-align:center"><em><a href="http://localhost:5000" target="_blank" rel="noopener">http://localhost:5000</a></em> 和 <em><a href="https://localhost:5001" target="_blank" rel="noopener">https://localhost:5001</a></em></td>
<td style="text-align:left">IP 地址或主机地址的分号分隔列表，其中包含服务器应针对请求侦听的端口和协议。 例如 <em><a href="http://localhost:123" target="_blank" rel="noopener">http://localhost:123</a></em>。 使用“*”指示服务器应针对请求侦听的使用特定端口和协议（例如 <em>http://*:5000</em>）的 IP 地址或主机名。 协议（http:// 或 https://）必须包含每个 URL。 不同的服务器支持的格式有所不同。</td>
<td style="text-align:center"><code>&lt;PREFIX_&gt;URLS</code></td>
<td style="text-align:center"><a href="#Set_URLS_Example_1_15">若要设置此值，请使用环境变量或调用 <code>UseUrls</code></a></td>
</tr>
<tr>
<td style="text-align:center"><code>webroot</code></td>
<td style="text-align:center">string</td>
<td style="text-align:center">默认值为 <em>wwwroot</em>。 <em>{content root}/wwwroot</em> 的路径必须存在。<strong>如果该路径不存在，则使用无操作文件提供程序</strong>。</td>
<td style="text-align:left"><code>&lt;PREFIX_&gt;WEBROOT</code></td>
<td style="text-align:center">应用的静态资产的相对路径。</td>
<td style="text-align:center"><a href="#Set_WebRoot_Example_1_16">若要设置此值，请使用环境变量或调用 <code>UseWebRoot</code></a></td>
</tr>
</tbody>
</table>
<p>用于 HTTP 工作负载的主机设置使用示例：</p>
<ol>
<li>
<p><span name="Set_CaptureStartupErrors_Example_1_7">CaptureStartupErrors 设置示例：</span></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">webBuilder.CaptureStartupErrors(true);<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><span name="Set_DetailedErrors_Example_1_8">DetailedErrors 设置示例：</span></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">webBuilder.UseSetting(WebHostDefaults.DetailedErrorsKey, &quot;true&quot;);<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><span name="Set_HostingStartupAssemblies_Example_1_9">HostingStartupAssemblies 使用示例：</span></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">webBuilder.UseSetting(WebHostDefaults.HostingStartupAssembliesKey, &quot;assembly1;assembly2&quot;);<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><span name="Set_HostingStartupExcludeAssemblies_Example_1_10">HostingStartupExcludeAssemblies 使用示例：</span></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">webBuilder.UseSetting(WebHostDefaults.HostingStartupExcludeAssembliesKey, &quot;assembly1;assembly2&quot;);<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><span name="Set_HTTPS_PORT_Example_1_11">HTTPS_Port 使用示例：</span></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">webBuilder.UseSetting(&quot;https_port&quot;, &quot;8080&quot;);<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><span name="Set_PreferHostingUrls_Example_1_12">PreferHostingUrls 使用示例：</span></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">webBuilder.PreferHostingUrls(true);<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><span name="Set_Prevent_Hosting_Startup_Example_1_13">PreventHostingStartup 使用示例：</span></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">webBuilder.UseSetting(WebHostDefaults.PreventHostingStartupKey, &quot;true&quot;);<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><span name="Set_StartupAssembly_Example_1_14">StartupAssembly 使用示例：</span></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">webBuilder.UseStartup(&quot;StartupAssemblyName&quot;);<br></code></pre></div></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">webBuilder.UseStartup&lt;Startup&gt;();<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><span name="Set_URLS_Example_1_15">URLS 使用示例：</span></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">webBuilder.UseUrls(&quot;http:&#x2F;&#x2F;*:5000;http:&#x2F;&#x2F;localhost:5001;https:&#x2F;&#x2F;hostname:5002&quot;);<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>Kestrel 具有自己的终结点配置 API。 有关详细信息，请参阅 <a href="http://www.zyiz.net/tutorial/detail-4761.html#endpoint-configuration" target="_blank" rel="noopener">ASP.NET Core 中的 Kestrel Web 服务器实现</a>。</p>
</blockquote>
</li>
<li>
<p><span name="Set_WebRoot_Example_1_16">URLS 使用示例：</span></p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">webBuilder.UseWebRoot(&quot;public&quot;);<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h4 id="管理主机生存期"><a class="header-anchor" href="#管理主机生存期">¶</a>管理主机生存期</h4>
<p>对生成的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.ihost" target="_blank" rel="noopener"><code>IHost</code></a> 实现调用方法，以启动和停止应用。 <strong>这些方法会影响所有在服务容器中注册的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.ihostedservice" target="_blank" rel="noopener"><code>IHostedService</code></a> 实现</strong>。</p>
<ol>
<li>
<p><code>Run</code>：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.hostingabstractionshostextensions.run" target="_blank" rel="noopener"><code>Run</code></a> 运行应用并阻止调用线程，直到关闭主机。</p>
</li>
<li>
<p><code>RunAsync</code>：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.hostingabstractionshostextensions.runasync" target="_blank" rel="noopener"><code>RunAsync</code></a> 运行应用并返回在触发取消令牌或关闭时完成的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task" target="_blank" rel="noopener"><code>Task</code></a>。</p>
</li>
<li>
<p><code>RunConsoleAsync</code>：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.hostinghostbuilderextensions.runconsoleasync" target="_blank" rel="noopener"><code>RunConsoleAsync</code></a> 启用控制台支持、生成和启动主机，以及等待 Ctrl+C/SIGINT 或 SIGTERM 关闭。</p>
</li>
<li>
<p><code>Start</code>：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.hostingabstractionshostextensions.start" target="_blank" rel="noopener"><code>Start</code></a> 同步启动主机。</p>
</li>
<li>
<p><code>StartAsync</code>：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.ihost.startasync" target="_blank" rel="noopener"><code>StartAsync</code></a> 启动主机并返回在触发取消令牌或关闭时完成的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task" target="_blank" rel="noopener"><code>Task</code></a>。在 <code>StartAsync</code> 开始时调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.ihostlifetime.waitforstartasync" target="_blank" rel="noopener"><code>WaitForStartAsync</code></a>，在继续之前，会一直等待该操作完成。 它可用于延迟启动，直到外部事件发出信号。</p>
</li>
<li>
<p><code>StopAsync</code>：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.hostingabstractionshostextensions.stopasync" target="_blank" rel="noopener"><code>StopAsync</code></a> 尝试在提供的超时时间内停止主机。</p>
</li>
<li>
<p><code>WaitForShutdown</code>：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.hostingabstractionshostextensions.waitforshutdown" target="_blank" rel="noopener"><code>WaitForShutdown</code></a> 阻止调用线程，直到 <code>IHostLifetime</code> 触发关闭，例如通过 Ctrl+C/SIGINT 或 SIGTERM。</p>
</li>
<li>
<p><code>WaitForShutdownAsync</code>：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.hostingabstractionshostextensions.waitforshutdownasync" target="_blank" rel="noopener"><code>WaitForShutdownAsync</code></a> 返回在通过给定的令牌和调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.ihost.stopasync" target="_blank" rel="noopener"><code>StopAsync</code></a> 来触发关闭时完成的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task" target="_blank" rel="noopener"><code>Task</code></a>。</p>
</li>
<li>
<p>外部控件：使用可从外部调用的方法，能够实现对主机生存期的直接控制：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Program<br>&#123;<br>    private IHost _host;<br><br>    public Program()<br>    &#123;<br>        _host &#x3D; new HostBuilder()<br>            .Build();<br>    &#125;<br><br>    public async Task StartAsync()<br>    &#123;<br>        _host.StartAsync();<br>    &#125;<br><br>    public async Task StopAsync()<br>    &#123;<br>        using (_host)<br>        &#123;<br>            await _host.StopAsync(TimeSpan.FromSeconds(5));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h3 id="二、Web-主机"><a class="header-anchor" href="#二、Web-主机">¶</a>二、Web 主机</h3>
<p>在低于 3.0 的 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 版本中，Web 主机用于 HTTP 工作负载。 不再建议将 Web 主机用于 Web 应用，但该主机仍可仅用于后向兼容性。故本节略。</p>
<h3 id="三、依赖注入服务"><a class="header-anchor" href="#三、依赖注入服务">¶</a>三、依赖注入服务</h3>
<p>**一个对象中包含所有应用的相互依赖资源的主要原因是生存期管理：控制应用启动和正常关闭。**<a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 支持依赖关系注入 (DI) 软件设计模式，这是一种在类及其依赖关系之间实现<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#dependency-inversion" target="_blank" rel="noopener">控制反转 (IoC)</a> 的技术。</p>
<h4 id="依赖关系注入概述"><a class="header-anchor" href="#依赖关系注入概述">¶</a>依赖关系注入概述</h4>
<p><strong>依赖项</strong>是另一个对象所需的任何对象。 使用应用中其他类所依赖的 <code>WriteMessage</code> 方法检查以下 <code>MyDependency</code> 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class MyDependency<br>&#123;<br>    public MyDependency()<br>    &#123;<br>    &#125;<br><br>    public Task WriteMessage(string message)<br>    &#123;<br>        Console.WriteLine(<br>            $&quot;MyDependency.WriteMessage called. Message: &#123;message&#125;&quot;);<br><br>        return Task.FromResult(0);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>可以创建 <code>MyDependency</code> 类的实例以使 <code>WriteMessage</code> 方法可用于类。 <code>MyDependency</code> 类是 <code>IndexModel</code> 类的依赖项：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class IndexModel : PageModel<br>&#123;<br>    MyDependency _dependency &#x3D; new MyDependency();<br><br>    public async Task OnGetAsync()<br>    &#123;<br>        await _dependency.WriteMessage(<br>            &quot;IndexModel.OnGetAsync created this message.&quot;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>该类创建并直接依赖于 <code>MyDependency</code> 实例。 代码依赖关系（如前面的示例）存在问题，应该避免使用，原因如下：</p>
<ul>
<li>要用不同的实现替换 <code>MyDependency</code>，必须修改类。</li>
<li>如果 <code>MyDependency</code> 具有依赖关系，则必须由类对其进行配置。 在具有多个依赖于 <code>MyDependency</code> 的类的大型项目中，配置代码在整个应用中会变得分散。</li>
<li>这种实现很难进行单元测试。 应用应使用模拟或存根 <code>MyDependency</code> 类，该类不能使用此方法。</li>
</ul>
<p>依赖关系注入通过以下方式解决了这些问题：</p>
<ul>
<li>使用接口或基类抽象化依赖关系实现。</li>
<li>注册服务容器中的依赖关系。<a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 提供了一个内置的服务容器 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.iserviceprovider" target="_blank" rel="noopener"><code>IServiceProvider</code></a>。 服务已在应用的 <code>Startup.ConfigureServices</code> 方法中注册。</li>
<li>将服务注入 到使用它的类的构造函数中。 框架负责创建依赖关系的实例，并在不再需要时对其进行处理。</li>
</ul>
<p>在<a href="https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/dependency-injection/samples" target="_blank" rel="noopener">示例应用</a>中，<code>IMyDependency</code> 接口定义了服务为应用提供的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public interface IMyDependency<br>&#123;<br>    Task WriteMessage(string message);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>此接口由具体类型 <code>MyDependency</code> 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class MyDependency : IMyDependency<br>&#123;<br>    private readonly ILogger&lt;MyDependency&gt; _logger;<br><br>    public MyDependency(ILogger&lt;MyDependency&gt; logger)<br>    &#123;<br>        _logger &#x3D; logger;<br>    &#125;<br><br>    public Task WriteMessage(string message)<br>    &#123;<br>        _logger.LogInformation(<br>            &quot;MyDependency.WriteMessage called. Message: &#123;MESSAGE&#125;&quot;,<br>            message);<br><br>        return Task.FromResult(0);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>MyDependency</code> 在其构造函数中请求一个 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.logging.ilogger-1" target="_blank" rel="noopener"><code>ILogger</code></a>。 以链式方式使用依赖关系注入并不罕见。 每个请求的依赖关系相应地请求其自己的依赖关系。 容器解析图中的依赖关系并返回完全解析的服务。 必须被解析的依赖关系的集合通常被称为“依赖关系树” 、“依赖关系图” 或“对象图” 。</p>
<p>必须在服务容器中注册 <code>IMyDependency</code> 和 <code>ILogger&lt;TCategoryName&gt;</code>。 <code>IMyDependency</code> 已在 <code>Startup.ConfigureServices</code> 中注册。 <code>ILogger&lt;TCategoryName&gt;</code> 由日志记录抽象基础结构注册，因此它是框架默认注册的<a href="http://www.zyiz.net/tutorial/detail-4542.html#framework-provided-services" target="_blank" rel="noopener">框架提供的服务</a>。</p>
<p>容器通过利用<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/types#open-and-closed-types" target="_blank" rel="noopener">（泛型）开放类型</a>解析 <code>ILogger&lt;TCategoryName&gt;</code>，而无需注册每个<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/language-specification/types#constructed-types" target="_blank" rel="noopener">（泛型）构造类型</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">services.AddSingleton(typeof(ILogger&lt;&gt;), typeof(Logger&lt;&gt;));<br></code></pre></div></td></tr></table></figure>
<p>在示例应用中，使用具体类型 <code>MyDependency</code> 注册 <code>IMyDependency</code> 服务。 注册将服务生存期的范围限定为单个请求的生存期。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public void ConfigureServices(IServiceCollection services)<br>&#123;<br>    services.AddRazorPages();<br><br>    services.AddScoped&lt;IMyDependency, MyDependency&gt;();<br>    services.AddTransient&lt;IOperationTransient, Operation&gt;();<br>    services.AddScoped&lt;IOperationScoped, Operation&gt;();<br>    services.AddSingleton&lt;IOperationSingleton, Operation&gt;();<br>    services.AddSingleton&lt;IOperationSingletonInstance&gt;(new Operation(Guid.Empty));<br><br>    &#x2F;&#x2F; OperationService depends on each of the other Operation types.<br>    services.AddTransient&lt;OperationService, OperationService&gt;();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public void ConfigureServices(IServiceCollection services)<br>&#123;<br>    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);<br><br>    services.AddScoped&lt;IMyDependency, MyDependency&gt;();<br>    services.AddTransient&lt;IOperationTransient, Operation&gt;();<br>    services.AddScoped&lt;IOperationScoped, Operation&gt;();<br>    services.AddSingleton&lt;IOperationSingleton, Operation&gt;();<br>    services.AddSingleton&lt;IOperationSingletonInstance&gt;(new Operation(Guid.Empty));<br><br>    &#x2F;&#x2F; OperationService depends on each of the other Operation types.<br>    services.AddTransient&lt;OperationService, OperationService&gt;();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>每个 <code>services.Add{SERVICE_NAME}</code> 扩展方法添加（并可能配置）服务。 例如，<code>services.AddMvc()</code> 添加 Razor Pages 和 MVC 需要的服务。 我们建议应用遵循此约定。 将扩展方法置于 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection" target="_blank" rel="noopener"><code>Microsoft.Extensions.DependencyInjection</code></a> 命名空间中以封装服务注册的组。</p>
</blockquote>
<p>如果服务的构造函数需要<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/built-in-types-table" target="_blank" rel="noopener">内置类型</a>（如 <code>string</code>），则可以使用配置或选项模式注入该类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class MyDependency : IMyDependency<br>&#123;<br>    public MyDependency(IConfiguration config)<br>    &#123;<br>        var myStringValue &#x3D; config[&quot;MyStringKey&quot;];<br><br>        &#x2F;&#x2F; Use myStringValue<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>通过使用服务并分配给私有字段的类的构造函数请求服务的实例。 该字段用于在整个类中根据需要访问服务。</p>
<p>在示例应用中，请求 <code>IMyDependency</code> 实例并用于调用服务的 <code>WriteMessage</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class IndexModel : PageModel<br>&#123;<br>    private readonly IMyDependency _myDependency;<br><br>    public IndexModel(<br>        IMyDependency myDependency,<br>        OperationService operationService,<br>        IOperationTransient transientOperation,<br>        IOperationScoped scopedOperation,<br>        IOperationSingleton singletonOperation,<br>        IOperationSingletonInstance singletonInstanceOperation)<br>    &#123;<br>        _myDependency &#x3D; myDependency;<br>        OperationService &#x3D; operationService;<br>        TransientOperation &#x3D; transientOperation;<br>        ScopedOperation &#x3D; scopedOperation;<br>        SingletonOperation &#x3D; singletonOperation;<br>        SingletonInstanceOperation &#x3D; singletonInstanceOperation;<br>    &#125;<br><br>    public OperationService OperationService &#123; get; &#125;<br>    public IOperationTransient TransientOperation &#123; get; &#125;<br>    public IOperationScoped ScopedOperation &#123; get; &#125;<br>    public IOperationSingleton SingletonOperation &#123; get; &#125;<br>    public IOperationSingletonInstance SingletonInstanceOperation &#123; get; &#125;<br><br>    public async Task OnGetAsync()<br>    &#123;<br>        await _myDependency.WriteMessage(<br>            &quot;IndexModel.OnGetAsync created this message.&quot;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="注入启动的服务"><a class="header-anchor" href="#注入启动的服务">¶</a>注入启动的服务</h4>
<p>使用通用主机 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.ihostbuilder" target="_blank" rel="noopener"><code>IHostBuilder</code></a>) 时，<strong>只能</strong>将以下服务类型注入 <code>Startup</code> 构造函数：</p>
<ul>
<li><code>IWebHostEnvironment</code></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.ihostenvironment" target="_blank" rel="noopener"><code>IHostEnvironment</code></a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.iconfiguration" target="_blank" rel="noopener"><code>IConfiguration</code></a></li>
</ul>
<p>服务可以注入 <code>Startup.Configure</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public void Configure(IApplicationBuilder app, IOptions&lt;MyOptions&gt; options)<br>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="框架提供的服务-v2"><a class="header-anchor" href="#框架提供的服务-v2">¶</a>框架提供的服务</h4>
<p><code>Startup.ConfigureServices</code> 方法负责定义应用使用的服务，包括 Entity Framework Core 和 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core MVC 等平台功能。 最初，提供给 <code>ConfigureServices</code> 的 <code>IServiceCollection</code> 具有框架定义的服务（具体取决于主机配置方式）。 基于 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 模板的应用程序具有框架注册的数百个服务的情况并不少见。 下表列出了框架注册的服务的一个小示例。</p>
<table>
<thead>
<tr>
<th style="text-align:left">服务类型</th>
<th style="text-align:left">生存期</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.builder.iapplicationbuilderfactory" target="_blank" rel="noopener"><code>Microsoft.AspNetCore.Hosting.Builder.IApplicationBuilderFactory</code></a></td>
<td style="text-align:left">暂时性</td>
</tr>
<tr>
<td style="text-align:left"><code>IHostApplicationLifetime</code></td>
<td style="text-align:left">单例</td>
</tr>
<tr>
<td style="text-align:left"><code>IWebHostEnvironment</code></td>
<td style="text-align:left">单例</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.istartup" target="_blank" rel="noopener"><code>Microsoft.AspNetCore.Hosting.IStartup</code></a></td>
<td style="text-align:left">单例</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.istartupfilter" target="_blank" rel="noopener"><code>Microsoft.AspNetCore.Hosting.IStartupFilter</code></a></td>
<td style="text-align:left">暂时性</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.server.iserver" target="_blank" rel="noopener"><code>Microsoft.AspNetCore.Hosting.Server.IServer</code></a></td>
<td style="text-align:left">单例</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.http.ihttpcontextfactory" target="_blank" rel="noopener"><code>Microsoft.AspNetCore.Http.IHttpContextFactory</code></a></td>
<td style="text-align:left">暂时性</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.logging.ilogger-1" target="_blank" rel="noopener"><code>Microsoft.Extensions.Logging.ILogger</code></a></td>
<td style="text-align:left">单例</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.logging.iloggerfactory" target="_blank" rel="noopener"><code>Microsoft.Extensions.Logging.ILoggerFactory</code></a></td>
<td style="text-align:left">单例</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.objectpool.objectpoolprovider" target="_blank" rel="noopener"><code>Microsoft.Extensions.ObjectPool.ObjectPoolProvider</code></a></td>
<td style="text-align:left">单例</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.options.iconfigureoptions-1" target="_blank" rel="noopener"><code>Microsoft.Extensions.Options.IConfigureOptions</code></a></td>
<td style="text-align:left">暂时性</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.options.ioptions-1" target="_blank" rel="noopener"><code>Microsoft.Extensions.Options.IOptions</code></a></td>
<td style="text-align:left">单例</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.diagnostics.diagnosticsource" target="_blank" rel="noopener"><code>System.Diagnostics.DiagnosticSource</code></a></td>
<td style="text-align:left">单例</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.diagnostics.diagnosticlistener" target="_blank" rel="noopener"><code>System.Diagnostics.DiagnosticListener</code></a></td>
<td style="text-align:left">单例</td>
</tr>
</tbody>
</table>
<h4 id="使用扩展方法注册附加服务"><a class="header-anchor" href="#使用扩展方法注册附加服务">¶</a>使用扩展方法注册附加服务</h4>
<p>当服务集合扩展方法可用于注册服务（及其依赖服务，如果需要）时，约定使用单个 <code>Add{SERVICE_NAME}</code> 扩展方法来注册该服务所需的所有服务。 以下代码是如何使用扩展方法 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.entityframeworkservicecollectionextensions.adddbcontext" target="_blank" rel="noopener"><code>AddDbContext</code></a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.identityservicecollectionextensions.addidentitycore" target="_blank" rel="noopener"><code>AddIdentityCore</code></a> 向容器添加附加服务的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public void ConfigureServices(IServiceCollection services)<br>&#123;<br>    ...<br><br>    services.AddDbContext&lt;ApplicationDbContext&gt;(options &#x3D;&gt;<br>        options.UseSqlServer(Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));<br><br>    services.AddIdentity&lt;ApplicationUser, IdentityRole&gt;()<br>        .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()<br>        .AddDefaultTokenProviders();<br><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="服务生存期"><a class="header-anchor" href="#服务生存期">¶</a>服务生存期</h4>
<p>为每个注册的服务选择适当的生存期。 可以使用以下生存期配置 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 服务：</p>
<ol>
<li>
<p><strong>暂时性生存期（Transient）</strong>：暂时生存期服务 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addtransient" target="_blank" rel="noopener"><code>AddTransient</code></a>) 是每次从服务容器进行请求时创建的。 这种生存期适合轻量级、 无状态的服务。</p>
</li>
<li>
<p><strong>作用域生存期（Scoped）</strong>：作用域生存期服务 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addscoped" target="_blank" rel="noopener"><code>AddScoped</code></a>) 以每个客户端请求（连接）一次的方式创建。</p>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>在中间件内使用有作用域的服务时，请将该服务注入至 <code>Invoke</code> 或 <code>InvokeAsync</code> 方法。 请不要通过构造函数注入进行注入，因为它会强制服务的行为与单一实例类似。</p>
</blockquote>
</li>
<li>
<p><strong>单例生存期（Singleton）</strong>：单例实例生存期服务 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addsingleton" target="_blank" rel="noopener"><code>AddSingleton</code></a>) 是在第一次请求时（或者在运行 <code>Startup.ConfigureServices</code> 并且使用服务注册指定实例时）创建的。 每个后续请求都使用相同的实例。 如果应用需要单一实例行为，建议允许服务容器管理服务的生存期。 不要实现单一实例设计模式并提供用户代码来管理对象在类中的生存期。</p>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>从单一实例解析有作用域的服务很危险。 当处理后续请求时，它可能会导致服务处于不正确的状态。</p>
</blockquote>
</li>
</ol>
<h4 id="服务注册方法"><a class="header-anchor" href="#服务注册方法">¶</a>服务注册方法</h4>
<p><span name="Methods_of_Registering_Services_3_1">服务注册扩展方法提供适用于特定场景的重载。</span></p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:center">自动 对象 (object) 处置</th>
<th style="text-align:center">多个 实现</th>
<th style="text-align:center">传递参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Add{LIFETIME}&lt;{SERVICE}, {IMPLEMENTATION}&gt;()</code> 示例： <code>services.AddSingleton&lt;IMyDep, MyDep&gt;();</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:left"><code>Add{LIFETIME}&lt;{SERVICE}&gt;(sp =&gt; new {IMPLEMENTATION})</code> 示例： <code>services.AddSingleton&lt;IMyDep&gt;(sp =&gt; new MyDep());</code> <code>services.AddSingleton&lt;IMyDep&gt;(sp =&gt; new MyDep(&quot;A string!&quot;));</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:left"><code>Add{LIFETIME}&lt;{IMPLEMENTATION}&gt;()</code> 示例： <code>services.AddSingleton&lt;MyDep&gt;();</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:left"><code>AddSingleton&lt;{SERVICE}&gt;(new {IMPLEMENTATION})</code> 示例： <code>services.AddSingleton&lt;IMyDep&gt;(new MyDep());</code> <code>services.AddSingleton&lt;IMyDep&gt;(new MyDep(&quot;A string!&quot;));</code></td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:left"><code>AddSingleton(new {IMPLEMENTATION})</code> 示例： <code>services.AddSingleton(new MyDep());</code> <code>services.AddSingleton(new MyDep(&quot;A string!&quot;));</code></td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<p><code>TryAdd{LIFETIME}</code> 方法仅当尚未注册实现时，注册该服务。</p>
<p>在以下示例中，第一行向 <code>IMyDependency</code> 注册 <code>MyDependency</code>。 第二行没有任何作用，因为 <code>IMyDependency</code> 已有一个已注册的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">services.AddSingleton&lt;IMyDependency, MyDependency&gt;();<br>&#x2F;&#x2F; The following line has no effect:<br>services.TryAddSingleton&lt;IMyDependency, DifferentDependency&gt;();<br></code></pre></div></td></tr></table></figure>
<p>有关详细信息，请参阅：</p>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.extensions.servicecollectiondescriptorextensions.tryadd" target="_blank" rel="noopener"><code>TryAdd</code></a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.extensions.servicecollectiondescriptorextensions.tryaddtransient" target="_blank" rel="noopener"><code>TryAddTransient</code></a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.extensions.servicecollectiondescriptorextensions.tryaddscoped" target="_blank" rel="noopener"><code>TryAddScoped</code></a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.extensions.servicecollectiondescriptorextensions.tryaddsingleton" target="_blank" rel="noopener"><code>TryAddSingleton</code></a></li>
</ul>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.extensions.servicecollectiondescriptorextensions.tryaddenumerable" target="_blank" rel="noopener"><code>TryAddEnumerable(ServiceDescriptor)</code></a> 方法仅当没有同一类型的实现时，注册该服务。 多个服务通过 <code>IEnumerable&lt;{SERVICE}&gt;</code> 解析。 注册服务时，开发人员只希望在尚未添加一个相同类型时添加实例。 通常情况下，库创建者使用此方法来避免在容器中注册一个实例的两个副本。</p>
<p>在以下示例中，第一行向 <code>IMyDep1</code> 注册 <code>MyDep</code>。 第二行向 <code>IMyDep2</code> 注册 <code>MyDep</code>。 第三行没有任何作用，因为 <code>IMyDep1</code> 已有一个 <code>MyDep</code> 的已注册的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public interface IMyDep1 &#123;&#125;<br>public interface IMyDep2 &#123;&#125;<br><br>public class MyDep : IMyDep1, IMyDep2 &#123;&#125;<br><br>services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IMyDep1, MyDep&gt;());<br>services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IMyDep2, MyDep&gt;());<br>&#x2F;&#x2F; Two registrations of MyDep for IMyDep1 is avoided by the following line:<br>services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IMyDep1, MyDep&gt;());<br></code></pre></div></td></tr></table></figure>
<h4 id="构造函数注入行为"><a class="header-anchor" href="#构造函数注入行为">¶</a>构造函数注入行为</h4>
<p>服务可以通过两种机制来解析：</p>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.iserviceprovider" target="_blank" rel="noopener"><code>IServiceProvider</code></a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.activatorutilities" target="_blank" rel="noopener"><code>ActivatorUtilities</code></a> – 允许在依赖关系注入容器中创建没有服务注册的对象。 <code>ActivatorUtilities</code> 用于面向用户的抽象，例如标记帮助器、MVC 控制器和模型绑定器。</li>
</ul>
<p><a href="#Methods_of_Registering_Services_3_1">构造函数可以接受依赖关系注入不提供的参数</a>，但参数必须分配默认值。</p>
<p>当服务由 <code>IServiceProvider</code> 或 <code>ActivatorUtilities</code> 解析时，构造函数注入需要 <strong>public</strong> 构造函数。</p>
<p>当服务由 <code>ActivatorUtilities</code> 解析时，构造函数注入要求只存在一个适用的构造函数，即<strong>支持构造函数重载，但其参数可以全部通过依赖注入来实现的重载只能存在一个</strong>。</p>
<h4 id="实体框架上下文"><a class="header-anchor" href="#实体框架上下文">¶</a>实体框架上下文</h4>
<p>通常使用设置了<strong>作用域生存期</strong>将实体框架上下文添加到服务容器中，因为 Web 应用数据库操作通常将范围设置为客户端请求。 如果在注册数据库上下文时，<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.entityframeworkservicecollectionextensions.adddbcontext" target="_blank" rel="noopener"><code>AddDbContext</code></a> 重载未指定生存期，则设置默认生存期范围。</p>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>给定生存期的服务不应使用生存期比服务短的数据库上下文。</p>
</blockquote>
<h4 id="生存期和注册选项"><a class="header-anchor" href="#生存期和注册选项">¶</a>生存期和注册选项</h4>
<p>为了演示生存期和注册选项之间的差异，请考虑以下接口，将任务表示为具有唯一标识符 <code>OperationId</code> 的操作。 根据为以下接口配置操作服务的生存期的方式，容器在类请求时提供相同或不同的服务实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public interface IOperation<br>&#123;<br>    Guid OperationId &#123; get; &#125;<br>&#125;<br><br>public interface IOperationTransient : IOperation<br>&#123;<br>&#125;<br><br>public interface IOperationScoped : IOperation<br>&#123;<br>&#125;<br><br>public interface IOperationSingleton : IOperation<br>&#123;<br>&#125;<br><br>public interface IOperationSingletonInstance : IOperation<br>&#123;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>接口在 <code>Operation</code> 类中实现。 <code>Operation</code> 构造函数将生成一个 GUID（如果未提供）：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Operation : IOperationTransient,<br>    IOperationScoped,<br>    IOperationSingleton,<br>    IOperationSingletonInstance<br>&#123;<br>    public Operation() : this(Guid.NewGuid())<br>    &#123;<br>    &#125;<br><br>    public Operation(Guid id)<br>    &#123;<br>        OperationId &#x3D; id;<br>    &#125;<br><br>    public Guid OperationId &#123; get; private set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>注册 <code>OperationService</code> 取决于，每个其他 <code>Operation</code> 类型。 当通过依赖关系注入请求 <code>OperationService</code> 时，它将接收每个服务的新实例或基于从属服务的生存期的现有实例。</p>
<ul>
<li>如果从容器请求时创建了临时服务，则 <code>IOperationTransient</code> 服务的 <code>OperationId</code> 与 <code>OperationService</code> 的 <code>OperationId</code> 不同。 <code>OperationService</code> 将接收 <code>IOperationTransient</code> 类的新实例。 新实例将生成一个不同的 <code>OperationId</code>。</li>
<li>如果按客户端请求创建有作用域的服务，则 <code>IOperationScoped</code> 服务的 <code>OperationId</code> 与客户端请求中 <code>OperationService</code> 的该 ID 相同。 在客户端请求中，两个服务共享不同的 <code>OperationId</code> 值。</li>
<li>如果单一数据库和单一实例服务只创建一次并在所有客户端请求和所有服务中使用，则 <code>OperationId</code> 在所有服务请求中保持不变。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class OperationService<br>&#123;<br>    public OperationService(<br>        IOperationTransient transientOperation,<br>        IOperationScoped scopedOperation,<br>        IOperationSingleton singletonOperation,<br>        IOperationSingletonInstance instanceOperation)<br>    &#123;<br>        TransientOperation &#x3D; transientOperation;<br>        ScopedOperation &#x3D; scopedOperation;<br>        SingletonOperation &#x3D; singletonOperation;<br>        SingletonInstanceOperation &#x3D; instanceOperation;<br>    &#125;<br><br>    public IOperationTransient TransientOperation &#123; get; &#125;<br>    public IOperationScoped ScopedOperation &#123; get; &#125;<br>    public IOperationSingleton SingletonOperation &#123; get; &#125;<br>    public IOperationSingletonInstance SingletonInstanceOperation &#123; get; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在 <code>Startup.ConfigureServices</code> 中，根据其指定的生存期，将每个类型添加到容器中：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public void ConfigureServices(IServiceCollection services)<br>&#123;<br>    services.AddRazorPages();<br><br>    services.AddScoped&lt;IMyDependency, MyDependency&gt;();<br>    services.AddTransient&lt;IOperationTransient, Operation&gt;();<br>    services.AddScoped&lt;IOperationScoped, Operation&gt;();<br>    services.AddSingleton&lt;IOperationSingleton, Operation&gt;();<br>    services.AddSingleton&lt;IOperationSingletonInstance&gt;(new Operation(Guid.Empty));<br><br>    &#x2F;&#x2F; OperationService depends on each of the other Operation types.<br>    services.AddTransient&lt;OperationService, OperationService&gt;();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>IOperationSingletonInstance</code> 服务正在使用已知 ID 为 <code>Guid.Empty</code> 的特定实例。 此类型在使用时很明显（其 GUID 全部为零）。</p>
<p>示例应用演示了各个请求中和之间的对象生存期。 示例应用的 <code>IndexModel</code> 请求每种 <code>IOperation</code> 类型和 <code>OperationService</code>。 然后，页面通过属性分配显示所有页面模型类和服务的 <code>OperationId</code> 值：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class IndexModel : PageModel<br>&#123;<br>    private readonly IMyDependency _myDependency;<br><br>    public IndexModel(<br>        IMyDependency myDependency,<br>        OperationService operationService,<br>        IOperationTransient transientOperation,<br>        IOperationScoped scopedOperation,<br>        IOperationSingleton singletonOperation,<br>        IOperationSingletonInstance singletonInstanceOperation)<br>    &#123;<br>        _myDependency &#x3D; myDependency;<br>        OperationService &#x3D; operationService;<br>        TransientOperation &#x3D; transientOperation;<br>        ScopedOperation &#x3D; scopedOperation;<br>        SingletonOperation &#x3D; singletonOperation;<br>        SingletonInstanceOperation &#x3D; singletonInstanceOperation;<br>    &#125;<br><br>    public OperationService OperationService &#123; get; &#125;<br>    public IOperationTransient TransientOperation &#123; get; &#125;<br>    public IOperationScoped ScopedOperation &#123; get; &#125;<br>    public IOperationSingleton SingletonOperation &#123; get; &#125;<br>    public IOperationSingletonInstance SingletonInstanceOperation &#123; get; &#125;<br><br>    public async Task OnGetAsync()<br>    &#123;<br>        await _myDependency.WriteMessage(<br>            &quot;IndexModel.OnGetAsync created this message.&quot;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>以下两个输出显示了两个请求的结果：</p>
<ol>
<li>
<p>第一个请求：</p>
<ul>
<li>控制器操作：
<ul>
<li>暂时性：d233e165-f417-469b-a866-1cf1935d2518</li>
<li>作用域：5d997e2d-55f5-4a64-8388-51c4e3a1ad19</li>
<li>单一实例：01271bc1-9e31-48e7-8f7c-7261b040ded9</li>
<li>实例：00000000-0000-0000-0000-000000000000</li>
</ul>
</li>
<li><code>OperationService</code> 操作：
<ul>
<li>暂时性：c6b049eb-1318-4e31-90f1-eb2dd849ff64</li>
<li>作用域：5d997e2d-55f5-4a64-8388-51c4e3a1ad19</li>
<li>单一实例：01271bc1-9e31-48e7-8f7c-7261b040ded9</li>
<li>实例：00000000-0000-0000-0000-000000000000</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第二个请示：</p>
<ul>
<li>
<p>控制器操作：</p>
<ul>
<li>暂时性：b63bd538-0a37-4ff1-90ba-081c5138dda0</li>
<li>作用域：31e820c5-4834-4d22-83fc-a60118acb9f4</li>
<li>单一实例：01271bc1-9e31-48e7-8f7c-7261b040ded9</li>
<li>实例：00000000-0000-0000-0000-000000000000</li>
</ul>
</li>
<li>
<p><code>OperationService</code> 操作：</p>
<ul>
<li>暂时性：c4cbacb8-36a2-436d-81c8-8c1b78808aaf</li>
<li>作用域：31e820c5-4834-4d22-83fc-a60118acb9f4</li>
<li>单一实例：01271bc1-9e31-48e7-8f7c-7261b040ded9</li>
<li>实例：00000000-0000-0000-0000-000000000000</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>观察哪个 <code>OperationId</code> 值会在一个请求之内和不同请求之间变化：</p>
<ul>
<li>暂时性 对象始终不同。 第一个和第二个客户端请求的暂时性 <code>OperationId</code> 值对于 <code>OperationService</code> 操作和在客户端请求内都是不同的。 为每个服务请求和客户端请求提供了一个新实例。</li>
<li>作用域 对象在一个客户端请求中是相同的，但在多个客户端请求中是不同的。</li>
<li>单一实例 对象对每个对象和每个请求都是相同的（不管 <code>Startup.ConfigureServices</code> 中是否提供 <code>Operation</code> 实例）。</li>
</ul>
<h4 id="从-main-调用服务"><a class="header-anchor" href="#从-main-调用服务">¶</a>从 main 调用服务</h4>
<p>使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.iservicescopefactory.createscope" target="_blank" rel="noopener"><code>IServiceScopeFactory.CreateScope</code></a> 创建 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.iservicescope" target="_blank" rel="noopener"><code>IServiceScope</code></a> 以解析应用范围内的已设置范围的服务。 此方法可以用于在启动时访问有作用域的服务以便运行初始化任务。 以下示例演示如何在 <code>Program.Main</code> 中获取 <code>MyScopedService</code> 的上下文：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">using System;<br>using System.Threading.Tasks;<br>using Microsoft.Extensions.DependencyInjection;<br>using Microsoft.AspNetCore.Hosting;<br>using Microsoft.Extensions.Hosting;<br><br>public class Program<br>&#123;<br>    public static async Task Main(string[] args)<br>    &#123;<br>        var host &#x3D; CreateHostBuilder(args).Build();<br><br>        using (var serviceScope &#x3D; host.Services.CreateScope())<br>        &#123;<br>            var services &#x3D; serviceScope.ServiceProvider;<br><br>            try<br>            &#123;<br>                var serviceContext &#x3D; services.GetRequiredService&lt;MyScopedService&gt;();<br>                &#x2F;&#x2F; Use the context here<br>            &#125;<br>            catch (Exception ex)<br>            &#123;<br>                var logger &#x3D; services.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();<br>                logger.LogError(ex, &quot;An error occurred.&quot;);<br>            &#125;<br>        &#125;<br><br>        await host.RunAsync();<br>    &#125;<br><br>    public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;<br>        Host.CreateDefaultBuilder(args)<br>            .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;<br>            &#123;<br>                webBuilder.UseStartup&lt;Startup&gt;();<br>            &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="作用域验证"><a class="header-anchor" href="#作用域验证">¶</a>作用域验证</h4>
<p>如果应用正在开发环境中运行，并调用 <a href="http://www.zyiz.net/tutorial/detail-4544.html#default-builder-settings" target="_blank" rel="noopener"><code>CreateDefaultBuilder</code></a> 生成主机，默认服务提供程序会执行检查，以确认以下内容：</p>
<ul>
<li>没有从根服务提供程序直接或间接解析到有作用域的服务。</li>
<li>未将有作用域的服务直接或间接注入到单一实例。</li>
</ul>
<p>调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectioncontainerbuilderextensions.buildserviceprovider" target="_blank" rel="noopener"><code>BuildServiceProvider</code></a> 时创建根服务提供程序。 在启动提供程序和应用时，根服务提供程序的生存期对应于应用/服务的生存期，并在关闭应用时释放。</p>
<p>有作用域的服务由创建它们的容器释放。 如果作用域创建于根容器，则该服务的生存会有效地提升至单一实例，因为根容器只会在应用/服务关闭时将其释放。 验证服务作用域，将在调用 <code>BuildServiceProvider</code> 时收集这类情况。</p>
<h4 id="请求服务"><a class="header-anchor" href="#请求服务">¶</a>请求服务</h4>
<p>来自 <code>HttpContext</code> 的 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 请求中可用的服务通过 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.http.httpcontext.requestservices#Microsoft_AspNetCore_Http_HttpContext_RequestServices" target="_blank" rel="noopener"><code>HttpContext.RequestServices</code></a> 集合公开。</p>
<p>请求服务表示作为应用的一部分配置和请求的服务。 当对象指定依赖关系时，<code>RequestServices</code>（而不是 <code>ApplicationServices</code>）中的类型将满足这些要求。</p>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>通常，应用不应直接使用这些属性。 相反，通过类构造函数请求类所需的类型，并允许框架注入依赖关系。 这样生成的类更易于测试。</p>
</blockquote>
<blockquote>
<p>与访问 <code>RequestServices</code> 集合相比，以构造函数参数的形式请求依赖项是更优先的选择。</p>
</blockquote>
<h4 id="设计能够进行依赖关系注入的服务"><a class="header-anchor" href="#设计能够进行依赖关系注入的服务">¶</a>设计能够进行依赖关系注入的服务</h4>
<p>最佳做法是：</p>
<ul>
<li>设计服务以使用依赖关系注入来获取其依赖关系。</li>
<li>避免有状态的、静态类和成员。 将应用设计为改用单一实例服务，可避免创建全局状态。</li>
<li>避免在服务中直接实例化依赖类。 直接实例化将代码耦合到特定实现。</li>
<li>不在应用类中包含过多内容，确保设计规范，并易于测试。</li>
</ul>
<p>如果一个类似乎有过多的注入依赖关系，这通常表明该类拥有过多的责任并且违反了<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#single-responsibility" target="_blank" rel="noopener">单一责任原则 (SRP)</a>。 尝试通过将某些职责移动到一个新类来重构类。 请记住，Razor Pages 页模型类和 MVC 控制器类应关注用户界面问题。 业务规则和数据访问实现细节应保留在适用于这些<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#separation-of-concerns" target="_blank" rel="noopener">分离的关注点</a>的类中。</p>
<h4 id="服务处理"><a class="header-anchor" href="#服务处理">¶</a>服务处理</h4>
<p>容器为其创建的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.idisposable" target="_blank" rel="noopener"><code>IDisposable</code></a> 类型调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.idisposable.dispose" target="_blank" rel="noopener"><code>Dispose</code></a>。 如果通过<strong>用户代码直接</strong>将实例添加到容器中，则不会自动处理该实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">&#x2F;&#x2F; Services that implement IDisposable:<br>public class Service1 : IDisposable &#123;&#125;<br>public class Service2 : IDisposable &#123;&#125;<br>public class Service3 : IDisposable &#123;&#125;<br><br>public interface ISomeService &#123;&#125;<br>public class SomeServiceImplementation : ISomeService, IDisposable &#123;&#125;<br><br>public void ConfigureServices(IServiceCollection services)<br>&#123;<br>    &#x2F;&#x2F; The container creates the following instances and disposes them automatically:<br>    services.AddScoped&lt;Service1&gt;();<br>    services.AddSingleton&lt;Service2&gt;();<br>    services.AddSingleton&lt;ISomeService&gt;(sp &#x3D;&gt; new SomeServiceImplementation());<br><br>    &#x2F;&#x2F; The container doesn&#39;t create the following instances, so it doesn&#39;t dispose of<br>    &#x2F;&#x2F; the instances automatically:<br>    services.AddSingleton&lt;Service3&gt;(new Service3());<br>    services.AddSingleton(new Service3());<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="默认服务容器替换"><a class="header-anchor" href="#默认服务容器替换">¶</a>默认服务容器替换</h4>
<p>内置的服务容器旨在满足框架和大多数消费者应用的需求。 我们建议使用内置容器，除非你需要的特定功能不受内置容器支持，例如：</p>
<ul>
<li>属性注入</li>
<li>基于名称的注入</li>
<li>子容器</li>
<li>自定义生存期管理</li>
<li>对迟缓初始化的 <code>Func&lt;T&gt;</code> 支持</li>
<li>基于约定的注册</li>
</ul>
<p>以下第三方容器可用于 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 应用：</p>
<ul>
<li><a href="https://autofac.readthedocs.io/en/latest/integration/aspnetcore.html" target="_blank" rel="noopener">Autofac</a></li>
<li><a href="https://www.nuget.org/packages/DryIoc.Microsoft.DependencyInjection" target="_blank" rel="noopener">DryIoc</a></li>
<li><a href="https://www.nuget.org/packages/Grace.DependencyInjection.Extensions" target="_blank" rel="noopener">Grace</a></li>
<li><a href="https://github.com/seesharper/LightInject.Microsoft.DependencyInjection" target="_blank" rel="noopener">LightInject</a></li>
<li><a href="https://jasperfx.github.io/lamar/" target="_blank" rel="noopener">Lamar</a></li>
<li><a href="https://github.com/z4kn4fein/stashbox-extensions-dependencyinjection" target="_blank" rel="noopener">Stashbox</a></li>
<li><a href="https://www.nuget.org/packages/Unity.Microsoft.DependencyInjection" target="_blank" rel="noopener">Unity</a></li>
</ul>
<h4 id="线程安全性"><a class="header-anchor" href="#线程安全性">¶</a>线程安全性</h4>
<p>创建线程安全的单一实例服务。 如果单例服务依赖于一个瞬时服务，那么瞬时服务可能也需要线程安全，具体取决于单例使用它的方式。</p>
<p>单个服务的工厂方法（例如 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectionserviceextensions.addsingleton" target="_blank" rel="noopener"><code>AddSingleton(IServiceCollection, Func)</code></a> 的第二个参数）不必是线程安全的。 像类型 (<code>static</code>) 构造函数一样，它保证由单个线程调用一次。</p>
<h4 id="建议"><a class="header-anchor" href="#建议">¶</a>建议</h4>
<ul>
<li>
<p>不支持基于 <code>async/await</code> 和 <code>Task</code> 的服务解析。 C# 不支持异步构造函数；因此建议模式是在同步解析服务后使用异步方法。</p>
</li>
<li>
<p>避免在服务容器中直接存储数据和配置。 例如，用户的购物车通常不应添加到服务容器中。 配置应使用选项模型。 同样，避免&quot;数据持有者&quot;对象，也就是仅仅为实现对某些其他对象的访问而存在的对象。 最好通过 DI 请求实际项目。</p>
</li>
<li>
<p>避免静态访问服务（例如，静态键入 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder.applicationservices#Microsoft_AspNetCore_Builder_IApplicationBuilder_ApplicationServices" target="_blank" rel="noopener"><code>IApplicationBuilder.ApplicationServices</code></a> 以便在其他地方使用）。</p>
</li>
<li>
<p>避免使用服务定位器模式 。 例如，可以改用 DI 时，不要调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.iserviceprovider.getservice" target="_blank" rel="noopener"><code>GetService</code></a> 来获取服务实例：</p>
<p>不正确：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">  public class MyClass()<br>&#123;<br>    public void MyMethod()<br>    &#123;<br>        var optionsMonitor &#x3D;<br>            _services.GetService&lt;IOptionsMonitor&lt;MyOptions&gt;&gt;();<br>        var option &#x3D; optionsMonitor.CurrentValue.Option;<br><br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>更正：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class MyClass<br>&#123;<br>    private readonly IOptionsMonitor&lt;MyOptions&gt; _optionsMonitor;<br><br>    public MyClass(IOptionsMonitor&lt;MyOptions&gt; optionsMonitor)<br>    &#123;<br>        _optionsMonitor &#x3D; optionsMonitor;<br>    &#125;<br><br>    public void MyMethod()<br>    &#123;<br>        var option &#x3D; _optionsMonitor.CurrentValue.Option;<br><br>        ...<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>要避免的另一个服务定位器变体是注入可在运行时解析依赖项的工厂。 这两种做法混合了<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#dependency-inversion" target="_blank" rel="noopener">控制反转</a>策略。</p>
</li>
<li>
<p>避免静态访问 <code>HttpContext</code>（例如，<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.http.ihttpcontextaccessor.httpcontext#Microsoft_AspNetCore_Http_IHttpContextAccessor_HttpContext" target="_blank" rel="noopener"><code>IHttpContextAccessor.HttpContext</code></a>）。</p>
</li>
</ul>
<blockquote>
<p>像任何一组建议一样，你可能会遇到需要忽略某建议的情况。 例外情况很少见 — 主要是框架本身内部的特殊情况。</p>
<p>DI 是静态/全局对象访问模式的替代方法 。 如果将其与静态对象访问混合使用，则可能无法实现 DI 的优点。</p>
</blockquote>
<h3 id="四、Startup-类"><a class="header-anchor" href="#四、Startup-类">¶</a>四、<code>Startup</code> 类</h3>
<p><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 应用使用 <code>Startup</code> 类，按照约定命名为 <code>Startup</code>。 <code>Startup</code> 类：</p>
<ul>
<li><strong>可选择性地</strong>包括  <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.startupbase.configureservices" target="_blank" rel="noopener"><code>ConfigureServices</code></a> 方法以配置应用的服务<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> 。在 <code>ConfigureServices</code> 中注册服务，并通过依赖关系注入 （DI）或 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder.applicationservices" target="_blank" rel="noopener"><code>ApplicationServices</code></a> 在整个应用中使用服务 。</li>
<li>包括  <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.startupbase.configure" target="_blank" rel="noopener"><code>Configure</code></a> 方法以创建应用的请求处理管道。</li>
</ul>
<blockquote></blockquote>
<p>在应用启动时，<a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 运行时会调用 <code>ConfigureServices</code> 和 <code>Configure</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Startup<br>&#123;<br>    public Startup(IConfiguration configuration)<br>    &#123;<br>        Configuration &#x3D; configuration;<br>    &#125;<br><br>    public IConfiguration Configuration &#123; get; &#125;<br><br>    public void ConfigureServices(IServiceCollection services)<br>    &#123;<br>        services.AddRazorPages();<br>    &#125;<br><br>    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)<br>    &#123;<br>        if (env.IsDevelopment())<br>        &#123;<br>            app.UseDeveloperExceptionPage();<br>        &#125;<br>        else<br>        &#123;<br>            app.UseExceptionHandler(&quot;&#x2F;Error&quot;);<br>            app.UseHsts();<br>        &#125;<br><br>        app.UseHttpsRedirection();<br>        app.UseStaticFiles();<br><br>        app.UseRouting();<br><br>        app.UseAuthorization();<br><br>        app.UseEndpoints(endpoints &#x3D;&gt;<br>        &#123;<br>            endpoints.MapRazorPages();<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>前面的示例适用于 Razor Pages，MVC 版本类似。</p>
</blockquote>
<p>在构建应用<a href="http://www.zyiz.net/tutorial/detail-4541.html#host" target="_blank" rel="noopener">主机</a>时指定 <code>Startup</code> 类。 通常通过在主机生成器上调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilderextensions.usestartup" target="_blank" rel="noopener"><code>WebHostBuilderExtensions.UseStartup</code></a> 方法来指定 <code>Startup</code> 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Program<br>&#123;<br>    public static void Main(string[] args)<br>    &#123;<br>        CreateHostBuilder(args).Build().Run();<br>    &#125;<br><br>    public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;<br>        Host.CreateDefaultBuilder(args)<br>        .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;<br>        &#123;<br>            webBuilder.UseStartup&lt;Startup&gt;();<br>        &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>主机提供 <code>Startup</code> 类构造函数可用的<strong>某些</strong>服务；应用通过 <code>ConfigureServices</code> 添加<strong>其他</strong>服务。<strong>服务都可以在 <code>Configure</code> 和整个应用中使用</strong>。</p>
<p>使用泛型主机（<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.ihostbuilder" target="_blank" rel="noopener"><code>IHostBuilder</code></a>）时，只能将以下服务类型注入 <code>Startup</code> 构造函数：</p>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.iwebhostenvironment" target="_blank" rel="noopener"><code>IWebHostEnvironment</code></a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.ihostenvironment" target="_blank" rel="noopener"><code>IHostEnvironment</code></a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.iconfiguration" target="_blank" rel="noopener"><code>IConfiguration</code></a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class Startup<br>&#123;<br>    private readonly IWebHostEnvironment _env;<br><br>    public Startup(IConfiguration configuration, IWebHostEnvironment env)<br>    &#123;<br>        Configuration &#x3D; configuration;<br>        _env &#x3D; env;<br>    &#125;<br><br>    public IConfiguration Configuration &#123; get; &#125;<br><br>    public void ConfigureServices(IServiceCollection services)<br>    &#123;<br>        if (_env.IsDevelopment())<br>        &#123;<br>        &#125;<br>        else<br>        &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>在调用 <code>Configure</code> 方法之前，大多数服务都不可用。</p>
</blockquote>
<h4 id="多个-Startup-类"><a class="header-anchor" href="#多个-Startup-类">¶</a>多个 <code>Startup</code> 类</h4>
<p>应用为不同的环境（例如，<code>StartupDevelopment</code>）单独定义 <code>Startup</code> 类时，相应的 <code>Startup</code> 类会在运行时被选中。 优先考虑名称后缀与当前环境相匹配的类。 如果应用在开发环境中运行并包含 <code>Startup</code> 类和 <code>StartupDevelopment</code> 类，则使用 <code>StartupDevelopment</code> 类。</p>
<h4 id="ConfigureServices-方法"><a class="header-anchor" href="#ConfigureServices-方法">¶</a><code>ConfigureServices</code> 方法</h4>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.startupbase.configureservices" target="_blank" rel="noopener"><code>ConfigureServices</code></a> 方法：</p>
<ul>
<li>可选。</li>
<li>在 <code>Configure</code> 方法配置应用服务之前，由主机调用。</li>
<li>其中按常规设置配置选项。</li>
</ul>
<p>主机可能会在调用 <code>Startup</code> 方法之前配置某些服务。</p>
<p>对于需要大量设置的功能，<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.iservicecollection" target="_blank" rel="noopener"><code>IServiceCollection</code></a> 上有 <code>Add{Service}</code> 扩展方法。 例如，<code>AddDbContext</code>、<code>AddDefaultIdentity</code>、<code>AddEntityFrameworkStores</code> 和 <code>AddRazorPages</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Startup<br>&#123;<br>    public Startup(IConfiguration configuration)<br>    &#123;<br>        Configuration &#x3D; configuration;<br>    &#125;<br><br>    public IConfiguration Configuration &#123; get; &#125;<br><br>    public void ConfigureServices(IServiceCollection services)<br>    &#123;<br><br>        services.AddDbContext&lt;ApplicationDbContext&gt;(options &#x3D;&gt;<br>            options.UseSqlServer(<br>                Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));<br>        services.AddDefaultIdentity&lt;IdentityUser&gt;(<br>            options &#x3D;&gt; options.SignIn.RequireConfirmedAccount &#x3D; true)<br>            .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();<br><br>        services.AddRazorPages();<br>    &#125;<br></code></pre></div></td></tr></table></figure>
<p>将服务添加到服务容器，使其在应用和 <code>Configure</code> 方法中可用。 服务通过依赖关系注入或 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder.applicationservices" target="_blank" rel="noopener"><code>ApplicationServices</code></a> 进行解析。</p>
<h4 id="Configure-方法"><a class="header-anchor" href="#Configure-方法">¶</a><code>Configure</code> 方法</h4>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.startupbase.configure" target="_blank" rel="noopener"><code>Configure</code></a> 方法用于指定应用响应 HTTP 请求的方式。 可通过将中间件组件添加到 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder" target="_blank" rel="noopener"><code>IApplicationBuilder</code></a> 实例来配置请求管道。 <code>Configure</code> 方法可使用 <code>IApplicationBuilder</code>，而无需在服务容器中注册。 托管创建 <code>IApplicationBuilder</code> 并将其直接传递到 <code>Configure</code>。</p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/core/tools/dotnet-new" target="_blank" rel="noopener">ASP.NET Core 模板</a>配置的管道支持：</p>
<ul>
<li>开发人员异常页</li>
<li>异常处理程序</li>
<li>HTTP 严格传输安全性 (HSTS)</li>
<li>HTTPS 重定向</li>
<li>静态文件</li>
<li><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core MVC 和 Razor Pages</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Startup<br>&#123;<br>    public Startup(IConfiguration configuration)<br>    &#123;<br>        Configuration &#x3D; configuration;<br>    &#125;<br><br>    public IConfiguration Configuration &#123; get; &#125;<br><br>    public void ConfigureServices(IServiceCollection services)<br>    &#123;<br>        services.AddRazorPages();<br>    &#125;<br><br>    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)<br>    &#123;<br>        if (env.IsDevelopment())<br>        &#123;<br>            app.UseDeveloperExceptionPage();<br>        &#125;<br>        else<br>        &#123;<br>            app.UseExceptionHandler(&quot;&#x2F;Error&quot;);<br>            app.UseHsts();<br>        &#125;<br><br>        app.UseHttpsRedirection();<br>        app.UseStaticFiles();<br><br>        app.UseRouting();<br><br>        app.UseAuthorization();<br><br>        app.UseEndpoints(endpoints &#x3D;&gt;<br>        &#123;<br>            endpoints.MapRazorPages();<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>前面的示例适用于 Razor Pages；MVC 版本类似。</p>
</blockquote>
<p>每个 <code>Use</code> 扩展方法将一个或多个中间件组件添加到请求管道。 例如，<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.staticfileextensions.usestaticfiles" target="_blank" rel="noopener"><code>UseStaticFiles</code></a> 配置中间件提供静态文件。</p>
<p>请求管道中的每个中间件组件负责调用管道中的下一个组件，或在适当情况下使链发生短路。</p>
<p>可以在 <code>Configure</code> 方法签名中指定其他服务，如 <code>IWebHostEnvironment</code>、<code>ILoggerFactory</code> 或 <code>ConfigureServices</code> 中定义的任何内容。 如果这些服务可用，则会被注入。</p>
<h4 id="在不使用-Startup-类的情况下配置服务"><a class="header-anchor" href="#在不使用-Startup-类的情况下配置服务">¶</a>在不使用 <code>Startup</code> 类的情况下配置服务</h4>
<p>若要配置服务和请求处理管道，而不使用 <code>Startup</code> 类，请在主机生成器上调用 <code>ConfigureServices</code> 和 <code>Configure</code> 便捷方法。 多次调用 <code>ConfigureServices</code> 将追加到另一个。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>如果存在多个 <code>Configure</code> 方法调用，则使用最后一个 <code>Configure</code> 调用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Program<br>&#123;<br>    public static void Main(string[] args)<br>    &#123;<br>        CreateHostBuilder(args).Build().Run();<br>    &#125;<br><br>    public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;<br>        Host.CreateDefaultBuilder(args)<br>            .ConfigureAppConfiguration((hostingContext, config) &#x3D;&gt;<br>            &#123;<br>            &#125;)<br>            .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;<br>            &#123;<br>                webBuilder.ConfigureServices(services &#x3D;&gt;<br>                &#123;<br>                    services.AddControllersWithViews();<br>                &#125;)<br>                .Configure(app &#x3D;&gt;<br>                &#123;<br>                    var loggerFactory &#x3D; app.ApplicationServices<br>                        .GetRequiredService&lt;ILoggerFactory&gt;();<br>                    var logger &#x3D; loggerFactory.CreateLogger&lt;Program&gt;();<br>                    var env &#x3D; app.ApplicationServices.GetRequiredService&lt;IWebHostEnvironment&gt;();<br>                    var config &#x3D; app.ApplicationServices.GetRequiredService&lt;IConfiguration&gt;();<br><br>                    logger.LogInformation(&quot;Logged in Configure&quot;);<br><br>                    if (env.IsDevelopment())<br>                    &#123;<br>                        app.UseDeveloperExceptionPage();<br>                    &#125;<br>                    else<br>                    &#123;<br>                        app.UseExceptionHandler(&quot;&#x2F;Home&#x2F;Error&quot;);<br>                        app.UseHsts();<br>                    &#125;<br><br>                    var configValue &#x3D; config[&quot;MyConfigKey&quot;];<br>                &#125;);<br>            &#125;);<br>        &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="使用-Startup-筛选器扩展-Startup"><a class="header-anchor" href="#使用-Startup-筛选器扩展-Startup">¶</a>使用 <code>Startup</code> 筛选器扩展 <code>Startup</code></h4>
<p>使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.istartupfilter" target="_blank" rel="noopener"><code>IStartupFilter</code></a>：</p>
<ul>
<li>在应用的 <code>Configure</code> 中间件管道的开头或末尾配置中间件，而无需显式调用 <code>Use{Middleware}</code>。 <code>IStartupFilter</code> 由 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 用于将默认值添加到管道的开头，而无需使应用作者显式注册默认中间件。 <code>IStartupFilter</code> 允许代表应用作者使用不同的组件调用 <code>Use{Middleware}</code>。</li>
<li>创建 <code>Configure</code> 方法的管道。 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.istartupfilter.configure" target="_blank" rel="noopener"><code>IStartupFilter.Configure</code></a> 可以将中间件设置为在库添加的中间件之前或之后运行。</li>
</ul>
<p><code>IStartupFilter</code> 实现了抽象方法 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.startupbase.configure" target="_blank" rel="noopener"><code>Configure</code></a>，即接收并返回 <code>Action&lt;IApplicationBuilder&gt;</code>。 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder" target="_blank" rel="noopener"><code>IApplicationBuilder</code></a> 定义用于配置应用请求管道的类。</p>
<p>每个 <code>IStartupFilter</code> 可以在请求管道中添加一个或多个中间件。 筛选器按照添加到服务容器的顺序调用。 筛选器可在将控件传递给下一个筛选器之前或之后添加中间件，从而附加到应用管道的开头或末尾。</p>
<p>下面的示例演示如何使用 <code>IStartupFilter</code> 注册中间件。 <code>RequestSetOptionsMiddleware</code> 中间件从查询字符串参数中设置选项值：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class RequestSetOptionsMiddleware<br>&#123;<br>    private readonly RequestDelegate _next;<br><br>    public RequestSetOptionsMiddleware( RequestDelegate next )<br>    &#123;<br>        _next &#x3D; next;<br>    &#125;<br><br>    &#x2F;&#x2F; Test with https:&#x2F;&#x2F;localhost:5001&#x2F;Privacy&#x2F;?option&#x3D;Hello<br>    public async Task Invoke(HttpContext httpContext)<br>    &#123;<br>        var option &#x3D; httpContext.Request.Query[&quot;option&quot;];<br><br>        if (!string.IsNullOrWhiteSpace(option))<br>        &#123;<br>            httpContext.Items[&quot;option&quot;] &#x3D; WebUtility.HtmlEncode(option);<br>        &#125;<br><br>        await _next(httpContext);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在 <code>RequestSetOptionsStartupFilter</code> 类中配置 <code>RequestSetOptionsMiddleware</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class RequestSetOptionsStartupFilter : IStartupFilter<br>&#123;<br>    public Action&lt;IApplicationBuilder&gt; Configure(Action&lt;IApplicationBuilder&gt; next)<br>    &#123;<br>        return builder &#x3D;&gt;<br>        &#123;<br>            builder.UseMiddleware&lt;RequestSetOptionsMiddleware&gt;();<br>            next(builder);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.startupbase.configureservices" target="_blank" rel="noopener"><code>ConfigureServices</code></a> 中的服务容器中注册 <code>IStartupFilter</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Program<br>&#123;<br>    public static void Main(string[] args)<br>    &#123;<br>        CreateHostBuilder(args).Build().Run();<br>    &#125;<br><br>    public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;<br>        Host.CreateDefaultBuilder(args)<br>           .ConfigureAppConfiguration((hostingContext, config) &#x3D;&gt;<br>           &#123;<br>           &#125;)<br>         .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;<br>         &#123;<br>             webBuilder.UseStartup&lt;Startup&gt;();<br>         &#125;)<br>        .ConfigureServices(services &#x3D;&gt;<br>        &#123;<br>            services.AddTransient&lt;IStartupFilter,<br>                      RequestSetOptionsStartupFilter&gt;();<br>        &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>当提供 <code>option</code> 的查询字符串参数时，中间件在 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 中间件呈现响应之前处理分配值。</p>
<p>中间件执行顺序由 <code>IStartupFilter</code> 注册顺序设置：</p>
<ul>
<li>多个 <code>IStartupFilter</code> 实现可能与相同的对象进行交互。 如果顺序很重要，请将它们的 <code>IStartupFilter</code> 服务注册进行排序，以匹配其中间件应有的运行顺序。</li>
<li>库可能添加包含一个或多个 <code>IStartupFilter</code> 实现的中间件，这些实现在向 <code>IStartupFilter</code> 注册的其他应用中间件之前或之后运行。 若要在库的 <code>IStartupFilter</code> 添加的中间件之前调用 <code>IStartupFilter</code> 中间件，请执行以下操作：
<ul>
<li>在库添加到服务容器之前定位服务注册。</li>
<li>要在此后调用，请在添加库之后定位服务注册。</li>
</ul>
</li>
</ul>
<h4 id="在启动时从外部程序集添加配置"><a class="header-anchor" href="#在启动时从外部程序集添加配置">¶</a>在启动时从外部程序集添加配置</h4>
<p>通过 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.hosting.ihostingstartup" target="_blank" rel="noopener"><code>IHostingStartup</code></a> 实现，可在启动时从应用 <code>Startup</code> 类之外的外部程序集向应用添加增强功能。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><code>IHostedService</code> 服务是一种后台运行的，单例（Singleton）的服务。参考<a href="#IHostedServiceExample">“设置主机”小节示例</a>，其中 Worker 类为 Worker 工程主类，它继承自 <code>BackgroundService</code>，<code>BackgroundService</code> 实现了 <code>IHostedService</code>。<code>IHostedService</code> 接口包含两个关键方法：<code>public Task StartAsync(CancellationToken cancellationToke)</code> 和 <code>public Task StopAsync(CancellationToken cancellationToken)</code>。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><code>StopApplication</code> 方法是 <a href="#IHostApplicationLifetime_1_1"><code>IHostApplictionLifetime</code></a> 接口唯一方法。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>此处可能翻译有误，猜测原文为“key”，本句应翻译为“例如，<code>ASPNETCORE_ENVIRONMENT</code> 的环境变量值就变成键为 <code>environment</code> 的主机配置值。”。 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>服务是一个提供应用功能的可重用组件。 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>.NETCore</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NET Core 3.1 学习笔记（二）</title>
    <url>/2021/04/10/ASP.NET-Core-3.1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 3.1 学习笔记（二）</h1>
<p><a href="http://www.zyiz.net/tutorial/xilie-293.html" target="_blank" rel="noopener">教程</a></p>
<hr>
<p>[TOC]</p>
<hr>
<h3 id="五、ASP-NET-Core-中间件"><a class="header-anchor" href="#五、ASP-NET-Core-中间件">¶</a>五、<a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 中间件</h3>
<p>中间件是一种装配到应用管道以处理请求和响应的软件。 每个组件：</p>
<ul>
<li>选择是否将请求传递到管道中的下一个组件。</li>
<li>可在管道中的下一个组件前后执行工作。</li>
<li>请求委托用于生成请求管道。 请求委托处理每个 HTTP 请求。</li>
</ul>
<p>使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mapextensions.map" target="_blank" rel="noopener"><code>RunMap</code></a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.useextensions.use" target="_blank" rel="noopener"><code>Use</code></a> 扩展方法来配置请求委托。 可将一个单独的请求委托并行指定为匿名方法（称为并行中间件），或在可重用的类中对其进行定义。 这些可重用的类和并行匿名方法即为中间件 ，也叫中间件组件 。 请求管道中的每个中间件组件负责调用管道中的下一个组件，或使管道短路。 当中间件短路时，它被称为“终端中间件” ，因为它阻止中间件进一步处理请求。</p>
<p>将 HTTP 处理程序和模块迁移到 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 中间件介绍了 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 和 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> 4.x 中请求管道之间的差异，并提供了更多的中间件示例。</p>
<h4 id="使用-IApplicationBuilder-创建中间件管道"><a class="header-anchor" href="#使用-IApplicationBuilder-创建中间件管道">¶</a>使用 <code>IApplicationBuilder</code> 创建中间件管道</h4>
<p><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 请求管道包含一系列请求委托，依次调用。 下图演示了这一概念。 沿黑色箭头执行。</p>
<p><img src="https://blog-1255671825.cos.ap-beijing-fsi.myqcloud.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/netcore/5.1.png" alt="5.1"></p>
<p>每个委托均可在下一个委托前后执行操作。 应尽早在管道中调用异常处理委托，这样它们就能捕获在管道的后期阶段发生的异常。</p>
<p>尽可能简单的 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 应用设置了处理所有请求的单个请求委托。 这种情况不包括实际请求管道。 调用单个匿名函数以响应每个 HTTP 请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Startup<br>&#123;<br>    public void Configure(IApplicationBuilder app)<br>    &#123;<br>        app.Run(async context &#x3D;&gt;<br>        &#123;<br>            await context.Response.WriteAsync(&quot;Hello, World!&quot;);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.useextensions.use" target="_blank" rel="noopener"><code>Use</code></a> 将多个请求委托链接在一起。 <code>next</code> 参数表示管道中的下一个委托。 可通过不 调用 <code>next</code> 参数使管道短路。 通常可在下一个委托前后执行操作，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Startup<br>&#123;<br>    public void Configure(IApplicationBuilder app)<br>    &#123;<br>        app.Use(async (context, next) &#x3D;&gt;<br>        &#123;<br>            &#x2F;&#x2F; Do work that doesn&#39;t write to the Response.<br>            await next.Invoke();<br>            &#x2F;&#x2F; Do logging or other work that doesn&#39;t write to the Response.<br>        &#125;);<br><br>        app.Run(async context &#x3D;&gt;<br>        &#123;<br>            await context.Response.WriteAsync(&quot;Hello from 2nd delegate.&quot;);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>当委托不将请求传递给下一个委托时，它被称为“让请求管道短路”。通常需要短路，因为这样可以避免不必要的工作。 例如，静态文件中间件可以处理对静态文件的请求，并让管道的其余部分短路，从而起到终端中间件 的作用。 如果中间件添加到管道中，且位于终止进一步处理的中间件前，它们仍处理 <code>next.Invoke</code> 语句后面的代码。 不过，请参阅下面有关尝试对已发送的响应执行写入操作的警告。</p>
<blockquote>
<h2 id="注意："><a class="header-anchor" href="#注意：">¶</a><strong>注意</strong>：</h2>
<p>在向客户端发送响应后，请勿调用 <code>next.Invoke</code>。 响应启动后，针对 <code>HttpResponse</code> 的更改将引发异常。 例如，设置标头和状态代码更改将引发异常。 调用 <code>next</code> 后写入响应正文：</p>
<ul>
<li>可能导致违反协议。 例如，写入的长度超过规定的 <code>Content-Length</code>。</li>
<li>可能损坏正文格式。 例如，向 CSS 文件中写入 HTML 页脚。</li>
<li><code>HasStarted</code> 是一个有用的提示，指示是否已发送标头或已写入正文。</li>
</ul>
</blockquote>
<p><strong><code>Run</code> 委托不会收到 <code>next</code> 参数。 第一个 <code>Run</code> 委托始终为终端，用于终止管道。</strong><code>Run</code> 是一种约定。 某些中间件组件可能会公开在管道末尾运行的 <code>Run[Middleware]</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Startup<br>&#123;<br>    public void Configure(IApplicationBuilder app)<br>    &#123;<br>        app.Use(async (context, next) &#x3D;&gt;<br>        &#123;<br>            &#x2F;&#x2F; Do work that doesn&#39;t write to the Response.<br>            await next.Invoke();<br>            &#x2F;&#x2F; Do logging or other work that doesn&#39;t write to the Response.<br>        &#125;);<br><br>        app.Run(async context &#x3D;&gt;<br>        &#123;<br>            await context.Response.WriteAsync(&quot;Hello from 2nd delegate.&quot;);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在前面的示例中，<code>Run</code> 委托将 <code>&quot;Hello from 2nd delegate.&quot;</code> 写入响应，然后终止管道。 如果在 <code>Run</code> 委托之后添加了另一个 <code>Use</code> 或 <code>Run</code> 委托，则不会调用该委托。</p>
<h4 id="中间件顺序"><a class="header-anchor" href="#中间件顺序">¶</a>中间件顺序</h4>
<p>向 <code>Startup.Configure</code> 方法添加中间件组件的顺序定义了针对请求调用这些组件的顺序，以及响应的相反顺序。 <strong>此顺序对于安全性、性能和功能至关重要。</strong><br>
下面的 <code>Startup.Configure</code> 方法按照建议的顺序增加与安全相关的中间件组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)<br>&#123;<br>    if (env.IsDevelopment())<br>    &#123;<br>        app.UseDeveloperExceptionPage();<br>        app.UseDatabaseErrorPage();<br>    &#125;<br>    else<br>    &#123;<br>        app.UseExceptionHandler(&quot;&#x2F;Error&quot;);<br>        app.UseHsts();<br>    &#125;<br><br>    app.UseHttpsRedirection();<br>    app.UseStaticFiles();<br>    &#x2F;&#x2F; app.UseCookiePolicy();<br><br>    app.UseRouting();<br>    &#x2F;&#x2F; app.UseRequestLocalization();<br>    &#x2F;&#x2F; app.UseCors();<br><br>    app.UseAuthentication();<br>    app.UseAuthorization();<br>    &#x2F;&#x2F; app.UseSession();<br><br>    app.UseEndpoints(endpoints &#x3D;&gt;<br>    &#123;<br>        endpoints.MapRazorPages();<br>        endpoints.MapControllerRoute(<br>            name: &quot;default&quot;,<br>            pattern: &quot;&#123;controller&#x3D;Home&#125;&#x2F;&#123;action&#x3D;Index&#125;&#x2F;&#123;id?&#125;&quot;);<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上述代码中：</p>
<ul>
<li>在使用单个用户帐户创建新的 Web 应用时未添加的中间件已被注释掉。</li>
<li>并非所有中间件都需要准确按照此顺序运行，但许多中间件必须遵循这个顺序。例如，<code>UseCors</code>、<code>UseAuthentication</code> 和 <code>UseAuthorization</code> 必须按照上述顺序运行。</li>
</ul>
<p>以下 <code>Startup.Configure</code> 方法将为常见应用方案添加中间件组件：</p>
<ol>
<li>异常/错误处理
<ol>
<li>当应用在开发环境中运行时：
<ul>
<li>开发人员异常页中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.developerexceptionpageextensions.usedeveloperexceptionpage" target="_blank" rel="noopener"><code>UseDeveloperExceptionPage</code></a>) 报告应用运行时错误。</li>
<li>数据库错误页中间件报告数据库运行时错误。</li>
</ul>
</li>
<li>当应用在生产环境中运行时：
<ul>
<li>异常处理程序中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.exceptionhandlerextensions.useexceptionhandler" target="_blank" rel="noopener"><code>UseExceptionHandler</code></a>) 捕获以下中间件中引发的异常。</li>
<li>HTTP 严格传输安全协议 (HSTS) 中间件 (UseHsts) 添加 Strict-Transport-Security 标头。</li>
</ul>
</li>
</ol>
</li>
<li>HTTPS 重定向中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.httpspolicybuilderextensions.usehttpsredirection" target="_blank" rel="noopener"><code>UseHttpsRedirection</code></a>) 将 HTTP 请求重定向到 HTTPS。</li>
<li>静态文件中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.staticfileextensions.usestaticfiles" target="_blank" rel="noopener"><code>UseStaticFiles</code></a>) 返回静态文件，并简化进一步请求处理。</li>
<li>Cookie 策略中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.cookiepolicyappbuilderextensions.usecookiepolicy" target="_blank" rel="noopener"><code>UseCookiePolicy</code></a>) 使应用符合欧盟一般数据保护条例 (GDPR) 规定。</li>
<li>用于路由请求的路由中间件 (<code>UseRouting</code>)。</li>
<li>身份验证中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.authappbuilderextensions.useauthentication" target="_blank" rel="noopener"><code>UseAuthentication</code></a>) 尝试对用户进行身份验证，然后才会允许用户访问安全资源。</li>
<li>用于授权用户访问安全资源的授权中间件 (<code>UseAuthorization</code>)。</li>
<li>会话中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.sessionmiddlewareextensions.usesession" target="_blank" rel="noopener"><code>UseSession</code></a>) 建立和维护会话状态。 如果应用使用会话状态，请在 Cookie 策略中间件之后和 MVC 中间件之前调用会话中间件。</li>
<li>用于将 Razor Pages 终结点添加到请求管道的终结点路由中间件（带有 <code>MapRazorPages</code> 的 <code>UseEndpoints</code>）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)<br>&#123;<br>    if (env.IsDevelopment())<br>    &#123;<br>        app.UseDeveloperExceptionPage();<br>        app.UseDatabaseErrorPage();<br>    &#125;<br>    else<br>    &#123;<br>        app.UseExceptionHandler(&quot;&#x2F;Error&quot;);<br>        app.UseHsts();<br>    &#125;<br><br>    app.UseHttpsRedirection();<br>    app.UseStaticFiles();<br>    app.UseCookiePolicy();<br>    app.UseRouting();<br>    app.UseAuthentication();<br>    app.UseAuthorization();<br>    app.UseSession();<br><br>    app.UseEndpoints(endpoints &#x3D;&gt;<br>    &#123;<br>        endpoints.MapRazorPages();<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在前面的示例代码中，每个中间件扩展方法都通过 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder" target="_blank" rel="noopener"><code>Microsoft.AspNetCore.Builder</code></a> 命名空间在 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder" target="_blank" rel="noopener"><code>IApplicationBuilder</code></a> 上公开。<br>
<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.exceptionhandlerextensions.useexceptionhandler" target="_blank" rel="noopener"><code>UseExceptionHandler</code></a> 是添加到管道的第一个中间件组件。 因此，异常处理程序中间件可捕获稍后调用中发生的任何异常。<br>
尽早在管道中调用静态文件中间件，以便它可以处理请求并使其短路，而无需通过剩余组件。 静态文件中间件不 提供授权检查。 可公开访问由静态文件中间件服务的任何文件，包括 <em>wwwroot</em> 下的文件。<br>
如果静态文件中间件未处理请求，则请求将被传递给执行身份验证的身份验证中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.authappbuilderextensions.useauthentication" target="_blank" rel="noopener"><code>UseAuthentication</code></a>)。 身份验证不使未经身份验证的请求短路。 虽然身份验证中间件对请求进行身份验证，但仅在 MVC 选择特定 Razor 页或 MVC 控制器和操作后，才发生授权（和拒绝）。<br>
以下示例演示中间件排序，其中静态文件的请求在响应压缩中间件前由静态文件中间件进行处理。 使用此中间件顺序不压缩静态文件。 可以压缩 Razor Pages 响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public void Configure(IApplicationBuilder app)<br>&#123;<br>    &#x2F;&#x2F; Static files aren&#39;t compressed by Static File Middleware.<br>    app.UseStaticFiles();<br><br>    app.UseResponseCompression();<br><br>    app.UseEndpoints(endpoints &#x3D;&gt;<br>    &#123;<br>        endpoints.MapRazorPages();<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>对于单页应用程序，SPA 中间件 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.spastaticfilesextensions.usespastaticfiles" target="_blank" rel="noopener"><code>UseSpaStaticFiles</code></a> 通常是中间件管道中的最后一个。 SPA 中间件处于最后的作用是：</p>
<ul>
<li>允许所有其他中间件首先响应匹配的请求。</li>
<li>允许具有客户端侧路由的 SPA 针对服务器应用无法识别的所有路由运行。</li>
</ul>
<p>有关单页应用程序的详细信息，请参阅 React 和 Angular 项目模板的指南。</p>
<h4 id="对中间件管道进行分支"><a class="header-anchor" href="#对中间件管道进行分支">¶</a>对中间件管道进行分支</h4>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mapextensions.map" target="_blank" rel="noopener"><code>Map</code></a> 扩展用作约定来创建管道分支。 <code>Map</code> 基于给定请求路径的匹配项来创建请求管道分支。 如果请求路径以给定路径开头，则执行分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Startup<br>&#123;<br>    private static void HandleMapTest1(IApplicationBuilder app)<br>    &#123;<br>        app.Run(async context &#x3D;&gt;<br>        &#123;<br>            await context.Response.WriteAsync(&quot;Map Test 1&quot;);<br>        &#125;);<br>    &#125;<br><br>    private static void HandleMapTest2(IApplicationBuilder app)<br>    &#123;<br>        app.Run(async context &#x3D;&gt;<br>        &#123;<br>            await context.Response.WriteAsync(&quot;Map Test 2&quot;);<br>        &#125;);<br>    &#125;<br><br>    public void Configure(IApplicationBuilder app)<br>    &#123;<br>        app.Map(&quot;&#x2F;map1&quot;, HandleMapTest1);<br><br>        app.Map(&quot;&#x2F;map2&quot;, HandleMapTest2);<br><br>        app.Run(async context &#x3D;&gt;<br>        &#123;<br>            await context.Response.WriteAsync(&quot;Hello from non-Map delegate. &lt;p&gt;&quot;);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>下表使用前面的代码显示来自 <em><a href="http://localhost:1234" target="_blank" rel="noopener">http://localhost:1234</a></em> 的请求和响应。</p>
<table>
<thead>
<tr>
<th style="text-align:center">请求</th>
<th style="text-align:center">响应</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em>localhost:1234</em></td>
<td style="text-align:center">Hello from non-Map delegate.</td>
</tr>
<tr>
<td style="text-align:center"><em>localhost:1234/map1</em></td>
<td style="text-align:center">Map Test 1</td>
</tr>
<tr>
<td style="text-align:center"><em>localhost:1234/map2</em></td>
<td style="text-align:center">Map Test 2</td>
</tr>
<tr>
<td style="text-align:center"><em>localhost:1234/map3</em></td>
<td style="text-align:center">Hello from non-Map delegate.</td>
</tr>
</tbody>
</table>
<p>使用 <code>Map</code> 时，将从 <code>HttpRequest.Path</code> 中删除匹配的路径段，并针对每个请求将该路径段追加到 <code>HttpRequest.PathBase</code>。<br>
<code>Map</code> 支持嵌套，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">app.Map(&quot;&#x2F;level1&quot;, level1App &#x3D;&gt; &#123;<br>    level1App.Map(&quot;&#x2F;level2a&quot;, level2AApp &#x3D;&gt; &#123;<br>        &#x2F;&#x2F; &quot;&#x2F;level1&#x2F;level2a&quot; processing<br>    &#125;);<br>    level1App.Map(&quot;&#x2F;level2b&quot;, level2BApp &#x3D;&gt; &#123;<br>        &#x2F;&#x2F; &quot;&#x2F;level1&#x2F;level2b&quot; processing<br>    &#125;);<br>&#125;);<br></code></pre></div></td></tr></table></figure>
<p>此外，<code>Map</code> 还可同时匹配多个段：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Startup<br>&#123;<br>    private static void HandleMultiSeg(IApplicationBuilder app)<br>    &#123;<br>        app.Run(async context &#x3D;&gt;<br>        &#123;<br>            await context.Response.WriteAsync(&quot;Map multiple segments.&quot;);<br>        &#125;);<br>    &#125;<br><br>    public void Configure(IApplicationBuilder app)<br>    &#123;<br>        app.Map(&quot;&#x2F;map1&#x2F;seg1&quot;, HandleMultiSeg);<br><br>        app.Run(async context &#x3D;&gt;<br>        &#123;<br>            await context.Response.WriteAsync(&quot;Hello from non-Map delegate.&quot;);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mapwhenextensions.mapwhen" target="_blank" rel="noopener"><code>MapWhen</code></a> 基于给定谓词的结果创建请求管道分支。 <code>Func&lt;HttpContext, bool&gt;</code> 类型的任何谓词均可用于将请求映射到管道的新分支。 在以下示例中，谓词用于检测查询字符串变量 <code>branch</code> 是否存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Startup<br>&#123;<br>    private static void HandleBranch(IApplicationBuilder app)<br>    &#123;<br>        app.Run(async context &#x3D;&gt;<br>        &#123;<br>            var branchVer &#x3D; context.Request.Query[&quot;branch&quot;];<br>            await context.Response.WriteAsync($&quot;Branch used &#x3D; &#123;branchVer&#125;&quot;);<br>        &#125;);<br>    &#125;<br><br>    public void Configure(IApplicationBuilder app)<br>    &#123;<br>        app.MapWhen(context &#x3D;&gt; context.Request.Query.ContainsKey(&quot;branch&quot;),<br>                               HandleBranch);<br><br>        app.Run(async context &#x3D;&gt;<br>        &#123;<br>            await context.Response.WriteAsync(&quot;Hello from non-Map delegate. &lt;p&gt;&quot;);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>下表使用前面的代码显示来自 <em><a href="http://localhost:1234" target="_blank" rel="noopener">http://localhost:1234</a></em> 的请求和响应：</p>
<table>
<thead>
<tr>
<th style="text-align:center">请求</th>
<th style="text-align:center">响应</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em>localhost:1234</em></td>
<td style="text-align:center">Hello from non-Map delegate.</td>
</tr>
<tr>
<td style="text-align:center"><em>localhost:1234/?branch=master</em></td>
<td style="text-align:center">Branch used = master</td>
</tr>
</tbody>
</table>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.usewhenextensions.usewhen" target="_blank" rel="noopener"><code>UseWhen</code></a> 也基于给定谓词的结果创建请求管道分支。 与 <code>MapWhen</code> 不同的是，如果这个分支发生短路或包含终端中间件，则会重新加入主管道：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Startup<br>&#123;<br>    private readonly ILogger&lt;Startup&gt; _logger;<br><br>    public Startup(ILogger&lt;Startup&gt; logger)<br>    &#123;<br>        _logger &#x3D; logger;<br>    &#125;<br><br>    private void HandleBranchAndRejoin(IApplicationBuilder app)<br>    &#123;<br>        app.Use(async (context, next) &#x3D;&gt;<br>        &#123;<br>            var branchVer &#x3D; context.Request.Query[&quot;branch&quot;];<br>            _logger.LogInformation(&quot;Branch used &#x3D; &#123;branchVer&#125;&quot;, branchVer);<br><br>            &#x2F;&#x2F; Do work that doesn&#39;t write to the Response.<br>            await next();<br>            &#x2F;&#x2F; Do other work that doesn&#39;t write to the Response.<br>        &#125;);<br>    &#125;<br><br>    public void Configure(IApplicationBuilder app)<br>    &#123;<br>        app.UseWhen(context &#x3D;&gt; context.Request.Query.ContainsKey(&quot;branch&quot;),<br>                               HandleBranchAndRejoin);<br><br>        app.Run(async context &#x3D;&gt;<br>        &#123;<br>            await context.Response.WriteAsync(&quot;Hello from main pipeline.&quot;);<br>        &#125;);<br>    &#125;<br></code></pre></div></td></tr></table></figure>
<p>在前面的示例中，响应 “Hello from main pipeline.” 是为所有请求编写的。 如果请求中包含查询字符串变量 <code>branch</code>，则在重新加入主管道之前会记录其值。</p>
<h4 id="内置中间件"><a class="header-anchor" href="#内置中间件">¶</a>内置中间件</h4>
<p><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 附带以下中间件组件。 “顺序” 列提供备注，以说明中间件在请求处理管道中的放置，以及中间件可能会终止请求处理的条件。 如果中间件让请求处理管道短路，并阻止下游中间件进一步处理请求，它被称为“终端中间件” 。</p>
<table>
<thead>
<tr>
<th style="text-align:center">中间件</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">身份验证</td>
<td style="text-align:center">提供身份验证支持。</td>
<td style="text-align:center">在需要 <code>HttpContext.User</code> 之前。 OAuth 回叫的终端。</td>
</tr>
<tr>
<td style="text-align:center">授权</td>
<td style="text-align:center">提供身份验证支持。</td>
<td style="text-align:center">紧接在身份验证中间件之后。</td>
</tr>
<tr>
<td style="text-align:center">Cookie 策略</td>
<td style="text-align:center">跟踪用户是否同意存储个人信息，并强制实施 cookie 字段（如 <code>secure</code> 和 <code>SameSite</code>）的最低标准。</td>
<td style="text-align:center">在发出 cookie 的中间件之前。 示例：身份验证、会话、MVC (TempData)。</td>
</tr>
<tr>
<td style="text-align:center">CORS</td>
<td style="text-align:center">配置跨域资源共享。</td>
<td style="text-align:center">在使用 CORS 的组件之前。</td>
</tr>
<tr>
<td style="text-align:center">诊断</td>
<td style="text-align:center">提供新应用的开发人员异常页、异常处理、状态代码页和默认网页的几个单独的中间件。</td>
<td style="text-align:center">在生成错误的组件之前。 异常终端或为新应用提供默认网页的终端。</td>
</tr>
<tr>
<td style="text-align:center">转发头</td>
<td style="text-align:center">将代理标头转发到当前请求。</td>
<td style="text-align:center">在使用已更新字段的组件之前。 示例：方案、主机、客户端 IP、方法。</td>
</tr>
<tr>
<td style="text-align:center">运行状况检查</td>
<td style="text-align:center">检查 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 应用及其依赖项的运行状况，如检查数据库可用性。</td>
<td style="text-align:center">如果请求与运行状况检查终结点匹配，则为终端。</td>
</tr>
<tr>
<td style="text-align:center">标头传播</td>
<td style="text-align:center">将 HTTP 标头从传入的请求传播到传出的 HTTP 客户端请求中。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">HTTP 方法重写</td>
<td style="text-align:center">允许传入 POST 请求重写方法。</td>
<td style="text-align:center">在使用已更新方法的组件之前。</td>
</tr>
<tr>
<td style="text-align:center">HTTPS 重定向</td>
<td style="text-align:center">将所有 HTTP 请求重定向到 HTTPS。</td>
<td style="text-align:center">在使用 URL 的组件之前。</td>
</tr>
<tr>
<td style="text-align:center">HTTP 严格传输安全性 (HSTS)</td>
<td style="text-align:center">添加特殊响应标头的安全增强中间件。</td>
<td style="text-align:center">在发送响应之前，修改请求的组件之后。 示例：转接头、URL 重写。</td>
</tr>
<tr>
<td style="text-align:center">MVC</td>
<td style="text-align:center">用 MVC/Razor Pages 处理请求。</td>
<td style="text-align:center">如果请求与路由匹配，则为终端。</td>
</tr>
<tr>
<td style="text-align:center">OWIN</td>
<td style="text-align:center">与基于 OWIN 的应用、服务器和中间件进行互操作。</td>
<td style="text-align:center">如果 OWIN 中间件处理完请求，则为终端。</td>
</tr>
<tr>
<td style="text-align:center">响应缓存</td>
<td style="text-align:center">提供对缓存响应的支持。</td>
<td style="text-align:center">在需要缓存的组件之前。</td>
</tr>
<tr>
<td style="text-align:center">响应压缩</td>
<td style="text-align:center">提供对压缩响应的支持。</td>
<td style="text-align:center">在需要压缩的组件之前。</td>
</tr>
<tr>
<td style="text-align:center">请求本地化</td>
<td style="text-align:center">提供本地化支持。</td>
<td style="text-align:center">在对本地化敏感的组件之前。</td>
</tr>
<tr>
<td style="text-align:center">终结点路由</td>
<td style="text-align:center">定义和约束请求路由。</td>
<td style="text-align:center">用于匹配路由的终端。</td>
</tr>
<tr>
<td style="text-align:center">SPA</td>
<td style="text-align:center">通过返回单页应用程序 (SPA) 的默认页面，在中间件链中处理来自这个点的所有请求</td>
<td style="text-align:center">在链中处于靠后位置，因此其他服务于静态文件、MVC 操作等内容的中间件占据优先位置。</td>
</tr>
<tr>
<td style="text-align:center">会话</td>
<td style="text-align:center">提供对管理用户会话的支持。</td>
<td style="text-align:center">在需要会话的组件之前。</td>
</tr>
<tr>
<td style="text-align:center">静态文件</td>
<td style="text-align:center">为提供静态文件和目录浏览提供支持。</td>
<td style="text-align:center">如果请求与文件匹配，则为终端。</td>
</tr>
<tr>
<td style="text-align:center">URL 重写</td>
<td style="text-align:center">提供对重写 URL 和重定向请求的支持。</td>
<td style="text-align:center">在使用 URL 的组件之前。</td>
</tr>
<tr>
<td style="text-align:center">WebSockets</td>
<td style="text-align:center">启用 WebSockets 协议。</td>
<td style="text-align:center">在接受 WebSocket 请求所需的组件之前。</td>
</tr>
</tbody>
</table>
<h3 id="六、ASP-NET-Core-中的配置"><a class="header-anchor" href="#六、ASP-NET-Core-中的配置">¶</a>六、<a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 中的配置</h3>
<p><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 中的应用配置基于配置提供程序 建立的键值对。 配置提供程序将配置数据从各种配置源读取到键值对：</p>
<ul>
<li>Azure Key Vault</li>
<li>Azure 应用程序配置</li>
<li>命令行参数</li>
<li>（已安装或已创建的）自定义提供程序</li>
<li>目录文件</li>
<li>环境变量</li>
<li>内存中的 .NET 对象</li>
<li>设置文件</li>
</ul>
<p>框架隐式包含通用配置提供程序方案的配置包 (<a href="https://www.nuget.org/packages/Microsoft.Extensions.Configuration/" target="_blank" rel="noopener">Microsoft Extensions.Configuration</a>)。</p>
<p>后面的代码示例和示例应用中的代码示例使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration" target="_blank" rel="noopener"><code>Microsoft.Extensions.Configuration</code></a> 命名空间：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">using Microsoft.Extensions.Configuration;<br></code></pre></div></td></tr></table></figure>
<p>选项模式 是本主题中描述的配置概念的扩展。 选项使用类来表示相关设置的组。<br>
<a href="https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/configuration/index/samples" target="_blank" rel="noopener">查看或下载实例代码</a></p>
<h4 id="主机与应用配置"><a class="header-anchor" href="#主机与应用配置">¶</a>主机与应用配置</h4>
<p>在配置并启动应用之前，配置并启动主机。主机负责应用程序启动和生存期管理。应用和主机均使用本主题中所述的配置提供程序进行配置。 应用的配置中也包含主机配置键值对。</p>
<h4 id="其它配置"><a class="header-anchor" href="#其它配置">¶</a>其它配置</h4>
<ul>
<li><em>launch.json</em>/<em>launchSettings.json</em> 是用于开发环境的工具配置文件，如
<ul>
<li>在 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 中使用多个环境中所述。</li>
<li>整个文档集中的文件用于为开发方案配置 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 应用。</li>
</ul>
</li>
<li><em>web.config</em> 是服务器配置文件，如以下主题中所述：
<ul>
<li>使用 IIS 在 Windows 上托管 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core</li>
<li><a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 模块</li>
</ul>
</li>
</ul>
<h4 id="默认配置"><a class="header-anchor" href="#默认配置">¶</a>默认配置</h4>
<p>基于 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core <a href="https://docs.microsoft.com/zh-cn/dotnet/core/tools/dotnet-new" target="_blank" rel="noopener">dotnet new</a> 模板的 Web 应用在生成主机时会调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.host.createdefaultbuilder" target="_blank" rel="noopener"><code>CreateDefaultBuilder</code></a>。<code>CreateDefaultBuilder</code> 按照以下顺序为应用提供默认配置，以下内容适用于使用通用主机的应用。</p>
<ul>
<li>主机配置通过以下方式提供：
<ul>
<li>使用环境变量配置提供程序，通过前缀为 <code>DOTNET_</code>（例如，<code>DOTNET_ENVIRONMENT</code>）的环境变量提供。在配置键值对加载后，前缀（<code>DOTNET_</code>）会遭去除。 ‎</li>
<li>使用命令行配置提供程序，通过命令行参数提供。</li>
</ul>
</li>
<li>已建立 Web 主机默认配置 (<code>ConfigureWebHostDefaults</code>)：
<ul>
<li>Kestrel 用作 Web 服务器，并使用应用的配置提供程序对其进行配置。</li>
<li>添加主机筛选中间件。</li>
<li>如果 <code>ASPNETCORE_FORWARDEDHEADERS_ENABLED</code> 环境变量设置为 <code>true</code>，则添加转发的标头中间件。</li>
<li>启用 IIS 集成。</li>
</ul>
</li>
<li>应用配置通过以下方式提供：
<ul>
<li>使用文件配置提供程序，通过 <em>appsettings.json</em> 提供。</li>
<li>使用文件配置提供程序，通过 <em>appsettings.{Environment}.json</em> 提供。‎</li>
<li>应用在使用入口程序集的 Development 环境中运行时的机密管理器。</li>
<li>使用环境变量配置提供程序，通过环境变量提供。</li>
<li>使用命令行配置提供程序，通过命令行参数提供。</li>
</ul>
</li>
</ul>
<h4 id="安全性"><a class="header-anchor" href="#安全性">¶</a>安全性</h4>
<p>采用以下做法来保护敏感配置数据：</p>
<ul>
<li>请勿在配置提供程序代码或纯文本配置文件中存储密码或其他敏感数据。</li>
<li>不要在开发或测试环境中使用生产机密。</li>
<li>请在项目外部指定机密，避免将其意外提交到源代码存储库。</li>
</ul>
<p><a href="https://azure.microsoft.com/services/key-vault/" target="_blank" rel="noopener">Azure Key Vault</a> 安全存储 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 应用的应用机密。</p>
<h4 id="分层配置数据"><a class="header-anchor" href="#分层配置数据">¶</a>分层配置数据</h4>
<p>配置 API 能够通过在配置键中使用分隔符来展平分层数据以保持分层配置数据。<br>
在以下 JSON 文件中，两个节的结构化层次结构中存在四个键：</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JSON">&#123;<br>  <span class="hljs-attr">"section0"</span>: &#123;<br>    <span class="hljs-attr">"key0"</span>: <span class="hljs-string">"value"</span>,<br>    <span class="hljs-attr">"key1"</span>: <span class="hljs-string">"value"</span><br>  &#125;,<br>  <span class="hljs-attr">"section1"</span>: &#123;<br>    <span class="hljs-attr">"key0"</span>: <span class="hljs-string">"value"</span>,<br>    <span class="hljs-attr">"key1"</span>: <span class="hljs-string">"value"</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>将文件读入配置时，将创建唯一键以保持配置源的原始分层数据结构。 使用冒号 (<code>:</code>) 展平节和键以保持原始结构：</p>
<ul>
<li><code>section0:key0</code></li>
<li><code>section0:key1</code></li>
<li><code>section1:key0</code></li>
<li><code>section1:key1</code></li>
</ul>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationsection.getsection" target="_blank" rel="noopener"><code>GetSection</code></a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.iconfiguration.getchildren" target="_blank" rel="noopener"><code>GetChildren</code></a> 方法可用于隔离各个节和配置数据中某节的子节。</p>
<h4 id="约定"><a class="header-anchor" href="#约定">¶</a>约定</h4>
<h5 id="源和提供程序"><a class="header-anchor" href="#源和提供程序">¶</a>源和提供程序</h5>
<p>在应用启动时，将按照指定的配置提供程序的顺序读取配置源。<br>
实现更改检测的配置提供程序能够在基础设置更改时重新加载配置。 例如，文件配置提供程序（本主题后面将对此进行介绍）和 Azure Key Vault 配置提供程序实现更改检测。<br>
应用的依赖关系注入 (DI) 容器中提供了 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.iconfiguration" target="_blank" rel="noopener"><code>IConfiguration</code></a>。<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.iconfiguration" target="_blank" rel="noopener"><code>IConfiguration</code></a> 可注入到 Razor Pages <code>PageModel</code> 或 MVC <code>Controller</code> 来获取以下类的配置。<br>
在下面的示例中，使用 <code>_config</code> 字段来访问配置值：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class IndexModel : PageModel<br>&#123;<br>    private readonly IConfiguration _config;<br><br>    public IndexModel(IConfiguration config)<br>    &#123;<br>        _config &#x3D; config;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<h2 id="注意：-v2"><a class="header-anchor" href="#注意：-v2">¶</a><strong>注意</strong>：</h2>
<p>配置提供程序不能使用 DI，因为主机在设置这些提供程序时 DI 不可用。</p>
</blockquote>
<h5 id="键"><a class="header-anchor" href="#键">¶</a>键</h5>
<p>配置键采用以下约定：</p>
<ul>
<li>键不区分大小写。 例如，<code>ConnectionString</code> 和 <code>connectionstring</code> 被视为等效键。</li>
<li>如果由相同或不同的配置提供程序设置相同键的值，则键上设置的最后一个值就是所使用的值。</li>
<li>分层键
<ul>
<li>在配置 API 中，冒号分隔符 (<code>:</code>) 适用于所有平台。</li>
<li>在环境变量中，冒号分隔符可能无法适用于所有平台。 所有平台均支持采用双下划线 (<code>__</code>)，并可以将其自动转换为冒号。</li>
<li>在 Azure Key Vault 中，分层键使用 <code>--</code>（两个破折号）作为分隔符。 将机密加载到应用的配置中时，用冒号替换破折号。</li>
</ul>
</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbinder" target="_blank" rel="noopener"><code>ConfigurationBinder</code></a> 支持使用配置键中的数组索引将数组绑定到对象。</li>
</ul>
<h5 id="值"><a class="header-anchor" href="#值">¶</a>值</h5>
<p>配置值采用以下约定：</p>
<ul>
<li>值是字符串。</li>
<li>NULL 值不能存储在配置中或绑定到对象。</li>
</ul>
<h4 id="提供程序"><a class="header-anchor" href="#提供程序">¶</a>提供程序</h4>
<p>下表显示了 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 应用可用的配置提供程序。</p>
<table>
<thead>
<tr>
<th style="text-align:center">提供程序</th>
<th style="text-align:center">通过以下对象提供配置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Azure Key Vault 配置提供程序（安全 主题）</td>
<td style="text-align:center">Azure Key Vault</td>
</tr>
<tr>
<td style="text-align:center">Azure 应用程序配置提供程序（Azure 文档）</td>
<td style="text-align:center">Azure 应用程序配置</td>
</tr>
<tr>
<td style="text-align:center">命令行配置提供程序</td>
<td style="text-align:center">命令行参数</td>
</tr>
<tr>
<td style="text-align:center">自定义配置提供程序</td>
<td style="text-align:center">自定义源</td>
</tr>
<tr>
<td style="text-align:center">环境变量配置提供程序</td>
<td style="text-align:center">环境变量</td>
</tr>
<tr>
<td style="text-align:center">文件配置提供程序</td>
<td style="text-align:center">文件（INI、JSON、XML）</td>
</tr>
<tr>
<td style="text-align:center">Key-per-file 配置提供程序</td>
<td style="text-align:center">目录文件</td>
</tr>
<tr>
<td style="text-align:center">内存配置提供程序</td>
<td style="text-align:center">内存中集合</td>
</tr>
<tr>
<td style="text-align:center">用户机密 (Secret Manager)（安全 主题）</td>
<td style="text-align:center">用户配置文件目录中的文件</td>
</tr>
</tbody>
</table>
<p>按照启动时指定的配置提供程序的顺序读取配置源。 本主题中所述的配置提供程序按字母顺序进行介绍，而不是按代码排列顺序进行介绍。代码中的配置提供程序应以特定顺序排列，从而满足应用所需的基础配置源的优先级。</p>
<p>配置提供程序的典型顺序为：</p>
<ol>
<li>文件（<em>appsettings.json</em>、<em>appsettings.{Environment}.json</em>，其中 <code>{Environment}</code> 是应用的当前托管环境）</li>
<li>Azure 密钥保管库</li>
<li>用户机密 (Secret Manager)（仅限开发环境中）</li>
<li>环境变量</li>
<li>命令行参数</li>
</ol>
<p>通常的做法是将命令行配置提供程序置于一系列提供程序的末尾，以允许命令行参数替代由其他提供程序设置的配置。<br>
使用 <code>CreateDefaultBuilder</code> 初始化新的主机生成器时，将使用上述提供程序序列。</p>
<h4 id="用-ConfigureHostConfiguration-配置主机生成器"><a class="header-anchor" href="#用-ConfigureHostConfiguration-配置主机生成器">¶</a>用 <code>ConfigureHostConfiguration</code> 配置主机生成器</h4>
<p>若要配置主机生成器，请调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.hostbuilder.configurehostconfiguration" target="_blank" rel="noopener"><code>ConfigureHostConfiguration</code></a> 并提供配置。 用 <code>ConfigureHostConfiguration</code> 初始化 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.ihostenvironment" target="_blank" rel="noopener"><code>IHostEnvironment</code></a>，以便稍后在生成过程中使用。 可多次调用 <code>ConfigureHostConfiguration</code>，并得到累计结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;<br>    Host.CreateDefaultBuilder(args)<br>        .ConfigureHostConfiguration(config &#x3D;&gt;<br>        &#123;<br>            var dict &#x3D; new Dictionary&lt;string, string&gt;<br>            &#123;<br>                &#123;&quot;MemoryCollectionKey1&quot;, &quot;value1&quot;&#125;,<br>                &#123;&quot;MemoryCollectionKey2&quot;, &quot;value2&quot;&#125;<br>            &#125;;<br><br>            config.AddInMemoryCollection(dict);<br>        &#125;)<br>        .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;<br>        &#123;<br>            webBuilder.UseStartup&lt;Startup&gt;();<br>        &#125;);<br></code></pre></div></td></tr></table></figure>
<h5 id="ConfigureAppConfiguration"><a class="header-anchor" href="#ConfigureAppConfiguration">¶</a><code>ConfigureAppConfiguration</code></h5>
<p>构建主机时调用 <code>ConfigureAppConfiguration</code> 以指定应用的配置提供程序以及 <code>CreateDefaultBuilder</code> 自动添加的配置提供程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Program<br>&#123;<br>    public static Dictionary&lt;string, string&gt; arrayDict &#x3D;<br>        new Dictionary&lt;string, string&gt;<br>        &#123;<br>            &#123;&quot;array:entries:0&quot;, &quot;value0&quot;&#125;,<br>            &#123;&quot;array:entries:1&quot;, &quot;value1&quot;&#125;,<br>            &#123;&quot;array:entries:2&quot;, &quot;value2&quot;&#125;,<br>            &#123;&quot;array:entries:4&quot;, &quot;value4&quot;&#125;,<br>            &#123;&quot;array:entries:5&quot;, &quot;value5&quot;&#125;<br>        &#125;;<br><br>    public static void Main(string[] args)<br>    &#123;<br>        CreateHostBuilder(args).Build().Run();<br>    &#125;<br><br>    public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;<br>        Host.CreateDefaultBuilder(args)<br>            .ConfigureAppConfiguration((hostingContext, config) &#x3D;&gt;<br>            &#123;<br>                config.AddInMemoryCollection(arrayDict);<br>                config.AddJsonFile(<br>                    &quot;json_array.json&quot;, optional: false, reloadOnChange: false);<br>                config.AddJsonFile(<br>                    &quot;starship.json&quot;, optional: false, reloadOnChange: false);<br>                config.AddXmlFile(<br>                    &quot;tvshow.xml&quot;, optional: false, reloadOnChange: false);<br>                config.AddEFConfiguration(<br>                    options &#x3D;&gt; options.UseInMemoryDatabase(&quot;InMemoryDb&quot;));<br>                config.AddCommandLine(args);<br>            &#125;)<br>            .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;<br>            &#123;<br>                webBuilder.UseStartup&lt;Startup&gt;();<br>            &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h5 id="用命令行参数替代以前的配置"><a class="header-anchor" href="#用命令行参数替代以前的配置">¶</a>用命令行参数替代以前的配置</h5>
<p>若要提供命令行参数可替代的应用配置，最后请调用 <code>AddCommandLine</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">.ConfigureAppConfiguration((hostingContext, config) &#x3D;&gt;<br>&#123;<br>    &#x2F;&#x2F; Call other providers here<br>    config.AddCommandLine(args);<br>&#125;)<br></code></pre></div></td></tr></table></figure>
<h5 id="删除-CreateDefaultBuilder-添加的提供程序"><a class="header-anchor" href="#删除-CreateDefaultBuilder-添加的提供程序">¶</a>删除 <code>CreateDefaultBuilder</code> 添加的提供程序</h5>
<p>要删除 <code>CreateDefaultBuilder</code> 添加的提供程序，请先对 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.iconfigurationbuilder.sources#Microsoft_Extensions_Configuration_IConfigurationBuilder_Sources" target="_blank" rel="noopener"><code>IConfigurationBuilder.Sources</code></a> 调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.icollection-1.clear" target="_blank" rel="noopener"><code>Clear</code></a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">.ConfigureAppConfiguration((hostingContext, config) &#x3D;&gt;<br>&#123;<br>    config.Sources.Clear();<br>    &#x2F;&#x2F; Add providers here<br>&#125;)<br></code></pre></div></td></tr></table></figure>
<h5 id="在应用启动期间使用配置"><a class="header-anchor" href="#在应用启动期间使用配置">¶</a>在应用启动期间使用配置</h5>
<p>在应用启动期间，可以使用 <code>ConfigureAppConfiguration</code> 中提供给应用的配置，包括 <code>Startup.ConfigureServices</code>。</p>
<h4 id="命令行配置提供程序"><a class="header-anchor" href="#命令行配置提供程序">¶</a>命令行配置提供程序</h4>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.commandline.commandlineconfigurationprovider" target="_blank" rel="noopener"><code>CommandLineConfigurationProvider</code></a> 在运行时从命令行参数键值对加载配置。</p>
<p>要激活命令行配置，请在 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbuilder" target="_blank" rel="noopener"><code>ConfigurationBuilder</code></a> 的实例上调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.commandlineconfigurationextensions.addcommandline" target="_blank" rel="noopener"><code>AddCommandLine</code></a> 扩展方法。</p>
<p>调用 <code>CreateDefaultBuilder(string [])</code> 时会自动调用 <code>AddCommandLine</code>。</p>
<p>此外，<code>CreateDefaultBuilder</code> 也会加载：</p>
<ul>
<li><em>appsettings.json</em> 和 <em>appsettings.{Environment}.json</em> 文件中的可选配置 。</li>
<li>用户机密 (Secret Manager)（在开发环境中）。</li>
<li>环境变量。</li>
</ul>
<p><code>CreateDefaultBuilder</code> 最后添加命令行配置提供程序。 在运行时传递的命令行参数会替代由其他提供程序设置的配置。</p>
<p><code>CreateDefaultBuilder</code> 在构造主机时起作用。 因此，<code>CreateDefaultBuilder</code> 激活的命令行配置可能会影响主机的配置方式。</p>
<p>对于基于 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> Core 模板的应用，<code>CreateDefaultBuilder</code> 已调用 <code>AddCommandLine</code>。 若要添加其他配置提供程序并保持能够用命令行参数替代这些提供程序的配置，请在 <code>ConfigureAppConfiguration</code> 中调用应用的其他提供程序，并最后调用 <code>AddCommandLine</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">.ConfigureAppConfiguration((hostingContext, config) &#x3D;&gt;<br>&#123;<br>    &#x2F;&#x2F; Call other providers here<br>    config.AddCommandLine(args);<br>&#125;)<br></code></pre></div></td></tr></table></figure>
<h5 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h5>
<p>示例应用利用静态便捷方法 <code>CreateDefaultBuilder</code> 来生成主机，其中包括一个对 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.commandlineconfigurationextensions.addcommandline" target="_blank" rel="noopener"><code>AddCommandLine</code></a> 的调用。</p>
<ol>
<li>在项目的目录中打开命令提示符。</li>
<li>为 <code>dotnet run</code> 命令提供命令行参数 <code>dotnet run CommandLineKey=CommandLineValue</code>。</li>
<li>应用运行后，在 <code>http://localhost:5000</code> 打开应用的浏览器。</li>
<li>观察输出是否包含提供给 <code>dotnet run</code> 的配置命令行参数的键值对。</li>
</ol>
<h5 id="自变量"><a class="header-anchor" href="#自变量">¶</a>自变量</h5>
<p>该值必须后跟一个等号 (<code>=</code>)，否则当值后跟一个空格时，键必须具有前缀（<code>--</code> 或 <code>/</code>）。 如果使用等号（例如 <code>CommandLineKey=</code>），则不需要该值。</p>
<table>
<thead>
<tr>
<th>键前缀</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>无前缀</td>
<td><code>CommandLineKey1=value1</code></td>
</tr>
<tr>
<td>双划线 (<code>--</code>)</td>
<td><code>--CommandLineKey2=value2</code>，<code>--CommandLineKey2 value2</code></td>
</tr>
<tr>
<td>正斜杠 (<code>/</code>)</td>
<td><code>/CommandLineKey3=value3</code>，<code>/CommandLineKey3 value3</code></td>
</tr>
</tbody>
</table>
<p>在同一命令中，不要将使用等号的命令行参数键值对与使用空格的键值对混合使用。</p>
<p>示例命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">dotnet run CommandLineKey1=value1 --CommandLineKey2=value2 /CommandLineKey3=value3<br>dotnet run --CommandLineKey1 value1 /CommandLineKey2 value2<br>dotnet run CommandLineKey1= CommandLineKey2=value2<br></code></pre></div></td></tr></table></figure>
<h5 id="交换映射"><a class="header-anchor" href="#交换映射">¶</a>交换映射</h5>
<p>交换映射支持键名替换逻辑。 使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbuilder" target="_blank" rel="noopener"><code>ConfigurationBuilder</code></a> 手动构建配置时，需要为 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.commandlineconfigurationextensions.addcommandline" target="_blank" rel="noopener"><code>AddCommandLine</code></a> 方法提供交换替换字典。</p>
<p>当使用交换映射字典时，会检查字典中是否有与命令行参数提供的键匹配的键。 如果在字典中找到命令行键，则传回字典值（键替换）以将键值对设置为应用的配置。 对任何具有单划线 (<code>-</code>) 前缀的命令行键而言，交换映射都是必需的。</p>
<p>交换映射字典键规则：</p>
<ul>
<li>交换必须以单划线 (<code>-</code>) 或双划线 (<code>--</code>) 开头。</li>
<li>交换映射字典不得包含重复键。</li>
</ul>
<p>创建交换映射字典。 在以下示例中，创建了两个交换映射：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public static readonly Dictionary&lt;string, string&gt; _switchMappings &#x3D;<br>    new Dictionary&lt;string, string&gt;<br>    &#123;<br>        &#123; &quot;-CLKey1&quot;, &quot;CommandLineKey1&quot; &#125;,<br>        &#123; &quot;-CLKey2&quot;, &quot;CommandLineKey2&quot; &#125;<br></code></pre></div></td></tr></table></figure>
<p>生成主机后，使用交换映射字典来调用 <code>AddCommandLine</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">.ConfigureAppConfiguration((hostingContext, config) &#x3D;&gt;<br>&#123;<br>    config.AddCommandLine(args, _switchMappings);<br>&#125;)<br></code></pre></div></td></tr></table></figure>
<p>对于使用交换映射的应用，调用 <code>CreateDefaultBuilder</code> 不应传递参数。 <code>CreateDefaultBuilder</code> 方法的 <code>AddCommandLine</code> 调用不包括映射的交换，并且无法将交换映射字典传递给 <code>CreateDefaultBuilder</code>。 解决方案不是将参数传递给 <code>CreateDefaultBuilder</code>，而是允许 <code>ConfigurationBuilder</code> 方法的 <code>AddCommandLine</code> 方法处理参数和交换映射字典。</p>
<p>创建交换映射字典后，它将包含下表所示的数据。</p>
<table>
<thead>
<tr>
<th>键</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-CLKey1</code></td>
<td><code>CommandLineKey1</code></td>
</tr>
<tr>
<td><code>-CLKey2</code></td>
<td><code>CommandLineKey2</code></td>
</tr>
</tbody>
</table>
<p>如果在启动应用时使用了交换映射的键，则配置将接收字典提供的密钥上的配置值：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">dotnet run -CLKey1=value1 -CLKey2=value2<br></code></pre></div></td></tr></table></figure>
<p>运行上述命令后，配置包含下表中显示的值。</p>
<table>
<thead>
<tr>
<th>键</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CommandLineKey1</code></td>
<td><code>value1</code></td>
</tr>
<tr>
<td><code>CommandLineKey2</code></td>
<td><code>value2</code></td>
</tr>
</tbody>
</table>
<h4 id="环境变量配置提供程序"><a class="header-anchor" href="#环境变量配置提供程序">¶</a>环境变量配置提供程序</h4>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.environmentvariables.environmentvariablesconfigurationprovider" target="_blank" rel="noopener"><code>EnvironmentVariablesConfigurationProvider</code></a> 在运行时从环境变量键值对加载配置。</p>
<p>要激活环境变量配置，请在 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbuilder" target="_blank" rel="noopener"><code>ConfigurationBuilder</code></a> 的实例上调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.environmentvariablesextensions.addenvironmentvariables" target="_blank" rel="noopener"><code>AddEnvironmentVariables</code></a> 扩展方法。</p>
<p>在环境变量中使用分层键时，冒号分隔符 (<code>:</code>) 可能无法适用于所有平台（例如 Bash）。 所有平台均支持采用双下划线 (<code>__</code>)，并可以用冒号自动替换。</p>
<p>借助 Azure 应用服务，可在 Azure 门户中设置使用环境变量配置提供程序替代应用配置的环境变量。 有关详细信息。</p>
<p>如果使用通用主机初始化新的主机生成器，且调用了 <code>CreateDefaultBuilder</code>，则使用 <code>AddEnvironmentVariables</code> 为主机配置加载前缀为 <code>DOTNET_</code> 的环境变量。</p>
<p>此外，<code>CreateDefaultBuilder</code> 也会加载：</p>
<ul>
<li>来自没有前缀的环境变量的应用配置，方法是通过调用不带前缀的 <code>AddEnvironmentVariables</code>。</li>
<li><em>appsettings.json</em> 和 <em>appsettings.{Environment}.json</em> 文件中的可选配置   。</li>
<li>用户机密 (Secret Manager)（在开发环境中）。</li>
<li>命令行参数。</li>
</ul>
<p>环境变量配置提供程序是在配置已根据用户机密和 appsettings  文件建立后调用。 在此位置调用提供程序允许在运行时读取的环境变量替代由用户机密和 appsettings  文件设置的配置。</p>
<p>要从其他环境变量提供应用配置，请在 <code>ConfigureAppConfiguration</code> 中调用应用的其他提供程序，并使用前缀调用 <code>AddEnvironmentVariables</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">.ConfigureAppConfiguration((hostingContext, config) &#x3D;&gt;<br>&#123;<br>    config.AddEnvironmentVariables(prefix: &quot;PREFIX_&quot;);<br>&#125;)<br></code></pre></div></td></tr></table></figure>
<p>最后调用 <code>AddEnvironmentVariables</code>让带给定前缀的环境变量可替代其他提供程序中的值。</p>
<h5 id="示例-v2"><a class="header-anchor" href="#示例-v2">¶</a>示例</h5>
<p>示例应用利用静态便捷方法 <code>CreateDefaultBuilder</code> 来生成主机，其中包括一个对 <code>AddEnvironmentVariables</code> 的调用。</p>
<ol>
<li>运行示例应用。 在 <code>http://localhost:5000</code> 打开应用的浏览器。</li>
<li>观察输出是否包含环境变量 <code>ENVIRONMENT</code> 的键值对。 该值反映了应用运行的环境，在本地运行时通常为 <code>Development</code>。</li>
</ol>
<p>为了缩短应用呈现的环境变量列表，应用会筛选环境变量。 请参阅示例应用的“Pages/Index.cshtml.cs”文件  。</p>
<p>要公开应用可用的所有环境变量，请将 Pages/Index.cshtml.cs 中的 <code>FilteredConfiguration</code> 更改为以下内容  ：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">FilteredConfiguration &#x3D; _config.AsEnumerable();<br></code></pre></div></td></tr></table></figure>
<h5 id="前缀"><a class="header-anchor" href="#前缀">¶</a>前缀</h5>
<p>为 <code>AddEnvironmentVariables</code> 方法提供前缀时，将筛选加载到应用的配置中的环境变量。 例如，要筛选前缀 <code>CUSTOM_</code> 上的环境变量，请将前缀提供给配置提供程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">var config &#x3D; new ConfigurationBuilder()<br>    .AddEnvironmentVariables(&quot;CUSTOM_&quot;)<br>    .Build();<br></code></pre></div></td></tr></table></figure>
<p>创建配置键值对时，将去除前缀。</p>
<p>若已创建主机生成器，则主机配置由环境变量提供。</p>
<h6 id="连接字符串前缀"><a class="header-anchor" href="#连接字符串前缀">¶</a><strong>连接字符串前缀</strong></h6>
<p>针对为应用环境配置 Azure 连接字符串所涉及的四个连接字符串环境变量，配置 API 具有特殊的处理规则。 如果没有向 <code>AddEnvironmentVariables</code> 提供前缀，则具有表中所示前缀的环境变量将加载到应用中。</p>
<table>
<thead>
<tr>
<th>连接字符串前缀</th>
<th>提供程序</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CUSTOMCONNSTR_</code></td>
<td>自定义提供程序</td>
</tr>
<tr>
<td><code>MYSQLCONNSTR_</code></td>
<td><a href="https://www.mysql.com/" target="_blank" rel="noopener">MySQL</a></td>
</tr>
<tr>
<td><code>SQLAZURECONNSTR_</code></td>
<td><a href="https://azure.microsoft.com/services/sql-database/" target="_blank" rel="noopener">Azure SQL 数据库</a></td>
</tr>
<tr>
<td><code>SQLCONNSTR_</code></td>
<td><a href="https://www.microsoft.com/sql-server/" target="_blank" rel="noopener">SQL Server</a></td>
</tr>
</tbody>
</table>
<p>当发现环境变量并使用表中所示的四个前缀中的任何一个加载到配置中时：</p>
<ul>
<li>通过删除环境变量前缀并添加配置键节 (<code>ConnectionStrings</code>) 来创建配置键。</li>
<li>创建一个新的配置键值对，表示数据库连接提供程序（<code>CUSTOMCONNSTR_</code> 除外，它没有声明的提供程序）。</li>
</ul>
<table>
<thead>
<tr>
<th>环境变量键</th>
<th>转换的配置键</th>
<th>提供程序配置条目</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CUSTOMCONNSTR_{KEY}</code></td>
<td><code>ConnectionStrings:{KEY}</code></td>
<td>配置条目未创建。</td>
</tr>
<tr>
<td><code>MYSQLCONNSTR_{KEY}</code></td>
<td><code>ConnectionStrings:{KEY}</code></td>
<td>键：<code>ConnectionStrings:{KEY}_ProviderName</code>： 值：<code>MySql.Data.MySqlClient</code></td>
</tr>
<tr>
<td><code>SQLAZURECONNSTR_{KEY}</code></td>
<td><code>ConnectionStrings:{KEY}</code></td>
<td>键：<code>ConnectionStrings:{KEY}_ProviderName</code>： 值：<code>System.Data.SqlClient</code></td>
</tr>
<tr>
<td><code>SQLCONNSTR_{KEY}</code></td>
<td><code>ConnectionStrings:{KEY}</code></td>
<td>键：<code>ConnectionStrings:{KEY}_ProviderName</code>： 值：<code>System.Data.SqlClient</code></td>
</tr>
</tbody>
</table>
<p>示例</p>
<p>在服务器上创建了一个自定义连接字符串环境变量：</p>
<ul>
<li>名称 – <code>CUSTOMCONNSTR_ReleaseDB</code></li>
<li>值 – <code>Data Source=ReleaseSQLServer;Initial Catalog=MyReleaseDB;Integrated Security=True</code></li>
</ul>
<p>如果 <code>IConfiguration</code> 已引入并分配给名为 <code>_config</code> 的字段，请读取值：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">_config[&quot;ConnectionStrings:ReleaseDB&quot;]<br></code></pre></div></td></tr></table></figure>
<h4 id="文件配置提供程序"><a class="header-anchor" href="#文件配置提供程序">¶</a>文件配置提供程序</h4>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.fileconfigurationprovider" target="_blank" rel="noopener"><code>FileConfigurationProvider</code></a> 是从文件系统加载配置的基类。 以下配置提供程序专用于特定文件类型：</p>
<ul>
<li>INI 配置提供程序</li>
<li>JSON 配置提供程序</li>
<li>XML 配置提供程序</li>
</ul>
<h5 id="INI-配置提供程序"><a class="header-anchor" href="#INI-配置提供程序">¶</a>INI 配置提供程序</h5>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.ini.iniconfigurationprovider" target="_blank" rel="noopener"><code>IniConfigurationProvider</code></a> 在运行时从 INI 文件键值对加载配置。</p>
<p>若要激活 INI 文件配置，请在 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbuilder" target="_blank" rel="noopener"><code>ConfigurationBuilder</code></a> 的实例上调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.iniconfigurationextensions.addinifile" target="_blank" rel="noopener"><code>AddIniFile</code></a> 扩展方法。</p>
<p>冒号可用作 INI 文件配置中的节分隔符。</p>
<p>重载允许指定：</p>
<ul>
<li>文件是否可选。</li>
<li>如果文件更改，是否重载配置。</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.fileproviders.ifileprovider" target="_blank" rel="noopener"><code>IFileProvider</code></a> 用于访问该文件。</li>
</ul>
<p>构建主机时调用 <code>ConfigureAppConfiguration</code> 以指定应用的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">.ConfigureAppConfiguration((hostingContext, config) &#x3D;&gt;<br>&#123;<br>    config.AddIniFile(<br>        &quot;config.ini&quot;, optional: true, reloadOnChange: true);<br>&#125;)<br></code></pre></div></td></tr></table></figure>
<p>INI 配置文件的通用示例：</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[section0]</span><br><span class="hljs-attr">key0</span>=value<br><span class="hljs-attr">key1</span>=value<br><br><span class="hljs-section">[section1]</span><br>subsection:key=value<br><br><span class="hljs-section">[section2:subsection0]</span><br><span class="hljs-attr">key</span>=value<br><br><span class="hljs-section">[section2:subsection1]</span><br><span class="hljs-attr">key</span>=value<br></code></pre></div></td></tr></table></figure>
<p>以上的配置文件使用 <code>value</code> 加载以下键：</p>
<ul>
<li><code>section0:key0</code></li>
<li><code>section0:key1</code></li>
<li><code>section1:subsection:key</code></li>
<li><code>section2:subsection0:key</code></li>
<li><code>section2:subsection1:key</code></li>
</ul>
<h5 id="JSON-配置提供程序"><a class="header-anchor" href="#JSON-配置提供程序">¶</a>JSON 配置提供程序</h5>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.json.jsonconfigurationprovider" target="_blank" rel="noopener"><code>JsonConfigurationProvider</code></a> 在运行时期间从 JSON 文件键值对加载配置。</p>
<p>若要激活 JSON 文件配置，请在 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbuilder" target="_blank" rel="noopener"><code>ConfigurationBuilder</code></a> 的实例上调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.jsonconfigurationextensions.addjsonfile" target="_blank" rel="noopener"><code>AddJsonFile</code></a> 扩展方法。</p>
<p>重载允许指定：</p>
<ul>
<li>文件是否可选。</li>
<li>如果文件更改，是否重载配置。</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.fileproviders.ifileprovider" target="_blank" rel="noopener"><code>IFileProvider</code></a> 用于访问该文件。</li>
</ul>
<p>使用 <code>CreateDefaultBuilder</code> 初始化新的主机生成器时，会自动调用两次 <code>AddJsonFile</code>。 调用该方法来从以下文件加载配置：</p>
<ul>
<li><em>appsettings.json</em> – 首先读取此文件  。 该文件的环境版本可以替代 <em>appsettings.json</em>  文件提供的值。</li>
<li><em>appsettings.{Environment}.json</em> – 根据 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.hosting.ihostingenvironment.environmentname" target="_blank" rel="noopener"><code>IHostingEnvironment.EnvironmentName</code></a> 加载文件的环境版本  。</li>
</ul>
<p>此外，<code>CreateDefaultBuilder</code> 也会加载：</p>
<ul>
<li>环境变量。</li>
<li>用户机密 (Secret Manager)（在开发环境中）。</li>
<li>命令行参数。</li>
</ul>
<p>首先建立 JSON 配置提供程序。 因此，用户机密、环境变量和命令行参数会替代由 appsettings  文件设置的配置。</p>
<p>构建主机时调用 <code>ConfigureAppConfiguration</code> 以指定除 <em>appsettings.json</em> 和 <em>appsettings.{Environment}.json</em> 以外的文件的应用配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">.ConfigureAppConfiguration((hostingContext, config) &#x3D;&gt;<br>&#123;<br>    config.AddJsonFile(<br>        &quot;config.json&quot;, optional: true, reloadOnChange: true);<br>&#125;)<br></code></pre></div></td></tr></table></figure>
<h6 id="示例-v3"><a class="header-anchor" href="#示例-v3">¶</a><strong>示例</strong></h6>
<p>示例应用利用静态便捷方法 <code>CreateDefaultBuilder</code> 来生成主机，其中包括两个对 <code>AddJsonFile</code> 的调用：</p>
<ul>
<li>
<p>第一次调用 <code>AddJsonFile</code> 会从 appsettings 加载配置  ：</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"Logging"</span>: &#123;<br>    <span class="hljs-attr">"LogLevel"</span>: &#123;<br>      <span class="hljs-attr">"Default"</span>: <span class="hljs-string">"Information"</span>,<br>      <span class="hljs-attr">"Microsoft"</span>: <span class="hljs-string">"Warning"</span>,<br>      <span class="hljs-attr">"Microsoft.Hosting.Lifetime"</span>: <span class="hljs-string">"Information"</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">"AllowedHosts"</span>: <span class="hljs-string">"*"</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>第二次调用 <code>AddJsonFile</code> 会从 <em>appsettings.{Environment}.json</em> 加载配置  。 对于示例应用中的 <em>appsettings.Development.json</em>，将加载以下文件  ：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">&#123;<br>  &quot;Logging&quot;: &#123;<br>    &quot;LogLevel&quot;: &#123;<br>      &quot;Default&quot;: &quot;Debug&quot;,<br>      &quot;System&quot;: &quot;Information&quot;,<br>      &quot;Microsoft&quot;: &quot;Information&quot;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<ol>
<li>
<p>运行示例应用。 在 <code>http://localhost:5000</code> 打开应用的浏览器。</p>
</li>
<li>
<p>输出包含配置的键值对（由应用的环境而定）。 在开发环境中运行应用时，键 <code>Logging:LogLevel:Default</code> 的日志级别为 <code>Debug</code>。</p>
</li>
<li>
<p>再次在生产环境中运行示例应用：</p>
<ol>
<li>打开 <em>Properties/launchSettings.json</em> 文件  。</li>
<li>在 <code>ConfigurationSample</code> 配置文件中，将 <code>ASPNETCORE_ENVIRONMENT</code> 环境变量的值更改为 <code>Production</code>。</li>
<li>保存文件，然后在命令外壳中使用 <code>dotnet run</code> 运行应用。</li>
</ol>
</li>
<li>
<p><em>appsettings.Development.json</em> 中的设置不再替代 <em>appsettings.json</em> 中的设置 。键 <code>Logging:LogLevel:Default</code> 的日志级别为 <code>Information</code>。</p>
</li>
</ol>
<h4 id="XML-配置提供程序"><a class="header-anchor" href="#XML-配置提供程序">¶</a>XML 配置提供程序</h4>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.xml.xmlconfigurationprovider" target="_blank" rel="noopener"><code>XmlConfigurationProvider</code></a> 在运行时从 XML 文件键值对加载配置。</p>
<p>若要激活 XML 文件配置，请在 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbuilder" target="_blank" rel="noopener"><code>ConfigurationBuilder</code></a> 的实例上调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.xmlconfigurationextensions.addxmlfile" target="_blank" rel="noopener"><code>AddXmlFile</code></a> 扩展方法。</p>
<p>重载允许指定：</p>
<ul>
<li>文件是否可选。</li>
<li>如果文件更改，是否重载配置。</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.fileproviders.ifileprovider" target="_blank" rel="noopener"><code>IFileProvider</code></a> 用于访问该文件。</li>
</ul>
<p>创建配置键值对时，将忽略配置文件的根节点。 不要在文件中指定文档类型定义 (DTD) 或命名空间。</p>
<p>构建主机时调用 <code>ConfigureAppConfiguration</code> 以指定应用的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">.ConfigureAppConfiguration((hostingContext, config) &#x3D;&gt;<br>&#123;<br>    config.AddXmlFile(<br>        &quot;config.xml&quot;, optional: true, reloadOnChange: true);<br>&#125;)<br></code></pre></div></td></tr></table></figure>
<p>XML 配置文件可以为重复节使用不同的元素名称：</p>
<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">section0</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">key0</span>&gt;</span>value<span class="hljs-tag">&lt;/<span class="hljs-name">key0</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span>value<span class="hljs-tag">&lt;/<span class="hljs-name">key1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">section0</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">section1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">key0</span>&gt;</span>value<span class="hljs-tag">&lt;/<span class="hljs-name">key0</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">key1</span>&gt;</span>value<span class="hljs-tag">&lt;/<span class="hljs-name">key1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">section1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>以上的配置文件使用 <code>value</code> 加载以下键：</p>
<ul>
<li><code>section0:key0</code></li>
<li><code>section0:key1</code></li>
<li><code>section1:key0</code></li>
<li><code>section1:key1</code></li>
</ul>
<p>如果使用 <code>name</code> 属性来区分元素，则使用相同元素名称的重复元素可以正常工作：</p>
<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"section0"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"key0"</span>&gt;</span>value<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"key1"</span>&gt;</span>value<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"section1"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"key0"</span>&gt;</span>value<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"key1"</span>&gt;</span>value<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>以上的配置文件使用 <code>value</code> 加载以下键：</p>
<ul>
<li><code>section:section0:key:key0</code></li>
<li><code>section:section0:key:key1</code></li>
<li><code>section:section1:key:key0</code></li>
<li><code>section:section1:key:key1</code></li>
</ul>
<p>属性可用于提供值：</p>
<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">attribute</span>=<span class="hljs-string">"value"</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">attribute</span>=<span class="hljs-string">"value"</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>以前的配置文件使用 <code>value</code> 加载以下键：</p>
<ul>
<li><code>key:attribute</code></li>
<li><code>section:key:attribute</code></li>
</ul>
<h4 id="Key-per-file-配置提供程序"><a class="header-anchor" href="#Key-per-file-配置提供程序">¶</a>Key-per-file 配置提供程序</h4>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.keyperfile.keyperfileconfigurationprovider" target="_blank" rel="noopener"><code>KeyPerFileConfigurationProvider</code></a> 使用目录的文件作为配置键值对。 该键是文件名。 该值包含文件的内容。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>Key-per-file 配置提供程序用于 Docker 托管方案。</p>
</blockquote>
<p>若要激活 Key-per-file 配置，请在 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbuilder" target="_blank" rel="noopener"><code>ConfigurationBuilder</code></a> 的实例上调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.keyperfileconfigurationbuilderextensions.addkeyperfile" target="_blank" rel="noopener">AddKeyPerFile</a> 扩展方法。 文件的 <code>directoryPath</code> 必须是绝对路径。</p>
<p>重载允许指定：</p>
<ul>
<li>配置源的 <code>Action&lt;KeyPerFileConfigurationSource&gt;</code> 委托。</li>
<li>目录是否可选以及目录的路径。</li>
</ul>
<p>双下划线字符 (<code>__</code>) 用作文件名中的配置键分隔符。 例如，文件名 <code>Logging__LogLevel__System</code> 生成配置键 <code>Logging:LogLevel:System</code>。</p>
<p>构建主机时调用 <code>ConfigureAppConfiguration</code> 以指定应用的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">.ConfigureAppConfiguration((hostingContext, config) &#x3D;&gt;<br>&#123;<br>    var path &#x3D; Path.Combine(<br>        Directory.GetCurrentDirectory(), &quot;path&#x2F;to&#x2F;files&quot;);<br>    config.AddKeyPerFile(directoryPath: path, optional: true);<br>&#125;)<br></code></pre></div></td></tr></table></figure>
<h4 id="内存配置提供程序"><a class="header-anchor" href="#内存配置提供程序">¶</a>内存配置提供程序</h4>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.memory.memoryconfigurationprovider" target="_blank" rel="noopener"><code>MemoryConfigurationProvider</code></a> 使用内存中集合作为配置键值对。</p>
<p>若要激活内存中集合配置，请在 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbuilder" target="_blank" rel="noopener"><code>ConfigurationBuilder</code></a> 的实例上调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.memoryconfigurationbuilderextensions.addinmemorycollection" target="_blank" rel="noopener"><code>AddInMemoryCollection</code></a> 扩展方法。</p>
<p>可以使用 <code>IEnumerable&lt;KeyValuePair&lt;String,String&gt;&gt;</code> 初始化配置提供程序。</p>
<p>构建主机时调用 <code>ConfigureAppConfiguration</code> 以指定应用的配置。</p>
<p>在下面的示例中，创建了配置字典：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public static readonly Dictionary&lt;string, string&gt; _dict &#x3D;<br>    new Dictionary&lt;string, string&gt;<br>    &#123;<br>        &#123;&quot;MemoryCollectionKey1&quot;, &quot;value1&quot;&#125;,<br>        &#123;&quot;MemoryCollectionKey2&quot;, &quot;value2&quot;&#125;<br>    &#125;;<br></code></pre></div></td></tr></table></figure>
<p>通过 <code>AddInMemoryCollection</code> 的调用使用字典，以提供配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">.ConfigureAppConfiguration((hostingContext, config) &#x3D;&gt;<br>&#123;<br>    config.AddInMemoryCollection(_dict);<br>&#125;)<br></code></pre></div></td></tr></table></figure>
<h4 id="GetValue"><a class="header-anchor" href="#GetValue">¶</a><code>GetValue</code></h4>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbinder.getvalue" target="_blank" rel="noopener"><code>ConfigurationBinder.GetValueT&lt;&gt;</code></a> 从配置中提取一个具有指定键的值，并将其转换为指定的非集合类型。 重载接受默认值。</p>
<p>如下示例中：</p>
<ul>
<li>使用键 <code>NumberKey</code> 从配置中提取字符串值。 如果在配置键中找不到 <code>NumberKey</code>，则使用默认值 <code>99</code>。</li>
<li>键入值作为 <code>int</code>。</li>
<li>存储 <code>NumberConfig</code> 属性中的值，以供页面使用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class IndexModel : PageModel<br>&#123;<br>    public IndexModel(IConfiguration config)<br>    &#123;<br>        _config &#x3D; config;<br>    &#125;<br><br>    public int NumberConfig &#123; get; private set; &#125;<br><br>    public void OnGet()<br>    &#123;<br>        NumberConfig &#x3D; _config.GetValue&lt;int&gt;(&quot;NumberKey&quot;, 99);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="GetSection、GetChildren-和-Exists"><a class="header-anchor" href="#GetSection、GetChildren-和-Exists">¶</a><code>GetSection</code>、<code>GetChildren</code> 和 <code>Exists</code></h4>
<p>对于下面的示例，请考虑以下 JSON 文件。 在两个节中找到四个键，其中一个包含一对子节：</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"section0"</span>: &#123;<br>    <span class="hljs-attr">"key0"</span>: <span class="hljs-string">"value"</span>,<br>    <span class="hljs-attr">"key1"</span>: <span class="hljs-string">"value"</span><br>  &#125;,<br>  <span class="hljs-attr">"section1"</span>: &#123;<br>    <span class="hljs-attr">"key0"</span>: <span class="hljs-string">"value"</span>,<br>    <span class="hljs-attr">"key1"</span>: <span class="hljs-string">"value"</span><br>  &#125;,<br>  <span class="hljs-attr">"section2"</span>: &#123;<br>    <span class="hljs-attr">"subsection0"</span> : &#123;<br>      <span class="hljs-attr">"key0"</span>: <span class="hljs-string">"value"</span>,<br>      <span class="hljs-attr">"key1"</span>: <span class="hljs-string">"value"</span><br>    &#125;,<br>    <span class="hljs-attr">"subsection1"</span> : &#123;<br>      <span class="hljs-attr">"key0"</span>: <span class="hljs-string">"value"</span>,<br>      <span class="hljs-attr">"key1"</span>: <span class="hljs-string">"value"</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>将文件读入配置时，会创建以下唯一的分层键来保存配置值：</p>
<ul>
<li><code>section0:key0</code></li>
<li><code>section0:key1</code></li>
<li><code>section1:key0</code></li>
<li><code>section1:key1</code></li>
<li><code>section2:subsection0:key0</code></li>
<li><code>section2:subsection0:key1</code></li>
<li><code>section2:subsection1:key0</code></li>
<li><code>section2:subsection1:key1</code></li>
</ul>
<h5 id="GetSection"><a class="header-anchor" href="#GetSection">¶</a><code>GetSection</code></h5>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.iconfiguration.getsection" target="_blank" rel="noopener"><code>IConfiguration.GetSection</code></a> 使用指定的子节键提取配置子节。</p>
<p>若要返回仅包含 <code>section1</code> 中键值对的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.iconfigurationsection" target="_blank" rel="noopener"><code>IConfigurationSection</code></a>，请调用 <code>GetSection</code> 并提供节名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">var configSection &#x3D; _config.GetSection(&quot;section1&quot;);<br></code></pre></div></td></tr></table></figure>
<p><code>configSection</code> 不具有值，只有密钥和路径。</p>
<p>同样，若要获取 <code>section2:subsection0</code> 中键的值，请调用 <code>GetSection</code> 并提供节路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">var configSection &#x3D; _config.GetSection(&quot;section2:subsection0&quot;);<br></code></pre></div></td></tr></table></figure>
<p><code>GetSection</code> 永远不会返回 <code>null</code>。 如果找不到匹配的节，则返回空 <code>IConfigurationSection</code>。</p>
<p>当 <code>GetSection</code> 返回匹配的部分时，<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.iconfigurationsection.value#Microsoft_Extensions_Configuration_IConfigurationSection_Value" target="_blank" rel="noopener"><code>Value</code></a> 未填充。 存在该部分时，返回一个 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.iconfigurationsection.key#Microsoft_Extensions_Configuration_IConfigurationSection_Key" target="_blank" rel="noopener"><code>Key</code></a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.iconfigurationsection.path#Microsoft_Extensions_Configuration_IConfigurationSection_Path" target="_blank" rel="noopener"><code>Path</code></a> 部分。</p>
<h5 id="GetChildren"><a class="header-anchor" href="#GetChildren">¶</a><code>GetChildren</code></h5>
<p>在 <code>section2</code> 上调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.iconfiguration.getchildren" target="_blank" rel="noopener">IConfiguration.GetChildren</a> 会获得 <code>IEnumerable&lt;IConfigurationSection&gt;</code>，其中包括：</p>
<ul>
<li><code>subsection0</code></li>
<li><code>subsection1</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">var configSection &#x3D; _config.GetSection(&quot;section2&quot;);<br><br>var children &#x3D; configSection.GetChildren();<br></code></pre></div></td></tr></table></figure>
<h5 id="Exists"><a class="header-anchor" href="#Exists">¶</a><code>Exists</code></h5>
<p>使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationextensions.exists" target="_blank" rel="noopener"><code>ConfigurationExtensions.Exists</code></a> 确定配置节是否存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">var sectionExists &#x3D; _config.GetSection(&quot;section2:subsection2&quot;).Exists();<br></code></pre></div></td></tr></table></figure>
<p>给定示例数据，<code>sectionExists</code> 为 <code>false</code>，因为配置数据中没有 <code>section2:subsection2</code> 节。</p>
<h4 id="绑定至类"><a class="header-anchor" href="#绑定至类">¶</a>绑定至类</h4>
<p>可以使用选项模式  将配置绑定到表示相关设置组的类。</p>
<p>配置值作为字符串返回，但调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbinder.bind" target="_blank" rel="noopener"><code>Bind</code></a> 可以构造 <a href="https://wikipedia.org/wiki/Plain_Old_CLR_Object" target="_blank" rel="noopener"><code>POCO</code></a> 对象。 绑定器将值绑定到所提供类型的所有公共读取/写入属性。 不会绑定字段  。</p>
<p>示例应用包含 <code>Starship</code> 模型 (<em>Models/Starship.cs</em>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Starship<br>&#123;<br>    public string Name &#123; get; set; &#125;<br>    public string Registry &#123; get; set; &#125;<br>    public string Class &#123; get; set; &#125;<br>    public decimal Length &#123; get; set; &#125;<br>    public bool Commissioned &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>当示例应用使用 JSON 配置提供程序加载配置时，<em>starship.json</em>  文件的 <code>starship</code> 节会创建配置：</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"starship"</span>: &#123;<br>    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"USS Enterprise"</span>,<br>    <span class="hljs-attr">"registry"</span>: <span class="hljs-string">"NCC-1701"</span>,<br>    <span class="hljs-attr">"class"</span>: <span class="hljs-string">"Constitution"</span>,<br>    <span class="hljs-attr">"length"</span>: <span class="hljs-number">304.8</span>,<br>    <span class="hljs-attr">"commissioned"</span>: <span class="hljs-literal">false</span><br>  &#125;,<br>  <span class="hljs-attr">"trademark"</span>: <span class="hljs-string">"Paramount Pictures Corp. http://www.paramount.com"</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>创建以下配置键值对：</p>
<table>
<thead>
<tr>
<th>键</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>starship:name</td>
<td>USS Enterprise</td>
</tr>
<tr>
<td>starship:registry</td>
<td>NCC-1701</td>
</tr>
<tr>
<td>starship:class</td>
<td>Constitution</td>
</tr>
<tr>
<td>starship:length</td>
<td>304.8</td>
</tr>
<tr>
<td>starship:commissioned</td>
<td>False</td>
</tr>
<tr>
<td>trademark</td>
<td>Paramount Pictures Corp. <a href="https://www.paramount.com" target="_blank" rel="noopener">https://www.paramount.com</a></td>
</tr>
</tbody>
</table>
<p>示例应用使用 <code>starship</code> 键调用 <code>GetSection</code>。 <code>starship</code> 键值对是独立的。 在子节传入 <code>Starship</code> 类的实例时调用 <code>Bind</code> 方法。 绑定实例值后，将实例分配给用于呈现的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">var starship &#x3D; new Starship();<br>_config.GetSection(&quot;starship&quot;).Bind(starship);<br>Starship &#x3D; starship;<br></code></pre></div></td></tr></table></figure>
<h4 id="绑定至对象图"><a class="header-anchor" href="#绑定至对象图">¶</a>绑定至对象图</h4>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbinder.bind" target="_blank" rel="noopener"><code>Bind</code></a> 能够绑定整个 POCO 对象图。 与绑定简单对象一样，只绑定公共读取/写入属性。</p>
<p>该示例包含 <code>TvShow</code> 模型，其对象图包含 <code>Metadata</code> 和 <code>Actors</code> 类 (<em>Models/TvShow.cs</em>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class TvShow<br>&#123;<br>    public Metadata Metadata &#123; get; set; &#125;<br>    public Actors Actors &#123; get; set; &#125;<br>    public string Legal &#123; get; set; &#125;<br>&#125;<br><br>public class Metadata<br>&#123;<br>    public string Series &#123; get; set; &#125;<br>    public string Title &#123; get; set; &#125;<br>    public DateTime AirDate &#123; get; set; &#125;<br>    public int Episodes &#123; get; set; &#125;<br>&#125;<br><br>public class Actors<br>&#123;<br>    public string Names &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>示例应用有一个包含配置数据的 <em>tvshow.xml</em>  文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tvshow</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">metadata</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">series</span>&gt;</span>Dr. Who<span class="hljs-tag">&lt;/<span class="hljs-name">series</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>The Sun Makers<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">airdate</span>&gt;</span>11/26/1977<span class="hljs-tag">&lt;/<span class="hljs-name">airdate</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">episodes</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">episodes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">metadata</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">actors</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">names</span>&gt;</span>Tom Baker, Louise Jameson, John Leeson<span class="hljs-tag">&lt;/<span class="hljs-name">names</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">actors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">legal</span>&gt;</span>(c)1977 BBC https://www.bbc.co.uk/programmes/b006q2x0<span class="hljs-tag">&lt;/<span class="hljs-name">legal</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tvshow</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>使用 <code>Bind</code> 方法将配置绑定到整个 <code>TvShow</code> 对象图。 将绑定实例分配给用于呈现的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">var tvShow &#x3D; new TvShow();<br>_config.GetSection(&quot;tvshow&quot;).Bind(tvShow);<br>TvShow &#x3D; tvShow;<br></code></pre></div></td></tr></table></figure>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbinder.get" target="_blank" rel="noopener"><code>ConfigurationBinder.Get</code></a> 绑定并返回指定类型。 <code>Get&lt;T&gt;</code> 比使用 <code>Bind</code> 更方便。 以下代码显示如何将 <code>Get&lt;T&gt;</code> 与前面的示例一起使用，该示例允许将绑定实例直接分配给用于呈现的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">TvShow &#x3D; _config.GetSection(&quot;tvshow&quot;).Get&lt;TvShow&gt;();<br></code></pre></div></td></tr></table></figure>
<h4 id="将数组绑定至类"><a class="header-anchor" href="#将数组绑定至类">¶</a>将数组绑定至类</h4>
<p>示例应用演示了本部分中介绍的概念。</p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbinder.bind" target="_blank" rel="noopener"><code>Bind</code></a> 支持使用配置键中的数组索引将数组绑定到对象。 公开数字键段（<code>:0:</code>、<code>:1:</code>、… <code>:{n}:</code>）的任何数组格式都能够与 POCO 类数组进行数组绑定。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>绑定是按约定提供的。 不需要自定义配置提供程序实现数组绑定。</p>
</blockquote>
<h5 id="内存中数组处理"><a class="header-anchor" href="#内存中数组处理">¶</a>内存中数组处理</h5>
<p>请考虑下表中所示的配置键和值。</p>
<table>
<thead>
<tr>
<th style="text-align:center">键</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">array:entries:0</td>
<td style="text-align:center">value0</td>
</tr>
<tr>
<td style="text-align:center">array:entries:1</td>
<td style="text-align:center">value1</td>
</tr>
<tr>
<td style="text-align:center">array:entries:2</td>
<td style="text-align:center">value2</td>
</tr>
<tr>
<td style="text-align:center">array:entries:4</td>
<td style="text-align:center">value4</td>
</tr>
<tr>
<td style="text-align:center">array:entries:5</td>
<td style="text-align:center">value5</td>
</tr>
</tbody>
</table>
<p>使用内存配置提供程序在示例应用中加载这些键和值：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Program<br>&#123;<br>    public static Dictionary&lt;string, string&gt; arrayDict &#x3D;<br>        new Dictionary&lt;string, string&gt;<br>        &#123;<br>            &#123;&quot;array:entries:0&quot;, &quot;value0&quot;&#125;,<br>            &#123;&quot;array:entries:1&quot;, &quot;value1&quot;&#125;,<br>            &#123;&quot;array:entries:2&quot;, &quot;value2&quot;&#125;,<br>            &#123;&quot;array:entries:4&quot;, &quot;value4&quot;&#125;,<br>            &#123;&quot;array:entries:5&quot;, &quot;value5&quot;&#125;<br>        &#125;;<br><br>    public static void Main(string[] args)<br>    &#123;<br>        CreateHostBuilder(args).Build().Run();<br>    &#125;<br><br>    public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;<br>        Host.CreateDefaultBuilder(args)<br>            .ConfigureAppConfiguration((hostingContext, config) &#x3D;&gt;<br>            &#123;<br>                config.AddInMemoryCollection(arrayDict);<br>                config.AddJsonFile(<br>                    &quot;json_array.json&quot;, optional: false, reloadOnChange: false);<br>                config.AddJsonFile(<br>                    &quot;starship.json&quot;, optional: false, reloadOnChange: false);<br>                config.AddXmlFile(<br>                    &quot;tvshow.xml&quot;, optional: false, reloadOnChange: false);<br>                config.AddEFConfiguration(<br>                    options &#x3D;&gt; options.UseInMemoryDatabase(&quot;InMemoryDb&quot;));<br>                config.AddCommandLine(args);<br>            &#125;)<br>            .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;<br>            &#123;<br>                webBuilder.UseStartup&lt;Startup&gt;();<br>            &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>该数组跳过索引 #3 的值。 配置绑定程序无法绑定 <code>null</code> 值，也无法在绑定对象中创建 <code>null</code> 条目，这在演示将此数组绑定到对象的结果时变得清晰。</p>
<p>在示例应用中，POCO 类可用于保存绑定的配置数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class ArrayExample<br>&#123;<br>    public string[] Entries &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>将配置数据绑定至对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">var arrayExample &#x3D; new ArrayExample();<br>_config.GetSection(&quot;array&quot;).Bind(arrayExample);<br></code></pre></div></td></tr></table></figure>
<p>还可以使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.configuration.configurationbinder.get" target="_blank" rel="noopener"><code>ConfigurationBinder.Get</code></a> 语法，这样会得到更精简的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">ArrayExample &#x3D; _config.GetSection(&quot;array&quot;).Get&lt;ArrayExample&gt;();<br></code></pre></div></td></tr></table></figure>
<p>绑定对象（<code>ArrayExample</code> 的实例）从配置接收数组数据。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>ArrayExample.Entries</code> 索引</th>
<th style="text-align:center"><code>ArrayExample.Entries</code> 值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">value0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">value1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">value2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">value4</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">value5</td>
</tr>
</tbody>
</table>
<p>绑定对象中的索引 #3 保留 <code>array:4</code> 配置键的配置数据及其值 <code>value4</code>。 当绑定包含数组的配置数据时，配置键中的数组索引仅用于在创建对象时迭代配置数据。 无法在配置数据中保留 <code>null</code> 值，并且当配置键中的数组跳过一个或多个索引时，不会在绑定对象中创建 <code>null</code> 值条目。</p>
<p>可以在由任何在配置中生成正确键值对的配置提供程序绑定到 <code>ArrayExample</code> 实例之前提供索引 #3 的缺失配置项。 如果示例包含具有缺失键值对的其他 JSON 配置提供程序，则 <code>ArrayExample.Entries</code> 与完整配置数组相匹配：</p>
<p><em>missing_value.json</em>:</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"array:entries:3"</span>: <span class="hljs-string">"value3"</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在 <code>ConfigureAppConfiguration</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">config.AddJsonFile(<br>    &quot;missing_value.json&quot;, optional: false, reloadOnChange: false);<br></code></pre></div></td></tr></table></figure>
<p>将表中所示的键值对加载到配置中。</p>
<table>
<thead>
<tr>
<th style="text-align:center">键</th>
<th style="text-align:center">“值”</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">array:entries:3</td>
<td style="text-align:center">value3</td>
</tr>
</tbody>
</table>
<p>如果在 JSON 配置提供程序包含索引 #3 的条目之后绑定 <code>ArrayExample</code> 类实例，则 <code>ArrayExample.Entries</code> 数组包含该值。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>ArrayExample.Entries</code> 索引</th>
<th style="text-align:center"><code>ArrayExample.Entries</code> 值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">value0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">value1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">value2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">value3</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">value4</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">value5</td>
</tr>
</tbody>
</table>
<h5 id="JSON-数组处理"><a class="header-anchor" href="#JSON-数组处理">¶</a>JSON 数组处理</h5>
<p>如果 JSON 文件包含数组，则会为具有从零开始的节索引的数组元素创建配置键。 在以下配置文件中，<code>subsection</code> 是一个数组：</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"json_array"</span>: &#123;<br>    <span class="hljs-attr">"key"</span>: <span class="hljs-string">"valueA"</span>,<br>    <span class="hljs-attr">"subsection"</span>: [<br>      <span class="hljs-string">"valueB"</span>,<br>      <span class="hljs-string">"valueC"</span>,<br>      <span class="hljs-string">"valueD"</span><br>    ]<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>JSON 配置提供程序将配置数据读入以下键值对：</p>
<table>
<thead>
<tr>
<th>键</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td>json_array:key</td>
<td style="text-align:center">valueA</td>
</tr>
<tr>
<td>json_array:subsection:0</td>
<td style="text-align:center">valueB</td>
</tr>
<tr>
<td>json_array:subsection:1</td>
<td style="text-align:center">valueC</td>
</tr>
<tr>
<td>json_array:subsection:2</td>
<td style="text-align:center">valueD</td>
</tr>
</tbody>
</table>
<p>在示例应用中，以下 POCO 类可用于绑定配置键值对：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class JsonArrayExample<br>&#123;<br>    public string Key &#123; get; set; &#125;<br>    public string[] Subsection &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>绑定后，<code>JsonArrayExample.Key</code> 保存值 <code>valueA</code>。 子节值存储在 POCO 数组属性 <code>Subsection</code> 中。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>JsonArrayExample.Subsection</code> 索引</th>
<th style="text-align:center"><code>JsonArrayExample.Subsection</code> 值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">valueB</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">valueC</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">valueD</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>.NETCore</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP 学习笔记</title>
    <url>/2020/12/04/Spring-AOP-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>Spring AOP 学习笔记</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="一、概述"><a class="header-anchor" href="#一、概述">¶</a>一、概述</h2>
<ul>
<li>设计模式：代理模式。</li>
<li>基本概念：
<ul>
<li><strong>Aspect（切面）</strong>：即一个横跨多个核心逻辑的功能，或者称之为 <strong>系统关注点</strong>。<span style="border-width: 0 0 3px 0; border-style: double">（对哪些方法进行拦截，拦截后怎么处理）</span>；</li>
<li><strong>Joinpoint（连接点）</strong>：即定义在应用程序流程的何处插入切面的执行。<span style="border-width: 0 0 3px 0; border-style: double">（被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring 中连接点指的就是被拦截到的 <strong>方法</strong>，实际上连接点还可以是字段或者构造器）</span>；</li>
<li><strong>Pointcut（切入点）</strong>：即一组连接点的集合。<span style="border-width: 0 0 3px 0; border-style: double">（对连接点进行拦截的定义，即 Pointcut 表达式所影响的范围）</span>；</li>
<li><strong>Advice（增强）</strong>：指特定连接点上执行的动作。<span style="border-width: 0 0 3px 0; border-style: double">（即 Pointcut 表达式修改的方法）</span>；</li>
<li><strong>Introduction（引介、引入）</strong>：指为一个已有的 Java 对象动态地增加新的接口。<span style="border-width: 0 0 3px 0; border-style: double">（在不修改代码的前提下，引入可以在 <strong>运行期</strong> 为类 <strong>动态</strong> 地添加一些方法或字段）</span>；</li>
<li><strong>Weaving（织入）</strong>：指将切面整合到程序的执行流程中。<span style="border-width: 0 0 3px 0; border-style: double">（将切面应用到目标对象并导致代理对象创建的 <strong>过程</strong>）</span>；</li>
<li><strong>Interceptor（拦截器）</strong>：是一种实现增强的方式；</li>
<li><strong>Target Object（目标对象）</strong>：即真正执行业务的核心逻辑对象。<span style="border-width: 0 0 3px 0; border-style: double">（代理的目标对象）</span>；</li>
<li><strong>AOP Proxy（AOP 代理）</strong>：是客户端持有的增强后的对象引用。</li>
</ul>
</li>
<li>在 Java 平台上，对于 AOP 的织入，有 3 种方式：
<ol>
<li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ 就扩展了 Java 编译器，使用关键字 <code>aspect</code> 来实现织入；</li>
<li>类加载器：在目标类被装载到 JVM 时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li>
<li>运行期：目标对象和切面都是普通 Java 类，通过 JVM 的动态代理功能或者第三方库实现运行期动态织入。</li>
</ol>
</li>
</ul>
<h2 id="二、装配-AOP"><a class="header-anchor" href="#二、装配-AOP">¶</a>二、装配 AOP</h2>
<p>首先，我们通过 Maven 引入 Spring 对 AOP 的支持：</p>
<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<h3 id="1-切面定义"><a class="header-anchor" href="#1-切面定义">¶</a>1. 切面定义</h3>
<p>首先，我们定义一个 <code>LoggingAspect</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggingAspect</span> </span>&#123;<br>    <span class="hljs-comment">// 在执行UserService的每个方法前执行:</span><br>    <span class="hljs-meta">@Before</span>(<span class="hljs-string">"execution(public * com.itranswarp.learnjava.service.UserService.*(..))"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAccessCheck</span><span class="hljs-params">()</span> </span>&#123;<br>        System.err.println(<span class="hljs-string">"[Before] do access check..."</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在执行MailService的每个方法前后执行:</span><br>    <span class="hljs-meta">@Around</span>(<span class="hljs-string">"execution(public * com.itranswarp.learnjava.service.MailService.*(..))"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doLogging</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.err.println(<span class="hljs-string">"[Around] start "</span> + pjp.getSignature());<br>        Object retVal = pjp.proceed();<br>        System.err.println(<span class="hljs-string">"[Around] done "</span> + pjp.getSignature());<br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>
<p>观察 <code>doAccessCheck()</code> 方法，我们定义了一个 <code>@Before</code> 注解，后面的字符串是告诉 AspectJ 应该在何处执行该方法，这里写的意思是：执行 <code>UserService</code> 的每个 <code>public</code> 方法前执行 <code>doAccessCheck()</code> 代码。</p>
</li>
<li>
<p>再观察 <code>doLogging()</code> 方法，我们定义了一个 <code>@Around</code> 注解，它和 <code>@Before</code> 不同，<code>@Around</code> 可以决定是否执行目标方法，因此，我们在 <code>doLogging()</code> 内部先打印日志，再调用方法，最后打印日志后返回结果。</p>
</li>
</ul>
<p>在 <code>LoggingAspect</code> 类的声明处，除了用 <code>@Component</code> 表示它本身也是一个 Bean 外，我们再加上 <code>@Aspect</code> 注解，表示它的 <code>@Before</code> 标注的方法需要注入到 <code>UserService</code> 的每个 <code>public</code> 方法执行前，<code>@Around</code> 标注的方法需要注入到 <code>MailService</code> 的每个 <code>public</code> 方法执行前后。</p>
<h3 id="2-装配-AOP"><a class="header-anchor" href="#2-装配-AOP">¶</a>2. 装配 AOP</h3>
<p>紧接着，我们需要给 <code>@Configuration</code> 类加上一个 <code>@EnableAspectJAutoProxy</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>Spring 的 IoC 容器看到这个注解，就会自动查找带有 <code>@Aspect</code> 的 Bean，然后根据每个方法的 <code>@Before</code>、<code>@Around</code> 等注解把 AOP 注入到特定的 Bean 中。执行代码，我们可以看到以下输出：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-attr">[Before]</span> <span class="hljs-selector-tag">do</span> <span class="hljs-selector-tag">access</span> <span class="hljs-selector-tag">check</span>...<br><span class="hljs-selector-attr">[Around]</span> <span class="hljs-selector-tag">start</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.itranswarp</span><span class="hljs-selector-class">.learnjava</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.MailService</span><span class="hljs-selector-class">.sendRegistrationMail</span>(<span class="hljs-selector-tag">User</span>)<br><span class="hljs-selector-tag">Welcome</span>, <span class="hljs-selector-tag">test</span>!<br><span class="hljs-selector-attr">[Around]</span> <span class="hljs-selector-tag">done</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.itranswarp</span><span class="hljs-selector-class">.learnjava</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.MailService</span><span class="hljs-selector-class">.sendRegistrationMail</span>(<span class="hljs-selector-tag">User</span>)<br><span class="hljs-selector-attr">[Before]</span> <span class="hljs-selector-tag">do</span> <span class="hljs-selector-tag">access</span> <span class="hljs-selector-tag">check</span>...<br><span class="hljs-selector-attr">[Around]</span> <span class="hljs-selector-tag">start</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.itranswarp</span><span class="hljs-selector-class">.learnjava</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.MailService</span><span class="hljs-selector-class">.sendLoginMail</span>(<span class="hljs-selector-tag">User</span>)<br><span class="hljs-selector-tag">Hi</span>, <span class="hljs-selector-tag">Bob</span>! <span class="hljs-selector-tag">You</span> <span class="hljs-selector-tag">are</span> <span class="hljs-selector-tag">logged</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">at</span> 2020<span class="hljs-selector-tag">-02-14T23</span><span class="hljs-selector-pseudo">:13</span><span class="hljs-selector-pseudo">:52.167996+08</span><span class="hljs-selector-pseudo">:00</span><span class="hljs-selector-attr">[Asia/Shanghai]</span><br><span class="hljs-selector-attr">[Around]</span> <span class="hljs-selector-tag">done</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.itranswarp</span><span class="hljs-selector-class">.learnjava</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.MailService</span><span class="hljs-selector-class">.sendLoginMail</span>(<span class="hljs-selector-tag">User</span>)<br></code></pre></div></td></tr></table></figure>
<h4 id="拦截器类型"><a class="header-anchor" href="#拦截器类型">¶</a>拦截器类型</h4>
<p>顾名思义，拦截器有以下类型：</p>
<ul>
<li>
<p><code>@Before</code>：这种拦截器先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；</p>
</li>
<li>
<p><code>@After</code>：这种拦截器先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；</p>
</li>
<li>
<p><code>@AfterReturning</code>：和 <code>@After</code> 不同的是，只有当目标代码正常返回时，才执行拦截器代码；</p>
</li>
<li>
<p><code>@AfterThrowing</code>：和 <code>@After</code> 不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；</p>
</li>
<li>
<p><code>@Around</code>：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能。</p>
</li>
</ul>
<h2 id="三、Pointcut-表达式"><a class="header-anchor" href="#三、Pointcut-表达式">¶</a>三、Pointcut 表达式</h2>
<h3 id="1-表达式类型"><a class="header-anchor" href="#1-表达式类型">¶</a>1. 表达式类型</h3>
<p>标准的 AspectJ AOP 的 Pointcut 的表达式类型是很丰富的，但是 Spring AOP 只支持其中的 9 种，外加 Spring AOP 自己扩充的一种一共是 10 种类型的表达式，分别如下：</p>
<ul>
<li><strong><code>execution</code></strong>：一般用于指定方法的执行，用的最多。</li>
<li><strong><code>within</code></strong>：指定某些类型的全部方法执行，也可用来指定一个包。</li>
<li><strong><code>this</code></strong>：Spring AOP 是基于代理的，生成的 Bean 也是一个代理对象，<code>this</code> 就是这个代理对象，当这个对象可以转换为指定的类型时，对应的切入点就是它了，Spring AOP 将生效。</li>
<li><strong><code>target</code></strong>：当被代理的对象可以转换为指定的类型时，对应的切入点就是它了，Spring AOP 将生效。</li>
<li><strong><code>args</code></strong>：当执行的方法的参数是指定类型时生效。</li>
<li><strong><code>@target</code></strong>：当代理的目标对象上拥有指定的注解时生效。</li>
<li><strong><code>@args</code></strong>：当执行的方法参数类型上拥有指定的注解时生效。</li>
<li><strong><code>@within</code></strong>：与 <code>@target</code> 类似，看官方文档和网上的说法都是 <code>@within</code> 只需要目标对象的类或者父类上有指定的注解，则 <code>@within</code> 会生效，而 <code>@target</code> 则是必须是目标对象的类上有指定的注解。而根据笔者的测试这两者都是只要目标类或父类上有指定的注解即可。</li>
<li><strong><code>@annotation</code></strong>：当执行的方法上拥有指定的注解时生效。</li>
<li><strong><code>bean</code></strong>：当调用的方法是指定的 Bean 的方法时生效。</li>
</ul>
<h3 id="2-使用示例"><a class="header-anchor" href="#2-使用示例">¶</a>2. 使用示例</h3>
<h4 id="execution"><a class="header-anchor" href="#execution">¶</a><code>execution</code></h4>
<p><code>execution</code> 是使用的最多的一种 Pointcut 表达式，表示某个方法的执行，其标准语法如下：</p>
<figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">execution(modifiers-<span class="hljs-built_in">pattern</span>? ret-type-<span class="hljs-built_in">pattern</span> declaring-type-<span class="hljs-built_in">pattern</span>? name-<span class="hljs-built_in">pattern</span>(param-<span class="hljs-built_in">pattern</span>) throws-<span class="hljs-built_in">pattern</span>?)<br></code></pre></div></td></tr></table></figure>
<ul>
<li><code>modifiers-pattern</code> 表示方法的访问类型，<code>public</code> 等；</li>
<li><code>ret-type-pattern</code> 表示方法的返回值类型，如 <code>String</code> 表示返回类型是<code>String</code>，<code>*</code> 表示所有的返回类型；</li>
<li><code>declaring-type-pattern</code> 表示方法的声明类，如 <code>com.elim..*</code> 表示<code>com.elim</code> 包及其子包下面的所有类型；</li>
<li><code>name-pattern</code> 表示方法的名称，如 <code>add*</code> 表示所有以 <code>add</code> 开头的方法名；</li>
<li><code>param-pattern</code>表示方法参数的类型，<code>name-pattern(param-pattern)</code> 其实是一起的表示的方法集对应的参数类型，如 <code>add()</code> 表示不带参数的 <code>add</code> 方法，<code>add(*)</code> 表示带一个任意类型的参数的 <code>add</code> 方法，<code>add(*,String)</code> 则表示带两个参数，且第二个参数是 <code>String</code> 类型的 <code>add</code> 方法；</li>
<li><code>throws-pattern</code> 表示异常类型；</li>
<li>其中以问号结束的部分都是可以省略的。</li>
</ul>
<p>例如：</p>
<ul>
<li><code>execution(* add())</code> 匹配所有的不带参数的 <code>add()</code> 方法。</li>
<li><code>execution(public * com.elim..*.add*(..))</code> 匹配所有 <code>com.elim</code> 包及其子包下所有类的以 <code>add</code> 开头的所有 <code>public</code> 方法。</li>
<li><code>execution(* *(..) throws Exception)</code> 匹配所有抛出 <code>Exception</code> 的方法。</li>
</ul>
<h4 id="within"><a class="header-anchor" href="#within">¶</a><code>within</code></h4>
<p><code>within</code> 是用来指定类型的，指定类型中的所有方法将被拦截。如：</p>
<ul>
<li><code>within(com.elim.spring.aop.service.UserServiceImpl)</code> 匹配<code>UserServiceImpl</code> 类对应对象的所有方法外部调用，而且这个对象只能是 <code>UserServiceImpl</code> 类型，不能是其子类型。</li>
<li><code>within(com.elim..*)</code>” 匹配 <code>com.elim</code> 包及其子包下面所有的类的所有方法的外部调用。</li>
</ul>
<h4 id="this"><a class="header-anchor" href="#this">¶</a><code>this</code></h4>
<p>Spring AOP 是基于代理的，<code>this</code> 就表示代理对象。<code>this</code> 类型的 Pointcut 表达式的语法是 <code>this(type)</code>，当生成的代理对象可以转换为 <code>type</code> 指定的类型时则表示匹配。基于 JDK 接口的代理和基于 CGLIB 的代理生成的代理对象是不一样的。如：</p>
<ul>
<li><code>this(com.elim.spring.aop.service.IUserService)</code> 匹配生成的代理对象是 <code>IUserService</code> 类型的所有方法的外部调用。</li>
</ul>
<h4 id="target"><a class="header-anchor" href="#target">¶</a><code>target</code></h4>
<p>Spring AOP 是基于代理的，<code>target</code> 则表示被代理的目标对象。当被代理的目标对象可以被转换为指定的类型时则表示匹配。如：</p>
<ul>
<li><code>target(com.elim.spring.aop.service.IUserService)</code> 则匹配所有被代理的目标对象能够转换为 <code>IUserService</code> 类型的所有方法的外部调用。</li>
</ul>
<h4 id="args"><a class="header-anchor" href="#args">¶</a><code>args</code></h4>
<p><code>args</code> 用来匹配方法参数的。如：</p>
<ul>
<li><code>args()</code> 匹配任何不带参数的方法。</li>
<li><code>args(java.lang.String)</code> 匹配任何只带一个参数，而且这个参数的类型是 <code>String</code> 的方法。</li>
<li><code>args(..)</code> 带任意参数的方法。</li>
<li><code>args(java.lang.String,..)</code> 匹配带任意个参数，但是第一个参数的类型是 <code>String</code> 的方法。</li>
<li><code>args(..,java.lang.String)</code> 匹配带任意个参数，但是最后一个参数的类型是 <code>String</code> 的方法。</li>
</ul>
<h4 id="target-v2"><a class="header-anchor" href="#target-v2">¶</a><code>@target</code></h4>
<p><code>@target</code> 匹配当被代理的目标对象对应的类型及其父类型上拥有指定的注解时。如：</p>
<ul>
<li><code>@target(com.elim.spring.support.MyAnnotation)</code> 匹配被代理的目标对象对应的类型上拥有 <code>MyAnnotation</code> 注解时。</li>
</ul>
<h4 id="args-v2"><a class="header-anchor" href="#args-v2">¶</a><code>@args</code></h4>
<p><code>@args</code> 匹配被调用的方法上含有参数，且对应的参数类型上拥有指定的注解的情况。如：</p>
<ul>
<li><code>@args(com.elim.spring.support.MyAnnotation)</code> 匹配方法参数类型上拥有 <code>MyAnnotation</code> 注解的方法调用。如我们有一个方法 <code>add(MyParam  param)</code> 接收一个 <code>MyParam</code> 类型的参数，而 <code>MyParam</code> 这个类是拥有注解 <code>MyAnnotation</code> 的，则它可以被 Pointcut 表达式 “、<code>@args(com.elim.spring.support.MyAnnotation)</code> 匹配上。</li>
</ul>
<h4 id="within-v2"><a class="header-anchor" href="#within-v2">¶</a><code>@within</code></h4>
<p><code>@within</code> 用于匹配被代理的目标对象对应的类型或其父类型拥有指定的注解的情况，但只有在调用拥有指定注解的类上的方法时才匹配。如：</p>
<ul>
<li><code>@within(com.elim.spring.support.MyAnnotation)</code> 匹配被调用的方法声明的类上拥有 <code>MyAnnotation</code> 注解的情况。比如有一个 <code>ClassA</code> 上使用了注解 <code>MyAnnotation</code> 标注，并且定义了一个方法 <code>a()</code>，那么在调用 <code>ClassA.a()</code> 方法时将匹配该 Pointcut；如果有一个 <code>ClassB</code> 上没有 <code>MyAnnotation</code> 注解，但是它继承自 <code>ClassA</code>，同时它上面定义了一个方法 <code>b()</code>，那么在调用 <code>ClassB().b()</code> 方法时不会匹配该 Pointcut，但是在调用 <code>ClassB().a()</code> 时将匹配该方法调用，因为 <code>a()</code> 是定义在父类型 <code>ClassA</code> 上的，且 <code>ClassA</code> 上使用了 <code>MyAnnotation</code> 注解。但是如果子类 <code>ClassB</code> 覆写了父类 <code>ClassA</code> 的 <code>a()</code> 方法，则调用 <code>ClassB.a()</code> 方法时也不匹配该 Pointcut。</li>
</ul>
<h4 id="annotation"><a class="header-anchor" href="#annotation">¶</a><code>@annotation</code></h4>
<p><code>@annotation</code> 用于匹配方法上拥有指定注解的情况。如：</p>
<ul>
<li><code>@annotation(com.elim.spring.support.MyAnnotation)</code> 匹配所有的方法上拥有 <code>MyAnnotation</code> 注解的方法外部调用。</li>
</ul>
<h4 id="bean"><a class="header-anchor" href="#bean">¶</a><code>bean</code></h4>
<p><code>bean</code> 用于匹配当调用的是指定的 Spring 的某个 Bean 的方法时。</p>
<ul>
<li><code>bean(abc)</code> 匹配 Spring Bean 容器中 id 或 name 为 <code>abc</code> 的 Bean 的方法调用。</li>
<li><code>bean(user*)</code> 匹配所有 id 或 name 为以 <code>user</code> 开头的 Bean 的方法调用。</li>
</ul>
<h3 id="3-表达式组合"><a class="header-anchor" href="#3-表达式组合">¶</a>3. 表达式组合</h3>
<p>表达式的组合其实就是对应的表达式的逻辑运算，与、或、非。可以通过它们把多个表达式组合在一起。</p>
<ul>
<li><code>bean(userService) &amp;&amp; args()</code> 匹配 id 或 name 为 <code>userService</code> 的 Bean 的所有无参方法。</li>
<li><code>bean(userService) || @annotation(MyAnnotation)</code> 匹配 id 或 name 为 <code>userService</code> 的 Bean 的方法调用，或者是方法上使用了 <code>MyAnnotation</code> 注解的方法调用。</li>
<li><code>bean(userService) &amp;&amp; !args()</code> 匹配 id 或 name 为 <code>userService</code> 的 Bean 的所有有参方法调用。</li>
</ul>
<h3 id="4-基于-AspectJ-注解的-Pointcut-表达式应用"><a class="header-anchor" href="#4-基于-AspectJ-注解的-Pointcut-表达式应用">¶</a>4. 基于 AspectJ 注解的 Pointcut 表达式应用</h3>
<p>在使用基于 AspectJ 注解的 Spring AOP 时，我们可以把通过 <code>@Pointcut</code> 注解定义 Pointcut，指定其表达式，然后在需要使用 Pointcut 表达式的时候直接指定 Pointcut。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br><br>    <span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* add(..))"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeAdd</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-meta">@Before</span>(<span class="hljs-string">"beforeAdd()"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"-----------before-----------"</span>);<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面的代码中我们就是在 <code>@Before()</code> 中直接指定使用当前类定义的 <code>beforeAdd()</code> 方法对应的 Pointcut 的表达式，如果我们需要指定的 Pointcut 定义不是在当前类中的，我们需要加上类名称，如下面这个示例中引用的就是定义在 <code>MyService</code> 中的 <code>add()</code> 方法上的 Pointcut 的表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-meta">@Before</span>(<span class="hljs-string">"com.elim.spring.aop.service.MyService.add()"</span>)<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before2</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">"-----------before2-----------"</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>当然了，除了通过引用 Pointcut 定义间接的引用其对应的 Pointcut 表达式外，我们也可以直接使用 Pointcut 表达式的，如下面这个示例就直接在 <code>@Before</code> 中使用了 Pointcut 表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所有的add方法的外部执行时</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Before</span>(<span class="hljs-string">"execution(* add())"</span>)<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeExecution</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">"-------------before execution---------------"</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="四、Spring-AOP-原理"><a class="header-anchor" href="#四、Spring-AOP-原理">¶</a>四、Spring AOP 原理</h2>
<p>其实 AOP 的原理非常简单。我们以 <code>LoggingAspect.doAccessCheck()</code> 为例，要把它注入到 <code>UserService</code> 的每个 <code>public</code> 方法中，最简单的方法是编写一个子类，并持有原始实例的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> UserServiceAopProxy extends UserService &#123;<br>    <span class="hljs-keyword">private</span> UserService target;<br>    <span class="hljs-keyword">private</span> LoggingAspect aspect;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserServiceAopProxy</span><span class="hljs-params">(UserService target, LoggingAspect aspect)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>        <span class="hljs-keyword">this</span>.aspect = aspect;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">login</span><span class="hljs-params">(String email, String password)</span> </span>&#123;<br>        <span class="hljs-comment">// 先执行Aspect的代码:</span><br>        aspect.doAccessCheck();<br>        <span class="hljs-comment">// 再执行UserService的逻辑:</span><br>        <span class="hljs-keyword">return</span> target.login(email, password);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">register</span><span class="hljs-params">(String email, String password, String name)</span> </span>&#123;<br>        aspect.doAccessCheck();<br>        <span class="hljs-keyword">return</span> target.register(email, password, name);<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这些都是 Spring 容器启动时为我们自动创建的注入了 Aspect 的子类，它取代了原始的 <code>UserService</code>（原始的 <code>UserService</code> 实例作为内部变量隐藏在 <code>UserServiceAopProxy</code> 中）。如果我们打印从 Spring 容器获取的 <code>UserService</code> 实例类型，它类似 <code>UserService$$EnhancerBySpringCGLIB$$1f44e01c</code>，实际上是 Spring 使用 CGLIB 动态创建的子类，但对于调用方来说，感觉不到任何区别。</p>
<p>Spring 对接口类型使用 JDK 动态代理，对普通类使用 CGLIB 创建子类。如果一个Bean 的 class 是 <code>final</code>，Spring 将无法为其创建子类。</p>
<blockquote>
<p>参考资料：</p>
<hr>
<ul>
<li><a href="https://blog.csdn.net/elim168/article/details/78150438" target="_blank" rel="noopener">elim168 . Spring  Aop（三）——Pointcut表达式介绍 [EB/OL] . https://blog.csdn.net/elim168/article/details/78150438</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1310052352786466" target="_blank" rel="noopener">廖雪峰 . Java教程 [EB/OL] . https://www.liaoxuefeng.com/wiki/1252599548343744/1310052352786466</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Web</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 下 138a:0090、138a:0097 和 06cb:009a 指纹识别器驱动及指纹认证</title>
    <url>/2020/07/15/Ubuntu-%E4%B8%8B-138a0090%E3%80%81138a0097-%E5%92%8C-06cb009a-%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E5%99%A8%E9%A9%B1%E5%8A%A8%E5%8F%8A%E6%8C%87%E7%BA%B9%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h1>Ubuntu 下 <code>138a:0090</code>、<code>138a:0097</code> 和 <code>06cb:009a</code> 指纹识别器驱动及指纹认证</h1>
<p><code>06cb:009a</code> (Thinkpad L480、Thinkpad L580 及 Thinkpad T480 等设备所使用的指纹设备) 在 Ubuntu 20.04 和 Kubuntu 20.04 下测试通过。</p>
<h2 id="1、安装驱动及-open-fprintd"><a class="header-anchor" href="#1、安装驱动及-open-fprintd">¶</a>1、安装驱动及 open-fprintd</h2>
<p>项目地址：<a href="https://github.com/uunicorn/python-validity" target="_blank" rel="noopener">https://github.com/uunicorn/python-validity</a></p>
<ol>
<li>
<p>卸载系统自带的 fprintd。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo apt remove fprintd<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>添加 open-fprintd 软件源。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo add-apt-repository ppa:uunicorn:open-fprintd<br>$ sudo apt update<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>安装 open-fprintd、fprintd 客户端及 python3-validity (驱动程序)。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo apt install open-fprintd fprintd-clients python3-validity<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>注册指纹，此处需将同一指纹进行多次录入。如要录入多个指纹，再运行此命令即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ fprintd-enroll<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>如果注册指纹报错，可能需要运行下面命令将指纹识别器重置成出厂设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /usr/share/python3-validity/playground<br>$ python3 ./factory-reset.py<br></code></pre></div></td></tr></table></figure>
</blockquote>
<h2 id="2、设置指纹登录"><a class="header-anchor" href="#2、设置指纹登录">¶</a>2、设置指纹登录</h2>
<blockquote>
<p><strong>提示</strong>：</p>
<hr>
<p>项目已更新自动注册程序，指纹登录和其它基本指纹认证 (如第三步的 <code>su</code> 和 <code>sudo</code> 认证等) 可以在 <strong>注册指纹后</strong> 使用如下命令自动添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo pam-auth-update<br></code></pre></div></td></tr></table></figure>
</blockquote>
<p>Gnome “设置” -&gt; “用户” -&gt; “指纹登录” -&gt; “启用”。</p>
<h2 id="3、设置其它指纹认证"><a class="header-anchor" href="#3、设置其它指纹认证">¶</a>3、设置其它指纹认证</h2>
<ol>
<li>
<p><code>su</code> 指纹认证。</p>
<p>编辑 <em>/etc/pam.d/su</em> 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo vim /etc/pam.d/su<br></code></pre></div></td></tr></table></figure>
<p>在文件开始处加入：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">auth</span> <span class="hljs-selector-tag">sufficient</span> <span class="hljs-selector-tag">pam_fprintd</span><span class="hljs-selector-class">.so</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>sudo</code> 指纹认证。</p>
<p>编辑 <em>/etc/pam.d/sudo</em> 文件：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo vim /etc/pam.d/sudo<br></code></pre></div></td></tr></table></figure>
<p>在文件开始处加入：</p>
 <figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">auth</span> <span class="hljs-selector-tag">sufficient</span> <span class="hljs-selector-tag">pam_fprintd</span><span class="hljs-selector-class">.so</span><br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><strong>常见异常</strong>：</p>
<hr>
<p>如果 <code>fprintd-enroll</code> 命令返回 <code>list_devices failed:</code> 异常，那么请使用 <code>$ sudo systemctl status python3-validity</code> 查看 python3-validity 守护进程运行状态，如果未运行，则根据状态信息选择使用 <code>$ sudo systemctl enable python3-validity</code> 或 <code>$ sudo systemctl start python3-validity</code> 启用或启动守护进程。</p>
<p>如果上一步守护进程状态显示 python3-validity 守护启动过程中发生错误，那么可能需要将指纹芯片恢复出厂设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo systemctl stop python3-validity<br>$ sudo validity-sensors-firmware<br>$ sudo python3 /usr/share/python-validity/playground/factory-reset.py<br><br><span class="hljs-comment"># 上述步骤中可以会出现"device busy"异常，此时需要根据 systemctl 状态信息杀死相关进程，或重新运行 systemctl stop python3-validity 命令以防止其已重新运行或杀死其它相关进程。</span><br><br>$ sudo systemctl start python3-validity<br>$ fprintd-enroll<br></code></pre></div></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>疑难</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
        <tag>疑难</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 下 Wine 安装并运行微信</title>
    <url>/2020/07/15/Ubuntu-%E4%B8%8B-Wine-%E5%AE%89%E8%A3%85%E5%B9%B6%E8%BF%90%E8%A1%8C%E5%BE%AE%E4%BF%A1/</url>
    <content><![CDATA[<h1>Ubuntu 下 Wine 安装并运行微信</h1>
<ol>
<li>
<p>安装 wine：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo apt install wine<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>配置 wine：</p>
<ul>
<li>
<p>运行 winecfg：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ winecfg<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>“应用程序”标签中，“Windows 版本”选择”Windows 7“。</p>
<p><img src="/images/Wine-Wechat/1.png" alt="图1"></p>
</li>
<li>
<p>”函数库“标签中，依图中所示添加函数库顶替：</p>
<p><img src="/images/Wine-Wechat/2.png" alt="图2"></p>
<blockquote>
<p><strong>说明</strong></p>
<hr>
<ul>
<li>
<p>如果不配置 riched20 和 riched32 的话则安装好后微信或 TIM 后无法输入用户名。</p>
</li>
<li>
<p>不停用 txplatform.exe 则微信或 TIM 无法完整退出，导致关掉重开后提示文件被占用。</p>
</li>
<li>
<p>禁用 ntoskrnl.exe 是为了规避可能出现微信 或 TIM 无法启动的 bug。</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>”显示“标签中，屏幕分辨率设置为 120。(可选，主要解决 hidpi 笔记本文字过小问题)</p>
<p><img src="/images/Wine-Wechat/3.png" alt="图3"></p>
</li>
<li>
<p>拷贝喜欢的中文字体至 <em>$HOME/.wine/drive_c/windows/Fonts</em> 下，以 Noto Sans CJK Regular 为例 (文件名为 <em>NotoSansCJK-Regular.ttc</em>)。</p>
</li>
<li>
<p>新建 <em>fonts.reg</em> 文件，内容如下：</p>
<figure class="highlight moonscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs moonscript">REGEDIT4<br> <br>[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink]<br><span class="hljs-string">"Lucida Sans Unicode"</span>=<span class="hljs-string">"NotoSansCJK-Regular.ttc"</span><br><span class="hljs-string">"Microsoft Sans Serif"</span>=<span class="hljs-string">"NotoSansCJK-Regular.ttc"</span><br><span class="hljs-string">"MS Sans Serif"</span>=<span class="hljs-string">"NotoSansCJK-Regular.ttc"</span><br><span class="hljs-string">"Tahoma"</span>=<span class="hljs-string">"NotoSansCJK-Regular.ttc"</span><br><span class="hljs-string">"Tahoma Bold"</span>=<span class="hljs-string">"NotoSansCJK-Regular.ttc"</span><br><span class="hljs-string">"SimSun"</span>=<span class="hljs-string">"NotoSansCJK-Regular.ttc"</span><br><span class="hljs-string">"Arial"</span>=<span class="hljs-string">"NotoSansCJK-Regular.ttc"</span><br><span class="hljs-string">"Arial Black"</span>=<span class="hljs-string">"NotoSansCJK-Regular.ttc"</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>运行 Wine 的注册表编辑器：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ wine regedit<br></code></pre></div></td></tr></table></figure>
<p>并将 <em>fonts.reg</em> 导入注册表。</p>
</li>
<li>
<p><strong>下载 Windows 7 系统的 <em>riched20.dll</em> (<span style="border-bottom: 3px black double">32 位</span>) 和  <em>riched32.dll</em> (<span style="border-bottom: 3px black double">32 位</span>)，替换 <em>$HOME/.wine/drive_c/windows/<span style="border-bottom: 3px black double">syswow64</span></em> 下同名文件。</strong></p>
<blockquote>
<p><strong>注意</strong></p>
<hr>
<p>本步可解决微信输入文字无法显示的问题。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>疑难</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
        <tag>疑难</tag>
      </tags>
  </entry>
  <entry>
    <title>Entity Framework Core 3.1 教程</title>
    <url>/2020/04/18/Entity-Framework-Core-3.1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>Entity Framework Core 3.1 教程</h1>
<h2 id="一、Entity-Framework-Core-简介"><a class="header-anchor" href="#一、Entity-Framework-Core-简介">¶</a>一、Entity Framework Core 简介</h2>
<h3 id="EF-Core-开发方法"><a class="header-anchor" href="#EF-Core-开发方法">¶</a>EF Core 开发方法</h3>
<p>EF Core 支持两种开发方法：</p>
<ul>
<li>
<p>Code-First (代码优先)：在 Code-First 方法中，EF Core API 会根据你的代码中的领域模型中提供的约定和配置，使用迁移来创建数据库和表。此方法在领域驱动设计 (DDD) 中很有用。</p>
</li>
<li>
<p>Database-First (数据库优先)：在 Database-First 方法中，EF Core API 使用 EF Core 命令基于现有数据库创建领域模型和数据库上下文 (DbContext) 类。由于它不支持可视设计器或向导，因此在 EF Core 中的支持有限。</p>
</li>
</ul>
<p>EF  Core 主要针对 Code-First 方法，很少提供对 Database-First 方法的支持，因为从 EF Core  2.0 开始不支持可视化的 DB 模型设计器或向导。</p>
<h2 id="二、安装-Entity-Framework-Core"><a class="header-anchor" href="#二、安装-Entity-Framework-Core">¶</a>二、安装 Entity Framework Core</h2>
<p>EF Core 不是 .NET Core 和标准 .NET 框架的一部分。它以 NuGet 软件包的形式提供。您需要在应用程序中安装两个 NuGet 软件包，才能在应用程序中使用 EF Core：</p>
<ul>
<li>EF Core DB Provider</li>
<li>EF Core Tools</li>
</ul>
<p>EF Core 的安装步骤：</p>
<ol>
<li>
<p>新建新项目，如空控制台项目：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; mkdir EFCoreTutorials<br>PM&gt; cd EFCoreTutorials<br>PM&gt; dotnet new console<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>安装 EF Core DB Provider，以 SQL Server 为例，其它 Provider 参考 <a href="https://docs.microsoft.com/zh-cn/ef/core/providers/?tabs=dotnet-core-cli" target="_blank" rel="noopener">EF Core Provider 列表</a>：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; dotnet add package Microsoft.EntityFrameworkCore.SqlServer<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>安装 EF Core Tools：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; dotnet add package Microsoft.EntityFrameworkCore.Tools<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>安装 EF Core CLI 工具。具体安装和使用方法参考 <a href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/dotnet" target="_blank" rel="noopener">Entity Framework Core 工具参考-.NET CLI</a>：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; dotnet add package Microsoft.EntityFrameworkCore.Design<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>为项目生成 <em>.config\dotnet-tools.json</em> 文件，没有此文件无法 <strong>为项目</strong> 安装 dotnet-ef  工具。参考上一步中的链接中 <a href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/dotnet" target="_blank" rel="noopener">tool manifest file</a> 说明：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; dotnet new tool<span class="hljs-literal">-manifest</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>安装 dotnet-ef 工具：</p>
 <figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powshell">PM&gt; dotnet tool install dotnet-ef<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h2 id="三、在-Entity-Framework-Core-中为现有数据库创建模型-即-Database-First-方法"><a class="header-anchor" href="#三、在-Entity-Framework-Core-中为现有数据库创建模型-即-Database-First-方法">¶</a>三、在 Entity Framework Core 中为现有数据库创建模型 (即 Database-First 方法)</h2>
<p>EF Core 不支持用于可视化设计器的 DB 模型和向导来创建类似于 EF 6 的实体和上下文类。</p>
<p>让我们在下面显示的本地 MS SQL Server 中为以下 SchoolDB 数据库创建实体和上下文类。因此，我们需要使用 <code>Scaffold-DbContext</code> 或 <code>dotnet ef dbcontext scaffold</code> 命令进行 <a href="https://docs.microsoft.com/zh-cn/ef/core/managing-schemas/scaffolding" target="_blank" rel="noopener">反向工程</a>。此反向工程命令基于现有数据库的架构创建实体和上下文类 (通过派生 <code>DbContext</code>)。</p>
<p><img src="/images/efcore/20200207210923466.png" alt="图3-1"></p>
<h3 id="dotnet-ef-dbcontext-scaffold-命令"><a class="header-anchor" href="#dotnet-ef-dbcontext-scaffold-命令">¶</a><code>dotnet ef dbcontext scaffold</code> 命令</h3>
<p>使用 <code>dotnet ef dbcontext scaffold</code> 基于现有数据库创建模型：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">dotnet ef dbcontext scaffold [-<span class="hljs-type">Connection</span>] [-<span class="hljs-type">Provider</span>] [-<span class="hljs-type">OutputDir</span>] [-<span class="hljs-type">Context</span>] [-<span class="hljs-type">Schemas</span>&gt;] [-<span class="hljs-type">Tables</span>&gt;] <br>                    [-<span class="hljs-type">DataAnnotations</span>] [-<span class="hljs-type">Force</span>] [-<span class="hljs-type">Project</span>] [-<span class="hljs-type">StartupProject</span>] [&lt;<span class="hljs-type">CommonParameters</span>&gt;]<br></code></pre></div></td></tr></table></figure>
<p>反向本例中的数据库：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">dotnet ef dbcontext scaffold <span class="hljs-string">"Server=.\SQLExpress;Database=SchoolDB;Trusted_Connection=True;"</span> Microsoft.EntityFrameworkCore.SqlServer <span class="hljs-literal">-OutputDir</span> Models<br></code></pre></div></td></tr></table></figure>
<p>在上面的命令中：</p>
<ul>
<li>第一个参数是一个连接字符串，它包括三个部分：
<ul>
<li>数据库服务器, 数据库名称和安全信息。在这里，<code>Server=.\SQLExpress;</code> 指本地 SQL Server Express 数据库服务器。</li>
<li><code>Database=SchoolDB;</code>  指定我们要为其创建类的数据库名称 “SchoolDB”。</li>
<li><code>Trusted_Connection=True;</code> 指定 Windows 身份验证。<br>
它将使用 Windows 凭据连接到 SQL Server。</li>
</ul>
</li>
<li>第二个参数是提供程序名称。我们将提供程序用于 SQL Server，因此它是 <code>Microsoft.EntityFrameworkCore.SqlServer</code>。</li>
<li><code>-OutputDir</code> 参数指定我们要在其中生成所有类的目录，在本例中为_Models_ 文件夹。</li>
</ul>
<p>上面的 <code>dotnet ef dbcontext scaffold</code> 命令使用为 <em>Models</em> 文件夹中所有实体的 Fluent API 配置为SchoolDB 数据库中的每个表创建实体类，并通过派生 DbContext 创建数据库上下文类。<br>
以下是为 Student 表生成的 <code>Student</code> 实体类：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">using System;<br>using System.Collections.Generic;<br><br>namespace EFCoreTutorials.Models &#123;<br>    public partial class Student &#123;<br>        public Student() &#123;<br>            StudentCourse &#x3D; new HashSet&lt;StudentCourse&gt;();<br>        &#125;<br><br>        public int StudentId &#123; get; set; &#125;<br>        public string FirstName &#123; get; set; &#125;<br>        public string LastName &#123; get; set; &#125;<br>        public int? StandardId &#123; get; set; &#125;<br><br>        public Standard Standard &#123; get; set; &#125;<br>        public StudentAddress StudentAddress &#123; get; set; &#125;<br>        public ICollection&lt;StudentCourse&gt; StudentCourse &#123; get; set; &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>以下是 <code>SchoolDBContext</code> 类，可用于保存或检索数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">using System;<br>using Microsoft.EntityFrameworkCore;<br>using Microsoft.EntityFrameworkCore.Metadata;<br><br>namespace EFCoreTutorials.Models &#123;<br>    public partial class SchoolDBContext : DbContext &#123;<br>        public virtual DbSet&lt;Course&gt; Course &#123; get; set; &#125;<br>        public virtual DbSet&lt;Standard&gt; Standard &#123; get; set; &#125;<br>        public virtual DbSet&lt;Student&gt; Student &#123; get; set; &#125;<br>        public virtual DbSet&lt;StudentAddress&gt; StudentAddress &#123; get; set; &#125;<br>        public virtual DbSet&lt;StudentCourse&gt; StudentCourse &#123; get; set; &#125;<br>        public virtual DbSet&lt;Teacher&gt; Teacher &#123; get; set; &#125;<br><br>        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;<br>            if (!optionsBuilder.IsConfigured) &#123;<br>#warning To protect potentially sensitive information in your connection string, you should move it out of source code. See http:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkId&#x3D;723263 for guidance on storing connection strings.<br>                optionsBuilder.UseSqlServer(@&quot;Server&#x3D;.\SQLExpress;Database&#x3D;SchoolDB;Trusted_Connection&#x3D;True;&quot;);<br>            &#125;<br>        &#125;<br><br>        protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;<br>            modelBuilder.Entity&lt;Course&gt;(entity &#x3D;&gt; &#123;<br>                entity.Property(e &#x3D;&gt; e.CourseName)<br>                    .HasMaxLength(50)<br>                    .IsUnicode(false);<br><br>                entity.HasOne(d &#x3D;&gt; d.Teacher)<br>                    .WithMany(p &#x3D;&gt; p.Course)<br>                    .HasForeignKey(d &#x3D;&gt; d.TeacherId)<br>                    .OnDelete(DeleteBehavior.Cascade)<br>                    .HasConstraintName(&quot;FK_Course_Teacher&quot;);<br>            &#125;);<br><br>            modelBuilder.Entity&lt;Standard&gt;(entity &#x3D;&gt; &#123;<br>                entity.Property(e &#x3D;&gt; e.Description)<br>                    .HasMaxLength(50)<br>                    .IsUnicode(false);<br><br>                entity.Property(e &#x3D;&gt; e.StandardName)<br>                    .HasMaxLength(50)<br>                    .IsUnicode(false);<br>            &#125;);<br><br>            modelBuilder.Entity&lt;Student&gt;(entity &#x3D;&gt; &#123;<br>                entity.Property(e &#x3D;&gt; e.StudentId).HasColumnName(&quot;StudentID&quot;);<br><br>                entity.Property(e &#x3D;&gt; e.FirstName)<br>                    .HasMaxLength(50)<br>                    .IsUnicode(false);<br><br>                entity.Property(e &#x3D;&gt; e.LastName)<br>                    .HasMaxLength(50)<br>                    .IsUnicode(false);<br><br>                entity.HasOne(d &#x3D;&gt; d.Standard)<br>                    .WithMany(p &#x3D;&gt; p.Student)<br>                    .HasForeignKey(d &#x3D;&gt; d.StandardId)<br>                    .OnDelete(DeleteBehavior.Cascade)<br>                    .HasConstraintName(&quot;FK_Student_Standard&quot;);<br>            &#125;);<br><br>            modelBuilder.Entity&lt;StudentAddress&gt;(entity &#x3D;&gt; &#123;<br>                entity.HasKey(e &#x3D;&gt; e.StudentId);<br><br>                entity.Property(e &#x3D;&gt; e.StudentId)<br>                    .HasColumnName(&quot;StudentID&quot;)<br>                    .ValueGeneratedNever();<br><br>                entity.Property(e &#x3D;&gt; e.Address1)<br>                    .IsRequired()<br>                    .HasMaxLength(50)<br>                    .IsUnicode(false);<br><br>                entity.Property(e &#x3D;&gt; e.Address2)<br>                    .HasMaxLength(50)<br>                    .IsUnicode(false);<br><br>                entity.Property(e &#x3D;&gt; e.City)<br>                    .IsRequired()<br>                    .HasMaxLength(50)<br>                    .IsUnicode(false);<br><br>                entity.Property(e &#x3D;&gt; e.State)<br>                    .IsRequired()<br>                    .HasMaxLength(50)<br>                    .IsUnicode(false);<br><br>                entity.HasOne(d &#x3D;&gt; d.Student)<br>                    .WithOne(p &#x3D;&gt; p.StudentAddress)<br>                    .HasForeignKey&lt;StudentAddress&gt;(d &#x3D;&gt; d.StudentId)<br>                    .HasConstraintName(&quot;FK_StudentAddress_Student&quot;);<br>            &#125;);<br><br>            modelBuilder.Entity&lt;StudentCourse&gt;(entity &#x3D;&gt; &#123;<br>                entity.HasKey(e &#x3D;&gt; new &#123; e.StudentId, e.CourseId &#125;);<br><br>                entity.HasOne(d &#x3D;&gt; d.Course)<br>                    .WithMany(p &#x3D;&gt; p.StudentCourse)<br>                    .HasForeignKey(d &#x3D;&gt; d.CourseId)<br>                    .OnDelete(DeleteBehavior.ClientSetNull)<br>                    .HasConstraintName(&quot;FK_StudentCourse_Course&quot;);<br><br>                entity.HasOne(d &#x3D;&gt; d.Student)<br>                    .WithMany(p &#x3D;&gt; p.StudentCourse)<br>                    .HasForeignKey(d &#x3D;&gt; d.StudentId)<br>                    .HasConstraintName(&quot;FK_StudentCourse_Student&quot;);<br>            &#125;);<br><br>            modelBuilder.Entity&lt;Teacher&gt;(entity &#x3D;&gt; &#123;<br>                entity.Property(e &#x3D;&gt; e.StandardId).HasDefaultValueSql(&quot;((0))&quot;);<br><br>                entity.Property(e &#x3D;&gt; e.TeacherName)<br>                    .HasMaxLength(50)<br>                    .IsUnicode(false);<br><br>                entity.HasOne(d &#x3D;&gt; d.Standard)<br>                    .WithMany(p &#x3D;&gt; p.Teacher)<br>                    .HasForeignKey(d &#x3D;&gt; d.StandardId)<br>                    .OnDelete(DeleteBehavior.Cascade)<br>                    .HasConstraintName(&quot;FK_Teacher_Standard&quot;);<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p><strong>创建模型后，无论何时更改模型，都必须使用“迁移”命令，以使数据库与模型保持最新。</strong></p>
</blockquote>
<h2 id="四、Entity-Framework-Core：DbContext"><a class="header-anchor" href="#四、Entity-Framework-Core：DbContext">¶</a>四、Entity Framework Core：<code>DbContext</code></h2>
<p><code>DbContext</code> 类是 Entity Framework Core 的组成部分。<code>DbContext</code> 实例代表与数据库的会话，可用于查询实体实例并将其保存到数据库。<strong><code>DbContext</code> 是工作单元和存储库模式的组合。</strong></p>
<p>EF Core 中的 <code>DbContext</code> 允许我们执行以下任务：</p>
<ul>
<li>管理数据库连接</li>
<li>配置模型和关系</li>
<li>查询数据库</li>
<li>将数据保存到数据库</li>
<li>配置变更跟踪</li>
<li>缓存</li>
<li>事务管理</li>
</ul>
<p>要在我们的应用程序中使用 <code>DbContext</code>，我们需要创建从 <code>DbContext</code> 派生的类，也称为上下文类。**该上下文类通常包括模型中每个实体的 <code>DbSet&lt;TEntity&gt;</code> 属性。**以下为 EF Core 中 <code>DbContext</code> 类的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class SchoolContext : DbContext &#123;<br>    public SchoolContext() &#123;<br>    &#125;<br><br>    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;<br>    &#125;<br><br>    protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;<br>    &#125;<br>    &#x2F;&#x2F;实体<br>    public DbSet&lt;Student&gt; Students &#123; get; set; &#125;<br>    public DbSet&lt;Course&gt; Courses &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>SchoolContext</code> 类派生自 <code>DbContext</code> 类。</p>
<ul>
<li><code>OnConfiguring()</code> 方法允许我们使用 <code>DbContextOptionsBuilder</code> 选择和配置要与上下文一起使用的 <strong>数据源</strong>。在此处了解如何配置 <code>DbContext</code> 类。</li>
<li><code>OnModelCreating()</code> 方法允许我们使用 ModelBuilder Fluent API 配置 <strong>模型</strong>。</li>
</ul>
<h3 id="DbContext-的方法"><a class="header-anchor" href="#DbContext-的方法">¶</a><code>DbContext</code> 的方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Add</code></td>
<td style="text-align:center">将一个新实体添加到具有添加状态的 <code>DbContext</code> 中，并开始对其进行跟踪。调用 <code>SaveChanges()</code> 时，会将新的实体数据插入数据库。</td>
</tr>
<tr>
<td style="text-align:center"><code>AddAsync</code></td>
<td style="text-align:center">用于向状态为“已添加”的 <code>DbContext</code> 添加新实体并开始对其进行跟踪的异步方法。调用 <code>SaveChangesAsync()</code> 时，会将新的实体数据插入数据库。</td>
</tr>
<tr>
<td style="text-align:center"><code>AddRange</code></td>
<td style="text-align:center">将具有添加状态的新实体集合添加到 <code>DbContext</code> 并开始对其进行跟踪。调用 <code>SaveChanges()</code> 时，会将新的实体数据插入数据库。</td>
</tr>
<tr>
<td style="text-align:center"><code>AddRangeAsync</code></td>
<td style="text-align:center">用于添加将保存在 <code>SaveChangesAsync()</code> 上的新实体集合的异步方法。</td>
</tr>
<tr>
<td style="text-align:center"><code>Attach</code></td>
<td style="text-align:center">将新的或现有的实体附加到状态不变的 <code>DbContext</code> 并开始跟踪它。</td>
</tr>
<tr>
<td style="text-align:center"><code>AttachRange</code></td>
<td style="text-align:center">将新实体或现有实体的集合以未更改的状态附加到 <code>DbContext</code> 并开始对其进行跟踪。</td>
</tr>
<tr>
<td style="text-align:center"><code>Entry</code></td>
<td style="text-align:center">获取给定实体的 <code>EntityEntry</code>。该条目提供对实体的更改跟踪信息和操作的访问。</td>
</tr>
<tr>
<td style="text-align:center"><code>Find</code></td>
<td style="text-align:center">查找具有给定主键值的实体。</td>
</tr>
<tr>
<td style="text-align:center"><code>FindAsync</code></td>
<td style="text-align:center">用于查找具有给定主键值的实体的异步方法。</td>
</tr>
<tr>
<td style="text-align:center"><code>Remove</code></td>
<td style="text-align:center">移除将删除状态设置为指定的实体，当调用 <code>SaveChanges()</code> 时，该实体将删除数据。</td>
</tr>
<tr>
<td style="text-align:center"><code>RemoveRange</code></td>
<td style="text-align:center">将 <code>Deleted</code> 状态设置为一组实体，这些实体将在调用 <code>SaveChanges()</code> 时在一次数据库往返中删除数据。</td>
</tr>
<tr>
<td style="text-align:center"><code>SaveChanges</code></td>
<td style="text-align:center">对状态为 <code>Added</code>，<code>Modified</code> 或 <code>Removed</code> 的实体执行 <code>INSERT</code>，<code>UPDATE</code> 或 <code>DELETE</code> 命令到数据库。</td>
</tr>
<tr>
<td style="text-align:center"><code>SaveChangesAsync</code></td>
<td style="text-align:center"><code>SaveChanges()</code> 的异步方法</td>
</tr>
<tr>
<td style="text-align:center"><code>Set</code></td>
<td style="text-align:center">创建一个 <code>DbSet&lt;TEntity&gt;</code>，可用于查询和保存 <code>TEntity</code> 的实例。</td>
</tr>
<tr>
<td style="text-align:center"><code>Update</code></td>
<td style="text-align:center">附加状态为 <code>Modified</code> 的断开连接的实体，并开始对其进行跟踪。调用 <code>SaveChagnes()</code> 时将保存数据。</td>
</tr>
<tr>
<td style="text-align:center"><code>UpdateRange</code></td>
<td style="text-align:center">附加状态为 <code>Modified</code> 的断开连接的实体的集合，并开始对其进行跟踪。调用 <code>SaveChagnes()</code> 时将保存数据。</td>
</tr>
<tr>
<td style="text-align:center"><code>OnConfiguring</code></td>
<td style="text-align:center">重写此方法，以配置要用于此上下文的数据库 (和其他选项)。创建的上下文的每个实例都会调用此方法。</td>
</tr>
<tr>
<td style="text-align:center"><code>OnModelCreating</code></td>
<td style="text-align:center">重写此方法，以进一步配置根据约定从派生上下文的 <code>DbSet&lt;TEntity&gt;</code> 属性中公开的实体类型发现的模型。</td>
</tr>
</tbody>
</table>
<h3 id="DbContext-属性"><a class="header-anchor" href="#DbContext-属性">¶</a><code>DbContext</code> 属性</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ChangeTracker</code></td>
<td style="text-align:center">提供对该上下文正在跟踪的实体实例的信息和操作的访问。</td>
</tr>
<tr>
<td style="text-align:center"><code>Database</code></td>
<td style="text-align:center">提供对此上下文的数据库相关信息和操作的访问。</td>
</tr>
<tr>
<td style="text-align:center"><code>Model</code></td>
<td style="text-align:center">返回有关实体的形状，它们之间的关系以及它们如何映射到数据库的元数据。</td>
</tr>
</tbody>
</table>
<h2 id="五、第一个-EF-Core-控制台应用程序"><a class="header-anchor" href="#五、第一个-EF-Core-控制台应用程序">¶</a>五、第一个 EF Core 控制台应用程序</h2>
<h3 id="创建模型"><a class="header-anchor" href="#创建模型">¶</a>创建模型</h3>
<p>EF 模型包括三个部分：</p>
<ul>
<li>概念模型</li>
<li>存储模型</li>
<li>概念模型和存储模型之间的映射。</li>
</ul>
<p>Code-First 方法中，EF 根据您的领域类 (实体类)，上下文类和配置来构建概念模型。 EF Core <strong>根据您使用的提供程序</strong> 构建存储模型和映射。例如，与 DB2 相比，SQL Server 的存储模型将有所不同。</p>
<p>我们需要首先创建实体类和上下文类。以下是学生和课程的简单实体类：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class Student &#123;<br>    public int StudentId &#123; get; set; &#125;<br>    public string Name &#123; get; set; &#125;<br>&#125;<br><br>public class Course &#123;<br>    public int CourseId &#123; get; set; &#125;<br>    public string CourseName &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>现在，我们需要通过派生 <code>DbContext</code> 来创建上下文类，如上一章所示。以下 <code>SchoolContext</code> 类也称为上下文类。</p>
<h4 id="在上下文类内配置数据库连接"><a class="header-anchor" href="#在上下文类内配置数据库连接">¶</a>在上下文类内配置数据库连接</h4>
<p><code>SchoolContext</code> 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">namespace EFCoreTutorials &#123;<br>    public class SchoolContext : DbContext &#123;<br>        &#x2F;&#x2F; 映射到 Student 表<br>        public DbSet&lt;Student&gt; Students &#123; get; set; &#125;<br>        <br>        &#x2F;&#x2F; 映射到 Course 表<br>        public DbSet&lt;Course&gt; Courses &#123; get; set; &#125;<br><br>        &#x2F;&#x2F; DbContextOptionsBuilder 的实例用于指定要使用的数据库<br>        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;<br>            optionsBuilder.UseSqlServer(@&quot;Server&#x3D;.\SQLEXPRESS;Database&#x3D;SchoolDB;Trusted_Connection&#x3D;True;&quot;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="用依赖注入的方式配置数据库连接"><a class="header-anchor" href="#用依赖注入的方式配置数据库连接">¶</a>用依赖注入的方式配置数据库连接</h4>
<p><code>SchoolContext</code> 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">namespace EFCoreTutorials &#123;<br>    public class SchoolContext : DbContext &#123;<br>        &#x2F;&#x2F; 映射到 Student 表<br>        public DbSet&lt;Student&gt; Students &#123; get; set; &#125;<br>        <br>        &#x2F;&#x2F; 映射到 Course 表<br>        public DbSet&lt;Course&gt; Courses &#123; get; set; &#125;<br>        <br>        public readonly DbContextOptions _dbContextOptions;<br>        <br>        public SchoolContext(DbContextOptions&lt;SchoolContext&gt; options): base(options) &#123;<br>            _dbContextOptions &#x3D; options;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>Startup</code> 类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">namespace EFCoreTutorials &#123;<br>    public class Startup &#123;<br>        private readonly IConfiguration _configuration;<br><br>        public Startup(IConfiguration configuration) &#123;<br>            _configuration &#x3D; configuration;<br>        &#125;<br>        <br>        public void ConfigureServices(IServiceCollection services) &#123;<br>            ...<br>            services.AddDbContextPool&lt;SchoolContext&gt;(options &#x3D;&gt; options.UseSqlServer(_configuration.GetConnectionString(&quot;SchoolDBConnection&quot;)));<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在 <em>appsettings.json</em> 中：</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>    ...<br>    "ConnectionStrings": &#123;<br>        <span class="hljs-comment">// Trusted_Connection=True、Integrated Security=SSPI、Integrated Security=True 都代表使用 Windows 身份认证</span><br>        "SchoolDBConnection": "Server=.\SQLEXPRESS;Database=SchoolDB;Trusted_Connection=True;"<br>    &#125;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>本项目为 Console 项目，无法使用依赖注入。</p>
<h3 id="添加迁移"><a class="header-anchor" href="#添加迁移">¶</a>添加迁移</h3>
<p>此时，尚无 SchoolDB 数据库。因此，我们需要通过添加迁移从模型 (实体和上下文) 创建数据库。</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">dotnet ef migrations add CreateSchoolDB<br></code></pre></div></td></tr></table></figure>
<p>这将在项目中创建一个名为 <em>Migrations</em> 的新文件夹，并创建 ModelSnapshot_ (<strong>迁移脚本文件</strong>，此时并未写入数据库) 文件。</p>
<p>创建迁移脚本后，我们需要将更改更新至数据库：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">dotnet ef database update<br></code></pre></div></td></tr></table></figure>
<p>这将使用 <code>UseSqlServer()</code> 方法中的连接字符串中指定的名称和位置创建数据库。它将为每个 <code>DbSet</code> 属性 (学生和课程) 创建一个表。</p>
<p>现在，<strong>无论何时添加或更新域类或配置，我们都需要使用 <code>dotnet ef migrations add</code> 和 <code>dotnet ef database update</code> 命令将数据库与模型同步。</strong></p>
<h3 id="读取或写入数据"><a class="header-anchor" href="#读取或写入数据">¶</a>读取或写入数据</h3>
<p>现在，我们可以使用上下文类来保存和检索数据，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">namespace EFCoreTutorials &#123;<br>    class Program &#123;<br>        static void Main(string[] args) &#123;<br>            using (var context &#x3D; new SchoolContext()) &#123;<br><br>                var std &#x3D; new Student() &#123;<br>                     Name &#x3D; &quot;Bill&quot;<br>                &#125;;<br><br>                context.Students.Add(std);<br>                context.SaveChanges();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="六、Entity-Framework-Core-中的查询"><a class="header-anchor" href="#六、Entity-Framework-Core-中的查询">¶</a>六、Entity Framework Core 中的查询</h2>
<p>Entity Framework Core 允许你在模型中使用导航属性来加载相关实体。有三种常见的 ORM 模式可用于加载关联数据:</p>
<ul>
<li>Eager loading (预先加载)：表示从数据库中加载关联数据，作为初始查询的一部分。</li>
<li>Explicit loading (显式加载)：表示稍后从数据库中显式加载关联数据。</li>
<li>Lazy loading (延迟加载)：表示在访问导航属性时，从数据库中以透明方式加载关联数据。</li>
</ul>
<p>访问 <a href="https://www.entityframeworktutorial.net/querying-entity-graph-in-entity-framework.aspx" target="_blank" rel="noopener">LINQ-to-Entities</a> 一章，以了解有关 Entity Framework 中查询基础的更多信息。</p>
<h3 id="查询中的-C-VB-NET-函数"><a class="header-anchor" href="#查询中的-C-VB-NET-函数">¶</a>查询中的 C# / <a href="http://VB.NET" target="_blank" rel="noopener">VB.NET</a> 函数</h3>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">private static void Main(string[] args) &#123;<br>    var context &#x3D; new SchoolContext();<br>    var studentsWithSameName &#x3D; context.Students<br>                                      .Where(s &#x3D;&gt; s.FirstName &#x3D;&#x3D; GetName())<br>                                      .ToList();<br>&#125;<br><br>public static string GetName() &#123;<br>    return &quot;Bill&quot;;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这将在数据库中执行以下查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">exec sp_executesql N&#39;SELECT [s].[StudentId], [s].[DoB], [s].[FirstName], <br>    [s].[GradeId], [s].[LastName], [s].[MiddleName]<br>FROM [Students] AS [s]<br>WHERE [s].[FirstName] &#x3D; @__GetName_0&#39;,N&#39;@__GetName_0 nvarchar(4000)&#39;,<br>    @__GetName_0&#x3D;N&#39;Bill&#39;<br>Go<br></code></pre></div></td></tr></table></figure>
<h3 id="Eager-Loading-预先加载"><a class="header-anchor" href="#Eager-Loading-预先加载">¶</a>Eager Loading 预先加载</h3>
<p>Entity Framework Core 支持使用 <code>Include()</code> 扩展方法和投影查询来快速加载相关实体。除此之外，它还提供了 <code>ThenInclude()</code> 扩展方法来加载多个级别的相关实体。</p>
<h4 id="Include"><a class="header-anchor" href="#Include">¶</a><code>Include</code></h4>
<p>我们可以在 <code>Include()</code> 方法中将 lambda 表达式指定为参数，以指定导航属性，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var context &#x3D; new SchoolContext();<br>var studentWithGrade &#x3D; context.Students<br>                           .Where(s &#x3D;&gt; s.FirstName &#x3D;&#x3D; &quot;Bill&quot;)<br>                           .Include(s &#x3D;&gt; s.Grade)<br>                           .FirstOrDefault();<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>.Include(s =&gt; s.Grade)</code> 传递 lambda 表达式 <code>s =&gt; s.Grade</code>，以指定引用属性，该属性将在单个 SQL 查询中与来自数据库的 <code>Student</code> 实体数据一起加载。上面的查询在数据库中执行以下 SQL 查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">SELECT TOP(1) [s].[StudentId], [s].[DoB], [s].[FirstName], [s].[GradeId],[s].[LastName], <br>        [s].[MiddleName], [s.Grade].[GradeId], [s.Grade].[GradeName], [s.Grade].[Section]<br>FROM [Students] AS [s]<br>LEFT JOIN [Grades] AS [s.Grade] ON [s].[GradeId] &#x3D; [s.Grade].[GradeId]<br>WHERE [s].[FirstName] &#x3D; N&#39;Bill&#39;<br></code></pre></div></td></tr></table></figure>
<p>我们还可以在 <code>Include()</code> 方法中将属性名称指定为字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var context &#x3D; new SchoolContext();<br>var studentWithGrade &#x3D; context.Students<br>                        .Where(s &#x3D;&gt; s.FirstName &#x3D;&#x3D; &quot;Bill&quot;)<br>                        .Include(&quot;Grade&quot;)<br>                        .FirstOrDefault();<br></code></pre></div></td></tr></table></figure>
<p><strong>不建议使用上面的示例，因为如果属性名称拼写错误或不存在，则会抛出运行时异常。</strong> 始终对 lambda 表达式使用 <code>Include()</code> 方法，以便可以在编译时检测到错误。</p>
<p><code>Include()</code> 扩展方法也可以在 <code>FromSql()</code> 方法之后使用，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var context &#x3D; new SchoolContext();<br>var studentWithGrade &#x3D; context.Students<br>                        .FromSql(&quot;Select * from Students where FirstName &#x3D;&#39;Bill&#39;&quot;)<br>                        .Include(s &#x3D;&gt; s.Grade)<br>                        .FirstOrDefault();<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p><code>DbSet.Find()</code>方法之后不能使用 <code>Include()</code> 扩展方法。例如。在 EF Core 2.0 中无法使用 <code>context.Students.Find(1).Include()</code>。在将来的版本中这可能是可能的。</p>
</blockquote>
<p>多次使用 <code>Include()</code> 方法来加载同一实体的多个导航属性。例如，以下代码加载与 <code>Student</code> 的 <code>Grade</code> 和 <code>StudentCourses</code> 相关的实体。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var context &#x3D; new SchoolContext();<br>var studentWithGrade &#x3D; context.Students.Where(s &#x3D;&gt; s.FirstName &#x3D;&#x3D; &quot;Bill&quot;)<br>                        .Include(s &#x3D;&gt; s.Grade)<br>                        .Include(s &#x3D;&gt; s.StudentCourses)<br>                        .FirstOrDefault();<br></code></pre></div></td></tr></table></figure>
<p>上面的查询将在单个数据库往返中执行两个 SQL 查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">SELECT TOP(1) [s].[StudentId], [s].[DoB], [s].[FirstName], [s].[GradeId], [s].[LastName], <br>        [s].[MiddleName], [s.Grade].[GradeId], [s.Grade].[GradeName], [s.Grade].[Section]<br>FROM [Students] AS [s]<br>LEFT JOIN [Grades] AS [s.Grade] ON [s].[GradeId] &#x3D; [s.Grade].[GradeId]<br>WHERE [s].[FirstName] &#x3D; N&#39;Bill&#39;<br>ORDER BY [s].[StudentId]<br>Go<br><br>SELECT [s.StudentCourses].[StudentId], [s.StudentCourses].[CourseId]<br>FROM [StudentCourses] AS [s.StudentCourses]<br>INNER JOIN (<br>    SELECT DISTINCT [t].*<br>    FROM (<br>        SELECT TOP(1) [s0].[StudentId]<br>        FROM [Students] AS [s0]<br>        LEFT JOIN [Grades] AS [s.Grade0] ON [s0].[GradeId] &#x3D; [s.Grade0].[GradeId]<br>        WHERE [s0].[FirstName] &#x3D; N&#39;Bill&#39;<br>        ORDER BY [s0].[StudentId]<br>    ) AS [t]<br>) AS [t0] ON [s.StudentCourses].[StudentId] &#x3D; [t0].[StudentId]<br>ORDER BY [t0].[StudentId]<br>Go<br></code></pre></div></td></tr></table></figure>
<h4 id="ThenInclude"><a class="header-anchor" href="#ThenInclude">¶</a><code>ThenInclude</code></h4>
<p>EF Core 引入了新的 <code>ThenInclude()</code> 扩展方法，以加载多个级别的相关实体。考虑以下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var context &#x3D; new SchoolContext();<br>var student &#x3D; context.Students.Where(s &#x3D;&gt; s.FirstName &#x3D;&#x3D; &quot;Bill&quot;)<br>                        .Include(s &#x3D;&gt; s.Grade)<br>                        .ThenInclude(g &#x3D;&gt; g.Teachers)<br>                        .FirstOrDefault();<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>.Include(s =&gt; s.Grade)</code> 将加载 <code>Student</code> 实体的 <code>Grade</code> 导航属性。 <code>.ThenInclude(g =&gt; g.Teachers)</code> 将加载 <code>Grade</code> 实体的<code> Teacher</code> 集合属性。必须在 <code>Include</code> 方法之后调用<code> ThenInclude</code> 方法。上面的代码将在数据库中执行以下 SQL 查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">SELECT TOP(1) [s].[StudentId], [s].[DoB], [s].[FirstName], [s].[GradeId], [s].[LastName],<br>         [s].[MiddleName], [s.Grade].[GradeId], [s.Grade].[GradeName], [s.Grade].[Section]<br>FROM [Students] AS [s]<br>LEFT JOIN [Grades] AS [s.Grade] ON [s].[GradeId] &#x3D; [s.Grade].[GradeId]<br>WHERE [s].[FirstName] &#x3D; N&#39;Bill&#39;<br>ORDER BY [s.Grade].[GradeId]<br>Go<br><br>SELECT [s.Grade.Teachers].[TeacherId], [s.Grade.Teachers].[GradeId], [s.Grade.Teachers].[Name]<br>FROM [Teachers] AS [s.Grade.Teachers]<br>INNER JOIN (<br>    SELECT DISTINCT [t].*<br>    FROM (<br>        SELECT TOP(1) [s.Grade0].[GradeId]<br>        FROM [Students] AS [s0]<br>        LEFT JOIN [Grades] AS [s.Grade0] ON [s0].[GradeId] &#x3D; [s.Grade0].[GradeId]<br>        WHERE [s0].[FirstName] &#x3D; N&#39;Bill&#39;<br>        ORDER BY [s.Grade0].[GradeId]<br>    ) AS [t]<br>) AS [t0] ON [s.Grade.Teachers].[GradeId] &#x3D; [t0].[GradeId]<br>ORDER BY [t0].[GradeId]<br>Go<br></code></pre></div></td></tr></table></figure>
<h4 id="Projection-Query-投影查询"><a class="header-anchor" href="#Projection-Query-投影查询">¶</a>Projection Query (投影查询)</h4>
<p>我们还可以通过使用投影查询而不是 <code>Include()</code> 或 <code>ThenInclude()</code> 方法来加载多个相关实体。以下示例演示了用于加载 <code>Student</code>，<code>Grade</code> 和 <code>Teacher</code> 实体的投影查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var context &#x3D; new SchoolContext();<br>var stud &#x3D; context.Students.Where(s &#x3D;&gt; s.FirstName &#x3D;&#x3D; &quot;Bill&quot;)<br>                        .Select(s &#x3D;&gt; new<br>                        &#123;<br>                            Student &#x3D; s,<br>                            Grade &#x3D; s.Grade,<br>                            GradeTeachers &#x3D; s.Grade.Teachers<br>                        &#125;)<br>                        .FirstOrDefault();<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>.Select</code> 扩展方法用于在结果中包括 <code>Student</code>、 <code>Grade</code> 和 <code>Teacher</code> 实体。这将执行与上述 <code>ThenInclude()</code>  方法相同的 SQL 查询。</p>
<h2 id="七、Entity-Framework-Core-在连接模式下保存数据"><a class="header-anchor" href="#七、Entity-Framework-Core-在连接模式下保存数据">¶</a>七、Entity Framework Core 在连接模式下保存数据</h2>
<p>Entity Framework Core 提供了不同的方法来添加，更新或删除基础数据库中的数据。一个实体的标量属性中包含的数据将根据其 <code>EntityState</code> 插入，更新或删除。<br>
保存实体数据有两种方案：</p>
<ul>
<li>连接模式</li>
<li>断开模式</li>
</ul>
<p>在本章中仅学习有关在连接的场景中保存数据的知识。下图说明了所连接场景中的CUD (创建，更新，删除) 操作。<br>
<img src="/images/efcore/save-data-in-connected-scenario.png" alt="图7-1"><br>
如上图所示，当调用 <code>DbContext.SaveChanges()</code> 方法时，Entity Framework 为其 <code>EntityState</code> 被添加，修改或删除的实体生成并执行 <code>INSERT</code>，<code>UPDATE</code> 或 <code>DELETE</code> 语句。在连接的场景中，<strong><code>DbContext</code> 实例跟踪所有实体，因此每当创建，修改或删除实体时，它都会自动为每个实体设置适当的 <code>EntityState</code>。</strong></p>
<h3 id="插入数据"><a class="header-anchor" href="#插入数据">¶</a>插入数据</h3>
<p><code>DbSet.Add</code> 和 <code>DbContext.Add</code> 方法将新实体添加到上下文 (<code>DbContext</code> 的实例)，当您调用 <code>SaveChanges()</code> 方法时，该实体将在数据库中插入新记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">using (var context &#x3D; new SchoolContext()) &#123;<br>    var std &#x3D; new Student() &#123;<br>        FirstName &#x3D; &quot;Bill&quot;,<br>        LastName &#x3D; &quot;Gates&quot;<br>    &#125;;<br>    context.Students.Add(std);<br>    &#x2F;&#x2F; or<br>    &#x2F;&#x2F; context.Add&lt;Student&gt;(std);<br>    context.SaveChanges();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>context.Students.Add(std)</code> 将一个新创建的 <code>Student</code> 实体实例添加到具有 <code>EntityState.Added</code> 的上下文中。 EF Core 引入了新的<code>DbContext.Add</code> 方法，该方法与 <code>DbSet.Add</code> 方法具有相同的作用。此后，<code>SaveChanges()</code> 方法将生成并执行以下对数据库的 <code>INSERT</code> 语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">exec sp_executesql N&#39;SET NOCOUNT ON;<br>INSERT INTO [Students] ( [FirstName], [LastName])<br>VALUES (@p0, @p1);<br>SELECT [StudentId]<br>FROM [Students]<br>WHERE @@ROWCOUNT &#x3D; 1 AND [StudentId] &#x3D; scope_identity();&#39;,N<br>&#39;@p0 nvarchar(4000), @p1 nvarchar(4000) &#39;,@p0&#x3D;N&#39;Bill&#39;,@p1&#x3D;N&#39;Gates&#39;<br>Go<br></code></pre></div></td></tr></table></figure>
<h3 id="更新数据"><a class="header-anchor" href="#更新数据">¶</a>更新数据</h3>
<p>在连接的场景中，EF Core API 跟踪使用上下文检索的所有实体。因此，当您编辑实体数据时，EF 会自动将 <code>EntityState</code> 标记为 <code>Modified</code>，这将在您调用 <code>SaveChanges()</code> 方法时在数据库中产生更新的语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">using (var context &#x3D; new SchoolContext()) &#123;<br>    var std &#x3D; context.Students.First&lt;Student&gt;(); <br>    std.FirstName &#x3D; &quot;Steve&quot;;<br>    context.SaveChanges();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，我们使用 <code>context.Students.First&lt;Student&gt;()</code> 从数据库中检索第一个学生。一旦修改了 <code>FirstName</code>，由于在 <code>DbContext</code> 实例 (上下文) 的范围内执行了修改，因此上下文将其 <code>EntityState</code> 设置为 <code>Modified</code>。因此，当我们调用 <code>SaveChanges()</code> 方法时，它将在数据库中生成并执行以下 <code>Update</code> 语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">exec sp_executesql N&#39;SET NOCOUNT ON;<br>UPDATE [Students] SET [FirstName] &#x3D; @p0<br>WHERE [StudentId] &#x3D; @p1;<br>SELECT @@ROWCOUNT;<br>&#39;,N&#39;@p1 int,@p0 nvarchar(4000)&#39;,@p1&#x3D;1,@p0&#x3D;N&#39;Steve&#39;<br>Go<br></code></pre></div></td></tr></table></figure>
<p>在更新语句中，EF Core API 包括具有修改后值的属性，其余部分将被忽略。在上面的示例中，仅 <code>FirstName</code> 属性被编辑，因此 <code>update</code> 语句仅包含 <code>FirstName</code> 列。</p>
<h3 id="删除数据"><a class="header-anchor" href="#删除数据">¶</a>删除数据</h3>
<p>使用 <code>DbSet.Remove()</code> 或 <code>DbContext.Remove</code> 方法删除数据库表中的记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">using (var context &#x3D; new SchoolContext()) &#123;<br>    var std &#x3D; context.Students.First&lt;Student&gt;();<br>    context.Students.Remove(std);<br>    &#x2F;&#x2F; or<br>    &#x2F;&#x2F; context.Remove&lt;Student&gt;(std);<br>    context.SaveChanges();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>context.Students.Remove(std)</code>  或者 <code>context.Remove&lt;Students&gt;(std)</code> 将 <code>std</code> 实体对象标记为 <code>Deleted</code>。因此，EF Core 将在数据库中生成并执行以下 <code>DELETE</code> 语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">exec sp_executesql N&#39;SET NOCOUNT ON;<br>DELETE FROM [Students]<br>WHERE [StudentId] &#x3D; @p0;<br>SELECT @@ROWCOUNT;<br>&#39;,N&#39;@p0 int&#39;,@p0&#x3D;1<br>Go<br></code></pre></div></td></tr></table></figure>
<h2 id="八、Entity-Framework-Core-中的约定"><a class="header-anchor" href="#八、Entity-Framework-Core-中的约定">¶</a>八、Entity Framework Core 中的约定</h2>
<p>约定是，使用 Entity Framework 根据您的领域模型 (实体) 类构建模型时的默认规则。</p>
<p>以下示例为应用程序的领域模型 (实体) 和数据库上下文类，它遵循默认约定，无需配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Student &#123;<br>    public int StudentId &#123; get; set; &#125;<br>    public string FirstName &#123; get; set; &#125;<br>    public string LastName &#123; get; set; &#125;<br>    public DateTime DateOfBirth &#123; get; set; &#125;<br>    public byte[] Photo &#123; get; set; &#125;<br>    public decimal Height &#123; get; set; &#125;<br>    public float Weight &#123; get; set; &#125;<br>    public int GradeId &#123; get; set; &#125;<br>    public Grade Grade &#123; get; set; &#125;<br>&#125;<br><br>public class Grade &#123;<br>    public int Id &#123; get; set; &#125;<br>    public string GradeName &#123; get; set; &#125;<br>    public string Section &#123; get; set; &#125;<br>    public IList&lt;Student&gt; Students &#123; get; set; &#125;<br>&#125;<br><br>public class SchoolContext : DbContext &#123;<br>    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)<br>    &#123; <br>        optionsBuilder.UseSqlServer(@&quot;Server&#x3D;.\SQLEXPRESS;Database&#x3D;SchoolDB;Trusted_Connection&#x3D;True;&quot;);<br>    &#125;<br><br>    public DbSet&lt;Student&gt; Students &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="Table-表"><a class="header-anchor" href="#Table-表">¶</a>Table (表)</h3>
<p>EF Core 将为上下文类中与属性名称相同的所有 <code>DbSet&lt;TEntity&gt;</code> 属性创建数据库表。<strong>它还将为实体创建表，这些表不包含在 <code>DbSet</code> 属性中，但可以通过其他 <code>DbSet</code> 实体中的引用属性访问。</strong> 对于上面的示例，即使 <code>SchoolContext</code> 类不包含<code>DbSet&lt;Grade&gt;</code> 属性，EF Core 也会在 <code>SchoolContext</code> 类中为 <code>DbSet&lt;Student&gt;</code> 属性创建 <code>Students</code> 表，在 <code>Student</code> 实体类中为 <code>Grade</code> 属性创建 <code>Grade</code> 表。</p>
<p><img src="/images/efcore/20200207213507370.png" alt="图8-1"></p>
<h3 id="Column-列"><a class="header-anchor" href="#Column-列">¶</a>Column (列)</h3>
<p>默认情况下，EF Core 将为实体类的所有基本类型的属性创建与该属性同名的列。它使用引用类属性和集合属性在数据库中相应表之间建立关系。</p>
<p><img src="/images/efcore/20200207213522900.png" alt="图8-2"></p>
<h3 id="列数据类型-Column-Data-Type"><a class="header-anchor" href="#列数据类型-Column-Data-Type">¶</a>列数据类型 (Column Data Type)</h3>
<p>数据库表中列的数据类型取决于数据库提供程序如何将 C# 数据类型映射到所选数据库的数据类型。下表列出了 C# 数据类型到 SQL Server 列数据类型之间的映射。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>C# 数据类型</strong></th>
<th style="text-align:center"><strong>SQL Server数据类型</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center"><code>int</code></td>
</tr>
<tr>
<td style="text-align:center"><code>string</code></td>
<td style="text-align:center"><code>nvarchar(Max)</code></td>
</tr>
<tr>
<td style="text-align:center"><code>decimal</code></td>
<td style="text-align:center"><code>decimal(18,2)</code></td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center"><code>real</code></td>
</tr>
<tr>
<td style="text-align:center"><code>byte[]</code></td>
<td style="text-align:center"><code>varbinary(Max)</code></td>
</tr>
<tr>
<td style="text-align:center"><code>datetime</code></td>
<td style="text-align:center"><code>datetime</code></td>
</tr>
<tr>
<td style="text-align:center"><code>bool</code></td>
<td style="text-align:center"><code>bit</code></td>
</tr>
<tr>
<td style="text-align:center"><code>byte</code></td>
<td style="text-align:center"><code>tinyint</code></td>
</tr>
<tr>
<td style="text-align:center"><code>short</code></td>
<td style="text-align:center"><code>smallint</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:center"><code>bigint</code></td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center"><code>float</code></td>
</tr>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center"><code>sbyte</code></td>
<td style="text-align:center">无 (会抛异常)</td>
</tr>
<tr>
<td style="text-align:center"><code>object</code></td>
<td style="text-align:center">无</td>
</tr>
</tbody>
</table>
<h3 id="Nullable-Column-可空列"><a class="header-anchor" href="#Nullable-Column-可空列">¶</a>Nullable Column (可空列)</h3>
<p>EF Core 为所有引用数据类型和可为空的原始类型属性创建可空列，例如 <code>string</code>、<code>Nullable&lt;int&gt;</code>、<code>decimal?</code> 等</p>
<h3 id="NotNull-Column-非空列"><a class="header-anchor" href="#NotNull-Column-非空列">¶</a>NotNull Column (非空列)</h3>
<p>EF Core 在数据库中为所有主键属性和原始类型属性创建 NotNull 列，例如 <code>int</code>、<code>float</code>、<code>decimal</code>、<code>DateTime</code> 等。</p>
<h3 id="Primary-Key-主键"><a class="header-anchor" href="#Primary-Key-主键">¶</a>Primary Key (主键)</h3>
<p>EF Core 将为名为 <code>Id</code> 或 <code>&lt;实体类名称&gt;Id</code> (不区分大小写) 的属性创建主键列。例如，如果 <code>Student</code> 类包含名为 <code>id</code>、<code>ID</code>、<code>iD</code>、<code>Id</code>、<code>studentid</code>、<code>StudentId</code>、<code>STUDENTID</code> 或 <code>sTUdentID</code> 的属性，则 EF Core 将在 <code>Student</code> 表中创建一列作为 PrimaryKey (主键)。</p>
<p><img src="/images/efcore/20200207213539655.png" alt="图8-3"></p>
<h3 id="Foreign-Key-外键"><a class="header-anchor" href="#Foreign-Key-外键">¶</a>Foreign Key (外键)</h3>
<p>根据外键约定，EF Core API 将使用以下命名模式之一为实体中的每个引用导航属性创建一个外键列：</p>
<ul>
<li>
<p><code>&lt;Reference Navigation Property Name&gt;Id</code></p>
</li>
<li>
<p><code>&lt;Reference Navigation Property Name&gt;</code></p>
</li>
<li>
<p><code>&lt;Principal Primary Key Property Name&gt;</code></p>
</li>
</ul>
<p>在我们的示例 (学生和成绩实体) 中，EF Core 将在 <code>Student</code> 表中创建一个外键列 <code>GradeId</code>，如下图所示。</p>
<p><img src="/images/efcore/20200207213556349.png" alt="图8-4"></p>
<p>下表列出了不同引用属性名称和主键属性名称的外键列名称:</p>
<table>
<thead>
<tr>
<th style="text-align:center">从属实体中的引用属性名称</th>
<th style="text-align:center">从属实体中的外键属性名称</th>
<th style="text-align:center">主体主键属性名称</th>
<th style="text-align:center">数据库中的外键列名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Grade</td>
<td style="text-align:center">GradeId</td>
<td style="text-align:center">GradeId</td>
<td style="text-align:center">GradeId</td>
</tr>
<tr>
<td style="text-align:center">Grade</td>
<td style="text-align:center">-</td>
<td style="text-align:center">GradeId</td>
<td style="text-align:center">GradeId</td>
</tr>
<tr>
<td style="text-align:center">Grade</td>
<td style="text-align:center">-</td>
<td style="text-align:center">Id</td>
<td style="text-align:center">GradeId</td>
</tr>
<tr>
<td style="text-align:center">CurrentGrade</td>
<td style="text-align:center">CurrentGradeId</td>
<td style="text-align:center">GradeId</td>
<td style="text-align:center">CurrentGradeId</td>
</tr>
<tr>
<td style="text-align:center">CurrentGrade</td>
<td style="text-align:center">-</td>
<td style="text-align:center">GradeId</td>
<td style="text-align:center">CurrentGradeGradeId</td>
</tr>
<tr>
<td style="text-align:center">CurrentGrade</td>
<td style="text-align:center">-</td>
<td style="text-align:center">Id</td>
<td style="text-align:center">CurrentGradeId</td>
</tr>
<tr>
<td style="text-align:center">CurrentGrade</td>
<td style="text-align:center">GradeId</td>
<td style="text-align:center">Id</td>
<td style="text-align:center">GradeId</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>笔记</strong>：</p>
<hr>
<p>即：</p>
<ul>
<li>从属实体有外键属性 (即符合上述外键列名称生成条件的属性) 时使用从属实体中的外键属性名称。</li>
<li>从属实体没有外键属性时：
<ul>
<li>第一步，按上述外键列名称生成条件生成一个列名。</li>
<li>第二步，判断主体主键属性名称是否是 <code>Id</code>、<code>ID</code>、<code>iD</code> 或 <code>id</code>。</li>
<li>第三步，如果主体主键是上一步的四个中之一，那么使用生成的外键名；如果不是那么列名 = 生成的外键列名 + 主体主键属性名。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="索引"><a class="header-anchor" href="#索引">¶</a>索引</h3>
<p>默认情况下，EF Core 在主键列上创建聚簇索引，在外键列上创建非聚簇索引。</p>
<h2 id="九、Entity-Framework-Core-中的一对多关系约定"><a class="header-anchor" href="#九、Entity-Framework-Core-中的一对多关系约定">¶</a>九、Entity Framework Core 中的一对多关系约定</h2>
<p>对于一对多关系，Entity Framework Core 遵循与 Entity Framework6.x 相同的约定。唯一的区别是 EF Core 创建的外键列的名称与导航属性名称相同，而不是与<code>&lt;NavigationPropertyName&gt;_&lt;PrimaryKeyPropertyName&gt;</code>。<br>
让我们看一下不同的约定，这些约定会自动在以下 <code>Student</code> 和 <code>Grade</code> 实体之间配置一对多关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class Student &#123;<br>    public int StudentId &#123; get; set; &#125;<br>    public string StudentName &#123; get; set; &#125;<br>&#125;<br>       <br>public class Grade &#123;<br>    public int GradeId &#123; get; set; &#125;<br>    public string GradeName &#123; get; set; &#125;<br>    public string Section &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的实体中应用了一对多关系的约定后，<code>Student</code> 和 <code>Grade</code> 实体的数据库表将如下所示，其中 <code>Student</code> 表包括外键 <code>GradeId</code>。</p>
<p><img src="/images/efcore/20200207214603619.png" alt="图9-1"></p>
<h3 id="约定一"><a class="header-anchor" href="#约定一">¶</a>约定一</h3>
<p>我们希望建立一对多的关系，其中许多学生与一个年级相关。可以通过在从属实体中包含引用导航属性来实现此目的，如下所示 (此处，学生实体是从属实体，而成绩实体是主要实体)：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Student &#123;<br>    public int Id &#123; get; set; &#125;<br>    public string Name &#123; get; set; &#125;<br>   <br>    public Grade Grade &#123; get; set; &#125;<br>&#125;<br><br>public class Grade &#123;<br>    public int GradeId &#123; get; set; &#125;<br>    public string GradeName &#123; get; set; &#125;<br>    public string Section &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，学生实体类包括班级类型的引用导航属性。这使我们可以将同一年级链接到许多不同的学生实体，从而在它们之间建立一对多的关系。这将在数据库的“学生”和“成绩”表之间产生一对多关系，其中“学生”表包含可为空的外键 <code>GradeId</code>，如下所示。 EF Core 将为概念模型中名为 <code>GradeId</code> 的外键创建一个阴影属性，该属性将映射到 <code>Students</code> 表中的 <code>GradeId</code> 外键列。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>引用属性 <code>Grade</code> 是可为空的，因此它将在 <code>Student</code> 表中创建可为空的ForeignKey <code>GradeId</code>。您可以使用 fluent API 配置 NotNull 外键。</p>
</blockquote>
<p><img src="/images/efcore/20200207214616638.png" alt="图9-2"></p>
<h3 id="约定二"><a class="header-anchor" href="#约定二">¶</a>约定二</h3>
<p>另一个约定是在主体实体中包括集合导航属性，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class Student &#123;<br>    public int StudentId &#123; get; set; &#125;<br>    public string StudentName &#123; get; set; &#125;<br>&#125;<br><br>public class Grade &#123;<br>    public int GradeId &#123; get; set; &#125;<br>    public string GradeName &#123; get; set; &#125;<br>    public string Section &#123; get; set; &#125;<br>	&#x2F;&#x2F;集合导航属性<br>    public ICollection&lt;Student&gt; Students &#123; get; set; &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>Grade</code> 实体包括类型为 <code>ICollection&lt;Student&gt;</code> 的集合导航属性。这将使我们能够向班级实体添加多个“学生”实体，从而导致数据库中“学生”和“班级”表之间存在一对多的关系，与约定一的目的相同。</p>
<h3 id="约定三"><a class="header-anchor" href="#约定三">¶</a>约定三</h3>
<p>一对多关系的另一个 EF 约定是在两端都包含导航属性，这也将会时数据表产生一对多关系（约定一 + 约定二）。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class Student &#123;<br>    public int Id &#123; get; set; &#125;<br>    public string Name &#123; get; set; &#125;<br>    &#x2F;&#x2F;引用导航属性<br>    public Grade Grade &#123; get; set; &#125;<br>&#125;<br><br>public class Grade &#123;<br>    public int GradeID &#123; get; set; &#125;<br>    public string GradeName &#123; get; set; &#125;<br>    &#x2F;&#x2F;集合导航属性<br>    public ICollection&lt;Student&gt; Students &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，学生实体包括班级类型的引用导航属性，班级实体类包括集合导航属性 <code>ICollection&lt;Student&gt;</code>，这导致相应的数据库表“学生”和“成绩”之间存在一对多关系，与约定一目的相同。</p>
<h3 id="约定四"><a class="header-anchor" href="#约定四">¶</a>约定四</h3>
<p>使用从属实体中的外键属性在两端完全定义该关系会创建一对多关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class Student &#123;<br>    public int Id &#123; get; set; &#125;<br>    public string Name &#123; get; set; &#125;<br><br>    public int GradeId &#123; get; set; &#125;<br>    public Grade Grade &#123; get; set; &#125;<br>&#125;<br><br>public class Grade &#123;<br>    public int GradeId &#123; get; set; &#125;<br>    public string GradeName &#123; get; set; &#125;<br><br>    public ICollection&lt;Student&gt; Students &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>Student</code> 实体包括类型为 <code>int</code> 的外键属性 <code>GradeId</code> 及其引用导航属性 <code>Grade</code>。在另一端，成绩实体还包括一个集合导航属性<code>ICollection&lt;Student&gt;</code>。这将与 <code>Student</code> 表中的 NotNull 外键列建立一对多关系，如下所示：</p>
<p><img src="/images/efcore/20200207214634262.png" alt="图9-3"></p>
<p>如果要将外键 <code>GradeId</code> 设置为可为空，则使用可为 <code>null</code> 的 <code>int</code> 数据类型 (<code>Nullable&lt;int&gt;</code> 或 <code>int?</code>)，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class Student &#123;<br>    public int Id &#123; get; set; &#125;<br>    public string Name &#123; get; set; &#125;<br><br>    public int? GradeId &#123; get; set; &#125; <br>    public Grade Grade &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这些约定是在相应的数据库表中自动创建一对多关系的约定。如果实体不遵循上述约定，则可以使用 Fluent API 来配置一对多关系。</p>
<h2 id="十、Entity-Framework-Core-一对一关系约定"><a class="header-anchor" href="#十、Entity-Framework-Core-一对一关系约定">¶</a>十、Entity Framework Core 一对一关系约定</h2>
<p>Entity Framework Core 引入了 <strong>默认约定</strong>，该约定自动配置两个实体之间的一对一关系 (EF 6.x或更早版本不支持一对一关系的约定)。<br>
在 EF Core 中，一对一关系在 <strong>两侧都需要参考导航属性</strong>。下列 <code>Student</code> 和 <code>StudentAddress</code> 实体遵循一对一关系的约定:</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class Student &#123;<br>    public int Id &#123; get; set; &#125;<br>    public string Name &#123; get; set; &#125;<br>       <br>    public StudentAddress Address &#123; get; set; &#125;<br>&#125;<br><br>public class StudentAddress &#123;<br>    public int StudentAddressId &#123; get; set; &#125;<br>    public string Address &#123; get; set; &#125;<br>    public string City &#123; get; set; &#125;<br>    public string State &#123; get; set; &#125;<br>    public string Country &#123; get; set; &#125;<br><br>    public int StudentId &#123; get; set; &#125;<br>    public Student Student &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>Student</code> 实体包括类型为 <code>StudentAddress</code> 的引用导航属性，而 <code>StudentAddress</code> 实体包括外键属性 <code>StudentId</code> 及其对应的引用属性 <code>Student</code> 。这将在数据库中的对应表 <code>Student</code> 和 <code>StudentAddresses</code> 中产生一对一的关系，如下所示：</p>
<p><img src="/images/efcore/20200207215111952.png" alt="图10-1"></p>
<p>EF Core 在 <code>StudentAddresses</code> 表的 NotNull 外键列 <code>StudentId</code> 上创建了唯一索引，如上所示。这样可以确保外键列 <code>StudentId</code> 的值在 <code>StudentAddress</code> 表中必须唯一，这是一对一关系所必需的。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>Entity Framework Core 支持唯一约束，但 EF 6 不支持唯一约束，因此 EF Core 包括一对一关系的约定，但不包括 EF6.x。如果实体不遵循约定，则使用 Fluent API 配置一对一关系。</p>
</blockquote>
<h2 id="十一、Entity-Framework-Core-配置"><a class="header-anchor" href="#十一、Entity-Framework-Core-配置">¶</a>十一、Entity Framework Core 配置</h2>
<p>您已在上一章中了解了 EF Core 中的 <strong>默认约定</strong>。很多时候，我们希望自定义实体到表的映射，并且不想遵循默认约定。 EF Core 允许我们配置领域实体类，以自定义 EF 模型到数据库的映射。此编程模式称为 <strong>约定优于配置</strong>。<br>
有两种方法可以在 EF Core 中配置领域实体类 (与 EF 6 中相同)：</p>
<ul>
<li>通过使用数据注释特性 (Data Annotation)</li>
<li>通过使用 Fluent API</li>
</ul>
<h3 id="数据注释特性-Data-Annotation-Attributes"><a class="header-anchor" href="#数据注释特性-Data-Annotation-Attributes">¶</a>数据注释特性 (Data Annotation Attributes)</h3>
<p>数据注释是一种基于特性的简单配置方法，其中可以将不同的.NET特性应用于领域模型类和属性以配置模型。<br>
数据注释属性不专用于 Entity Framework，因为它们在 <a href="http://ASP.NET" target="_blank" rel="noopener">ASP.NET</a> MVC 中也使用。这就是为什么这些属性包含在单独的命名空间 <code>System.ComponentModel.DataAnnotations</code> 中的原因。<br>
下面的示例演示如何将数据注释特性应用于领域实体类和属性以覆盖约定。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">[Table(&quot;StudentInfo&quot;)] &#x2F;&#x2F;定义映射的表名<br>public class Student &#123;<br>    public Student() &#123; &#125;<br><br>    [Key]&#x2F;&#x2F;定义主键<br>    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]  &#x2F;&#x2F; 自增主键。其中 DatabaseGeneratedOption 的有三个属性：Identity：自增长、None：不处理、Computed：表示这一列是计算列。<br>    public int SID &#123; get; set; &#125;<br><br>    [Column(&quot;Name&quot;, TypeName&#x3D;&quot;ntext&quot;)]&#x2F;&#x2F;定义列名及类型<br>    [MaxLength(20)]<br>    public string StudentName &#123; get; set; &#125;<br><br>    [NotMapped] &#x2F;&#x2F;不在数据库中生成列<br>    public int? Age &#123; get; set; &#125;<br><br>    public int StdId &#123; get; set; &#125;<br><br>    [ForeignKey(&quot;StdId&quot;)] &#x2F;&#x2F;定义外键<br>    public virtual Standard Standard &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>数据注释特性在 EF 6 和 EF Core 中相同。有关更多信息，请访问 EF 6 部分中的“数据注释”一章。</p>
<h3 id="Fluent-API"><a class="header-anchor" href="#Fluent-API">¶</a>Fluent API</h3>
<p>配置领域模型类的另一种方法是使用 Entity Framework Fluent API。EF Fluent API 基于 Fluent API 设计模式 (也称为 Fluent 接口)，其中结果通过方法链来表示，下一节我们将介绍。</p>
<h2 id="十二、Entity-Framework-Core-Fluent-API"><a class="header-anchor" href="#十二、Entity-Framework-Core-Fluent-API">¶</a>十二、Entity Framework Core Fluent API</h2>
<p><strong>Entity Framework Core Fluent API 用于配置领域实体类以覆盖约定</strong>。EF Fluent API 基于 Fluent API 设计模式 (也称为 Fluent 接口)，其中结果通过方法链来表示。</p>
<p>在 Entity Framework Core 中，<code>ModelBuilder</code> 类充当 Fluent API。通过使用它，我们可以配置许多不同的东西，因为它提供了比数据注释属性更多的配置选项。<br>
Entity Framework Core Fluent API 配置了模型的以下方面：</p>
<ul>
<li>
<p><strong>模型配置</strong>：将 EF 模型配置为数据库映射。配置默认架构，数据库功能，其他数据注释属性和要从映射中排除的实体。</p>
</li>
<li>
<p><strong>实体配置</strong>：配置实体到表和关系的映射，例如 PrimaryKey、AlternateKey、Index、表名、一对一、一对多、多对多关系等。</p>
</li>
<li>
<p><strong>属性配置</strong>：将属性配置为列映射，例如列名称、默认值、可空性、外键、数据类型、并发列等。</p>
</li>
</ul>
<p>下表列出了每种配置类型的重要方法：</p>
<table>
    <thead>
        <tr>
            <th style="text-align: center">配置</th>
            <th style="text-align: center"><span style="font-wegiht: bold">Fluent API 方法</span></th>
            <th style="text-align: center">用法</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="4" style="text-align: center; vertical-align: middle">模型配置</td>
            <td style="text-align: center"><code>HasDbFunction()</code></td>
            <td style="text-align: center">在定位关系数据库时配置数据库功能</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasDefaultSchema()</code></td>
            <td style="text-align: center">指定数据库架构</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasAnnotation()</code></td>
            <td style="text-align: center">在实体上添加或更新数据注释属性</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasSequence()</code></td>
            <td style="text-align: center">定位关系数据库时配置数据库序列</td>
        </tr>
        <tr>
            <td rowspan="8" style="text-align: center; vertical-align: middle">实体配置</td>
            <td style="text-align: center"><code>HasAlternateKey()</code></td>
            <td style="text-align: center">在 EF 模型中为实体配置备用密钥</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasIndex()</code></td>
            <td style="text-align: center">配置指定属性的索引</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasKey()</code></td>
            <td style="text-align: center">将属性或属性列表配置为主键</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasMany()</code></td>
            <td style="text-align: center">配置关系的“很多”部分，其中实体包含一对多或多对多关系的其他类型的引用集合属性</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasOne()</code></td>
            <td style="text-align: center">配置关系的“一部分”，其中实体包含一对一或一对多关系的其他类型的引用属性</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>Ignore()</code></td>
            <td style="text-align: center">配置不应将类或属性映射到表或列</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>OwnsOne()</code></td>
            <td style="text-align: center">配置关系，其中目标实体由该实体拥有。目标实体键值是从它所属的实体传播的</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>ToTable()</code></td>
            <td style="text-align: center">配置实体映射到的数据库表</td>
        </tr>
        <tr>
            <td rowspan="15" style="text-align: center; vertical-align: middle">属性配置</td>
            <td style="text-align: center"><code>HasColumnName()</code></td>
            <td style="text-align: center">在数据库中为属性配置相应的列名称</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasColumnType()</code></td>
            <td style="text-align: center">为属性配置数据库中相应列的数据类型</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasComputedColumnSql()</code></td>
            <td style="text-align: center">配置属性以在关系数据库为目标时映射到数据库中的计算列</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasDefaultValue()</code></td>
            <td style="text-align: center">为目标关系数据库配置属性映射到的列的默认值</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasDefaultValueSql()</code></td>
            <td style="text-align: center">在定位关系数据库时，为属性映射到的列配置默认值表达式</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasField()</code></td>
            <td style="text-align: center">在指定要与属性一起使用的后备字段</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>HasMaxLength()</code></td>
            <td style="text-align: center">配置可以存储在属性中的最大数据长度</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>IsConcurrencyToken()</code></td>
            <td style="text-align: center">将属性配置为用作乐观并发令牌</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>IsRequired()</code></td>
            <td style="text-align: center">配置属性的有效值是必需的还是 <code>null</code> 为有效值</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>IsRowVersion()</code></td>
            <td style="text-align: center">配置要在乐观并发检测中使用的属性</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>IsUnicode()</code></td>
            <td style="text-align: center">配置字符串属性，该属性可以包含或不包含 Unicode 字符</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>ValueGeneratedNever()</code></td>
            <td style="text-align: center">配置保存实体时不能具有生成值的属</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>ValueGeneratedOnAdd()</code></td>
            <td style="text-align: center">配置在保存新实体时属性具有生成的值</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>ValueGeneratedOnAddOrUpdate()</code></td>
            <td style="text-align: center">配置保存新实体或现有实体时属性具有生成的值</td>
        </tr>
        <tr>
            <td style="text-align: center"><code>ValueGeneratedOnUpdate()</code></td>
            <td style="text-align: center">配置在保存现有实体时属性具有生成的值</td>
        </tr>
    </tbody>
</table>
<h3 id="Fluent-API-配置"><a class="header-anchor" href="#Fluent-API-配置">¶</a>Fluent API 配置</h3>
<p>重写 <code>OnModelCreating</code> 方法，并使用 <code>ModelBuilder</code> 类型的参数 <code>modelBuilder</code>来配置领域实体类，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class SchoolDBContext: DbContext  &#123;<br>    public DbSet&lt;Student&gt; Students &#123; get; set; &#125;<br>        <br>    protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;<br>        &#x2F;&#x2F;Write Fluent API configurations here<br>        &#x2F;&#x2F;Property Configurations<br>        modelBuilder.Entity&lt;Student&gt;()<br>                .Property(s &#x3D;&gt; s.StudentId)<br>                .HasColumnName(&quot;Id&quot;)<br>                .HasDefaultValue(0)<br>                .IsRequired();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>ModelBuilder</code> Fluent API 实例用于通过调用链中的多个方法来配置属性。它配置 <code>Student</code> 实体的 <code>StudentId</code> 属性；它在单个语句而不是多个语句中使用 <code>HasColumnName</code> 配置名称，使用 <code>HasDefaultValue</code> 配置默认值，并使用 <code>IsRequired</code> 方法配置可空性。与多条语句相比，这提高了可读性，并且花费的时间更少，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">&#x2F;&#x2F;Fluent API method chained calls<br>modelBuilder.Entity&lt;Student&gt;()<br>        .Property(s &#x3D;&gt; s.StudentId)<br>        .HasColumnName(&quot;Id&quot;)<br>        .HasDefaultValue(0)<br>        .IsRequired();<br><br>&#x2F;&#x2F;Separate method calls<br>modelBuilder.Entity&lt;Student&gt;().Property(s &#x3D;&gt; s.StudentId).HasColumnName(&quot;Id&quot;);<br>modelBuilder.Entity&lt;Student&gt;().Property(s &#x3D;&gt; s.StudentId).HasDefaultValue(0);<br>modelBuilder.Entity&lt;Student&gt;().Property(s &#x3D;&gt; s.StudentId).IsRequired();<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>Fluent API配置的优先级高于数据注释属性。</p>
</blockquote>
<h2 id="十三、Entity-Framework-Core-Fluent-API-配置一对一关系"><a class="header-anchor" href="#十三、Entity-Framework-Core-Fluent-API-配置一对一关系">¶</a>十三、Entity Framework Core Fluent API 配置一对一关系</h2>
<p>通常，您不需要手动配置一对一关系，因为 EF Core 包含一对一关系的约定。但是，如果键或外键属性不遵循约定，则可以使用数据注释属性或 Fluent API 在两个实体之间配置一对一关系。<br>
让我们在以下不遵循外键约定的 <code>Student</code> 和 <code>StudentAddress</code> 实体之间配置一对一关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class Student &#123;<br>    public int Id &#123; get; set; &#125;<br>    public string Name &#123; get; set; &#125;<br>       <br>    public StudentAddress Address &#123; get; set; &#125;<br>&#125;<br><br>public class StudentAddress &#123;<br>    public int StudentAddressId &#123; get; set; &#125;<br>    public string Address &#123; get; set; &#125;<br>    public string City &#123; get; set; &#125;<br>    public string State &#123; get; set; &#125;<br>    public string Country &#123; get; set; &#125;<br><br>    public int AddressOfStudentId &#123; get; set; &#125;<br>    public Student Student &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>要在 EF Core 中使用 Fluent API 配置一对一关系，请使用 <code>HasOne</code>、<code>WithOne</code> 和 <code>HasForeignKey</code> 方法，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class SchoolContext : DbContext &#123;<br>    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;<br>        optionsBuilder.UseSqlServer(&quot;Server&#x3D;.\\SQLEXPRESS;Database&#x3D;EFCore-SchoolDB;Trusted_Connection&#x3D;True&quot;);<br>    &#125;<br><br>    protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;<br>        modelBuilder.Entity&lt;Student&gt;()<br>            .HasOne&lt;StudentAddress&gt;(s &#x3D;&gt; s.Address)<br>            .WithOne(ad &#x3D;&gt; ad.Student)<br>            .HasForeignKey&lt;StudentAddress&gt;(ad &#x3D;&gt; ad.AddressOfStudentId);<br>    &#125;<br><br>    public DbSet&lt;Student&gt; Students &#123; get; set; &#125;<br>    public DbSet&lt;StudentAddress&gt; StudentAddresses &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，以下代码片段配置了一对一关系:</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">modelBuilder.Entity&lt;Student&gt;()<br>    .HasOne&lt;StudentAddress&gt;(s &#x3D;&gt; s.Address)<br>    .WithOne(ad &#x3D;&gt; ad.Student)<br>    .HasForeignKey&lt;StudentAddress&gt;(ad &#x3D;&gt; ad.AddressOfStudentId);<br></code></pre></div></td></tr></table></figure>
<p>让我们逐步分析代码:</p>
<ol>
<li><code>modelBuilder.Entity&lt;Student&gt;()</code> 开始配置 <code>Student</code> 实体。</li>
<li><code>.HasOne&lt;StudentAddress&gt;(s =&gt; s.Address)</code> 方法使用 lambda 表达式指定 <code>Student</code> 实体包括一个 <code>StudentAddress</code> 引用属性。</li>
<li><code>.WithOne(ad =&gt; ad.Student)</code> 配置关系的另一端，<code>StudentAddress</code> 实体。它指定 <code>StudentAddress</code> 实体包括 <code>Student</code> 类型的参考导航属性。</li>
<li><code>.HasForeignKey&lt;StudentAddress&gt;(ad =&gt; ad.AddressOfStudentId)</code> 指定外键属性名称。</li>
</ol>
<p>现在，要将其反映在数据库中，请执行迁移命令，<code>add-migration &lt;名称&gt;</code> 和 <code>update-database</code>。该数据库将包括两个具有一对一关系的表，如下所示：</p>
<p><img src="/images/efcore/20200207221956122.png" alt="图13-1"></p>
<p>下图说明了一对一关系的 Fluent API 配置：</p>
<p><img src="/images/efcore/20200207222010325.png" alt="13-2"></p>
<p>您可以按照以下相同的方式开始使用 <code>StudentAddress</code> 实体进行配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">modelBuilder.Entity&lt;StudentAddress&gt;()<br>    .HasOne&lt;Student&gt;(ad &#x3D;&gt; ad.Student)<br>    .WithOne(s &#x3D;&gt; s.Address)<br>    .HasForeignKey&lt;StudentAddress&gt;(ad &#x3D;&gt; ad.AddressOfStudentId);<br></code></pre></div></td></tr></table></figure>
<p>因此，您可以在 Entity Framework Core 中配置一对一关系。</p>
<h2 id="十四、在-Entity-Framework-Core-Fluent-API-配置多对多关系"><a class="header-anchor" href="#十四、在-Entity-Framework-Core-Fluent-API-配置多对多关系">¶</a>十四、在 Entity Framework Core Fluent API 配置多对多关系</h2>
<p>让我们在以下学生和课程实体之间实现多对多关系，其中一个学生可以报名参加许多课程，并且以同样的方式，许多学生可以加入一门课程。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class Student &#123;<br>    public int StudentId &#123; get; set; &#125;<br>    public string Name &#123; get; set; &#125;<br>&#125;<br><br>public class Course &#123;<br>    public int CourseId &#123; get; set; &#125;<br>    public string CourseName &#123; get; set; &#125;<br>    public string Description &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>数据库中的多对多关系由联接表表示，联接表包括两个表的外键。同样，这些外键是复合主键。</strong></p>
<p><img src="/images/efcore/20200207222442650.png" alt="图14-1"></p>
<h3 id="约定"><a class="header-anchor" href="#约定">¶</a>约定</h3>
<p><strong>Entity Framework Core 中没有可用于自动配置多对多关系的默认约定</strong>。您必须使用 Fluent API 对其进行配置。</p>
<h3 id="Fluent-API-v2"><a class="header-anchor" href="#Fluent-API-v2">¶</a>Fluent API</h3>
<p>在 Entity Framework 6.x 或更低版本中，EF API 用于为多对多关系创建联接表。我们不需要为联接表创建联接实体 (但是，我们当然可以在 EF 6 中显式创建联接实体)。</p>
<p>在 Entity Framework Core 中，这尚未实现。<strong>我们必须为联接表创建联接实体类</strong>。上述学生和课程实体的加入实体应包括每个实体的外键属性和参考导航属性。</p>
<p>配置多对多关系的步骤如下:</p>
<ol>
<li>定义一个新的加入实体类，该类包括每个实体的外键属性和引用导航属性。</li>
<li>通过在两侧的实体中包括集合导航属性 (在本例中为“学生”和“课程”)，定义其他两个实体与加入实体之间的一对多关系。</li>
<li>使用 Fluent API 将加入实体中的两个外键都配置为组合键。<br>
因此，首先，定义连接实体 <code>StudentCourse</code>，如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class StudentCourse &#123;<br>    public int StudentId &#123; get; set; &#125;<br>    public Student Student &#123; get; set; &#125;<br><br>    public int CourseId &#123; get; set; &#125;<br>    public Course Course &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上述加入实体 <code>StudentCourse</code> 分别包括引用导航属性 <code>Student</code> 和 <code>Course</code> 以及它们的外键属性 <code>StudentId</code> 和 <code>CourseId</code> (外键属性遵循约定)。<br>
现在，我们还需要在 <code>Student</code> -&gt; <code>StudentCourse</code> 和 <code>Course</code> -&gt; <code>StudentCourse</code> 实体之间配置两个单独的一对多关系。我们可以通过遵循一对多关系的约定来做到这一点，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Student &#123;<br>    public int StudentId &#123; get; set; &#125;<br>    public string Name &#123; get; set; &#125;<br><br>    public IList&lt;StudentCourse&gt; StudentCourses &#123; get; set; &#125;<br>&#125;<br><br>public class Course<br>&#123;<br>    public int CourseId &#123; get; set; &#125;<br>    public string CourseName &#123; get; set; &#125;<br>    public string Description &#123; get; set; &#125;<br><br>    public IList&lt;StudentCourse&gt; StudentCourses &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如您在上面所看到的，<code>Student</code> 和 <code>Course</code> 实体现在包括 <code>StudentCourse</code> 类型的集合导航属性。<code>StudentCourse</code> 实体已经包含了 <code>Student</code> 和 <code>Course</code> 的外键属性和导航属性。这使其在 <code>Student</code> 和 <code>StudentCourse</code> 与<code>Course</code> 和 <code>StudentCourse</code> 之间建立了完全定义的一对多关系。<br>
现在，外键必须是联接表中的复合主键。只能使用 Fluent API 进行配置，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class SchoolContext : DbContext &#123;<br>    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;<br>        optionsBuilder.UseSqlServer(&quot;Server&#x3D;.\\SQLEXPRESS;Database&#x3D;EFCore-SchoolDB;Trusted_Connection&#x3D;True&quot;);<br>    &#125;<br><br>    protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;<br>        modelBuilder.Entity&lt;StudentCourse&gt;().HasKey(sc &#x3D;&gt; new &#123; sc.StudentId, sc.CourseId &#125;);<br>    &#125;<br>    <br>    public DbSet&lt;Student&gt; Students &#123; get; set; &#125;<br>    public DbSet&lt;Course&gt; Courses &#123; get; set; &#125;<br>    public DbSet&lt;StudentCourse&gt; StudentCourses &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的代码中，<code>modelBuilder.Entity&lt;StudentCourse&gt;().HasKey(sc =&gt; new { sc.StudentId, sc.CourseId })</code> 将 <code>StudentId</code> 和<code> CourseId</code> 配置为组合键。<br>
如果实体遵循与加入实体的一对多关系的约定，则可以通过这种方法配置多对多关系。假设外键属性名称不遵循约定 (例如，<code>SID</code> 代替 <code>StudentId</code>，<code>CID</code> 代替 <code>CourseId</code>)，则可以使用 Fluent API 对其进行配置，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">modelBuilder.Entity&lt;StudentCourse&gt;().HasKey(sc &#x3D;&gt; new &#123; sc.SId, sc.CId &#125;);<br><br>modelBuilder.Entity&lt;StudentCourse&gt;()<br>    .HasOne&lt;Student&gt;(sc &#x3D;&gt; sc.Student)<br>    .WithMany(s &#x3D;&gt; s.StudentCourses)<br>    .HasForeignKey(sc &#x3D;&gt; sc.SId);<br><br>modelBuilder.Entity&lt;StudentCourse&gt;()<br>    .HasOne&lt;Course&gt;(sc &#x3D;&gt; sc.Course)<br>    .WithMany(s &#x3D;&gt; s.StudentCourses)<br>    .HasForeignKey(sc &#x3D;&gt; sc.CId);<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>EF 团队将包含一项功能，将来我们无需为多对多关系创建加入实体。在 GitHub 上跟踪此问题。</p>
</blockquote>
<h2 id="十五、在-Entity-Framework-Core-的断开模式下插入数据"><a class="header-anchor" href="#十五、在-Entity-Framework-Core-的断开模式下插入数据">¶</a>十五、在 Entity Framework Core 的断开模式下插入数据</h2>
<p>在断开连接的方案中保存数据与在连接的方案中保存数据有些不同。在断开连接的情况下，<code>DbContext</code> 不知道断开连接的实体，因为在当前 <code>DbContext</code> 实例的范围之外添加或修改了实体。因此，您需要将断开连接的实体附加到具有适当 <code>EntityState</code> 的上下文，以便对数据库执行 CUD (创建，更新，删除) 操作。<br>
下图说明了断开连接情况下的 CUD 操作：</p>
<p><img src="/images/efcore/20200208105621549.png" alt="图14-1"></p>
<p>根据上图，断开的实体 (<code>DbContext</code> 不会跟踪的实体) 需要使用适当的 <code>EntityState</code> 附加到 <code>DbContext</code>。例如，新实体的已添加状态，已编辑实体的已修改状态和已删除实体的已删除状态，这将在调用 <code>SaveChanges()</code> 方法时在数据库中产生 <code>INSERT</code>，<code>UPDATE</code> 或 <code>DELETE</code> 命令。<br>
为了在断开连接的情况下使用 Entity Framework Core 将记录插入，更新或删除到 <code>DB</code> 表中，必须执行以下步骤：</p>
<ol>
<li>使用适当的 <code>EntityState</code> 将实体附加到 <code>DbContext</code> ，例如添加，修改或删除。</li>
<li>调用 <code>SaveChanges()</code> 方法。</li>
</ol>
<p>下面的示例演示如何使用上述步骤将新记录插入数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">&#x2F;&#x2F; Disconnected entity<br>var std &#x3D; new Student() &#123; Name &#x3D; &quot;Bill&quot; &#125;;<br><br>using (var context &#x3D; new SchoolContext()) &#123;<br>    &#x2F;&#x2F; 1. 使用添加的EntityState将实体附加到上下文<br>    context.Add&lt;Student&gt;(std);<br>    &#x2F;&#x2F; 或以下内容也有效<br>    &#x2F;&#x2F; context.Students.Add(std);<br>    <br>    &#x2F;&#x2F; context.Entry&lt;Student&gt;(std).State &#x3D; EntityState.Added;<br>    &#x2F;&#x2F; context.Attach&lt;Student&gt;(std);<br>                  <br>    &#x2F;&#x2F; 2. 调用SaveChanges将新记录插入Student表<br>    context.SaveChanges();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>std</code> 是 <code>Student</code> 实体的断开连接的实例。<code>context.Add&lt;Student&gt;()</code> 方法将 <code>Student</code> 实体附加到具有添加状态的上下文。 <code>SaveChanges()</code> 方法将生成并执行以下 <code>INSERT</code> 语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">exec sp_executesql N&#39;SET NOCOUNT ON;<br>INSERT INTO [Students] ([Name])<br>VALUES (@p0);<br>SELECT [StudentId]<br>FROM [Students]<br>WHERE @@ROWCOUNT &#x3D; 1 AND [StudentId] &#x3D; scope_identity();&#39;,N&#39;@p0 nvarchar(4000), <br>@p1 nvarchar(4000) &#39;,@p0&#x3D;N&#39;Bill&#39;<br>Go<br></code></pre></div></td></tr></table></figure>
<p>EF Core 提供了多种添加状态为 “Added” 的实体的方法。在上面的示例中，<code>context.Students.Add(std);</code>、 <code>context.Entry&lt;Student&gt;(std).State = EntityState.Added;</code> 和 <code>context.Attach&lt;Student&gt;(std);</code> 将导致与上述相同的<code>INSERT</code> 语句。</p>
<p>EF Core 提供了以下 <code>DbContext</code> 和 <code>DbSet</code> 方法，这些方法将断开连接的实体与添加的 <code>EntityState</code> 附加在一起，后者又将在数据库中执行 <code>INSERT</code> 语句。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong><code>DbContext</code> 方法</strong></th>
<th style="text-align:center"><strong><code>DbSet</code> 方法</strong></th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>DbContext.Attach</code></td>
<td style="text-align:center"><code>DbSet.Attach</code></td>
<td style="text-align:center">将实体附加到 <code>DbContext</code>。为其 <code>Key</code> 属性具有值的实体设置“不变”状态，为其 <code>Key</code> 属性为空或数据类型的默认值的实体设置“添加”状态</td>
</tr>
<tr>
<td style="text-align:center"><code>DbContext.Add</code></td>
<td style="text-align:center"><code>DbSet.Add</code></td>
<td style="text-align:center"><code>DbContext.Add</code>、<code>DbSet.Add</code> 将具有附加状态的实体附加到 <code>DbContext</code></td>
</tr>
<tr>
<td style="text-align:center"><code>DbContext.AddRange</code></td>
<td style="text-align:center"><code>DbSet.AddRange</code></td>
<td style="text-align:center"><code>DbContext.AddRange</code>、<code>DbSet.AddRange</code> 将实体集合附加到具有添加状态的 <code>DbContext</code></td>
</tr>
<tr>
<td style="text-align:center"><code>DbContext.Entry</code></td>
<td style="text-align:center">-</td>
<td style="text-align:center"><code>DbContext.Entry</code> - 获取指定实体的 <code>EntityEntry</code>，该实体提供对更改跟踪信息和操作的访问</td>
</tr>
<tr>
<td style="text-align:center"><code>DbContext.AddAsync</code></td>
<td style="text-align:center"><code>DbSet.AddAsync</code></td>
<td style="text-align:center"><code>DbContext.AddAsync</code>、<code>DbSet.AddAsync</code> 异步方法，用于将实体附加到具有“已添加”状态的 <code>DbContext</code>上，如果没有，则开始跟踪它。调用 <code>SaveChangesAsync()</code> 时，数据将插入数据库中</td>
</tr>
<tr>
<td style="text-align:center"><code>DbContext.AddRangeAsync</code></td>
<td style="text-align:center"><code>DbSet.AddRangeAsync</code></td>
<td style="text-align:center"><code>DbContext.AddRangeAsync</code>、<code>DbSet.AddRangeAsync</code> 异步方法，用于一次性将多个实体附加到具有添加状态的 <code>DbContext</code> 上，如果没有，则开始跟踪它们。调用 <code>SaveChangesAsync()</code> 时，数据将插入数据库中</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>上面的 <code>DbContext</code> 方法是在 EF Core 中引入的 (它们在 EF 6 或更早版本中不可用)。 <code>DbContext</code> 和 <code>DbSet</code> 方法都执行相同的操作。您使用哪一种取决于您的编码模式和偏好。</p>
</blockquote>
<h3 id="插入关系数据"><a class="header-anchor" href="#插入关系数据">¶</a>插入关系数据</h3>
<p>在上一章中，我们学习了在两个实体之间创建一对一、一对多和多对多关系。Entity Framework API 会插入相关实体中包含的所有关系数据。<br>
使用 <code>DbContext.Add</code> 或 <code>DbSet.Add</code> 方法将相关实体添加到数据库。 <code>Add</code> 方法将实体附加到上下文，并将“已添加”状态设置为 <code>ID</code> (键) 属性为空，空或数据类型默认值的实体图中的所有实体。考虑以下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var stdAddress &#x3D; new StudentAddress() &#123;<br>    City &#x3D; &quot;SFO&quot;,<br>    State &#x3D; &quot;CA&quot;,<br>    Country &#x3D; &quot;USA&quot;<br>&#125;;<br><br>var std &#x3D; new Student() &#123;<br>    Name &#x3D; &quot;Steve&quot;,<br>    Address &#x3D; stdAddress<br>&#125;;<br>using (var context &#x3D; new SchoolContext()) &#123;<br>    &#x2F;&#x2F; 将实体附加到具有添加状态的 DbContext<br>    context.Add&lt;Student&gt;(std);<br><br>    &#x2F;&#x2F; 调用 SaveChanges 将新记录插入 Student 表<br>    context.SaveChanges();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>context.Add&lt;Student&gt;(std)</code> 添加了 <code>Student</code> 实体的实例。 EF Core API 通过 <code>Student</code> 的引用导航属性到达 <code>StudentAddress</code> 实例，并将两个实体的 <code>EntityState</code> 标记为 <code>Added</code> ，这将在 <code>SaveChanges()</code> 上构建并执行以下两个 <code>INSERT</code> 命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">exec sp_executesql N&#39;SET NOCOUNT ON;<br>INSERT INTO [Students] ([Name])<br>VALUES (@p0);<br>SELECT [StudentId]<br>FROM [Students]<br>WHERE @@ROWCOUNT &#x3D; 1 AND [StudentId] &#x3D; scope_identity();&#39;,N&#39;@p0 nvarchar(4000), <br>@p1 nvarchar(4000) &#39;,@p0&#x3D;N&#39;Steve&#39;<br>Go<br><br>exec sp_executesql N&#39;SET NOCOUNT ON;<br>INSERT INTO [StudentAddresses] ([Address], [City], [Country], [State], [StudentId])<br>VALUES (@p5, @p6, @p7, @p8, @p9);<br>SELECT [StudentAddressId]<br>FROM [StudentAddresses]<br>WHERE @@ROWCOUNT &#x3D; 1 AND [StudentAddressId] &#x3D; scope_identity();<br>&#39;,N&#39;@p5 nvarchar(4000),@p6 nvarchar(4000),@p7 nvarchar(4000),@p8 nvarchar(4000),<br>@p9 int&#39;,@p5&#x3D;NULL,@p6&#x3D;N&#39;SFO&#39;,@p7&#x3D;N&#39;USA&#39;,@p8&#x3D;N&#39;CA&#39;,@p9&#x3D;1<br>Go<br></code></pre></div></td></tr></table></figure>
<p>使用 <code>DbContext.AddRange</code> 或 <code>DbSet.AddRange</code> 方法可一次性添加多个实体。您无需多次调用 <code>DbContext.Add</code> 方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>AddRange</code> 方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>void AddRange(IEnumerable&lt;Object&gt; entities)</code></td>
<td style="text-align:center"><code>void AddRange(IEnumerable&lt;Object&gt; entities)</code> 将具有相同或不同类型的实体的列表添加到具有“已添加”状态的 <code>DbContext</code> 中</td>
</tr>
<tr>
<td style="text-align:center"><code>void AddRange(param object[] entities)</code></td>
<td style="text-align:center"><code>void AddRange(param object[] entities)</code> 将具有相同或不同类型的实体的数组添加到具有“Added”状态的 <code>DbContext</code> 中</td>
</tr>
<tr>
<td style="text-align:center"><code>void AddRangeAsync(IEnumerable&lt;Object&gt;, CancellationToken)</code></td>
<td style="text-align:center"><code>void AddRangeAsync(IEnumerable&lt;Object&gt;, CancellationToken)</code> 异步方法，用于将相同或不同类型的实体列表添加到具有添加状态的 <code>DbContext</code> 中</td>
</tr>
</tbody>
</table>
<p>以下示例演示了使用 <code>AddRange</code> 添加学生实体对象列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var studentList &#x3D; new List&lt;Student&gt;() &#123;<br>    new Student()&#123; Name &#x3D; &quot;Bill&quot; &#125;,<br>    new Student()&#123; Name &#x3D; &quot;Steve&quot; &#125;<br>&#125;;<br><br>using (var context &#x3D; new SchoolContext()) &#123;<br>    context.AddRange(studentList);<br>    context.SaveChanges();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面的示例将在 <code>Student</code> 表中插入两个新记录。<br>
您还可以添加不同类型的实体的列表，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var std1 &#x3D; new Student()&#123; Name &#x3D; &quot;Bill&quot; &#125;;<br><br>var std2 &#x3D; new Student()&#123; Name &#x3D; &quot;Steve&quot; &#125;;<br><br>var computer &#x3D; new Course() &#123; CourseName &#x3D; &quot;Computer Science&quot; &#125;;<br><br>var entityList &#x3D; new List&lt;Object&gt;() &#123;<br>    std1,<br>    std2,<br>    computer<br>&#125;;<br><br>using (var context &#x3D; new SchoolContext()) &#123;                <br>    context.AddRange(entityList);<br><br>    &#x2F;&#x2F; or <br>    &#x2F;&#x2F; context.AddRange(std1, std2, computer);<br><br>    context.SaveChanges();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>entityList</code> 是 <code>List&lt;Object&gt;</code> 的一种。因此，它可以包含任何类型的实体。<code>AddRange()</code> 方法将所有指定的实体添加到上下文中，<code>SaveChanges()</code> 将一次性构建并执行 <code>INSERT</code> 语句。<br>
EF Core 通过在一次数据库往返中对所有上述实体执行 <code>INSERT</code> 语句来提高性能。上面的示例将在数据库中执行以下语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">exec sp_executesql N&#39;SET NOCOUNT ON;<br>INSERT INTO [Courses] ([CourseName], [Description])<br>VALUES (@p0, @p1);<br>SELECT [CourseId]<br>FROM [Courses]<br>WHERE @@ROWCOUNT &#x3D; 1 AND [CourseId] &#x3D; scope_identity();<br><br>DECLARE @inserted1 TABLE ([StudentId] int, [_Position] [int]);<br>MERGE [Students] USING (<br>VALUES (@p2, 0),<br>(@p3, 1)) AS i ([Name], _Position) ON 1&#x3D;0<br>WHEN NOT MATCHED THEN<br>INSERT ([Name])<br>VALUES (i.[Name])<br>OUTPUT INSERTED.[StudentId], i._Position<br>INTO @inserted1;<br><br>SELECT [t].[StudentId] FROM [Students] t<br>INNER JOIN @inserted1 i ON ([t].[StudentId] &#x3D; [i].[StudentId])<br>ORDER BY [i].[_Position];<br>&#39;,N&#39;@p0 nvarchar(4000),@p1 nvarchar(4000),@p2 nvarchar(4000),@p3 nvarchar(4000)&#39;,<br>@p0&#x3D;N&#39;Computer Science&#39;,@p1&#x3D;NULL,@p2&#x3D;N&#39;Steve&#39;,@p3&#x3D;N&#39;Bill&#39;<br>Go<br></code></pre></div></td></tr></table></figure>
<h3 id="使用-DbSet-插入数据"><a class="header-anchor" href="#使用-DbSet-插入数据">¶</a>使用 <code>DbSet</code> 插入数据</h3>
<p>如前所述，您可以使用 <code>DbSet</code> 来保存实体的实例，该实例将以与 EF 6.x 相同的方式转换为数据库中的 <code>INSERT</code> / <code>UPDATE</code> / <code>DELETE</code> 命令。<br>
使用 <code>DbSet&lt;TEntity&gt;.Add()</code> 方法附加具有添加状态的实体，或使用 <code>DbSet&lt;TEntity&gt; .AddRange()</code> 方法附加具有添加状态的实体的集合，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var std &#x3D; new Student() &#123;<br>    Name &#x3D; &quot;Bill&quot;<br>&#125;;<br><br>using (var context &#x3D; new SchoolContext()) &#123;<br>    context.Students.Add(std);<br><br>    &#x2F;&#x2F; or<br>    &#x2F;&#x2F; context.Students.Attach(std);<br><br>    context.SaveChanges();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>context.Students</code> 的类型为 <code>DbSet&lt;Student&gt;</code> 类型。因此，我们只能添加 <code>Student</code> 实体。<code>context.Students.Add(std)</code> 将 <code>Student</code> 实体附加到具有 <code>Added</code> 状态的上下文，当调用 <code>SaveChanges()</code> 方法时，这将导致 <code>INSERT</code> 语句。</p>
<h2 id="十六、Entity-Framework-Core-断开模式下删除数据"><a class="header-anchor" href="#十六、Entity-Framework-Core-断开模式下删除数据">¶</a>十六、Entity Framework Core 断开模式下删除数据</h2>
<p>EF Core API 会为 <code>EntityState</code> 为 <code>Deleted</code> 的实体建立并执行数据库中的 <code>DELETE</code> 语句。在 EF Core 中已连接和已断开连接的场景中删除实体没有什么区别。 EF Core 使得从上下文中删除实体变得容易，而上下文又将使用以下方法删除数据库中的记录。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong><code>DbContext</code> 方法</strong></th>
<th style="text-align:center"><strong><code>DbSet</code> 方法</strong></th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>DbContext.Remove</code></td>
<td style="text-align:center"><code>DbSet.Remove</code></td>
<td style="text-align:center">将指定的实体附加到状态为“已删除”的 <code>DbContext</code> 并开始对其进行跟踪</td>
</tr>
<tr>
<td style="text-align:center"><code>DbContext.RemoveRang</code></td>
<td style="text-align:center"><code>DbSet.RemoveRange</code></td>
<td style="text-align:center">将实体的集合或数组附加到具有 <code>Deleted</code> 状态的 <code>DbContext</code> 并开始跟踪它们</td>
</tr>
</tbody>
</table>
<p>以下示例演示了在断开连接的场景中删除实体的不同方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">&#x2F;&#x2F; entity to be deleted<br>var student &#x3D; new Student() &#123;<br>        StudentId &#x3D; 1<br>&#125;;<br><br>using (var context &#x3D; new SchoolContext()) &#123;<br>    context.Remove&lt;Student&gt;(student);<br>   <br>    &#x2F;&#x2F; or the followings are also valid<br>    &#x2F;&#x2F; context.RemoveRange(student);<br>    &#x2F;&#x2F;context.Students.Remove(student);<br>    &#x2F;&#x2F;context.Students.RemoveRange(student);<br>    &#x2F;&#x2F;context.Attach&lt;Student&gt;(student).State &#x3D; EntityState.Deleted;<br>    &#x2F;&#x2F;context.Entry&lt;Student&gt;(student).State &#x3D; EntityState.Deleted;<br>    <br>    context.SaveChanges();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，使用 <code>Remove()</code> 或 <code>RemoveRange()</code> 方法从上下文中删除了具有有效 <code>StudentId</code> 的 <code>Studnet</code> 实体。数据将从 <code>SaveChanges()</code> 上的数据库中删除。上面的示例在数据库中执行以下 <code>delete</code> 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">exec sp_executesql N&#39;SET NOCOUNT ON;<br>DELETE FROM [Students]<br>WHERE [StudentId] &#x3D; @p0;<br>SELECT @@ROWCOUNT;<br>&#39;,N&#39;@p0 int&#39;,@p0&#x3D;1<br>Go<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>EF Core 中新引入了 <code>DbContext.Remove()</code> 和 <code>DbContext.RemoveRange()</code> 方法，以简化删除操作。</p>
</blockquote>
<h3 id="异常"><a class="header-anchor" href="#异常">¶</a>异常</h3>
<p>如果相应数据库表中不存在 <code>Remove()</code> 或 <code>RemoveRange()</code> 方法中指定实体中的 <code>Key</code> 值，则 EF Core 将引发异常：以下示例将引发异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var student &#x3D; new Student() &#123;<br>    StudentId &#x3D; 50<br>&#125;;<br><br>using (var context &#x3D; new SchoolContext()) &#123;<br>    context.Remove&lt;Student&gt;(student);<br>    context.SaveChanges();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，数据库中不存在 <code>StudentId = 50</code> 的 <code>Student</code>。因此，EF Core 将引发以下 <code>DbUpdateConcurrencyException</code>：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">Database operation expected to affect <span class="hljs-number">1</span> row(s) but actually affected <span class="hljs-number">0</span> row(s). Data may have been modified <span class="hljs-keyword">or</span> deleted since entities were loaded.<br>数据库操作预期会影响<span class="hljs-number">1</span>行，但实际上会影响<span class="hljs-number">0</span>行。自加载实体以来，数据可能已被修改或删除。<br></code></pre></div></td></tr></table></figure>
<p>因此，您需要适当地处理以上异常，或者在删除 ID 之前确保数据库中存在具有 ID 的对应数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">var student &#x3D; new Student() &#123;<br>    StudentId &#x3D; 50<br>&#125;;<br><br>using (var context &#x3D; new SchoolContext()) &#123;<br>    try &#123;<br>        context.Remove&lt;Student&gt;(deleteStudent);<br>        context.SaveChanges();<br>    &#125;    <br>    catch (DbUpdateConcurrencyException ex) &#123;<br>        throw new Exception(&quot;数据库中不存在此纪录&quot;);<br>    &#125;<br>    catch (Exception ex) &#123;<br>        throw;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="删除多条记录"><a class="header-anchor" href="#删除多条记录">¶</a>删除多条记录</h3>
<p>您可以使用 <code>DbContext.RemoveRange()</code> 或 <code>DbSet.RemoveRange()</code> 方法一次性删除多个实体。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">IList&lt;Student&gt; students &#x3D; new List&lt;Student&gt;() &#123;<br>    new Student()&#123; StudentId &#x3D; 1 &#125;,<br>    new Student()&#123; StudentId &#x3D; 2 &#125;,<br>    new Student()&#123; StudentId &#x3D; 3 &#125;,<br>    new Student()&#123; StudentId &#x3D; 4 &#125;<br>&#125;;<br><br>using (var context &#x3D; new SchoolContext()) &#123;<br>    context.RemoveRange(students);<br>    <br>    &#x2F;&#x2F; or<br>    &#x2F;&#x2F; context.Students.RemoveRange(students);<br>    <br>    context.SaveChanges();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面的示例将在单个数据库行程中从数据库中删除 4 条记录。因此，EF Core 改善了性能。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">exec sp_executesql N&#39;SET NOCOUNT ON;<br>DELETE FROM [Students]<br>WHERE [StudentId] &#x3D; @p0;<br>SELECT @@ROWCOUNT;<br><br><br>DELETE FROM [Students]<br>WHERE [StudentId] &#x3D; @p1;<br>SELECT @@ROWCOUNT;<br><br>DELETE FROM [Students]<br>WHERE [StudentId] &#x3D; @p2;<br>SELECT @@ROWCOUNT;<br><br><br>DELETE FROM [Students]<br>WHERE [StudentId] &#x3D; @p3;<br>SELECT @@ROWCOUNT;<br><br>&#39;,N&#39;@p0 int,@p1 int&#39;,@p0&#x3D;1,@p1&#x3D;2,@p2&#x3D;3,@p3&#x3D;4<br>Go<br></code></pre></div></td></tr></table></figure>
<h3 id="删除关联数据"><a class="header-anchor" href="#删除关联数据">¶</a>删除关联数据</h3>
<p>如果一个实体与其他实体有一对一或一对多的关系，则在删除根实体时删除相关数据取决于如何配置该关系。<br>
例如，考虑“学生”和“年级”实体之间存在一对多关系。特定的 <code>GradeId</code> 将有许多学生记录。如果我们尝试删除数据库中具有相关学生记录的成绩，EF 将抛出参考完整性错误。要解决此问题，您可以使用 Fluent API 定义引用约束操作选项。例如，您可以为该关系配置一个级联删除选项，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">modelBuilder.Entity&lt;Student&gt;()<br>    .HasOne&lt;Grade&gt;(s &#x3D;&gt; s.Grade)<br>    .WithMany(g &#x3D;&gt; g.Students)<br>    .HasForeignKey(s &#x3D;&gt; s.GradeId)<br>    .OnDelete(DeleteBehavior.Cascade);<br></code></pre></div></td></tr></table></figure>
<p>现在，如果您删除成绩实体，那么所有相关的学生记录也将在数据库中删除。<br>
EF Core中还有其他引用约束操作选项，例如 <code>SetNull</code>、<code>ClientSetNull</code>和<code>Restrict</code>。</p>
<h2 id="十七、Entity-Framework-Core-中的-ChangeTracker-变更追踪器"><a class="header-anchor" href="#十七、Entity-Framework-Core-中的-ChangeTracker-变更追踪器">¶</a>十七、Entity Framework Core 中的 <code>ChangeTracker</code> (变更追踪器)</h2>
<p>Entity Framework Core 中的 <code>DbContext</code> 在 <code>Microsoft.EntityFrameworkCore.ChangeTracking</code> 命名空间中包含 <code>ChangeTracker</code> 类，该类负责跟踪使用同一 <code>DbContext</code> 实例检索的每个实体的状态。它不打算直接在您的应用程序代码中使用，因为它可能在将来的版本中更改。但是，您可以使用一些方法进行跟踪。</p>
<p>一旦使用 <code>DbContext</code> 检索了所有实体，Entity Framework Core 中的<code>ChangeTracker</code> 类就会开始跟踪所有实体，直到它们超出其范围。 EF 跟踪应用于所有实体及其属性的所有更改，以便它可以为基础数据源生成并执行适当的 DML 语句。</p>
<p>实体在任何时间点都具有以下状态之一，这些状态由 EF Core 中的枚举 <code>Microsoft.EntityFrameworkCore.EntityState</code> 表示。</p>
<ul>
<li><code>Added</code></li>
<li><code>Modified</code></li>
<li><code>Deleted</code></li>
<li><code>Unchanged</code></li>
<li><code>Detached</code></li>
</ul>
<p>让我们看看如何根据对实体执行的操作自动更改 <code>EntityState</code>：</p>
<h3 id="Unchanged-State-不变的状态"><a class="header-anchor" href="#Unchanged-State-不变的状态">¶</a>Unchanged State (不变的状态)</h3>
<p>首先，使用直接 SQL 查询或 LINQ-to-Entities 查询检索的所有实体都将具有“Unchanged”状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public static void Main() &#123;<br>    using (var context &#x3D; new SchoolContext()) &#123;<br>        &#x2F;&#x2F; retrieve entity <br>        var student &#x3D; context.Students.First();<br>        DisplayStates(context.ChangeTracker.Entries());<br>    &#125;<br>&#125;<br><br>private static void DisplayStates(IEnumerable&lt;EntityEntry&gt; entries) &#123;<br>    foreach (var entry in entries) &#123;<br>        Console.WriteLine($&quot;Entity: &#123;entry.Entity.GetType().Name&#125;,<br>                             State: &#123;entry.State.ToString()&#125; &quot;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy"><span class="hljs-string">Entity:</span> Student, <span class="hljs-string">State:</span> Unchanged<br></code></pre></div></td></tr></table></figure>
<h3 id="Added-State-新增状态"><a class="header-anchor" href="#Added-State-新增状态">¶</a>Added State (新增状态)</h3>
<p>使用 <code>Add()</code> 或 <code>Update()</code> 方法在 <code>DbContext</code> 中添加的所有没有键属性值的新实体都将标记为“Added”。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">using (var context &#x3D; new SchoolContext()) &#123;              <br>    context.Add(new Student() &#123; FirstName &#x3D; &quot;Bill&quot;, LastName &#x3D; &quot;Gates&quot; &#125;);<br>    <br>    DisplayStates(context.ChangeTracker.Entries());<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy"><span class="hljs-string">Entity:</span> Student, <span class="hljs-string">State:</span> Added<br></code></pre></div></td></tr></table></figure>
<h3 id="Modified-State-修改状态"><a class="header-anchor" href="#Modified-State-修改状态">¶</a>Modified State (修改状态)</h3>
<p>如果实体的任何属性的值在 <code>DbContext</code> 的范围内更改，则它将被标记为 <code>Modified</code> 状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">using (var context &#x3D; new SchoolContext()) &#123;<br>    var student &#x3D; context.Students.First();<br>    student.LastName &#x3D; &quot;LastName changed&quot;;<br>              <br>    DisplayStates(context.ChangeTracker.Entries());<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy"><span class="hljs-string">Entity:</span> Student, <span class="hljs-string">State:</span> Modified<br></code></pre></div></td></tr></table></figure>
<h3 id="Deleted-State-删除状态"><a class="header-anchor" href="#Deleted-State-删除状态">¶</a>Deleted State (删除状态)</h3>
<p>如果实体的任何属性的值在 <code>DbContext</code> 的范围内更改，则它将被标记为 <code>Modified</code> 状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">using (var context &#x3D; new SchoolContext()) &#123;<br>    var student &#x3D; context.Students.First();<br>    student.LastName &#x3D; &quot;LastName changed&quot;;<br>              <br>    DisplayStates(context.ChangeTracker.Entries());<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy"><span class="hljs-string">Entity:</span> Student, <span class="hljs-string">State:</span> Modified<br></code></pre></div></td></tr></table></figure>
<h3 id="Deleted-State-删除状态-v2"><a class="header-anchor" href="#Deleted-State-删除状态-v2">¶</a>Deleted State (删除状态)</h3>
<p>如果使用 <code>DbContext.Remove</code> 或 <code>DbSet.Remove</code> 方法从 <code>DbContext</code> 中删除了任何实体，则它将被标记为 <code>Deleted</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">using (var context &#x3D; new SchoolContext()) &#123;<br>    var student &#x3D; context.Students.First();<br>    context.Students.Remove(student);<br>    <br>    DisplayStates(context.ChangeTracker.Entries());<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy"><span class="hljs-string">Entity:</span> Student, <span class="hljs-string">State:</span> Deleted<br></code></pre></div></td></tr></table></figure>
<h3 id="Detached-State-分离状态"><a class="header-anchor" href="#Detached-State-分离状态">¶</a>Detached State (分离状态)</h3>
<p>在当前 <code>DbContext</code> 实例范围之外创建或检索的所有实体都将处于 <code>Detached</code> 状态。它们也称为断开连接的实体，现有的 <code>DbContext</code> 实例不会对其进行跟踪。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var disconnectedEntity &#x3D; new Student() &#123; StudentId &#x3D; 1, Name &#x3D; &quot;Bill&quot; &#125;;<br><br>using (var context &#x3D; new SchoolContext()) &#123;              <br>    Console.Write(context.Entry(disconnectedEntity).State);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs `">Detached<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>disconnectedEntity</code> 是在 <code>DbContext</code> 实例 (上下文) 的范围之外创建的。因此，对于上下文，它处于 <code>Detached</code> 状态。</p>
<h2 id="十八、Entity-Framework-Core-的影子属性-Shadow-Property"><a class="header-anchor" href="#十八、Entity-Framework-Core-的影子属性-Shadow-Property">¶</a>十八、Entity Framework Core 的影子属性 (Shadow Property)</h2>
<p>Entity Framework Core 引入了一种新的属性类型，称为“影子”属性，该属性在 EF 6.x 中不存在。<br>
<strong>影子属性是未在 .NET 实体类中直接定义的属性</strong>。相反，您可以为实体数据模型中的特定实体类型配置它。可以在上下文类的 <code>OnModelCreating()</code> 方法中配置它们。<br>
下图说明了影子属性：</p>
<p><img src="/images/efcore/20200208111446921.png" alt="图18-1"></p>
<p>如上图所示，影子属性不属于您的实体类。因此，<strong>您无法在访问实体的其他属性时访问它。只能在构建实体数据模型时为实体类型配置影子属性，并且它们也将映射到数据库列</strong>。影子属性的值和状态仅在更改跟踪器中维护。</p>
<p>让我们了解影子属性的实际方面。假设我们需要维护数据库表中每个记录的创建和更新日期。您学习了如何通过在实体类中定义 <code>CreatedDate</code> 和 <code>UpdatedDate</code> 属性来设置 EF Core 中实体的创建和修改日期。在这里，我们将看到如何通过使用影子属性而不在实体类中包含影子属性来实现相同的结果。</p>
<p>考虑以下学生实体类：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">public class Student &#123;<br>    public int StudentID &#123; get; set; &#125;<br>    public string StudentName &#123; get; set; &#125;<br>    public DateTime? DateOfBirth &#123; get; set; &#125;<br>    public decimal Height &#123; get; set; &#125;<br>    public float Weight &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面的 <code>Student</code> 类不包含 <code>CreatedDate</code> 和 <code>UpdatedDate</code> 属性来维护创建或更新的时间。我们将它们配置为 <code>Student</code> 实体上的影子属性。</p>
<h3 id="定义影子属性"><a class="header-anchor" href="#定义影子属性">¶</a>定义影子属性</h3>
<p>您可以使用 <code>Property()</code> 方法在 <code>OnModelCreating()</code> 中使用 Fluent API 为实体类型定义影子属性。<br>
以下内容在 <code>Student</code> 实体上配置了两个影子属性 <code>CreatedDate</code> 和 <code>UpdatedDate</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class SchoolContext : DbContext &#123;<br>    public SchoolContext() : base() &#123;<br>    &#125;<br>    <br>    protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;<br>        modelBuilder.Entity&lt;Student&gt;().Property&lt;DateTime&gt;(&quot;CreatedDate&quot;);<br>        modelBuilder.Entity&lt;Student&gt;().Property&lt;DateTime&gt;(&quot;UpdatedDate&quot;);<br>    &#125;<br><br>    public DbSet&lt;Student&gt; Students &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如您所见，<code>Property()</code> 方法用于配置影子属性。将影子属性的名称指定为字符串，并将类型指定为通用参数。如果在 <code>Property()</code> 方法中指定的名称与现有属性的名称匹配，则 EF Core 将将该现有属性配置为影子属性，而不是引入新的影子属性。</p>
<h3 id="数据库中的影子属性"><a class="header-anchor" href="#数据库中的影子属性">¶</a>数据库中的影子属性</h3>
<p>定义影子属性后，我们需要更新数据库架构，因为影子属性将映射到相应的数据库列。<br>
为此，请使用以下命令添加数据库迁移。</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; dotnet ef migrations add addShadowProperty<br>PM&gt; dotnet ef db update<br></code></pre></div></td></tr></table></figure>
<p>现在，<code>Student</code> 表将包括两列，SQL Server 中的 <code>CreatedDate</code> 和 <code>UpdatedDate</code>，如下所示。</p>
<p><img src="/images/efcore/shadow-property-in-db.png" alt="图18-2"></p>
<p>因此，<strong>即使我们没有在 <code>Student</code> 类中包含这些属性并将其配置为影子属性，数据库也将具有相应的列</strong>。</p>
<h3 id="访问影子属性"><a class="header-anchor" href="#访问影子属性">¶</a>访问影子属性</h3>
<p>您可以使用 <code>EntityEntry</code> 的 <code>Property()</code> 方法获取或设置影子属性的值。以下代码访问影子属性的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">using (var context &#x3D; new SchoolContext()) &#123;<br>    var std &#x3D; new Student() &#123; StudentName &#x3D; &quot;Bill&quot;  &#125;;<br>    <br>    &#x2F;&#x2F; sets the value to the shadow property<br>    context.Entry(std).Property(&quot;CreatedDate&quot;).CurrentValue &#x3D; DateTime.Now;<br><br>    &#x2F;&#x2F; gets the value of the shadow property<br>    var createdDate &#x3D; context.Entry(std).Property(&quot;CreatedDate&quot;).CurrentValue; <br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>但是，在我们的方案中，我们想在 <code>SaveChanges()</code> 方法上自动将值设置为这些影子属性，这样就不必在每个实体对象上手动设置它们。因此，请在上下文类中重写<code>SaveChanges()</code> 方法，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public override int SaveChanges() &#123;<br>    var entries &#x3D; ChangeTracker<br>        .Entries()<br>        .Where(e &#x3D;&gt;<br>                e.State &#x3D;&#x3D; EntityState.Added<br>                || e.State &#x3D;&#x3D; EntityState.Modified);<br><br>    foreach (var entityEntry in entries) &#123;<br>        entityEntry.Property(&quot;UpdatedDate&quot;).CurrentValue &#x3D; DateTime.Now;<br><br>        if (entityEntry.State &#x3D;&#x3D; EntityState.Added) &#123;<br>            entityEntry.Property(&quot;CreatedDate&quot;).CurrentValue &#x3D; DateTime.Now;<br>        &#125;<br>    &#125;<br><br>    return base.SaveChanges();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这将自动将值设置为 <code>CreatedDate</code> 和 <code>UpdatedDate</code> 影子属性。<br>
现在，执行以下代码并检查数据库中的记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">using (var context &#x3D; new SchoolContext()) &#123;<br>    var std &#x3D; new Student()&#123; StudentName &#x3D; &quot;Bill&quot;  &#125;;<br>    context.Add(std);<br>    context.SaveChanges();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面的代码将在 <code>Student</code> 表中插入带有 <code>CreatedDate</code> 和 <code>UpdatedDate</code> 的以下记录。</p>
<p><img src="/images/efcore/db-record.png" alt="图18-3"></p>
<p>因此，通过配置影子属性，我们不必将它们包括在实体类中。</p>
<h3 id="在所有实体上配置阴影属性"><a class="header-anchor" href="#在所有实体上配置阴影属性">¶</a>在所有实体上配置阴影属性</h3>
<p>您可以一次在所有实体上配置影子属性，而不是为所有实体手动配置它们。<br>
例如，我们可以一次在所有实体上配置 <code>CreatedDate</code> 和 <code>UpdatedDate</code>，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">protected override void OnModelCreating(ModelBuilder modelBuilder) &#123;<br>    var allEntities &#x3D; modelBuilder.Model.GetEntityTypes();<br><br>    foreach (var entity in allEntities) &#123;<br>        entity.AddProperty(&quot;CreatedDate&quot;,typeof(DateTime));<br>        entity.AddProperty(&quot;UpdatedDate&quot;,typeof(DateTime));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="何时使用影子属性？"><a class="header-anchor" href="#何时使用影子属性？">¶</a>何时使用影子属性？</h3>
<p>影子属性可以在两种情况下使用：</p>
<ol>
<li>当您不想在映射的实体上公开数据库列时，例如上面讨论的方案。</li>
<li>当您不想公开外键属性而只想使用导航属性来管理关系时。外键属性将是影子属性并映射到数据库列，但不会作为实体的属性公开。(在 EF Core 中，如果您未在实体类中定义外键属性，则它将自动为此生成影子属性。您无需手动配置外键属性。)</li>
</ol>
<h2 id="十九、Entity-Framework-Core-使用断开模式的实体图-Entity-Graph"><a class="header-anchor" href="#十九、Entity-Framework-Core-使用断开模式的实体图-Entity-Graph">¶</a>十九、Entity Framework Core 使用断开模式的实体图 (Entity Graph)</h2>
<p>在这里，您将了解 Entity Framework Core 中断开连接的实体图的根实体和子实体上不同方法的行为。</p>
<p>实体框架核心提供了以下不同方法，<strong>这些方法不仅将实体附加到上下文，而且还更改了断开连接的实体图中每个实体的 <code>EntityState</code></strong>：</p>
<ul>
<li><code>Attach()</code></li>
<li><code>Entry()</code></li>
<li><code>Add()</code></li>
<li><code>Update()</code></li>
<li><code>Remove()</code></li>
</ul>
<h3 id="Attach"><a class="header-anchor" href="#Attach">¶</a><code>Attach()</code></h3>
<p><code>DbContext.Attach()</code> 和 <code>DbSet.Attach()</code> 方法将附加指定的断开连接的实体图并开始对其进行跟踪。它们返回 <code>EntityEntry</code> 的实例，该实例用于分配适当的 <code>EntityState</code>。</p>
<p>下面的示例演示 <code>DbContext.Attach()</code> 方法在图形中每个实体的 <code>EntityState</code> 上的行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public static void Main() &#123;<br>    var stud &#x3D; new Student() &#123; &#x2F;&#x2F;Root entity (empty key)<br>        Name &#x3D; &quot;Bill&quot;,<br>        Address &#x3D; new StudentAddress() &#123;  &#x2F;&#x2F;Child entity (with key value)<br>             StudentAddressId &#x3D; 1,<br>            City &#x3D; &quot;Seattle&quot;,<br>            Country &#x3D; &quot;USA&quot;<br>        &#125;,<br>        StudentCourses &#x3D; new List&lt;StudentCourse&gt;() &#123;<br>            new StudentCourse()&#123;  Course &#x3D; new Course()&#123; CourseName &#x3D; &quot;Machine Language&quot; &#125; &#125;,&#x2F;&#x2F;Child entity (empty key)<br>            new StudentCourse()&#123;  Course &#x3D; new Course()&#123;  CourseId &#x3D; 2 &#125; &#125; &#x2F;&#x2F;Child entity (with key value)<br>        &#125;<br>    &#125;;<br><br>    var context &#x3D; new SchoolContext();<br>    context.Attach(stud).State &#x3D; EntityState.Added;  <br><br>    DisplayStates(context.ChangeTracker.Entries());<br>&#125;<br><br>private static void DisplayStates(IEnumerable&lt;EntityEntry&gt; entries) &#123;<br>    foreach (var entry in entries) &#123;<br>        Console.WriteLine($&quot;Entity: &#123;entry.Entity.GetType().Name&#125;,<br>                             State: &#123;entry.State.ToString()&#125; &quot;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy"><span class="hljs-string">Entity:</span> Student, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> StudentAddress, <span class="hljs-string">State:</span> Unchanged<br><span class="hljs-string">Entity:</span> StudentCourse, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> Course, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> StudentCourse, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> Course, <span class="hljs-string">State:</span> Unchanged<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>stud</code> 是学生实体图的实例，其中包括对 <code>StudentAddress</code> 和 <code>StudentCourse</code> 实体的引用。<code>context.Attach(stud).State = EntityState.Added</code> 会将图钉实体图附加到上下文，并为其设置 <code>Added</code> 状态。<br>
<code>Attach()</code> 方法将添加的 <code>EntityState</code> 设置为根实体 (在本例中为 <code>Student</code> )，无论其是否包含 <code>Key</code> 值。如果子实体包含键值，则它将被标记为“不变”，否则将被标记为“已添加”。上面示例的输出显示，学生实体具有 <code>Added EntityState</code> ，具有非空键值的子实体具有 <code>Unchanged</code> <code>EntityState</code>，而具有空键值的子实体具有 <code>Added</code> 状态。<br>
下表列出了在为断开连接的实体图设置其他 <code>EntityStat</code> e时，<code>Attach()</code> 方法的行为：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>Attach()</code></th>
<th style="text-align:center">具有键值的根实体</th>
<th style="text-align:center">具有空值或 CLR 默认值的根实体</th>
<th style="text-align:center">具有键值的子实体</th>
<th style="text-align:center">空实体或 CLR 默认值的子实体</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>context.Attach(entityGraph).State = EntityState.Added</code></td>
<td style="text-align:center"><code>Added</code></td>
<td style="text-align:center"><code>Added</code></td>
<td style="text-align:center"><code>Unchanged</code></td>
<td style="text-align:center"><code>Added</code></td>
</tr>
<tr>
<td style="text-align:center"><code>context.Attach(entityGraph).State = EntityState.Modified</code></td>
<td style="text-align:center"><code>Modified</code></td>
<td style="text-align:center"><code>Exception</code></td>
<td style="text-align:center"><code>Unchanged</code></td>
<td style="text-align:center"><code>Added</code></td>
</tr>
<tr>
<td style="text-align:center"><code>context.Attach(entityGraph).State = EntityState.Deleted</code></td>
<td style="text-align:center"><code>Deleted</code></td>
<td style="text-align:center"><code>Exception</code></td>
<td style="text-align:center"><code>Unchanged</code></td>
<td style="text-align:center"><code>Added</code></td>
</tr>
</tbody>
</table>
<h3 id="Entry"><a class="header-anchor" href="#Entry">¶</a><code>Entry()</code></h3>
<p>与以前的 EF 6.x 相比，<code>DbContext.Entry()</code> 方法在 Entity Framework Core 中的行为有所不同。考虑以下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var student &#x3D; new Student() &#123; &#x2F;&#x2F;Root entity (empty key)<br>    Name &#x3D; &quot;Bill&quot;,<br>    Address &#x3D; new StudentAddress() &#123; &#x2F;&#x2F;Child entity (with key value)<br>        StudentAddressId &#x3D; 1,<br>        City &#x3D; &quot;Seattle&quot;,<br>        Country &#x3D; &quot;USA&quot;<br>    &#125;,<br>    StudentCourses &#x3D; new List&lt;StudentCourse&gt;() &#123;<br>            new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseName&#x3D;&quot;Machine Language&quot; &#125; &#125;,&#x2F;&#x2F;Child entity (empty key)<br>            new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseId&#x3D;2 &#125; &#125; &#x2F;&#x2F;Child entity (with key value)<br>        &#125;<br>&#125;;<br><br>var context &#x3D; new SchoolContext();<br>context.Entry(student).State &#x3D; EntityState.Modified;<br><br>DisplayStates(context.ChangeTracker.Entries());<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy"><span class="hljs-string">Entity:</span> Student, <span class="hljs-string">State:</span> Modified<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>context.Entry(student).State = EntityState.Modified</code> 将实体附加到上下文，并将指定的 <code>EntityState</code> (在本例中为 <code>Modified</code>) 应用于根实体，而不管其是否包含 <code>Key</code> 属性值或不。它会忽略图中的所有子实体，并且不会附加或设置其 <code>EntityState</code>。<br>
下表列出了 <code>DbContext.Entry()</code> 方法的不同行为。</p>
<table>
<thead>
<tr>
<th style="text-align:center">使用 <code>Entry()</code> 设置 <code>EntityState</code></th>
<th style="text-align:center">具有键值的根实体</th>
<th style="text-align:center">具有空值或 CLR 默认值的根实体</th>
<th style="text-align:center">有/没有键值的子实体</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>context.Entry(entityGraph).State = EntityState.Added</code></td>
<td style="text-align:center"><code>Added</code></td>
<td style="text-align:center"><code>Added</code></td>
<td style="text-align:center"><code>Ignored</code></td>
</tr>
<tr>
<td style="text-align:center"><code>context.Entry(entityGraph).State = EntityState.Modified</code></td>
<td style="text-align:center"><code>Modified</code></td>
<td style="text-align:center"><code>Modified</code></td>
<td style="text-align:center"><code>Ignored</code></td>
</tr>
<tr>
<td style="text-align:center"><code>context.Entry(entityGraph).State = EntityState.Deleted</code></td>
<td style="text-align:center"><code>Deleted</code></td>
<td style="text-align:center"><code>Deleted</code></td>
<td style="text-align:center"><code>Ignored</code></td>
</tr>
</tbody>
</table>
<h3 id="Add"><a class="header-anchor" href="#Add">¶</a><code>Add()</code></h3>
<p><code>DbContext.Add</code> 和 <code>DbSet.Add</code> 方法将实体图附加到上下文，并将“Added EntityState”设置为根和子实体，而不管它们是否具有键值。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var student &#x3D; new Student() &#123; &#x2F;&#x2F;Root entity (with key value)<br>    StudentId &#x3D; 1,<br>    Name &#x3D; &quot;Bill&quot;,<br>    Address &#x3D; new StudentAddress() &#123; &#x2F;&#x2F;Child entity (with key value)<br>        StudentAddressId &#x3D; 1,<br>        City &#x3D; &quot;Seattle&quot;,<br>        Country &#x3D; &quot;USA&quot;<br>    &#125;,<br>    StudentCourses &#x3D; new List&lt;StudentCourse&gt;() &#123;<br>            new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseName&#x3D;&quot;Machine Language&quot; &#125; &#125;,&#x2F;&#x2F;Child entity (empty key)<br>            new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseId&#x3D;2 &#125; &#125; &#x2F;&#x2F;Child entity (with key value)<br>        &#125;<br>&#125;;<br><br>var context &#x3D; new SchoolContext();<br>context.Students.Add(student);<br><br>DisplayStates(context.ChangeTracker.Entries());<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy"><span class="hljs-string">Entity:</span> Student, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> StudentAddress, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> StudentCourse, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> Course, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> StudentCourse, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> Course, <span class="hljs-string">State:</span> Added<br></code></pre></div></td></tr></table></figure>
<p>下表列出了使用 <code>DbContext.Add</code> 或 <code>DbSet.Add</code> 方法的图形中每个实体的可能 <code>EntityState</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">具有/不具有键值的根实体</th>
<th style="text-align:center">有/没有键值的子实体</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>DbContext.Add(entityGraph)</code> 或 <code>DbSet.Add(entityGraph)</code></td>
<td style="text-align:center"><code>Added</code></td>
<td style="text-align:center"><code>Added</code></td>
</tr>
</tbody>
</table>
<h3 id="Update"><a class="header-anchor" href="#Update">¶</a><code>Update()</code></h3>
<p><code>DbContext.Update</code> (和 <code>DbSet.Update</code>) 方法将实体图附加到上下文，并根据图中是否包含键属性值来设置图中每个实体的 <code>EntityState</code>。考虑以下示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var student &#x3D; new Student() &#123; &#x2F;&#x2F;Root entity (with key value)<br>    StudentId &#x3D; 1,<br>    Name &#x3D; &quot;Bill&quot;,<br>    Address &#x3D; new StudentAddress()  &#x2F;&#x2F;Child entity (with key value)<br>    &#123;<br>        StudentAddressId &#x3D; 1,<br>        City &#x3D; &quot;Seattle&quot;,<br>        Country &#x3D; &quot;USA&quot;<br>    &#125;,<br>    StudentCourses &#x3D; new List&lt;StudentCourse&gt;() &#123;<br>        new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseName&#x3D;&quot;Machine Language&quot; &#125; &#125;,&#x2F;&#x2F;Child entity (empty key)<br>        new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseId&#x3D;2 &#125; &#125; &#x2F;&#x2F;Child entity (with key value)<br>    &#125;<br>&#125;;<br><br>var context &#x3D; new SchoolContext();<br>context.Update(student);<br><br>DisplayStates(context.ChangeTracker.Entries());<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy"><span class="hljs-string">Entity:</span> Student, <span class="hljs-string">State:</span> Modified<br><span class="hljs-string">Entity:</span> StudentAddress, <span class="hljs-string">State:</span> Modified<br><span class="hljs-string">Entity:</span> StudentCourse, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> Course, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> StudentCourse, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> Course, <span class="hljs-string">State:</span> Modified<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>Update()</code> 方法将 <code>Modified</code> 状态应用于包含非空键属性值的实体，并将 <code>Added</code> 状态应用于包含空或默认 CLR 键值的实体，而不管它们是根实体还是子实体。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>Update()</code></th>
<th style="text-align:center">具有键值的根实体</th>
<th style="text-align:center">具有空值或 CLR 默认值的根实体</th>
<th style="text-align:center">具有键值的子实体</th>
<th style="text-align:center">空键值的子实体</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>DbContext.Update(entityGraph)</code> 或 <code>DbSet.Update(entityGraph)</code></td>
<td style="text-align:center"><code>Modified</code></td>
<td style="text-align:center"><code>Added</code></td>
<td style="text-align:center"><code>Modified</code></td>
<td style="text-align:center"><code>Added</code></td>
</tr>
</tbody>
</table>
<h3 id="Remove"><a class="header-anchor" href="#Remove">¶</a><code>Remove()</code></h3>
<p><code>DbContext.Remove()</code> 和 <code>DbSet.Remove()</code> 方法将 <code>Deleted</code> <code>EntityState</code> 设置为根实体。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var student &#x3D; new Student() &#123; &#x2F;&#x2F;Root entity (with key value)<br>    StudentId &#x3D; 1,<br>    Name &#x3D; &quot;Bill&quot;,<br>    Address &#x3D; new StudentAddress() &#123; &#x2F;&#x2F;Child entity (with key value)<br>        StudentAddressId &#x3D; 1,<br>        City &#x3D; &quot;Seattle&quot;,<br>        Country &#x3D; &quot;USA&quot;<br>    &#125;,<br>    StudentCourses &#x3D; new List&lt;StudentCourse&gt;() &#123;<br>        new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseName&#x3D;&quot;Machine Language&quot; &#125; &#125;,&#x2F;&#x2F;Child entity (empty key)<br>        new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseId&#x3D;2 &#125; &#125; &#x2F;&#x2F;Child entity (with key value)<br>    &#125;<br>&#125;;<br><br>var context &#x3D; new SchoolContext();<br>context.Remove(student);<br><br>DisplayStates(context.ChangeTracker.Entries());<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy"><span class="hljs-string">Entity:</span> Student, <span class="hljs-string">State:</span> Deleted<br><span class="hljs-string">Entity:</span> StudentAddress, <span class="hljs-string">State:</span> Unchanged<br><span class="hljs-string">Entity:</span> StudentCourse, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> Course, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> StudentCourse, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> Course, <span class="hljs-string">State:</span> Unchanged<br></code></pre></div></td></tr></table></figure>
<p>下表列出了每个实体的 <code>EntityState</code> 上 <code>Remove()</code> 方法的行为。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>Remove()</code></th>
<th style="text-align:center">具有键值的根实体</th>
<th style="text-align:center">具有空值或 CLR 默认值的根实体</th>
<th style="text-align:center">具有键值的子实体</th>
<th style="text-align:center">空键值的子实体</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>DbContext.Remove(entityGraph)</code> 或 <code>DbSet.Remove(entityGraph)</code></td>
<td style="text-align:center"><code>Deleted</code></td>
<td style="text-align:center"><code>Exception</code></td>
<td style="text-align:center"><code>Unchanged</code></td>
<td style="text-align:center"><code>Added</code></td>
</tr>
</tbody>
</table>
<p>因此，在 EF Core 中使用上述方法时要小心。</p>
<h2 id="二十、Entity-Framework-Core-中的-ChangeTracker-TrackGraph"><a class="header-anchor" href="#二十、Entity-Framework-Core-中的-ChangeTracker-TrackGraph">¶</a>二十、Entity Framework Core 中的 <code>ChangeTracker.TrackGraph()</code></h2>
<p>在这里，您将学习如何跟踪实体图并为图中的每个单个实体设置适当的 <code>EntityState</code>。<br>
Entity Framework Core 中引入了 <code>ChangeTracker.TrackGraph()</code> 方法，以跟踪整个实体图并将自定义实体状态设置为图中的每个实体。<br>
方法签名：<code>public virtual void TrackGraph(object rootEntity, Action&lt;EntityEntryGraphNode&gt; callback)</code><br>
<code>ChangeTracker.TrackGraph()</code> 方法开始跟踪实体以及通过遍历其导航属性可到达的任何实体。为每个发现的实体调用指定的回调，并且必须为每个实体设置适当的 <code>EntityState</code>。回调函数使我们可以实现自定义逻辑来设置适当的状态。如果未设置任何状态，则实体保持未跟踪状态。<br>
下面的示例演示 <code>TrackGraph</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var student &#x3D; new Student() &#123; &#x2F;&#x2F;Root entity (with key value)<br>    StudentId &#x3D; 1,<br>    Name &#x3D; &quot;Bill&quot;,<br>    Address &#x3D; new StudentAddress() &#123; &#x2F;&#x2F;Child entity (with key value)<br>        StudentAddressId &#x3D; 1,<br>        City &#x3D; &quot;Seattle&quot;,<br>        Country &#x3D; &quot;USA&quot;<br>    &#125;,<br>    StudentCourses &#x3D; new List&lt;StudentCourse&gt;() &#123;<br>        new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseName&#x3D;&quot;Machine Language&quot; &#125; &#125;,&#x2F;&#x2F;Child entity (empty key)<br>        new StudentCourse() &#123; Course &#x3D; new Course() &#123; CourseId&#x3D;2 &#125; &#125; &#x2F;&#x2F;Child entity (with key value)<br>    &#125;<br>&#125;;<br>var context &#x3D; new SchoolContext();<br>            <br>context.ChangeTracker.TrackGraph(student, e &#x3D;&gt; &#123;<br>                                                if (e.Entry.IsKeySet) &#123;<br>                                                    e.Entry.State &#x3D; EntityState.Unchanged;<br>                                                &#125; else &#123;<br>                                                    e.Entry.State &#x3D; EntityState.Added;<br>                                                &#125;<br>                                            &#125;);<br><br>foreach (var entry in context.ChangeTracker.Entries()) &#123;<br>    Console.WriteLine($&quot;Entity: &#123;entry.Entity.GetType().Name&#125;, <br>                        State: &#123;entry.State.ToString()&#125; &quot;);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy"><span class="hljs-string">Entity:</span> Student, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> StudentAddress, <span class="hljs-string">State:</span> Unchanged<br><span class="hljs-string">Entity:</span> StudentCourse, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> Course, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> StudentCourse, <span class="hljs-string">State:</span> Added<br><span class="hljs-string">Entity:</span> Course, <span class="hljs-string">State:</span> Unchanged<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>ChangeTracker.TrackGraph()</code> 方法用于为学生实体图中的每个实体设置状态。第一个参数是实体图，第二个参数是设置每个实体状态的函数。我们使用 lambda 表达式为具有有效键值的实体设置了“不变”状态，为具有空键值的实体设置了“添加”状态。当实体具有有效的键属性值时，<code>IsKeySet</code> 变为 <code>true</code>。<br>
因此，我们可以使用 <code>ChangeTracker.TrackGraph()</code> 方法为图中的每个实体设置不同的 <code>EntityState</code>。</p>
<h2 id="二十一、在-Entity-Framework-Core-中执行原生-SQL-查询"><a class="header-anchor" href="#二十一、在-Entity-Framework-Core-中执行原生-SQL-查询">¶</a>二十一、在 Entity Framework Core 中执行原生 SQL 查询</h2>
<p>Entity Framework Core 提供了 <code>DbSet.FromSql()</code> 方法来对基础数据库执行原始 SQL 查询，并将结果作为实体对象获取。<br>
下面的示例演示如何对 MS SQL Server 数据库执行原始 SQL 查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var context &#x3D; new SchoolContext();<br>var students &#x3D; context.Students<br>                  .FromSql(&quot;Select * from Students where Name &#x3D; &#39;Bill&#39;&quot;)<br>                  .ToList();<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，在 <code>Student</code> 实体集 (<code>DbSet&lt;Student&gt;</code>) 之后使用 <code>FromSql()</code> 方法，因此指定的 SQL 查询必须从 <code>Student</code> 表返回记录，该记录将在 <code>Student</code> 实体中进行转换。 Entity Framework Core 将执行对数据库的指定查询，即在上面的示例中，从 <strong><code>Name ='Bill'</code> 的 <code>Student</code> 中选择</strong>。</p>
<h3 id="Parameterized-Query-参数化查询"><a class="header-anchor" href="#Parameterized-Query-参数化查询">¶</a>Parameterized Query (参数化查询)</h3>
<p><code>FromSql</code>方法允许使用 C# 中的字符串插值语法进行参数化查询，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">string name &#x3D; &quot;Bill&quot;;<br>var context &#x3D; new SchoolContext();<br>var students &#x3D; context.Students<br>                    .FromSql($&quot;Select * from Students where Name &#x3D; &#39;&#123;name&#125;&#39;&quot;)<br>                    .ToList();<br><br>The following is also valid.<br>string name &#x3D; &quot;Bill&quot;;<br>var context &#x3D; new SchoolContext();<br>var students &#x3D; context.Students<br>                    .FromSql(&quot;Select * from Students where Name &#x3D; &#39;&#123;0&#125;&#39;&quot;, name)<br>                    .ToList();<br></code></pre></div></td></tr></table></figure>
<p>上面的示例将对 SQL Server 数据库执行以下 SQL 查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">exec sp_executesql N&#39;Select * from Students where Name &#x3D; &#39;&#39;@p0&#39;&#39;<br>&#39;,N&#39;@p0 nvarchar(4000)&#39;,@p0&#x3D;N&#39;Bill&#39;<br>Go<br></code></pre></div></td></tr></table></figure>
<h3 id="LINQ-运算符"><a class="header-anchor" href="#LINQ-运算符">¶</a>LINQ 运算符</h3>
<p>您还可以在使用 <code>FromSql</code> 方法的原始查询之后使用 LINQ 运算符。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">string name &#x3D; &quot;Bill&quot;;<br>var context &#x3D; new SchoolContext();<br>var students &#x3D; context.Students<br>                    .FromSql(&quot;Select * from Students where Name &#x3D; &#39;&#123;0&#125;&#39;&quot;, name)<br>                    .OrderBy(s &#x3D;&gt; s.StudentId)<br>                    .ToList();<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，EF Core 通过将 <code>FromSql</code> 方法和 <code>OrderBy</code> 运算符结合在一起执行以下查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">exec sp_executesql N&#39;SELECT [s].[StudentId], [s].[Name]<br>FROM (<br>    Select * from Students where Name &#x3D; &#39;&#39;@p0&#39;&#39;<br>) AS [s]<br>ORDER BY [s].[StudentId]&#39;,N&#39;@p0 nvarchar(4000)&#39;,@p0&#x3D;N&#39;Bill&#39;<br>Go<br></code></pre></div></td></tr></table></figure>
<h3 id="FromSql-的局限性"><a class="header-anchor" href="#FromSql-的局限性">¶</a><code>FromSql</code> 的局限性</h3>
<p>SQL 查询必须返回与 <code>DbSet&lt;T&gt;</code> 类型相同类型的实体。例如如果在学生之后使用 <code>FromSql</code>，则指定的查询无法返回课程实体。从 <code>FromSql()</code> 方法返回临时类型在待办事项列表中。<br>
SQL 查询必须返回表的所有列。例如 <code>context.Students.FromSql(&quot;select StudentId，LastName from Students).ToList()</code> 将引发异常。<br>
<strong>SQL 查询不能包含 <code>JOIN</code> 查询以获取相关数据。在 <code>FromSql()</code> 方法之后，使用 <code>Include</code> 方法加载相关实体</strong>。</p>
<h2 id="二十二、在-Entity-Framework-Core-中使用存储过程"><a class="header-anchor" href="#二十二、在-Entity-Framework-Core-中使用存储过程">¶</a>二十二、在 Entity Framework Core 中使用存储过程</h2>
<p>在这里，您将学习如何在 Entity Framework Core 中执行数据库存储过程。<br>
EF Core 提供了以下方法来执行存储过程：</p>
<ol>
<li><code>DbSet&lt;TEntity&gt;.FromSql()</code></li>
<li><code>DbContext.Database.ExecuteSqlCommand()</code></li>
</ol>
<p>在 EF Core 2.x 中使用 <code>FromSql</code> 或 <code>ExecuteSqlCommand</code> 方法执行数据库存储过程存在一些限制：</p>
<ul>
<li>结果必须是实体类型。这意味着存储过程必须返回实体对应表的所有列。</li>
<li>结果不能包含相关数据。这意味着存储过程无法执行 <code>JOIN</code> 来表示结果。</li>
<li>插入，更新和删除过程无法与该实体映射，因此 <code>SaveChanges</code> 方法无法为 CUD 操作调用存储过程。</li>
</ul>
<p>在 EF Core 中执行存储过程之前，让我们在 MS SQL Server 中创建存储过程。<br>
如果遵循 database-first 方法，则在本地 SQL Server 数据库中执行以下脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">USE [SchoolDB]<br>GO<br><br>SET ANSI_NULLS ON<br>GO<br><br>SET QUOTED_IDENTIFIER ON<br>GO<br><br>CREATE PROCEDURE [dbo].[GetStudents]<br>            @FirstName varchar(50)<br>        AS<br>        BEGIN<br>            SET NOCOUNT ON;<br>            select * from Students where FirstName like @FirstName +&#39;%&#39;<br>        END<br>GO<br></code></pre></div></td></tr></table></figure>
<p>如果您遵循 code-first 方法，请按照以下步骤操作：</p>
<ol>
<li>
<p>执行以下命令来添加空迁移：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; dotnet ef migrations add<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>在 <code>&lt;DateTime&gt; _sp-GetStudents.cs</code> 中的空迁移类的 <code>Up</code> 方法中编写以下代码：</p>
 <figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public partial class spGetStudents : Migration &#123;<br>    protected override void Up(MigrationBuilder migrationBuilder) &#123;<br>        var sp &#x3D; @&quot;CREATE PROCEDURE [dbo].[GetStudents]<br>                    @FirstName varchar(50)<br>                AS<br>                BEGIN<br>                    SET NOCOUNT ON;<br>                    select * from Students where FirstName like @FirstName +&#39;%&#39;<br>                END&quot;;<br><br>        migrationBuilder.Sql(sp);<br>    &#125;<br><br>    protected override void Down(MigrationBuilder migrationBuilder) &#123;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>在控制台中执行以下命令，在数据库中创建以上存储过程：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; dotnet ef db update<br></code></pre></div></td></tr></table></figure>
<p>这将在 SQL Server 数据库中创建 <code>GetStudents</code> 存储过程。</p>
</li>
</ol>
<h3 id="使用-FromSql-执行存储过程"><a class="header-anchor" href="#使用-FromSql-执行存储过程">¶</a>使用 <code>FromSql</code> 执行存储过程</h3>
<p>如上一章所述，<code>DbSet</code> 的 <code>FromSql</code> 方法可用于对基础数据库执行原始 SQL 查询。同样，它可用于执行返回实体数据的存储过程，但有一些限制。<br>
在数据库中，我们可以使用如下INPUT参数值执行GetStudents存储过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">GetStudents &quot;Bill&quot;<br></code></pre></div></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">exec GetStudents &quot;Bill&quot;<br></code></pre></div></td></tr></table></figure>
<p>您可以按照与上述相同的方式在 EF Core 中使用 <code>FromSql</code> 方法执行 SP，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var context &#x3D; new SchoolContext(); <br>var students &#x3D; context.Students.FromSql(&quot;GetStudents &#39;Bill&#39;&quot;).ToList();<br></code></pre></div></td></tr></table></figure>
<p>您还可以使用 C# 字符串插值语法传递参数值，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var name &#x3D; &quot;Bill&quot;;<br><br>var context &#x3D; new SchoolContext(); <br>var students &#x3D; context.Students<br>                      .FromSql($&quot;GetStudents &#123;name&#125;&quot;)<br>                      .ToList();<br>&#x2F;&#x2F;or<br>&#x2F;&#x2F;var students &#x3D; context.Students.FromSql($&quot;exec GetStudents &#123;name&#125;&quot;).ToList();<br></code></pre></div></td></tr></table></figure>
<p>使用 <code>SqlParameter</code> 实例指定 <code>in</code> 或 <code>out</code> 参数的值，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var context &#x3D; new SchoolContext(); <br>var param &#x3D; new SqlParameter(&quot;@FirstName&quot;, &quot;Bill&quot;);<br>&#x2F;&#x2F;or<br>&#x2F;*var param &#x3D; new SqlParameter() &#123;<br>                    ParameterName &#x3D; &quot;@FirstName&quot;,<br>                    SqlDbType &#x3D;  System.Data.SqlDbType.VarChar,<br>                    Direction &#x3D; System.Data.ParameterDirection.Input,<br>                    Size &#x3D; 50,<br>                    Value &#x3D; &quot;Bill&quot;<br>&#125;;*&#x2F;<br><br>var students &#x3D; context.Students.FromSql(&quot;GetStudents @FirstName&quot;, param).ToList();<br></code></pre></div></td></tr></table></figure>
<p>您还可以为第一个参数指定 <code>@p0</code>，为第二个参数指定 <code>@p1</code>，依此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var context &#x3D; new SchoolContext(); <br>var students &#x3D; context.Students.FromSql(&quot;GetStudents @p0&quot;,&quot;Bill&quot;).ToList();<br></code></pre></div></td></tr></table></figure>
<p>在以上示例中，<code>@p0</code> 用于第一个参数，因为 EF Core 中尚不支持命名参数。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>默认情况下，<code>DbContext</code> 将跟踪结果中的所有实体。如果您多次使用相同的参数执行相同的存储过程，则它将每次执行相同的 SQL 语句，但只会跟踪一个结果集。例如，以下示例将执行 <code>GetStudents</code> 存储过程 3 次，但将仅缓存和跟踪结果的一个副本。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var context &#x3D; new SchoolContext(); <br>var list1 &#x3D; context.Students.FromSql(&quot;GetStudents &#39;Bill&#39;&quot;).ToList();<br>var list2 &#x3D; context.Students.FromSql(&quot;GetStudents &#39;Bill&#39;&quot;).ToList();<br>var list3 &#x3D; context.Students.FromSql(&quot;GetStudents &#39;Bill&#39;&quot;).ToList();<br></code></pre></div></td></tr></table></figure>
</blockquote>
<h3 id="使用-ExecuteSqlCommand-执行存储过程"><a class="header-anchor" href="#使用-ExecuteSqlCommand-执行存储过程">¶</a>使用 <code>ExecuteSqlCommand()</code> 执行存储过程</h3>
<p><code>ExecuteSqlCommand()</code> 方法用于以字符串形式执行数据库命令。对于受指定命令影响的行数，它返回一个整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">var context &#x3D; new SchoolContext();<br>var rowsAffected &#x3D; context.Database.ExecuteSqlCommand(&quot;Update Students set FirstName &#x3D; &#39;Bill&#39; where StudentId &#x3D; 1;&quot;);<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，<code>update</code> 命令在 <code>ExecuteSqlCommand</code> 方法中传递。  <code>rowsAffected</code>  的值将为 <code>1</code>，因为只有 1 行受指定的 <code>update</code> 命令影响。<br>
同样，我们可以执行存储过程来创建，更新和删除命令。考虑以下存储过程，该存储过程将一条记录插入数据库的<code> Student</code> 表中：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mssql">CREATE PROCEDURE CreateStudent<br>    @FirstName Varchar(50),<br>    @LastName Varchar(50)<br>AS<br>BEGIN<br>    SET NOCOUNT ON;<br>    Insert into Students(<br>           [FirstName]<br>           ,[LastName]<br>           )<br> Values (@FirstName, @LastName)<br>END<br>Go<br></code></pre></div></td></tr></table></figure>
<p>现在，您可以执行上面的存储过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C#">var context &#x3D; new SchoolContext(); <br>context.Database.ExecuteSqlCommand(&quot;CreateStudents @p0, @p1&quot;, parameters: new[] &#123; &quot;Bill&quot;, &quot;Gates&quot; &#125;);<br></code></pre></div></td></tr></table></figure>
<p>以相同的方式，您可以执行 <code>Update</code> 和 <code>Delete</code> 命令的存储过程。</p>
<h2 id="二十三、Entity-Framework-Core-日志"><a class="header-anchor" href="#二十三、Entity-Framework-Core-日志">¶</a>二十三、Entity Framework Core 日志</h2>
<p>我们经常需要在 EF Core 中记录 SQL 并更改跟踪信息以进行调试。<br>
EF Core 日志记录自动与 .NET Core 的日志记录机制集成。因此，在隐含使用 EF Core 的日志记录之前，了解有关 .NET Core 日志记录的基础知识。<br>
Entity Framework Core 与 .NET Core 日志记录集成在一起，以记录 SQL 并将跟踪信息更改为各种输出目标。首先，安装您选择的日志记录提供程序的 Nuget 程序包，然后将 <code>DbContext</code> 绑定到 <code>ILoggerFactory</code>。<br>
让我们安装日志记录提供程序的NuGet软件包。在这里，我们将在控制台上显示日志，因此从 NuGet 程序包管理器安装 <code>Microsoft.Extensions.Logging.Console NuGet</code> 程序包，或在程序包管理器控制台中执行以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; dotnet add package Microsoft.Extensions.Logging.Console<br></code></pre></div></td></tr></table></figure>
<p>下图说明了 <code>DbContext</code> 如何与日志记录API和控制台日志记录提供程序一起使用。<br>
<img src="/images/efcore/logging-in-efcore.png" alt="图22-1"></p>
<p>在安装控制台记录器提供程序之后，您需要创建 <code>LoggerFactory</code> 的静态/单个实例，然后将其与 <code>DbContext</code> 绑定，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public class SchoolContext : DbContext &#123;<br>    &#x2F;&#x2F;static LoggerFactory object<br>    public static readonly ILoggerFactory loggerFactory &#x3D; new LoggerFactory(new[] &#123;<br>        new ConsoleLoggerProvider((_, __) &#x3D;&gt; true, true)<br>    &#125;);<br><br>    &#x2F;&#x2F;or<br>    &#x2F;&#x2F; public static readonly ILoggerFactory loggerFactory  &#x3D; new LoggerFactory().AddConsole((_,___) &#x3D;&gt; true);<br>    <br>    public SchoolContext() : base() &#123;<br>    &#125;<br>    <br>    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123;<br>        optionsBuilder.UseLoggerFactory(loggerFactory)  &#x2F;&#x2F;tie-up DbContext with LoggerFactory object<br>            .EnableSensitiveDataLogging()  <br>            .UseSqlServer(@&quot;Server&#x3D;.\SQLEXPRESS;Database&#x3D;SchoolDB;Trusted_Connection&#x3D;True;&quot;);<br>    &#125;<br><br>    public DbSet&lt;Student&gt; Students &#123; get; set; &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在上面的示例中，我们创建了 <code>LoggerFactory</code> 类的对象，并将其分配给 <code>ILoggerFactory</code> 类型的静态变量。然后，我们在 <code>OnConfiguring()</code> 方法的 <code>optionsBuilder.UseLoggerFactory()</code> 方法中传递了此对象。这将使 <code>DbContext</code> 与 <code>loggerFactory</code> 对象共享信息，该对象又将在控制台上显示所有日志记录信息。<br>
默认情况下，EF Core 将不记录敏感数据，例如过滤器参数值。因此，调用 <code>EnableSensitiveDataLogging()</code> 记录敏感数据。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>EF 团队建议在应用程序生存期内，将同一个 logger 工厂对象与 <code>DbContext</code> 类的所有实例一起使用。否则，可能会导致内存泄漏和性能下降。您还可以创建一个单独的工厂类，为您提供 <code>LoggerFactory</code> 类的单例对象，以与 <code>DbContext</code> 一起使用。</p>
</blockquote>
<p>让我们详细了解上面的示例。<br>
首先，我们创建了 <code>LoggerFactory</code> 类的对象，并将其分配给 <code>ILoggerFactory</code> 类型的静态变量，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public static readonly ILoggerFactory loggerFactory &#x3D; new LoggerFactory(<br>    new[] &#123; new ConsoleLoggerProvider ((_, __) &#x3D;&gt; true, true) &#125;<br>);<br></code></pre></div></td></tr></table></figure>
<p><code>LoggerFactory</code> 可以包含一个或多个日志记录提供程序，可用于同时记录到多个介质。<code> LoggerFactory</code> 的构造函数接受一系列不同的记录器提供程序对象作为 <code>new [] {}</code>。我们希望在控制台上显示日志，因此创建控制台记录器提供程序 <code>ConsoleLoggerProvider</code> 的对象。<br>
<code>ConsoleLoggerProvider</code> 有四个构造函数。使用允许 lambda 表达式 (<code>Func &lt;&gt;</code>) 进行日志过滤的方法，并使用 <code>includeScope</code> 布尔值，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">new ConsoleLoggerProvider((_, __) &#x3D;&gt; true, true)<br></code></pre></div></td></tr></table></figure>
<p>在这里，我们不想过滤任何信息，因此 lambda 表达式将始终返回 <code>true (_, __) =&gt; true</code>。</p>
<p>创建 <code>ILoggerFactory</code> 对象之后，使用 <code>DbContextOptionsBuilder</code> 在 <code>OnConfiguring()</code> 方法中将 <code>DbContext</code> 与 <code>ILoggerFactory</code> 绑定在一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">optionsBuilder.UseLoggerFactory(loggerFactory)<br></code></pre></div></td></tr></table></figure>
<p>因此，我们将<code>DbContext</code> 与包括控制台记录器提供程序的 <code>LoggerFactory</code> 绑定在一起。现在，每当 <code>DbContext</code> 实例执行任何操作时，我们都可以在控制台上看到所有日志。<br>
考虑以下示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">using (var context &#x3D; new SchoolContext()) &#123;<br>    var std &#x3D; new Student()&#123; StudentName &#x3D; &quot;Steve&quot; &#125;;<br>    context.Add(std);<br>                <br>    context.SaveChanges();<br>    Console.ReadLine();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面的示例将在控制台上显示以下日志：</p>
<figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">dbug: Microsoft.EntityFrameworkCore.Infrastructure[100401]<br>An <span class="hljs-string">'IServiceProvider'</span> was created <span class="hljs-keyword">for</span> internal use by Entity Framework.<br>info: Microsoft.EntityFrameworkCore.Infrastructure[100403]<br>Entity Framework Core 2.0.0-rtm-26452 initialized <span class="hljs-string">'SchoolContext'</span> using pr<br>ovider <span class="hljs-string">'Microsoft.EntityFrameworkCore.SqlServer'</span> with options: SensitiveDataLoggingEnabled<br>dbug: Microsoft.EntityFrameworkCore.Database.Connection[200000]<br>Opening<span class="hljs-built_in"> connection </span><span class="hljs-keyword">to</span> database <span class="hljs-string">'SchoolDB'</span> on<span class="hljs-built_in"> server </span><span class="hljs-string">'.\SQLEXPRESS'</span>.<br><br>dbug: Microsoft.EntityFrameworkCore.Database.Connection[200001]<br>Opened<span class="hljs-built_in"> connection </span><span class="hljs-keyword">to</span> database <span class="hljs-string">'SchoolDB'</span> on<span class="hljs-built_in"> server </span><span class="hljs-string">'.\SQLEXPRESS'</span>.<br>dbug: Microsoft.EntityFrameworkCore.Database.Transaction[200200]<br>Beginning transaction with isolation level <span class="hljs-string">'ReadCommitted'</span>.<br>warn: Microsoft.EntityFrameworkCore.Database.Command[100400]<br>Sensitive data<span class="hljs-built_in"> logging </span>is enabled. Log entries <span class="hljs-keyword">and</span> exception messages may<br>include sensitive application data, this mode should only be enabled during development.<br>dbug: Microsoft.EntityFrameworkCore.Database.Command[200100]<br>Executing DbCommand [Parameters=[@<span class="hljs-attribute">p0</span>=<span class="hljs-string">''</span> (DbType = DateTime2), @<span class="hljs-attribute">p1</span>=<span class="hljs-string">''</span> (DbTy<br>pe = Int32), @<span class="hljs-attribute">p2</span>=<span class="hljs-string">'0'</span>, @<span class="hljs-attribute">p3</span>=<span class="hljs-string">''</span> (Size = 8000) (DbType = Binary), @<span class="hljs-attribute">p4</span>=<span class="hljs-string">'Steve'</span> (Size = 4000), @<span class="hljs-attribute">p5</span>=<span class="hljs-string">'0'</span>], <span class="hljs-attribute">CommandType</span>=<span class="hljs-string">'Text'</span>, <span class="hljs-attribute">CommandTimeout</span>=<span class="hljs-string">'30'</span>]<br><span class="hljs-builtin-name">SET</span> NOCOUNT ON;<br>INSERT INTO [Students] ([DateOfBirth], [GradeId], [Height], [Photo], [Stud<br>entName], [Weight])<br>VALUES (@p0, @p1, @p2, @p3, @p4, @p5);<br>SELECT [StudentID]<br><span class="hljs-keyword">FROM</span> [Students]<br>WHERE @@ROWCOUNT = 1 <span class="hljs-keyword">AND</span> [StudentID] = scope_identity();<br>info: Microsoft.EntityFrameworkCore.Database.Command[200101]<br>Executed DbCommand (68ms) [Parameters=[@<span class="hljs-attribute">p0</span>=<span class="hljs-string">''</span> (DbType = DateTime2), @<span class="hljs-attribute">p1</span>=<span class="hljs-string">''</span><br>(DbType = Int32), @<span class="hljs-attribute">p2</span>=<span class="hljs-string">'0'</span>, @<span class="hljs-attribute">p3</span>=<span class="hljs-string">''</span> (Size = 8000) (DbType = Binary), @<span class="hljs-attribute">p4</span>=<span class="hljs-string">'Steve'</span><br>(Size = 4000), @<span class="hljs-attribute">p5</span>=<span class="hljs-string">'0'</span>], <span class="hljs-attribute">CommandType</span>=<span class="hljs-string">'Text'</span>, <span class="hljs-attribute">CommandTimeout</span>=<span class="hljs-string">'30'</span>]<br><span class="hljs-builtin-name">SET</span> NOCOUNT ON;<br>INSERT INTO [Students] ([DateOfBirth], [GradeId], [Height], [Photo], [Stud<br>entName], [Weight])<br>VALUES (@p0, @p1, @p2, @p3, @p4, @p5);<br>SELECT [StudentID]<br><span class="hljs-keyword">FROM</span> [Students]<br>WHERE @@ROWCOUNT = 1 <span class="hljs-keyword">AND</span> [StudentID] = scope_identity();<br>dbug: Microsoft.EntityFrameworkCore.Database.Command[200300]<br>A data reader was disposed.<br>dbug: Microsoft.EntityFrameworkCore.Database.Transaction[200202]<br>Committing transaction.<br>dbug: Microsoft.EntityFrameworkCore.Database.Connection[200002]<br>Closing<span class="hljs-built_in"> connection </span><span class="hljs-keyword">to</span> database <span class="hljs-string">'SchoolDB'</span> on<span class="hljs-built_in"> server </span><span class="hljs-string">'.\SQLEXPRESS'</span>.<br><br>dbug: Microsoft.EntityFrameworkCore.Database.Connection[200003]<br>Closed<span class="hljs-built_in"> connection </span><span class="hljs-keyword">to</span> database <span class="hljs-string">'SchoolDB'</span> on<span class="hljs-built_in"> server </span><span class="hljs-string">'.\SQLEXPRESS'</span>.<br>dbug: Microsoft.EntityFrameworkCore.Database.Transaction[200204]<br>Disposing transaction.、<br></code></pre></div></td></tr></table></figure>
<p>如您所见，它记录了所有信息。</p>
<h3 id="过滤日志"><a class="header-anchor" href="#过滤日志">¶</a>过滤日志</h3>
<p>在上面的示例中，<code>DbContext</code> 在保存实体时记录了所有信息。有时您不想记录所有信息并过滤一些不需要的日志。在 EF Core 中，您可以通过指定记录器类别和日志级别来过滤日志。</p>
<h3 id="日志分类"><a class="header-anchor" href="#日志分类">¶</a>日志分类</h3>
<p>EF Core 2.x 包含 <code>DbLoggerCategory</code> 类，以使用其 <code>Name</code> 属性获取 Entity Framework Core 记录器类别。下表列出了不同的记录器类别。</p>
<table>
<thead>
<tr>
<th style="text-align:center">日志类别类</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Database.Command</code></td>
<td style="text-align:center">命令执行的记录器类别，包括发送到数据库的SQL。</td>
</tr>
<tr>
<td style="text-align:center"><code>Database.Connection</code></td>
<td style="text-align:center">数据库连接操作的记录器类别。</td>
</tr>
<tr>
<td style="text-align:center"><code>Database.Transaction</code></td>
<td style="text-align:center">数据库事务的记录器类别。</td>
</tr>
<tr>
<td style="text-align:center"><code>Infrastructure</code></td>
<td style="text-align:center">EF 基础结构的其他消息的记录器类别。</td>
</tr>
<tr>
<td style="text-align:center"><code>Migration</code></td>
<td style="text-align:center">迁移的记录器类别。</td>
</tr>
<tr>
<td style="text-align:center"><code>Model</code></td>
<td style="text-align:center">用于模型构建和元数据的记录器类别。</td>
</tr>
<tr>
<td style="text-align:center"><code>Query</code></td>
<td style="text-align:center">查询的记录器类别 (不包括生成的 SQL)。</td>
</tr>
<tr>
<td style="text-align:center"><code>Scaffolding</code></td>
<td style="text-align:center">脚手架和逆向工程的记录仪类别。</td>
</tr>
<tr>
<td style="text-align:center"><code>Update</code></td>
<td style="text-align:center"><code>DbContext.SaveChanges()</code> 消息的记录器类别。</td>
</tr>
</tbody>
</table>
<h3 id="记录-SQL-查询"><a class="header-anchor" href="#记录-SQL-查询">¶</a>记录 SQL 查询</h3>
<p>要仅记录 SQL 查询，请在 <code>ConsoleLoggerProvider</code> 的构造函数的 lambda 表达式中指定 <code>DbLoggerCategory.Database.Command</code> 类别和 <code>LogLevel.Information</code>，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public static readonly ILoggerFactory consoleLoggerFactory  <br>            &#x3D; new LoggerFactory(new[] &#123;<br>                  new ConsoleLoggerProvider((category, level) &#x3D;&gt;<br>                    category &#x3D;&#x3D; DbLoggerCategory.Database.Command.Name &amp;&amp;<br>                    level &#x3D;&#x3D; LogLevel.Information, true)<br>                &#125;);<br></code></pre></div></td></tr></table></figure>
<p>或者，默认情况下，只需在 <code>LoggerFactory</code> 上调用 <code>AddConsole()</code> 方法即可记录 SQL 查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c#">public static readonly ILoggerFactory consoleLoggerFactory<br>         &#x3D; new LoggerFactory().AddConsole();<br></code></pre></div></td></tr></table></figure>
<p>现在，这将记录以下查询信息，这些查询信息使用 <code>DbContext</code> 保存一个实体：</p>
<figure class="highlight autoit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autoit">info: Microsoft.EntityFrameworkCore.Database.Command[<span class="hljs-number">200101</span>]<br>Executed DbCommand (<span class="hljs-number">73</span>ms) [Parameters=[<span class="hljs-symbol">@p0</span>=<span class="hljs-string">''</span> (DbType = DateTime2), <span class="hljs-symbol">@p1</span>=<span class="hljs-string">''</span><br>(DbType = Int32), <span class="hljs-symbol">@p2</span>=<span class="hljs-string">'0'</span>, <span class="hljs-symbol">@p3</span>=<span class="hljs-string">''</span> (Size = <span class="hljs-number">8000</span>) (DbType = <span class="hljs-built_in">Binary</span>), <span class="hljs-symbol">@p4</span>=<span class="hljs-string">'Steve'</span><br>(Size = <span class="hljs-number">4000</span>), <span class="hljs-symbol">@p5</span>=<span class="hljs-string">'0'</span>], CommandType=<span class="hljs-string">'Text'</span>, CommandTimeout=<span class="hljs-string">'30'</span>]<br>SET NOCOUNT ON<span class="hljs-comment">;</span><br>INSERT INTO [Students] ([DateOfBirth], [GradeId], [Height], [Photo], [Stud<br>entName], [Weight])<br>VALUES (<span class="hljs-symbol">@p0</span>, <span class="hljs-symbol">@p1</span>, <span class="hljs-symbol">@p2</span>, <span class="hljs-symbol">@p3</span>, <span class="hljs-symbol">@p4</span>, <span class="hljs-symbol">@p5</span>)<span class="hljs-comment">;</span><br><span class="hljs-keyword">SELECT</span> [StudentID]<br>FROM [Students]<br>WHERE @<span class="hljs-symbol">@ROWCOUNT</span> = <span class="hljs-number">1</span> <span class="hljs-literal">AND</span> [StudentID] = scope_identity()<span class="hljs-comment">;</span><br></code></pre></div></td></tr></table></figure>
<h2 id="二十四、Entity-Framework-Core-数据迁移"><a class="header-anchor" href="#二十四、Entity-Framework-Core-数据迁移">¶</a>二十四、Entity Framework Core 数据迁移</h2>
<p>迁移是一种通过保留数据来使数据库架构与 EF Core 模型保持同步的方法。</p>
<p><img src="/images/efcore/20200208203737156.png" alt="图24-1"></p>
<p>如上图所示，EF Core API 从域 (实体) 类构建 EF Core 模型，并且 EF Core 迁移将基于 EF Core 模型创建或更新数据库架构。每当更改域类时，都需要运行迁移以使数据库架构保持最新。<br>
EF Core 迁移是一组命令，您可以在 NuGet 软件包管理器控制台或 dotnet 命令行界面 (CLI) 中执行。<br>
下表列出了 EF Core 中的重要迁移命令。</p>
<table>
<thead>
<tr>
<th style="text-align:center">程序包管理器控制台命令</th>
<th style="text-align:center">dotnet 命令行命令</th>
<th style="text-align:center">使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>add-migration &lt;migration name&gt;</code></td>
<td style="text-align:center"><code>dotnet ef migrations add &lt;migration name&gt;</code></td>
<td style="text-align:center">通过添加迁移快照来创建迁移</td>
</tr>
<tr>
<td style="text-align:center"><code>Remove-migration</code></td>
<td style="text-align:center"><code>dotnet ef migrations remove</code></td>
<td style="text-align:center">删除最后一个迁移快照</td>
</tr>
<tr>
<td style="text-align:center"><code>Update-database</code></td>
<td style="text-align:center"><code>dotnet ef db update</code></td>
<td style="text-align:center">根据上一个迁移快照更新数据库架构</td>
</tr>
<tr>
<td style="text-align:center"><code>Script-migration</code></td>
<td style="text-align:center"><code>dotnet ef migrations script</code></td>
<td style="text-align:center">使用所有迁移快照生成 SQL 脚本</td>
</tr>
</tbody>
</table>
<h3 id="添加迁移-v2"><a class="header-anchor" href="#添加迁移-v2">¶</a>添加迁移</h3>
<p>第一次，您定义了初始领域类。此时，您的应用程序没有数据库可以存储您的域类中的数据。因此，首先，您需要创建一个迁移。</p>
<p>从 Visual Studio 中的工具-&gt; NuGet 软件包管理器-&gt;软件包管理器控制台中打开软件包管理器控制台，然后执行以下命令以添加迁移。</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; <span class="hljs-built_in">add-migration</span> MyFirstMigration<br></code></pre></div></td></tr></table></figure>
<p>如果使用的是 dotnet 命令行界面，请执行以下命令。</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; dotnet ef migrations add MyFirstMigration<br></code></pre></div></td></tr></table></figure>
<p>在以上命令中，<code>MyFirstMigration</code> 是迁移的名称。这将在项目的“迁移”文件夹中创建三个文件，如下所示。<br>
<img src="/images/efcore/20200208203750920.png" alt="图24-2"></p>
<ol>
<li><code>&lt;timestamp&gt;_&lt;迁移名称&gt;.cs</code>：主迁移文件，其中包含 <code>Up()</code> 和 <code>Down()</code> 方法中的迁移操作。 <code>Up()</code> 方法包括用于创建数据库对象的代码，而<code>Down()</code> 方法包括用于删除数据库对象的代码。</li>
<li><code>&lt;时间戳&gt;_&lt;迁移名称&gt;.Designer.cs</code>：迁移元数据文件，其中包含 EF Core 使用的信息。</li>
<li><code>&lt;contextclassname&gt; ModelSnapshot.cs</code>：当前模型的快照。这用于确定在创建下一个迁移时所做的更改。</li>
</ol>
<p>现在，在创建迁移快照之后，该创建数据库了。</p>
<h3 id="创建或更新数据库"><a class="header-anchor" href="#创建或更新数据库">¶</a>创建或更新数据库</h3>
<p>使用以下命令创建或更新数据库架构。</p>
<ol>
<li>
<p>程序包管理器控制台</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; <span class="hljs-built_in">Update-Database</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>dotnet 命令行</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; dotnet ef database update<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<p><code>Update</code> 命令将基于上下文和域类以及迁移快照创建数据库，这些快照是使用 <code>add-migration</code> 或 <code>add</code> 命令创建的。<br>
如果这是第一次迁移，则还将创建一个名为 <code>__EFMigrationsHistory</code> 的表，该表将存储所有迁移的名称以及何时将它们应用于数据库。</p>
<p><img src="/images/efcore/20200208203805157.png" alt="图24-3"></p>
<h3 id="删除迁移"><a class="header-anchor" href="#删除迁移">¶</a>删除迁移</h3>
<p>如果上一次迁移未应用到数据库，则可以将其删除。使用以下 <code>remove</code> 命令删除上一次创建的迁移文件并还原模型快照。</p>
<ol>
<li>
<p>程序包管理器控制台</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; <span class="hljs-built_in">remove-migration</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>dotnet 命令行</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; dotnet ef migrations remove<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<p>上面的命令将删除上一次迁移，并将模型快照还原为之前的迁移。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>如果已将迁移应用于数据库，则它将引发以下异常：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey">迁移 `&lt;迁移名称&gt;` 已被应用于数据库。还原它，然后再试一次。如果已将迁移应用于其他数据库，请考虑使用新迁移来还原其更改。<br></code></pre></div></td></tr></table></figure>
</blockquote>
<h3 id="还原迁移"><a class="header-anchor" href="#还原迁移">¶</a>还原迁移</h3>
<p>假设您更改了域类，并使用 <code>add-migration</code> 命令创建了名为 <code>MySecondMigration</code> 的第二个迁移，并使用 <code>Update</code> 命令将该迁移应用于数据库。但是，由于某种原因，您想将数据库还原到以前的状态。在这种情况下，请使用 <code>update-database &lt;迁移名称&gt;</code> 命令将数据库还原到指定的先前迁移快照。</p>
<ol>
<li>
<p>程序包管理器控制台</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; <span class="hljs-built_in">Update-database</span> MyFirstMigration<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>dotnet 命令行</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; dotnet ef database update MyFirstMigration<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<p>上面的命令将基于名为 <code>MyFirstMigration</code> 的迁移还原数据库，并删除应用于名为 <code>MySecondMigration</code> 的第二个迁移的所有更改。这还将从数据库的 <code>__EFMigrationsHistory</code> 表中删除 <code>MySecondMigration</code> 条目。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>这不会删除与 <code>MySecondMigration</code> 相关的迁移文件。使用 <code>remove</code> 命令将其从项目中删除。</p>
</blockquote>
<h3 id="生成-SQL-脚本"><a class="header-anchor" href="#生成-SQL-脚本">¶</a>生成 SQL 脚本</h3>
<p>使用以下命令为数据库生成 SQL 脚本。</p>
<ol>
<li>
<p>程序包管理器控制台</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; script<span class="hljs-literal">-migration</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>dotnet 命令行</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; dotnet ef migrations script<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<p>上面的脚本命令默认将包含所有迁移的脚本。您可以使用 <code>-to</code> 和 <code>-from</code> 选项来指定迁移范围。</p>
<h3 id="程序包管理器控制台命令进行迁移"><a class="header-anchor" href="#程序包管理器控制台命令进行迁移">¶</a>程序包管理器控制台命令进行迁移</h3>
<p>可以使用 Visual Studio 中的程序包管理器控制台执行 Entity Framework Core 中的迁移命令。从 Visual Studio 中的工具-&gt; NuGet软件包管理器-&gt;软件包管理器控制台中打开软件包管理器控制台，以执行以下命令：</p>
<table>
<thead>
<tr>
<th style="text-align:center">程序包管理器控制台</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#get-help" target="_blank" rel="noopener">Get-Help EntityFramework</a></td>
<td style="text-align:center">获取帮助 Entity Framework 显示有关实体框架命令的信息</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#add-migration" target="_blank" rel="noopener">Add-Migration</a></td>
<td style="text-align:center"><code>&lt;迁移名称&gt;</code> 通过添加迁移快照来创建迁移</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#remove-migration" target="_blank" rel="noopener">Remove-Migration</a></td>
<td style="text-align:center">删除最后一个迁移快照</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#update-database" target="_blank" rel="noopener">Update-Database</a></td>
<td style="text-align:center">根据上一个迁移快照更新数据库架构</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#script-migration" target="_blank" rel="noopener">Script-Migration</a></td>
<td style="text-align:center">使用所有迁移快照生成 SQL 脚本</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#scaffold-dbcontext" target="_blank" rel="noopener">Scaffold-DbContext</a></td>
<td style="text-align:center">为指定的数据库生成 <code>DbContext</code> 和实体类型类。这称为逆向工程</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#get-dbcontext" target="_blank" rel="noopener">Get-DbContext</a></td>
<td style="text-align:center">获取有关 <code>DbContext</code> 类型的信息</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.entityframeworktutorial.net/efcore/pmc-commands-for-ef-core-migration.aspx#drop-database" target="_blank" rel="noopener">Drop-Database</a></td>
<td style="text-align:center">删除数据库</td>
</tr>
</tbody>
</table>
<h3 id="Get-Help-获取帮助"><a class="header-anchor" href="#Get-Help-获取帮助">¶</a><code>Get-Help</code> 获取帮助</h3>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">PM&gt; <span class="hljs-built_in">get-help</span> entityframework<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">                     _/\__<br>               <span class="hljs-comment">---==/    \\</span><br>         ___  ___   |.    \|\<br>        | __|| __|  |  )   \\\<br>        | _| | _|   \_/ |  //|\\<br>        |___||_|       /   \\\/\\<br><br>TOPIC<br>    about_EntityFrameworkCore<br><br>SHORT DESCRIPTION<br>    Provides information about the Entity Framework Core Package Manager Console Tools.<br><br>LONG DESCRIPTION<br>    This topic describes the Entity Framework Core Package Manager Console Tools. <br>    See https://docs.efproject.net <span class="hljs-keyword">for</span> information <span class="hljs-keyword">on</span> Entity Framework Core.<br><br>    The <span class="hljs-keyword">following</span> Entity Framework Core commands are available.<br><br>        Cmdlet                      Description<br>        <span class="hljs-comment">--------------------------  ---------------------------------------------------</span><br>        <span class="hljs-keyword">Add</span>-Migration               Adds a <span class="hljs-built_in">new</span> migration.<br><br>        <span class="hljs-keyword">Drop</span>-<span class="hljs-keyword">Database</span>               Drops the <span class="hljs-keyword">database</span>.<br><br>        <span class="hljs-keyword">Get</span>-DbContext               Gets information about a DbContext <span class="hljs-keyword">type</span>.<br><br>        Remove-Migration            Removes the last migration.<br><br>        Scaffold-DbContext          Scaffolds a DbContext <span class="hljs-keyword">and</span> entity <span class="hljs-keyword">types</span> <span class="hljs-keyword">for</span> a <span class="hljs-keyword">database</span>.<br><br>        Script-Migration            Generates a <span class="hljs-keyword">SQL</span> script <span class="hljs-keyword">from</span> migrations.<br><br>        <span class="hljs-keyword">Update</span>-<span class="hljs-keyword">Database</span>             Updates the <span class="hljs-keyword">database</span> <span class="hljs-keyword">to</span> a specified migration.<br><br>SEE <span class="hljs-keyword">ALSO</span><br>    <span class="hljs-keyword">Add</span>-Migration<br>    <span class="hljs-keyword">Drop</span>-<span class="hljs-keyword">Database</span><br>    <span class="hljs-keyword">Get</span>-DbContext<br>    Remove-Migration<br>    Scaffold-DbContext<br>    Script-Migration<br>    <span class="hljs-keyword">Update</span>-<span class="hljs-keyword">Database</span><br></code></pre></div></td></tr></table></figure>
<h3 id="Add-Migration-添加迁移"><a class="header-anchor" href="#Add-Migration-添加迁移">¶</a><code>Add-Migration</code> 添加迁移</h3>
<figure class="highlight fsharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fsharp">NAME<br>    Add-Migration<br>    <br>SYNOPSIS<br>    Adds a <span class="hljs-keyword">new</span> migration.<br>    <br>    <br>SYNTAX<br>    Add-Migration [-Name] &lt;String&gt; [-OutputDir &lt;String&gt;] [-Context &lt;String&gt;] [-Project &lt;String&gt;] <br>                    [-StartupProject &lt;String&gt;] <span class="hljs-meta">[&lt;CommonParameters&gt;]</span><br>    <br>    <br>DESCRIPTION<br>    Adds a <span class="hljs-keyword">new</span> migration.<br><br>REMARKS<br>    To see the examples, <span class="hljs-class"><span class="hljs-keyword">type</span>: "<span class="hljs-title">get</span>-<span class="hljs-title">help</span> <span class="hljs-title">Add</span>-<span class="hljs-title">Migration</span> -<span class="hljs-title">examples</span>".</span><br>    For more information, <span class="hljs-class"><span class="hljs-keyword">type</span>: "<span class="hljs-title">get</span>-<span class="hljs-title">help</span> <span class="hljs-title">Add</span>-<span class="hljs-title">Migration</span> -<span class="hljs-title">detailed</span>".</span><br>    For technical information, <span class="hljs-class"><span class="hljs-keyword">type</span>: "<span class="hljs-title">get</span>-<span class="hljs-title">help</span> <span class="hljs-title">Add</span>-<span class="hljs-title">Migration</span> -<span class="hljs-title">full</span>".</span><br></code></pre></div></td></tr></table></figure>
<h3 id="Remove-Migration-删除迁移"><a class="header-anchor" href="#Remove-Migration-删除迁移">¶</a><code>Remove-Migration</code> 删除迁移</h3>
<figure class="highlight fsharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fsharp">NAME<br>    Remove-Migration<br>    <br>SYNOPSIS<br>    Removes the last migration.<br>    <br>SYNTAX<br>    Remove-Migration [-Force] [-Context &lt;String&gt;] [-Project &lt;String&gt;] [-StartupProject &lt;String&gt;] <br>                        <span class="hljs-meta">[&lt;CommonParameters&gt;]</span><br>    <br>DESCRIPTION<br>    Removes the last migration.<br><br>RELATED LINKS<br>    Add-Migration<br>    about_EntityFrameworkCore <br><br>REMARKS<br>    To see the examples, <span class="hljs-class"><span class="hljs-keyword">type</span>: "<span class="hljs-title">get</span>-<span class="hljs-title">help</span> <span class="hljs-title">Remove</span>-<span class="hljs-title">Migration</span> -<span class="hljs-title">examples</span>".</span><br>    For more information, <span class="hljs-class"><span class="hljs-keyword">type</span>: "<span class="hljs-title">get</span>-<span class="hljs-title">help</span> <span class="hljs-title">Remove</span>-<span class="hljs-title">Migration</span> -<span class="hljs-title">detailed</span>".</span><br>    For technical information, <span class="hljs-class"><span class="hljs-keyword">type</span>: "<span class="hljs-title">get</span>-<span class="hljs-title">help</span> <span class="hljs-title">Remove</span>-<span class="hljs-title">Migration</span> -<span class="hljs-title">full</span>".</span><br></code></pre></div></td></tr></table></figure>
<h3 id="Update-Database-更新数据库"><a class="header-anchor" href="#Update-Database-更新数据库">¶</a><code>Update-Database</code> 更新数据库</h3>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">NAME<br>    <span class="hljs-keyword">Update</span>-<span class="hljs-keyword">Database</span><br>    <br>SYNOPSIS<br>    Updates the <span class="hljs-keyword">database</span> <span class="hljs-keyword">to</span> a specified migration.<br>    <br>    <br>SYNTAX<br>    <span class="hljs-keyword">Update</span>-<span class="hljs-keyword">Database</span> [[-<span class="hljs-keyword">Migration</span>] &lt;<span class="hljs-keyword">String</span>&gt;] [-<span class="hljs-keyword">Context</span> &lt;<span class="hljs-keyword">String</span>&gt;] [-<span class="hljs-keyword">Project</span> &lt;<span class="hljs-keyword">String</span>&gt;] <br>                        [-StartupProject &lt;<span class="hljs-keyword">String</span>&gt;] [&lt;CommonParameters&gt;]<br>    <br>    <br>DESCRIPTION<br>    Updates the <span class="hljs-keyword">database</span> <span class="hljs-keyword">to</span> a specified migration.<br>    <br><br>RELATED LINKS<br>    Script-<span class="hljs-keyword">Migration</span><br>    about_EntityFrameworkCore <br><br>REMARKS<br>    <span class="hljs-keyword">To</span> see the examples, <span class="hljs-keyword">type</span>: <span class="hljs-string">"get-help Update-Database -examples"</span>.<br>    <span class="hljs-keyword">For</span> more information, <span class="hljs-keyword">type</span>: <span class="hljs-string">"get-help Update-Database -detailed"</span>.<br>    <span class="hljs-keyword">For</span> technical information, <span class="hljs-keyword">type</span>: <span class="hljs-string">"get-help Update-Database -full"</span>.<br></code></pre></div></td></tr></table></figure>
<h3 id="Script-migration-脚本迁移"><a class="header-anchor" href="#Script-migration-脚本迁移">¶</a><code>Script-migration</code> 脚本迁移</h3>
<figure class="highlight fsharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fsharp">NAME<br>    Script-Migration<br>    <br>SYNOPSIS<br>    Generates a SQL script from migrations.<br>    <br>    <br>SYNTAX<br>    Script-Migration [-From] &lt;String&gt; [-To] &lt;String&gt; [-Idempotent] [-Output &lt;String&gt;] <br>                        [-Context &lt;String&gt;] [-Project &lt;String&gt;] [-StartupProject &lt;String&gt;] <br>                        <span class="hljs-meta">[&lt;CommonParameters&gt;]</span><br>    <br>    Script-Migration [[-From] &lt;String&gt;] [-Idempotent] [-Output &lt;String&gt;] [-Context &lt;String&gt;] <br>                        [-Project &lt;String&gt;] [-StartupProject &lt;String&gt;] <span class="hljs-meta">[&lt;CommonParameters&gt;]</span><br>    <br>    <br>DESCRIPTION<br>    Generates a SQL script from migrations.<br>    <br><br>RELATED LINKS<br>    Update-Database<br>    about_EntityFrameworkCore <br><br>REMARKS<br>    To see the examples, <span class="hljs-class"><span class="hljs-keyword">type</span>: "<span class="hljs-title">get</span>-<span class="hljs-title">help</span> <span class="hljs-title">Script</span>-<span class="hljs-title">Migration</span> -<span class="hljs-title">examples</span>".</span><br>    For more information, <span class="hljs-class"><span class="hljs-keyword">type</span>: "<span class="hljs-title">get</span>-<span class="hljs-title">help</span> <span class="hljs-title">Script</span>-<span class="hljs-title">Migration</span> -<span class="hljs-title">detailed</span>".</span><br>    For technical information, <span class="hljs-class"><span class="hljs-keyword">type</span>: "<span class="hljs-title">get</span>-<span class="hljs-title">help</span> <span class="hljs-title">Script</span>-<span class="hljs-title">Migration</span> -<span class="hljs-title">full</span>".</span><br></code></pre></div></td></tr></table></figure>
<h3 id="scaffold-dbcontext-支架数据库上下文"><a class="header-anchor" href="#scaffold-dbcontext-支架数据库上下文">¶</a><code>scaffold-dbcontext</code> 支架数据库上下文</h3>
<figure class="highlight prolog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs prolog"><span class="hljs-symbol">NAME</span><br>    <span class="hljs-symbol">Scaffold</span>-<span class="hljs-symbol">DbContext</span><br>    <br><span class="hljs-symbol">SYNOPSIS</span><br>    <span class="hljs-symbol">Scaffolds</span> a <span class="hljs-symbol">DbContext</span> and entity types for a database.<br>    <br>    <br><span class="hljs-symbol">SYNTAX</span><br>    <span class="hljs-symbol">Scaffold</span>-<span class="hljs-symbol">DbContext</span> [-<span class="hljs-symbol">Connection</span>] &lt;<span class="hljs-symbol">String</span>&gt; [-<span class="hljs-symbol">Provider</span>] &lt;<span class="hljs-symbol">String</span>&gt; [-<span class="hljs-symbol">OutputDir</span> &lt;<span class="hljs-symbol">String</span>&gt;] <br>                        [-<span class="hljs-symbol">Context</span> &lt;<span class="hljs-symbol">String</span>&gt;] [-<span class="hljs-symbol">Schemas</span> &lt;<span class="hljs-symbol">String</span>[]&gt;] [-<span class="hljs-symbol">Tables</span> &lt;<span class="hljs-symbol">String</span>[]&gt;] <br>                        [-<span class="hljs-symbol">DataAnnotations</span>] [-<span class="hljs-symbol">Force</span>] [-<span class="hljs-symbol">Project</span> &lt;<span class="hljs-symbol">String</span>&gt;] [-<span class="hljs-symbol">StartupProject</span> &lt;<span class="hljs-symbol">String</span>&gt;] <br>                        [&lt;<span class="hljs-symbol">CommonParameters</span>&gt;]<br>    <br>    <br><span class="hljs-symbol">DESCRIPTION</span><br>    <span class="hljs-symbol">Scaffolds</span> a <span class="hljs-symbol">DbContext</span> and entity types for a database.<br>    <br><br><span class="hljs-symbol">RELATED</span> <span class="hljs-symbol">LINKS</span><br>    about_EntityFrameworkCore <br><br><span class="hljs-symbol">REMARKS</span><br>    <span class="hljs-symbol">To</span> see the examples, type: <span class="hljs-string">"get-help Scaffold-DbContext -examples"</span>.<br>    <span class="hljs-symbol">For</span> more information, type: <span class="hljs-string">"get-help Scaffold-DbContext -detailed"</span>.<br>    <span class="hljs-symbol">For</span> technical information, type: <span class="hljs-string">"get-help Scaffold-DbContext -full"</span>.<br></code></pre></div></td></tr></table></figure>
<h3 id="Get-DbContext"><a class="header-anchor" href="#Get-DbContext">¶</a><code>Get-DbContext</code></h3>
<figure class="highlight fsharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fsharp">NAME<br>    Get-DbContext<br>    <br>SYNOPSIS<br>    Gets information about a DbContext <span class="hljs-class"><span class="hljs-keyword">type</span>.</span><br>    <br>    <br>SYNTAX<br>    Get-DbContext [-Context &lt;String&gt;] [-Project &lt;String&gt;] [-StartupProject &lt;String&gt;] <br>                    <span class="hljs-meta">[&lt;CommonParameters&gt;]</span><br>    <br>    <br>DESCRIPTION<br>    Gets information about a DbContext <span class="hljs-class"><span class="hljs-keyword">type</span>.</span><br>    <br><br>RELATED LINKS<br>    about_EntityFrameworkCore <br><br>REMARKS<br>    To see the examples, <span class="hljs-class"><span class="hljs-keyword">type</span>: "<span class="hljs-title">get</span>-<span class="hljs-title">help</span> <span class="hljs-title">Get</span>-<span class="hljs-title">DbContext</span> -<span class="hljs-title">examples</span>".</span><br>    For more information, <span class="hljs-class"><span class="hljs-keyword">type</span>: "<span class="hljs-title">get</span>-<span class="hljs-title">help</span> <span class="hljs-title">Get</span>-<span class="hljs-title">DbContext</span> -<span class="hljs-title">detailed</span>".</span><br>    For technical information, <span class="hljs-class"><span class="hljs-keyword">type</span>: "<span class="hljs-title">get</span>-<span class="hljs-title">help</span> <span class="hljs-title">Get</span>-<span class="hljs-title">DbContext</span> -<span class="hljs-title">full</span>".</span><br></code></pre></div></td></tr></table></figure>
<h3 id="Drop-Database-删除数据库"><a class="header-anchor" href="#Drop-Database-删除数据库">¶</a><code>Drop-Database</code> 删除数据库</h3>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">NAME<br>    <span class="hljs-keyword">Drop</span>-<span class="hljs-keyword">Database</span><br>    <br>SYNOPSIS<br>    Drops the database.<br>    <br>    <br>SYNTAX<br>    <span class="hljs-keyword">Drop</span>-<span class="hljs-keyword">Database</span> [-<span class="hljs-keyword">Context</span> &lt;<span class="hljs-keyword">String</span>&gt;] [-<span class="hljs-keyword">Project</span> &lt;<span class="hljs-keyword">String</span>&gt;] [-StartupProject &lt;<span class="hljs-keyword">String</span>&gt;] <br>                    [-WhatIf] [-<span class="hljs-keyword">Confirm</span>] [&lt;CommonParameters&gt;]<br>    <br>    <br>DESCRIPTION<br>    Drops the database.<br>    <br><br>RELATED LINKS<br>    <span class="hljs-keyword">Update</span>-<span class="hljs-keyword">Database</span><br>    about_EntityFrameworkCore <br><br>REMARKS<br>    <span class="hljs-keyword">To</span> see the examples, <span class="hljs-keyword">type</span>: <span class="hljs-string">"get-help Drop-Database -examples"</span>.<br>    <span class="hljs-keyword">For</span> more information, <span class="hljs-keyword">type</span>: <span class="hljs-string">"get-help Drop-Database -detailed"</span>.<br>    <span class="hljs-keyword">For</span> technical information, <span class="hljs-keyword">type</span>: <span class="hljs-string">"get-help Drop-Database -full"</span>.<br></code></pre></div></td></tr></table></figure>
<h3 id="用于迁移的命令行界面命令"><a class="header-anchor" href="#用于迁移的命令行界面命令">¶</a>用于迁移的命令行界面命令</h3>
<p>使用 .NET Core Command List Interface 执行实体框架核心命令。要使用 .NET CLI，请通过编辑 .NET Core 项目的 .csproj 文件，在 <code>&lt;ItemGroup&gt;</code> 节点下添加<code>&lt;DotNetCliToolReference Include=&quot;Microsoft.EntityFrameworkCore.Tools.DotNet&quot; Version =&quot;2.0.0&quot; /&gt;</code>。<br>
打开命令提示符，然后导航到项目的根文件夹，然后输入 <code>dotnet ef --help</code> 列出 EF Core 命令，如下所示：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">PM&gt; dotnet ef <span class="hljs-comment">--help</span><br>Entity Framework Core .NET Command Line Tools <span class="hljs-number">2.0</span><span class="hljs-number">.0</span>-rtm<span class="hljs-number">-26452</span><br><br>Usage: dotnet ef [options] [<span class="hljs-keyword">command</span>]<br><br>Options:<br>  <span class="hljs-comment">--version        Show version information</span><br>  -h|<span class="hljs-comment">--help        Show help information</span><br>  -v|<span class="hljs-comment">--verbose     Show verbose output.</span><br>  <span class="hljs-comment">--no-color       Don't colorize output.</span><br>  <span class="hljs-comment">--prefix-output  Prefix output with level.</span><br><br>Commands:<br>  database    Commands <span class="hljs-built_in">to</span> manage <span class="hljs-keyword">the</span> database.<br>  dbcontext   Commands <span class="hljs-built_in">to</span> manage DbContext types.<br>  migrations  Commands <span class="hljs-built_in">to</span> manage migrations.<br><br>Use <span class="hljs-string">"dotnet ef [command] --help"</span> <span class="hljs-keyword">for</span> more information about <span class="hljs-keyword">a</span> <span class="hljs-keyword">command</span>.<br></code></pre></div></td></tr></table></figure>
<p>正如您在上面看到的，有三个主要的 EF 命令可用：<code>database</code>，<code>dbcontext</code> 和 <code>migrations</code>。下表列出了所有 EF 命令和子命令。</p>
<table>
    <thead>
        <tr>
            <th style="text-align: center">命令</th>
            <th style="text-align: center">子命令</th>
            <th style="text-align: center">用法</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="2" style="text-align: center; vertical-align: middle">
                <code>dotnet ef database</code>
            </td>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#database-drop" target="_blank" rel="noopener"><code>drop</code></a>
            </td>
            <td style="text-align: center">删除数据库</td>
        </tr>
        <tr>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#database-update" target="_blank" rel="noopener"><code>update</code></a>
            </td>
            <td style="text-align: center">将数据库更新为指定的迁移</td>
        </tr>
        <tr>
            <td rowspan="3" style="text-align: center; vertical-align: middle">
                <code>dotnet ef dbcontext</code>
            </td>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#dbcontext-info" target="_blank" rel="noopener"><code>info</code></a>
            </td>
            <td style="text-align: center">获取有关 <code>DbContext</code> 类型的信息</td>
        </tr>
        <tr>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#dbcontext-list" target="_blank" rel="noopener"><code>list</code></a>
            </td>
            <td style="text-align: center">列出可用的 <code>DbContext</code> 类型</td>
        </tr>
        <tr>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#dbcontext-scaffold" target="_blank" rel="noopener"><code>scaffold</code></a>
            </td>
            <td style="text-align: center">为数据库提供 <code>DbContext</code> 和实体类型</td>
        </tr>
        <tr>
            <td rowspan="4" style="text-align: center; vertical-align: middle">
                <code>dotnet ef migrations</code>
            </td>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#migrations-add" target="_blank" rel="noopener"><code>add</code></a>
            </td>
            <td style="text-align: center">添加新的迁移</td>
        </tr>
        <tr>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#migrations-list" target="_blank" rel="noopener"><code>list</code></a>
            </td>
            <td style="text-align: center">列出可用的迁移</td>
        </tr>
        <tr>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#migrations-remove" target="_blank" rel="noopener"><code>remove</code></a>
            </td>
            <td style="text-align: center">删除上一次迁移</td>
        </tr>
        <tr>
            <td style="text-align: center">
                <a href="https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx#migrations-script" target="_blank" rel="noopener"><code>script</code></a>
            </td>
            <td style="text-align: center">从迁移生成 SQL 脚本</td>
        </tr>
    </tbody>
</table>
<p>让我们看看每个命令的可用选项。</p>
<h3 id="dotnet-ef-database-drop"><a class="header-anchor" href="#dotnet-ef-database-drop">¶</a><code>dotnet ef database drop</code></h3>
<figure class="highlight vhdl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vhdl">PM&gt; dotnet ef database drop<br>Usage: dotnet ef database drop [options]<br><br>Options:<br>  -f|<span class="hljs-comment">--force                             Don't confirm.</span><br>  <span class="hljs-comment">--dry-run                              Show which database would be dropped, but don't drop it.</span><br>  -c|<span class="hljs-comment">--context &lt;DBCONTEXT&gt;               The DbContext to use.</span><br>  -p|<span class="hljs-comment">--project &lt;PROJECT&gt;                 The project to use.</span><br>  -s|<span class="hljs-comment">--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br>  <span class="hljs-comment">--framework &lt;FRAMEWORK&gt;                The target framework.</span><br>  <span class="hljs-comment">--configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br>  <span class="hljs-comment">--runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br>  <span class="hljs-comment">--msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to "obj".</span><br>  <span class="hljs-comment">--no-build                             Don't build the project. Only use this when </span><br>                                         the build <span class="hljs-keyword">is</span> up-<span class="hljs-keyword">to</span>-date.<br></code></pre></div></td></tr></table></figure>
<h3 id="dotnet-ef-database-update"><a class="header-anchor" href="#dotnet-ef-database-update">¶</a><code>dotnet ef database update</code></h3>
<figure class="highlight vhdl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vhdl">PM&gt; dotnet ef database update<br>Usage: dotnet ef database update [arguments] [options]<br><br>Arguments:<br>  &lt;MIGRATION&gt;  The target migration. <span class="hljs-keyword">If</span> <span class="hljs-string">'0'</span>, <span class="hljs-keyword">all</span> migrations will be reverted. De<br>faults <span class="hljs-keyword">to</span> the last migration.<br><br>Options:<br>  -c|<span class="hljs-comment">--context &lt;DBCONTEXT&gt;               The DbContext to use.</span><br>  -p|<span class="hljs-comment">--project &lt;PROJECT&gt;                 The project to use.</span><br>  -s|<span class="hljs-comment">--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br>  <span class="hljs-comment">--framework &lt;FRAMEWORK&gt;                The target framework.</span><br>  <span class="hljs-comment">--configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br>  <span class="hljs-comment">--runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br>  <span class="hljs-comment">--msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to "obj".</span><br>  <span class="hljs-comment">--no-build                             Don't build the project. Only use this when</span><br>                                         the build <span class="hljs-keyword">is</span> up-<span class="hljs-keyword">to</span>-date.<br></code></pre></div></td></tr></table></figure>
<h3 id="dotnet-ef-dbcontext-info"><a class="header-anchor" href="#dotnet-ef-dbcontext-info">¶</a><code>dotnet ef dbcontext info</code></h3>
<figure class="highlight vhdl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vhdl">PM&gt; dotnet ef dbcontext info<br><br>Usage: dotnet ef dbcontext info [options]<br><br>Options:<br>  <span class="hljs-comment">--json                                 Show JSON output.</span><br>  -c|<span class="hljs-comment">--context &lt;DBCONTEXT&gt;               The DbContext to use.</span><br>  -p|<span class="hljs-comment">--project &lt;PROJECT&gt;                 The project to use.</span><br>  -s|<span class="hljs-comment">--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br>  <span class="hljs-comment">--framework &lt;FRAMEWORK&gt;                The target framework.</span><br>  <span class="hljs-comment">--configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br>  <span class="hljs-comment">--runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br>  <span class="hljs-comment">--msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to "obj".</span><br>  <span class="hljs-comment">--no-build                             Don't build the project. Only use this </span><br>                                         <span class="hljs-keyword">when</span> the build <span class="hljs-keyword">is</span> up-<span class="hljs-keyword">to</span>-date.<br></code></pre></div></td></tr></table></figure>
<h3 id="dotnet-ef-dbcontext-scaffold"><a class="header-anchor" href="#dotnet-ef-dbcontext-scaffold">¶</a><code>dotnet ef dbcontext scaffold</code></h3>
<figure class="highlight vhdl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vhdl">PM&gt; dotnet ef dbcontext scaffold<br><br>Usage: dotnet ef dbcontext scaffold [arguments] [options]<br><br>Arguments:<br>  &lt;CONNECTION&gt;  The connection <span class="hljs-built_in">string</span> <span class="hljs-keyword">to</span> the database.<br>  &lt;PROVIDER&gt;    The provider <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span>. (E.g. Microsoft.EntityFrameworkCore.SqlServ<br>er)<br><br>Options:<br>  -d|<span class="hljs-comment">--data-annotations                  Use attributes to configure the model (</span><br>where possible). <span class="hljs-keyword">If</span> omitted, only the fluent API <span class="hljs-keyword">is</span> used.<br>  -c|<span class="hljs-comment">--context &lt;NAME&gt;                    The name of the DbContext.</span><br>  -f|<span class="hljs-comment">--force                             Overwrite existing files.</span><br>  -o|<span class="hljs-comment">--output-dir &lt;PATH&gt;                 The directory to put files in. Paths ar</span><br>e relative <span class="hljs-keyword">to</span> the project directory.<br>  <span class="hljs-comment">--schema &lt;SCHEMA_NAME&gt;...              The schemas of tables to generate entit</span><br>y types <span class="hljs-keyword">for</span>.<br>  -t|<span class="hljs-comment">--table &gt;TABLE_NAME&lt;...             The tables to generate entity types for.</span><br>  <span class="hljs-comment">--use-database-names                   Use table and column names directly from the database.</span><br>  <span class="hljs-comment">--json                                 Show JSON output.</span><br>  -p|<span class="hljs-comment">--project &lt;PROJECT&gt;                 The project to use.</span><br>  -s|<span class="hljs-comment">--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br>  <span class="hljs-comment">--framework &lt;FRAMEWORK&gt;                The target framework.</span><br>  <span class="hljs-comment">--configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br>  <span class="hljs-comment">--runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br>  <span class="hljs-comment">--msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to "obj".</span><br>  <span class="hljs-comment">--no-build                             Don't build the project. Only use this </span><br>                                         <span class="hljs-keyword">when</span> the build <span class="hljs-keyword">is</span> up-<span class="hljs-keyword">to</span>-date.<br></code></pre></div></td></tr></table></figure>
<h3 id="dotnet-ef-migrations-add"><a class="header-anchor" href="#dotnet-ef-migrations-add">¶</a><code>dotnet ef migrations add</code></h3>
<figure class="highlight vhdl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vhdl">PM&gt; dotnet ef migrations add<br><br>Usage: dotnet ef migrations add [arguments] [options]<br><br>Arguments:<br>  &lt;NAME&gt;  The name <span class="hljs-keyword">of</span> the migration.<br><br>Options:<br>  -o|<span class="hljs-comment">--output-dir &lt;PATH&gt;                 The directory (and sub-namespace) to us</span><br>e. Paths are relative <span class="hljs-keyword">to</span> the project directory. Defaults <span class="hljs-keyword">to</span> <span class="hljs-string">"Migrations"</span>.<br>  <span class="hljs-comment">--json                                 Show JSON output.</span><br>  -c|<span class="hljs-comment">--context &lt;DBCONTEXT&gt;               The DbContext to use.</span><br>  -p|<span class="hljs-comment">--project &lt;PROJECT&gt;                 The project to use.</span><br>  -s|<span class="hljs-comment">--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br>  <span class="hljs-comment">--framework &lt;FRAMEWORK&gt;                The target framework.</span><br>  <span class="hljs-comment">--configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br>  <span class="hljs-comment">--runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br>  <span class="hljs-comment">--msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to "obj".</span><br>  <span class="hljs-comment">--no-build                             Don't build the project. Only use this </span><br>                                         <span class="hljs-keyword">when</span> the build <span class="hljs-keyword">is</span> up-<span class="hljs-keyword">to</span>-date.<br></code></pre></div></td></tr></table></figure>
<h3 id="dotnet-ef-migrations-list"><a class="header-anchor" href="#dotnet-ef-migrations-list">¶</a><code>dotnet ef migrations list</code></h3>
<figure class="highlight vhdl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vhdl">PM&gt; dotnet ef migrations list<br><br>Usage: dotnet ef migrations list [options]<br><br>Options:<br>  <span class="hljs-comment">--json                                 Show JSON output.</span><br>  -c|<span class="hljs-comment">--context &lt;DBCONTEXT&gt;               The DbContext to use.</span><br>  -p|<span class="hljs-comment">--project &lt;PROJECT&gt;                 The project to use.</span><br>  -s|<span class="hljs-comment">--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br>  <span class="hljs-comment">--framework &lt;FRAMEWORK&gt;                The target framework.</span><br>  <span class="hljs-comment">--configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br>  <span class="hljs-comment">--runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br>  <span class="hljs-comment">--msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to "obj".</span><br>  <span class="hljs-comment">--no-build                             Don't build the project. Only use this </span><br>                                         <span class="hljs-keyword">when</span> the build <span class="hljs-keyword">is</span> up-<span class="hljs-keyword">to</span>-date.<br></code></pre></div></td></tr></table></figure>
<h3 id="dotnet-ef-migrations-remove"><a class="header-anchor" href="#dotnet-ef-migrations-remove">¶</a><code>dotnet ef migrations remove</code></h3>
<figure class="highlight vhdl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vhdl">PM&gt; dotnet ef migrations remove<br><br>Usage: dotnet ef migrations remove [options]<br><br>Options:<br>  -f|<span class="hljs-comment">--force                             Don't check to see if the migration has</span><br> been applied <span class="hljs-keyword">to</span> the database.<br>  <span class="hljs-comment">--json                                 Show JSON output.</span><br>  -c|<span class="hljs-comment">--context &lt;DBCONTEXT&gt;               The DbContext to use.</span><br>  -p|<span class="hljs-comment">--project &lt;PROJECT&gt;                 The project to use.</span><br>  -s|<span class="hljs-comment">--startup-project &lt;PROJECT&gt;         The startup project to use.</span><br>  <span class="hljs-comment">--framework &lt;FRAMEWORK&gt;                The target framework.</span><br>  <span class="hljs-comment">--configuration &lt;CONFIGURATION&gt;        The configuration to use.</span><br>  <span class="hljs-comment">--runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime to use.</span><br>  <span class="hljs-comment">--msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults to "obj".</span><br>  <span class="hljs-comment">--no-build                             Don't build the project. Only use this </span><br>                                         <span class="hljs-keyword">when</span> the build <span class="hljs-keyword">is</span> up-<span class="hljs-keyword">to</span>-date.<br></code></pre></div></td></tr></table></figure>
<h3 id="dotnet-ef-migrations-script"><a class="header-anchor" href="#dotnet-ef-migrations-script">¶</a><code>dotnet ef migrations script</code></h3>
<figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">PM&gt; dotnet ef migrations script<br><br>Usage: dotnet ef migrations<span class="hljs-built_in"> script </span>[arguments] [options]<br><br>Arguments:<br>  &lt;<span class="hljs-keyword">FROM</span>&gt;  The starting migration. Defaults <span class="hljs-keyword">to</span> <span class="hljs-string">'0'</span> (the initial database).<br>  &lt;<span class="hljs-keyword">TO</span>&gt;    The ending migration. Defaults <span class="hljs-keyword">to</span> the last migration.<br><br>Options:<br>  -o|--output &lt;FILE&gt;                     The file <span class="hljs-keyword">to</span> write the result <span class="hljs-keyword">to</span>.<br>  -i|--idempotent                        Generate a<span class="hljs-built_in"> script </span>that can be used on a<br> database at any migration.<br>  -c|--context &lt;DBCONTEXT&gt;               The DbContext <span class="hljs-keyword">to</span> use.<br>  -p|--project &lt;PROJECT&gt;                 The project <span class="hljs-keyword">to</span> use.<br>  -s|--startup-project &lt;PROJECT&gt;         The startup project <span class="hljs-keyword">to</span> use.<br>  --framework &lt;FRAMEWORK&gt;                The target framework.<br>  --configuration &lt;CONFIGURATION&gt;        The configuration <span class="hljs-keyword">to</span> use.<br>  --runtime &lt;RUNTIME_IDENTIFIER&gt;         The runtime <span class="hljs-keyword">to</span> use.<br>  --msbuildprojectextensionspath &lt;PATH&gt;  The MSBuild project extensions path. Defaults <span class="hljs-keyword">to</span> <span class="hljs-string">"obj"</span>.<br>  --no-build                             Don<span class="hljs-string">'t build the project. Only use this </span><br><span class="hljs-string">                                         when the build is up-to-date.</span><br></code></pre></div></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>.NET Core</tag>
        <tag>ORM</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer （第五版）》学习笔记 -- 之三</title>
    <url>/2020/03/21/C++-Primer-%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1>C++ Primer 第五版学习笔记（三）</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="第三章-字符串、向量和数组"><a class="header-anchor" href="#第三章-字符串、向量和数组">¶</a>第三章 字符串、向量和数组</h2>
<h3 id="3-1-命名空间的-using-声明"><a class="header-anchor" href="#3-1-命名空间的-using-声明">¶</a>3.1 命名空间的 <code>using</code> 声明</h3>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// using 声明，当我们使用名字 cin 时，从命名空间 std 中获取它</span><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; i;         <span class="hljs-comment">// 正确：cin 和 std::cin 含义相同</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; i;        <span class="hljs-comment">// 错误：没有对应的 using 声明，必须使用完整的名字</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i;   <span class="hljs-comment">// 正确：显式地从 std 中使用 cout</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="第个名字都需要独立的-using-声明"><a class="header-anchor" href="#第个名字都需要独立的-using-声明">¶</a>第个名字都需要独立的 <code>using</code> 声明</h4>
<p>用到的每个名字都必须有自己的声明语句，而且每句话都得以分号结束。</p>
<h4 id="头文件不应该包含-using-声明"><a class="header-anchor" href="#头文件不应该包含-using-声明">¶</a>头文件不应该包含 <code>using</code> 声明</h4>
<p>这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个 <code>using</code> 声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p>
<h4 id="一点注意事项"><a class="header-anchor" href="#一点注意事项">¶</a>一点注意事项</h4>
<p>略。见 P75。</p>
<h4 id="3-1-节练习"><a class="header-anchor" href="#3-1-节练习">¶</a>3.1 节练习</h4>
<ul>
<li>
<p>练习 3.1：使用恰当的 <code>using</code> 声明重做 1.4.1 节 (第 11 页) 和 2.6.2 节 (第 67 页) 的练习。</p>
<p>解：</p>
<ul>
<li>
<p>练习 1.9：编写程序，使用 <code>while</code> 循环将 50 到 100 的整数相加。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>:<span class="hljs-built_in">endl</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> v = <span class="hljs-number">49</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(v &lt; <span class="hljs-number">100</span>) &#123;<br>        sum += (++v);<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The sum of 50 ~ 100 is "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 1.10：除了 <code>++</code> 运算符将运算对象增加 <code>1</code> 之外，还有一个递减运算符 (<code>--</code>) 实现将值减少 <code>1</code>。编写程序，使用递减运算符在循环中顺序打印 <code>10</code> 到 <code>0</code> 之间的整数。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>, <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> v = <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">while</span>(v &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; --v &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 1.11：编写程序，提示用户输入两个整数，打印出这两个整数所指定的范围内的所有整数。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>, <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span>, <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> v_start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> v_end = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Please enter start number: "</span>;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; v_start;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Please enter end number: "</span>;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; v_end;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">"The integers between "</span><br>         &lt;&lt; v_start &lt;&lt; <span class="hljs-string">" and "</span> &lt;&lt; v_end &lt;&lt; <span class="hljs-string">" are: "</span>;<br>    <br>    <span class="hljs-keyword">while</span>(v_end &gt;= v_start) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; v_start &lt;&lt; <span class="hljs-string">" "</span>;<br>        ++v_start;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 2.41：使用你自己的 <code>Sales_data</code> 类重写 1.5.1 节 (P20)、1.5.2 节 (P21) 和 1.6 节 (P22) 的练习。眼下先把 <code>Sales_data</code> 类的定义和 <code>main</code> 函数放在同一个文件里。</p>
<p>解：略。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-标准库类型-string"><a class="header-anchor" href="#3-2-标准库类型-string">¶</a>3.2 标准库类型 <code>string</code></h3>
<p>标准库类型 <code>string</code> 表示 <strong>可变长</strong> 的字符序列，<strong>使用 <code>string</code> 类型必须首先包含 <em>string</em> 头文件</strong>。作为标准库的一部分，<strong><code>string</code> 定义在命名空间 <code>std</code> 中</strong>。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>C++ 标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现者做出一些性能上的需求。因此，标准库类型对于一般应用场合来说有足够的效率。</p>
</blockquote>
<h4 id="3-2-1-定义和初始化-string-对象"><a class="header-anchor" href="#3-2-1-定义和初始化-string-对象">¶</a>3.2.1 定义和初始化 <code>string</code> 对象</h4>
<p>一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别：或者是初始值的数量不同，或者是初始值的类型不同：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> s1;               <span class="hljs-comment">// 默认初始化，s1 是一个空字符串</span><br><span class="hljs-built_in">string</span> s2 = s1;          <span class="hljs-comment">// s2 是 s1 的副本</span><br><span class="hljs-built_in">string</span> s3 = <span class="hljs-string">"hiya"</span>;      <span class="hljs-comment">// s3 是该字符串字面值的副本</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>)</span></span>;      <span class="hljs-comment">// s4 的内容是 cccccccccc</span><br></code></pre></div></td></tr></table></figure>
<table>
    <thead>
        <tr>
            <th colspan="2" style="text-align: center">表 3.1：初始化 string 对象的方式</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>string s1</td>
            <td>默认初始化，s1 是一个空串</td>
        </tr>
        <tr>
            <td>string s2(s1)</td>
            <td>s2 是 s1 的副本</td>
        </tr>
        <tr>
            <td>string s2 = s1</td>
            <td>等价于 s2(s1)，s2 是 s1 的副本</td>
        </tr>
        <tr>
            <td>string s3("value")</td>
            <td>s3 是字面值 "value" 的副本，除了字面值最后的那个空字符外</td>
        </tr>
        <tr>
            <td>string s3 = "value"</td>
            <td>等价于 s3("value")，s3 是字面值 "value" 的副本</td>
        </tr>
        <tr>
            <td>string s4(n, 'c')</td>
            <td>把 s4 初始化为由连续 n 个字符 c 组成的串</td>
        </tr>
    </tbody>
</table>
<h5 id="直接初始化和拷贝初始化"><a class="header-anchor" href="#直接初始化和拷贝初始化">¶</a>直接初始化和拷贝初始化</h5>
<p>由第 2.2.1 节 (P39) 的学习可知：</p>
<ul>
<li><strong>如果使用等号 (<code>=</code>) 初始化一个变量，实际上执行的是 <span style="border-bottom: 3px black double">拷贝初始化</span> (copy initialization)，编译器把等号右侧的初始值拷贝到新创建的对象中去</strong>。</li>
<li>与之相反，如果不使用等号，则执行的是 <strong>直接初始化</strong> (direct initialization)。</li>
</ul>
<p>当初始值只有一个时，使用直接初始化或拷贝初始化都行。如果像上面的 <code>s4</code> 那样初始化要用到的值有多个，一般来说只能使用 <strong>直接初始化</strong> 的方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">string</span> s5 = <span class="hljs-string">"hiya"</span>;     <span class="hljs-comment">// 拷贝初始化</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s6</span><span class="hljs-params">(<span class="hljs-string">"hiya"</span>)</span></span>;      <span class="hljs-comment">// 直接初始化</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s7</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">'c'</span>)</span></span>;     <span class="hljs-comment">// 直接初始化，s7 的内容是 cccccccccc</span><br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL 自签发配置有多域名或 IP 地址的证书</title>
    <url>/2020/02/19/OpenSSL-%E8%87%AA%E7%AD%BE%E5%8F%91%E9%85%8D%E7%BD%AE%E6%9C%89%E5%A4%9A%E5%9F%9F%E5%90%8D%E6%88%96-IP-%E5%9C%B0%E5%9D%80%E7%9A%84%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h1>OpenSSL 自签发配置有多域名或 IP 地址的证书</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2>
<p>HTTPS 服务是工作在 SSL/TLS上 的 HTTP。<br>
首先简单区分一下 HTTPS、SSL 、TLS 和 OpenSSL 这四者的关系：</p>
<ul>
<li>SSL：（Secure Socket Layer，安全套接字层）是在客户端和服务器之间建立一条 SSL 安全通道的安全协议；</li>
<li>TLS：（Transport Layer Security，传输层安全协议），用于两个应用程序之间提供保密性和数据完整性；</li>
<li>TLS 的前身是 SSL；</li>
<li>OpenSSL 是 TLS/SSL 协议的开源实现，提供开发库和命令行程序；</li>
<li>HTTPS 是 HTTP 的加密版，底层使用的加密协议是 TLS。</li>
</ul>
<p>结论：SSL/TLS 是协议，OpenSSL 是协议的代码实现。</p>
<h3 id="本文采用的目录结构"><a class="header-anchor" href="#本文采用的目录结构">¶</a>本文采用的目录结构</h3>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">ca<br>├── certs               证书目录<br>├── crl                 证书吊销目录<br>├── index.txt           CA 签发证书列表<br>├── index.txt.attr      CA 签发证书列表配置<br>├── newcerts            CA 签发的证书备份目录<br>├── openssl.cnf         openssl 配置文件，-config 参数用<br>├── private             私钥目录<br>└── serial              CA 下一次签发证书时使用的序列号，文本文件<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p><em>serial</em> 文件在建立时应添加初始内容“00”。</p>
</blockquote>
<h3 id="用-OpenSSL-配置带有-SubjectAltName-的-SSL-请求"><a class="header-anchor" href="#用-OpenSSL-配置带有-SubjectAltName-的-SSL-请求">¶</a>用 OpenSSL 配置带有 SubjectAltName 的 SSL 请求</h3>
<p>对于多域名，只需要一个证书就可以保护非常多的域名。</p>
<p>SubjectAltName 是 X509 Version 3 (RFC 2459) 的扩展，允许 SSL 证书指定多个可以匹配的名称。</p>
<p>SubjectAltName 可以包含 Email 地址，IP 地址，正则匹配 DNS 主机名，等等。SSL 这样的一个特性叫做：SubjectAlternativeName（简称：SAN）。</p>
<h2 id="第一部分-生成证书"><a class="header-anchor" href="#第一部分-生成证书">¶</a>第一部分 生成证书</h2>
<h3 id="第一步-生成证书请求文件"><a class="header-anchor" href="#第一步-生成证书请求文件">¶</a>第一步 生成证书请求文件</h3>
<p>对于一个通用的 SSL 证书请求文件（CSR），OpenSSL 不需要很多操作。因为我们可能需要添加一个或者两个 SAN 到我们 CSR，我们需要在 OpenSSL 配置文件中添加一些东西：你需要告诉 OpenSSL 创建一个包含 x509 V3 扩展的 CSR，并且你也需要告诉 OpenSSL 在你的 CSR 中包含 SubjectAlternativeNames 列表。</p>
<p>创建一个<code>OpenSSL</code>配置文件（<em>openssl.cnf</em>），并启用 SubjectAlternativeNames：</p>
<ol>
<li>
<p>找到 <code>req</code> 段落。这段落的内容将会告诉 OpenSSL如何去处理证书请求（CSR）。</p>
</li>
<li>
<p>在 <code>req</code> 段落中应该要包含一个以 <code>req_extensions</code> 开始的行。如下：</p>
 <figure class="highlight toml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs toml"><span class="hljs-section">[req]</span><br><span class="hljs-attr">distinguished_name</span> = req_distinguished_name<br><span class="hljs-attr">req_extensions</span> = v3_req<br></code></pre></div></td></tr></table></figure>
<p>这个配置是告诉  OpenSSL 在 CSR 中要包含 <code>v3_req</code> 段落的部分。</p>
</li>
<li>
<p>现在我们来配置 <code>v3_req</code>，如下：</p>
 <figure class="highlight toml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs toml"><span class="hljs-section">[req_distinguished_name]</span><br><span class="hljs-attr">countryName</span> = Country Name (<span class="hljs-number">2</span> letter code)<br><span class="hljs-attr">countryName_default</span> = US<br><span class="hljs-attr">stateOrProvinceName</span> = State or Province Name (full name)<br><span class="hljs-attr">stateOrProvinceName_default</span> = MN<br><span class="hljs-attr">localityName</span> = Locality Name (eg, city)<br><span class="hljs-attr">localityName_default</span> = Minneapolis<br><span class="hljs-attr">organizationalUnitName</span>  = Organizational Unit Name (eg, section)<br><span class="hljs-attr">organizationalUnitName_default</span>  = Domain Control Validated<br><span class="hljs-attr">commonName</span> = Internet Widgits Ltd<br><span class="hljs-attr">commonName_max</span>  = <span class="hljs-number">64</span><br><br><span class="hljs-section">[ v3_req ]</span><br><span class="hljs-comment"># Extensions to add to a certificate request</span><br><span class="hljs-attr">basicConstraints</span> = CA:<span class="hljs-literal">FALSE</span><br><span class="hljs-attr">keyUsage</span> = nonRepudiation, digitalSignature, keyEncipherment<br><span class="hljs-attr">subjectAltName</span> = @alt_names<br><br><span class="hljs-section">[alt_names]</span><br><span class="hljs-attr">DNS.1</span> = kb.example.com<br><span class="hljs-attr">DNS.2</span> = helpdesk.example.org<br><span class="hljs-attr">DNS.3</span> = systems.example.net<br><span class="hljs-attr">DNS.4</span> = *.example.cn<br><span class="hljs-attr">IP.1</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span><br><span class="hljs-attr">IP.2</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">69.14</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>无论 <code>v3_req</code> 放哪里，都是可以的，都会在所有生成的 CSR 中。<br>
要是之后，你又想生成一个不同的 SAN 的 CSR 文件，你需要编辑这个配置文件，并改变 <code>DNS.x</code> 列表。</p>
</blockquote>
</li>
</ol>
<h3 id="第二步-生成私钥"><a class="header-anchor" href="#第二步-生成私钥">¶</a>第二步 生成私钥</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 使用椭圆曲线算法生成私钥</span><br>openssl ecparam -genkey -name secp256r1 | openssl ec -out private/san_domain_com.key.pem<br><br><span class="hljs-comment"># 或</span><br><br><span class="hljs-comment"># 使用 RSA 算法生成私钥</span><br>openssl genrsa -out private/san_domain_com.key.pem 2048<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<ol>
<li>
<p><code>ecparam</code> 为椭圆曲线密钥参数生成：</p>
<figure class="highlight haml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haml">-<span class="ruby">genkey        生成椭圆曲线密钥</span><br><span class="ruby">-name          使用短名称（<span class="hljs-string">"short name"</span>）命名的椭圆曲线参数</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>ec</code> 为椭圆曲线密钥处理工具。</p>
</li>
<li>
<p>这里的 <code>san_domain_com</code>，是你正式使用的服务器的全称地址，这不是必须的，也就是说，你可以随便取名字；但是按照这个格式去，会更清晰点。</p>
</li>
</ol>
</blockquote>
<h3 id="第三步-创建-CSR-文件"><a class="header-anchor" href="#第三步-创建-CSR-文件">¶</a>第三步 创建 CSR 文件</h3>
<ol>
<li>
<p>执行下面语句：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">openssl req -config openssl.cnf -new -key private/san_domain_com.key.pem -out certs/san_domain_com.csr.pem<br><span class="hljs-comment"># 注意这里指定了openssl.cnf，使用了下面我们创建的，因为默认是没有`san`。</span><br></code></pre></div></td></tr></table></figure>
<p>执行后，系统会提示你要你输入组织信息，并询问你是否想要包含密码（你可以不需要）。接着你将会看到 <em>san_domain_com.csr</em> 被创建。</p>
</li>
<li>
<p>我们可以使用下面的命令来查看 CSR 包含的信息：</p>
 <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">openssl req -text -noout -in certs/san_domain_com.csr.pem<br></code></pre></div></td></tr></table></figure>
<p>你将会看到类似如下的信息：</p>
 <figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">Certificate <span class="hljs-string">Request:</span><br><span class="hljs-symbol">        Data:</span><br><span class="hljs-symbol">            Version:</span> <span class="hljs-number">1</span> (<span class="hljs-number">0x0</span>)<br><span class="hljs-symbol">            Subject:</span> C = US, ST = Texas, L = Fort Worth, O = <span class="hljs-string">"My Company"</span>, OU = My Department, CN = server.example<br>            Subject Public Key <span class="hljs-string">Info:</span><br>                Public Key <span class="hljs-string">Algorithm:</span> id-ecPublicKey<br>                    Public-<span class="hljs-string">Key:</span> (<span class="hljs-number">256</span> bit)<br><span class="hljs-symbol">                    pub:</span><br><span class="hljs-symbol">                        xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><br><span class="hljs-symbol">                        xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><br><span class="hljs-symbol">                        xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><br><span class="hljs-symbol">                        xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><br><span class="hljs-symbol">                        xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span><span class="hljs-string">xx:</span>xx<br>                    ASN1 <span class="hljs-string">OID:</span> prime256v1<br>                    NIST <span class="hljs-string">CURVE:</span> P<span class="hljs-number">-256</span><br><span class="hljs-symbol">            Attributes:</span><br>            Requested <span class="hljs-string">Extensions:</span><br>                X509v3 Basic <span class="hljs-string">Constraints:</span><br><span class="hljs-symbol">                    CA:</span>FALSE<br>                X509v3 Key <span class="hljs-string">Usage:</span><br>                    Digital Signature, Non Repudiation, Key Encipherment<br>                X509v3 Subject Alternative <span class="hljs-string">Name:</span><br><span class="hljs-symbol">                    DNS:</span>kb.example.com, <span class="hljs-string">DNS:</span>helpdesk.example.org, <span class="hljs-string">DNS:</span>systems.example.net, <span class="hljs-string">DNS:</span>*.example.cn, IP <span class="hljs-string">Address:</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>, IP <span class="hljs-string">Address:</span><span class="hljs-number">192.168</span><span class="hljs-number">.69</span><span class="hljs-number">.14</span><br>        Signature <span class="hljs-string">Algorithm:</span> ecdsa-with-SHA256<br><span class="hljs-symbol">             yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><br><span class="hljs-symbol">             yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><br><span class="hljs-symbol">             yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><br><span class="hljs-symbol">             yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span><span class="hljs-string">yy:</span>yy<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h3 id="第四步-自签名并创建服务器证书"><a class="header-anchor" href="#第四步-自签名并创建服务器证书">¶</a>第四步 自签名并创建服务器证书</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">openssl x509 -req -days 3650 -<span class="hljs-keyword">in</span> certs/san_domain_com.csr.pem -signkey private/san_domain_com.key.pem<br> -out certs/san_domain_com.crt.pem -extensions server_cert -extfile openssl.cnf<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<ol>
<li>上面的证书 有效期是 3650 天。</li>
<li><span style="border-bottom: 3px black double; font-weight: bold">对于服务器证书，<code>-extensions</code> 参数为 <code>server_cert</code>；对于客户端证书 <code>-extensions</code> 参数 为 <code>user_cert</code>。但服务器和客户端证书都可以使用通用参数 <code>v3_req</code>。<code>server_cert</code>、<code>user_cert</code> 和 <code>v3_req</code> 的定义参见本文最后 <em>openssl.cnf</em> 文件示例。</span></li>
</ol>
</blockquote>
<h3 id="第五步-自签名并创建（双向认证）客户端证书"><a class="header-anchor" href="#第五步-自签名并创建（双向认证）客户端证书">¶</a>第五步 自签名并创建（双向认证）客户端证书</h3>
<p>抓包工具可以轻松获取到你请求的接口名称字段结构等，虽然不能修改本次请求，但是得到你的请求规则以后就可以脱离你的软件自行进行访问，这也是我们不想看到的，所以双向认证就是很有需要的了。</p>
<ol>
<li>
<p>与第四步相同步骤生成证书，注意 <code>-extensions</code> 参数。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>在生成客户端证书的时候填写的那些国家、地域以及Common Name等<strong>不能与根证书完全一致</strong>（未验证），否则会访问失败。</p>
</blockquote>
</li>
<li>
<p>客户端需要使用 p12 格式证书。p12 格式证书导出：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">openssl pkcs12 -<span class="hljs-built_in">export</span> -clcerts -<span class="hljs-keyword">in</span> certs/san_domain_com_client.crt -inkey private/san_domain_com_client.key -out certs/san_domain_com_client.p12<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>客户端导入 p12 证书。</p>
</li>
<li>
<p>nginx <code>server</code> 节点添加：</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">...<br><br>ssl_client_certificate  /path/to/client.crt;  # 此处可以是 CA 证书，注意是 pem 格式，不是 p12 格式。<br>ssl_verify_client  on;<br><br>...<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h2 id="第二部分-使用-CA-证书签名服务器证书"><a class="header-anchor" href="#第二部分-使用-CA-证书签名服务器证书">¶</a>第二部分 使用 CA 证书签名服务器证书</h2>
<h3 id="第一步-修改-openssl-cnf，添加-CA-信息"><a class="header-anchor" href="#第一步-修改-openssl-cnf，添加-CA-信息">¶</a>第一步 修改 <em>openssl.cnf</em>，添加 CA 信息</h3>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs toml">...<br><br><span class="hljs-section">[ ca ]</span><br><span class="hljs-comment"># `man ca`</span><br><span class="hljs-attr">default_ca</span> = CA_default<br><br>...<br><br><span class="hljs-section">[ CA_default ]</span><br><span class="hljs-comment"># Directory and file locations.</span><br><span class="hljs-attr">dir</span>               = /path/to/some/dir <span class="hljs-comment">#这里改成实际目录</span><br><span class="hljs-attr">certs</span>             = <span class="hljs-variable">$dir</span>/certs<br><span class="hljs-attr">crl_dir</span>           = <span class="hljs-variable">$dir</span>/crl<br><span class="hljs-attr">new_certs_dir</span>     = <span class="hljs-variable">$dir</span>/newcerts<br><span class="hljs-attr">database</span>          = <span class="hljs-variable">$dir</span>/index.txt<br><span class="hljs-attr">serial</span>            = <span class="hljs-variable">$dir</span>/serial<br><span class="hljs-attr">RANDFILE</span>          = <span class="hljs-variable">$dir</span>/private/.rand<br><br><span class="hljs-comment"># The root key and root certificate.</span><br><span class="hljs-attr">private_key</span>       = <span class="hljs-variable">$dir</span>/private/ca.key.pem<br><span class="hljs-attr">certificate</span>       = <span class="hljs-variable">$dir</span>/certs/ca.cert.pem<br><br><span class="hljs-comment"># For certificate revocation lists.</span><br><span class="hljs-attr">crlnumber</span>         = <span class="hljs-variable">$dir</span>/crlnumber<br><span class="hljs-attr">crl</span>               = <span class="hljs-variable">$dir</span>/crl/ca.crl.pem<br><span class="hljs-attr">crl_extensions</span>    = crl_ext<br><span class="hljs-attr">default_crl_days</span>  = <span class="hljs-number">30</span><br><br><span class="hljs-comment"># SHA-1 is deprecated, so use SHA-2 instead.</span><br><span class="hljs-attr">default_md</span>        = sha256<br><br><span class="hljs-attr">name_opt</span>          = ca_default<br><span class="hljs-attr">cert_opt</span>          = ca_default<br><span class="hljs-attr">default_days</span>      = <span class="hljs-number">375</span><br><span class="hljs-attr">preserve</span>          = <span class="hljs-literal">no</span><br><span class="hljs-attr">policy</span>            = policy_strict<br><br>...<br><br><span class="hljs-section">[req]</span><br><br>...<br><br><span class="hljs-attr">x509_extensions</span>     = v3_ca<br><br>...<br><br><span class="hljs-section">[ v3_ca ]</span><br><span class="hljs-comment"># Extensions for a typical CA (`man x509v3_config`).</span><br><span class="hljs-attr">subjectKeyIdentifier</span> = hash<br><span class="hljs-attr">authorityKeyIdentifier</span> = keyid:always,issuer<br><span class="hljs-attr">basicConstraints</span> = critical, CA:<span class="hljs-literal">true</span><br><span class="hljs-attr">keyUsage</span> = critical, digitalSignature, cRLSign, keyCertSign<br><br>...<br><br><span class="hljs-section">[ v3_intermediate_ca ]</span><br><span class="hljs-comment"># Extensions for a typical intermediate CA (`man x509v3_config`).</span><br><span class="hljs-attr">subjectKeyIdentifier</span> = hash<br><span class="hljs-attr">authorityKeyIdentifier</span> = keyid:always,issuer<br><span class="hljs-attr">basicConstraints</span> = critical, CA:<span class="hljs-literal">true</span>, pathlen:<span class="hljs-number">0</span><br><span class="hljs-attr">keyUsage</span> = critical, digitalSignature, cRLSign, keyCertSign<br><br>...<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>当生成 CA 证书时 <code>basicConstraints</code> 字段值应包含 <code>CA:true</code>。</p>
</blockquote>
<h3 id="第二步-创建-CA-私钥"><a class="header-anchor" href="#第二步-创建-CA-私钥">¶</a>第二步 创建 CA 私钥</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 使用椭圆曲线算法生成私钥</span><br>openssl ecparam -genkey -name secp256r1 | openssl ec -out private/ca.key.pem<br><br><span class="hljs-comment"># 或</span><br><br><span class="hljs-comment"># 使用 RSA 算法生成私钥</span><br>openssl genrsa -out private/ca.key.pem 2048<br></code></pre></div></td></tr></table></figure>
<h3 id="第三步-生成-CA-证书"><a class="header-anchor" href="#第三步-生成-CA-证书">¶</a>第三步 生成 CA 证书</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">openssl req -config openssl.cnf -key private/ca.key.pem -new -x509 -days 7300 -sha256 -extensions v3_ca -out certs/ca.cert.pem<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>任何证书的生成都可以不生成请求文件而直接生成证书文件。</p>
</blockquote>
<h3 id="第四步-生成服务端或客户端证书"><a class="header-anchor" href="#第四步-生成服务端或客户端证书">¶</a>第四步 生成服务端或客户端证书</h3>
<p>见第一部分。</p>
<h3 id="第五步-利用-ca-cert-pem-来签署证书"><a class="header-anchor" href="#第五步-利用-ca-cert-pem-来签署证书">¶</a>第五步 利用 <em>ca.cert.pem</em> 来签署证书</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">openssl ca -config openssl.cnf -extensions server_cert -days 1095 -md sha256 -<span class="hljs-keyword">in</span> certs/san_domain_com.csr.pem -out certs/san_domain_com.cert.pem<br><br><span class="hljs-comment"># 或</span><br>openssl x509 -req -sha256 -extfile v3.ext -CA certs/ca.cert.pem -CAkey private/ca.key.pem -CAcreateserial -<span class="hljs-keyword">in</span> certs/san_domain_com.csr.pem -out certs/san_domain_com.cert.pem<br><br><span class="hljs-comment"># 或者 把v3.ext 改为 openssl.cnf</span><br>openssl x509 -req -sha256 -extfile openssl.cnf -CA certs/ca.cert.pem -CAkey private/ca.key.pem -CAcreateserial -<span class="hljs-keyword">in</span> certs/san_domain_com.csr.pem -out certs/san_domain_com.cert.pem<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<ol>
<li><code>sha256</code> 是哈希算法</li>
<li><code>v3.ext</code> 是要自己创建的</li>
</ol>
</blockquote>
<p><em>v3.ext</em> 内容：</p>
<figure class="highlight toml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs toml"><span class="hljs-attr">authorityKeyIdentifier</span>=keyid,issuer<br><span class="hljs-attr">basicConstraints</span>=CA:<span class="hljs-literal">FALSE</span><br><span class="hljs-attr">keyUsage</span>=digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment<br><span class="hljs-attr">subjectAltName</span>=@alt_names<br><br><span class="hljs-section">[alt_names]</span><br><span class="hljs-attr">DNS.1</span>=www.test.com<br><span class="hljs-attr">IP.1</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span><br></code></pre></div></td></tr></table></figure>
<h2 id="完整的-openssl-cnf-示例内容"><a class="header-anchor" href="#完整的-openssl-cnf-示例内容">¶</a>完整的 <em>openssl.cnf</em> 示例内容</h2>
<figure class="highlight toml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs toml"><span class="hljs-section">[ ca ]</span><br><span class="hljs-comment"># `man ca`</span><br><span class="hljs-attr">default_ca</span> = CA_default<br><br><span class="hljs-section">[ CA_default ]</span><br><span class="hljs-comment"># Directory and file locations.</span><br><span class="hljs-attr">dir</span>               = /path/to/some/dir <span class="hljs-comment">#这里改成实际目录</span><br><span class="hljs-attr">certs</span>             = <span class="hljs-variable">$dir</span>/certs<br><span class="hljs-attr">crl_dir</span>           = <span class="hljs-variable">$dir</span>/crl<br><span class="hljs-attr">new_certs_dir</span>     = <span class="hljs-variable">$dir</span>/newcerts<br><span class="hljs-attr">database</span>          = <span class="hljs-variable">$dir</span>/index.txt<br><span class="hljs-attr">serial</span>            = <span class="hljs-variable">$dir</span>/serial<br><span class="hljs-attr">RANDFILE</span>          = <span class="hljs-variable">$dir</span>/private/.rand<br><br><span class="hljs-comment"># The root key and root certificate.</span><br><span class="hljs-attr">private_key</span>       = <span class="hljs-variable">$dir</span>/private/ca.key.pem<br><span class="hljs-attr">certificate</span>       = <span class="hljs-variable">$dir</span>/certs/ca.cert.pem<br><br><span class="hljs-comment"># For certificate revocation lists.</span><br><span class="hljs-attr">crlnumber</span>         = <span class="hljs-variable">$dir</span>/crlnumber<br><span class="hljs-attr">crl</span>               = <span class="hljs-variable">$dir</span>/crl/ca.crl.pem<br><span class="hljs-attr">crl_extensions</span>    = crl_ext<br><span class="hljs-attr">default_crl_days</span>  = <span class="hljs-number">30</span><br><br><span class="hljs-comment"># SHA-1 is deprecated, so use SHA-2 instead.</span><br><span class="hljs-attr">default_md</span>        = sha256<br><br><span class="hljs-attr">name_opt</span>          = ca_default<br><span class="hljs-attr">cert_opt</span>          = ca_default<br><span class="hljs-attr">default_days</span>      = <span class="hljs-number">375</span><br><span class="hljs-attr">preserve</span>          = <span class="hljs-literal">no</span><br><span class="hljs-attr">policy</span>            = policy_strict<br><br><span class="hljs-section">[ policy_strict ]</span><br><span class="hljs-comment"># The root CA should only sign intermediate certificates that match.</span><br><span class="hljs-comment"># See the POLICY FORMAT section of `man ca`.</span><br><span class="hljs-attr">countryName</span>             = match<br><span class="hljs-attr">stateOrProvinceName</span>     = match<br><span class="hljs-attr">organizationName</span>        = match<br><span class="hljs-attr">organizationalUnitName</span>  = optional<br><span class="hljs-attr">commonName</span>              = supplied<br><span class="hljs-attr">emailAddress</span>            = optional<br><br><span class="hljs-section">[ policy_loose ]</span><br><span class="hljs-comment"># Allow the intermediate CA to sign a more diverse range of certificates.</span><br><span class="hljs-comment"># See the POLICY FORMAT section of the `ca` man page.</span><br><span class="hljs-attr">countryName</span>             = optional<br><span class="hljs-attr">stateOrProvinceName</span>     = optional<br><span class="hljs-attr">localityName</span>            = optional<br><span class="hljs-attr">organizationName</span>        = optional<br><span class="hljs-attr">organizationalUnitName</span>  = optional<br><span class="hljs-attr">commonName</span>              = supplied<br><span class="hljs-attr">emailAddress</span>            = optional<br><br><span class="hljs-section">[ req ]</span><br><span class="hljs-comment"># Options for the `req` tool (`man req`).</span><br><span class="hljs-attr">default_bits</span>        = <span class="hljs-number">2048</span><br><span class="hljs-attr">distinguished_name</span>  = req_distinguished_name<br><span class="hljs-attr">string_mask</span>         = utf8only<br><br><span class="hljs-comment"># SHA-1 is deprecated, so use SHA-2 instead.</span><br><span class="hljs-attr">default_md</span>          = sha256<br><br><span class="hljs-comment"># Extension to add when the -x509 option is used.</span><br><span class="hljs-attr">x509_extensions</span>     = v3_ca<br><br><span class="hljs-attr">req_extensions</span> = v3_req<br><br><span class="hljs-section">[ req_distinguished_name ]</span><br><span class="hljs-comment"># See &lt;https://en.wikipedia.org/wiki/Certificate_signing_request&gt;.</span><br><span class="hljs-attr">countryName</span>                     = Country Name (<span class="hljs-number">2</span> letter code)<br><span class="hljs-attr">stateOrProvinceName</span>             = State or Province Name<br><span class="hljs-attr">localityName</span>                    = Locality Name<br><span class="hljs-attr">0.organizationName</span>              = Organization Name<br><span class="hljs-attr">organizationalUnitName</span>          = Organizational Unit Name<br><span class="hljs-attr">commonName</span>                      = Common Name<br><span class="hljs-attr">emailAddress</span>                    = Email Address<br><br><span class="hljs-comment"># Optionally, specify some defaults.</span><br><span class="hljs-attr">countryName_default</span>             = US<br><span class="hljs-attr">stateOrProvinceName_default</span>     = Texas<br><span class="hljs-attr">localityName_default</span>            = Fort Worth<br><span class="hljs-attr">0.organizationName_default</span>      = My Company<br><span class="hljs-comment">#organizationalUnitName_default =</span><br><span class="hljs-comment">#emailAddress_default           =</span><br><br><span class="hljs-section">[ v3_req ]</span><br><br><span class="hljs-comment"># Extensions to add to a certificate request</span><br><br><span class="hljs-attr">basicConstraints</span> = CA:<span class="hljs-literal">FALSE</span><br><span class="hljs-attr">keyUsage</span> = nonRepudiation, digitalSignature, keyEncipherment<br><span class="hljs-attr">subjectAltName</span> = @alt_names<br><br><span class="hljs-section">[ v3_ca ]</span><br><span class="hljs-comment"># Extensions for a typical CA (`man x509v3_config`).</span><br><span class="hljs-attr">subjectKeyIdentifier</span> = hash<br><span class="hljs-attr">authorityKeyIdentifier</span> = keyid:always,issuer<br><span class="hljs-attr">basicConstraints</span> = critical, CA:<span class="hljs-literal">true</span><br><span class="hljs-attr">keyUsage</span> = critical, digitalSignature, cRLSign, keyCertSign<br><br><span class="hljs-section">[ v3_intermediate_ca ]</span><br><span class="hljs-comment"># Extensions for a typical intermediate CA (`man x509v3_config`).</span><br><span class="hljs-attr">subjectKeyIdentifier</span> = hash<br><span class="hljs-attr">authorityKeyIdentifier</span> = keyid:always,issuer<br><span class="hljs-attr">basicConstraints</span> = critical, CA:<span class="hljs-literal">true</span>, pathlen:<span class="hljs-number">0</span><br><span class="hljs-attr">keyUsage</span> = critical, digitalSignature, cRLSign, keyCertSign<br><br><span class="hljs-section">[ usr_cert ]</span><br><span class="hljs-comment"># Extensions for client certificates (`man x509v3_config`).</span><br><span class="hljs-attr">basicConstraints</span> = CA:<span class="hljs-literal">FALSE</span><br><span class="hljs-attr">nsCertType</span> = client, email<br><span class="hljs-attr">nsComment</span> = <span class="hljs-string">"OpenSSL Generated Client Certificate"</span><br><span class="hljs-attr">subjectKeyIdentifier</span> = hash<br><span class="hljs-attr">authorityKeyIdentifier</span> = keyid,issuer<br><span class="hljs-attr">keyUsage</span> = critical, nonRepudiation, digitalSignature, keyEncipherment<br><span class="hljs-attr">extendedKeyUsage</span> = clientAuth, emailProtection<br><br><span class="hljs-section">[ server_cert ]</span><br><span class="hljs-comment"># Extensions for server certificates (`man x509v3_config`).</span><br><span class="hljs-attr">basicConstraints</span> = CA:<span class="hljs-literal">FALSE</span><br><span class="hljs-attr">nsCertType</span> = server<br><span class="hljs-attr">nsComment</span> = <span class="hljs-string">"OpenSSL Generated Server Certificate"</span><br><span class="hljs-attr">subjectKeyIdentifier</span> = hash<br><span class="hljs-attr">authorityKeyIdentifier</span> = keyid,issuer:always<br><span class="hljs-attr">keyUsage</span> = critical, digitalSignature, keyEncipherment<br><span class="hljs-attr">extendedKeyUsage</span> = serverAuth<br><span class="hljs-attr">subjectAltName</span> = @alt_names<br><br><span class="hljs-section">[ crl_ext ]</span><br><span class="hljs-comment"># Extension for CRLs (`man x509v3_config`).</span><br><span class="hljs-attr">authorityKeyIdentifier</span>=keyid:always<br><br><span class="hljs-section">[ ocsp ]</span><br><span class="hljs-comment"># Extension for OCSP signing certificates (`man ocsp`).</span><br><span class="hljs-attr">basicConstraints</span> = CA:<span class="hljs-literal">FALSE</span><br><span class="hljs-attr">subjectKeyIdentifier</span> = hash<br><span class="hljs-attr">authorityKeyIdentifier</span> = keyid,issuer<br><span class="hljs-attr">keyUsage</span> = critical, digitalSignature<br><span class="hljs-attr">extendedKeyUsage</span> = critical, OCSPSigning<br><br><span class="hljs-section">[alt_names]</span><br><span class="hljs-attr">DNS.1</span> = *.example.com<br><span class="hljs-attr">DNS.2</span> = test.example.net<br><span class="hljs-attr">IP.1</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">1.0</span>/<span class="hljs-number">24</span><br><span class="hljs-attr">IP.2</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">2.111</span><br></code></pre></div></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer （第五版）》学习笔记 -- 之一</title>
    <url>/2020/02/18/C++-Primer-%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1>C++ Primer 第五版学习笔记（一）</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="第一章-开始"><a class="header-anchor" href="#第一章-开始">¶</a>第一章 开始</h2>
<p>在本章中，我们将编写一个程序来解决简单的书店问题。<br>
我们的书店保存所有销售记录的档案，每条记录保存了某本书的一次销售的信息（一册或多册）。每条记录包含三个数据项：</p>
<ul>
<li>书的 ISBN 号（唯一标识）。如： 0-201-70353-X</li>
<li>售出册数。如：4</li>
<li>单价。如： 24.99</li>
</ul>
<h3 id="1-1-缩写一个简单的-C-程序"><a class="header-anchor" href="#1-1-缩写一个简单的-C-程序">¶</a>1.1 缩写一个简单的 C++ 程序</h3>
<p>每个 C++ 程序都包含一个或多个函数，其中一个必须命名为 <code>main</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在大多数系统中，<code>main</code> 的返回值被用来指示状态。返回 <code>0</code> 表明成功，<strong>非 <code>0</code> 的返回值的含义由系统定义</strong>，通常用来指出错误类型。</p>
<h4 id="1-1-1-编译、运行程序"><a class="header-anchor" href="#1-1-1-编译、运行程序">¶</a>1.1.1 编译、运行程序</h4>
<h5 id="程序源文件命名约定"><a class="header-anchor" href="#程序源文件命名约定">¶</a>程序源文件命名约定</h5>
<p>略，见 P3。</p>
<h5 id="从命令行运行编译器"><a class="header-anchor" href="#从命令行运行编译器">¶</a>从命令行运行编译器</h5>
<ul>
<li>
<p>GNU 编译器的命令是：</p>
  <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$g</span>++ -o prog1 prog1.cc<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>根据使用的 GNU 编译器版本，你可能需要指定 <code>-std=c++0x</code> 参数来打开对 C++11 的支持。</p>
</blockquote>
</li>
<li>
<p>Visual Studio 2010 编译器命令为 cl：</p>
  <figure class="highlight bat"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bat"><span class="hljs-function">C:\<span class="hljs-title">Users</span>\<span class="hljs-title">me</span>\<span class="hljs-title">Programs</span>&gt; <span class="hljs-title">cl</span> /<span class="hljs-title">EHsc</span> <span class="hljs-title">prog1.cpp</span></span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>/EHsc</code> 选项用来打开标准异常处理。</p>
</blockquote>
</li>
<li>
<p>编译器通常包含一些选项，能对有问题的程序结构发出警告。我们习惯在 GNU 编译器中使用 <code>-Wall</code> 选项，在微软编译器中则使用 <code>/W</code> 打开警告。</p>
</li>
</ul>
<h4 id="1-1-节习题"><a class="header-anchor" href="#1-1-节习题">¶</a>1.1 节习题</h4>
<ul>
<li>
<p>练习 1.1：查阅你使用的编译器的文档，确定它所使用的文件命名约定。编译并运行第 2 页的 <code>main</code> 程序。</p>
<p>解：</p>
<p><img src="images/C++Primer/practice1.1.PNG" alt="习题1.1.1"></p>
</li>
<li>
<p>练习 1.2：改写程序，让它返回 <code>-1</code>。返回 <code>-1</code> 通常被当作程序错误的标识。重新编译并运行你的程序，观察你的系统如何处理 main 返回的错误标识。</p>
<p>解：</p>
<p><img src="images/C++Primer/practice1.1.PNG" alt="习题1.1.1"></p>
</li>
</ul>
<h3 id="1-2-初识输入输出"><a class="header-anchor" href="#1-2-初识输入输出">¶</a>1.2 初识输入输出</h3>
<p><code>iostream</code> 库包含两个基础类型 <code>istream</code> 和 <code>ostream</code>，分别表示 <strong>输入流</strong> 和 <strong>输出流</strong> 。一个 <strong>流</strong> 就是一个字符序列，是从 IO 设备读出或输入 IO 设备的。</p>
<blockquote>
<p>术语“流”(stream)想要表达的是，随着时间的失衡，字符是顺序生成或消耗的。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：<code>iostream</code> 是 <strong>库</strong>，<code>istream</code> 和 <code>ostream</code> 是 <code>iostream</code> 库中的对象。若 <strong>仅</strong>  <code>#include &lt;istream&gt;</code> 或 <code>#include &lt;ostream&gt;</code> 将不会报错，但对于命名空间 <code>std</code> 的引用将会出现类似 <code>“cout”: 不是“std”的成员</code> 的错误。</p>
</blockquote>
<h4 id="标准输入输出对象"><a class="header-anchor" href="#标准输入输出对象">¶</a>标准输入输出对象</h4>
<p>标准库定义了 4 个 IO 对象：</p>
<ol>
<li><code>cin</code>： 为了处理输入，我们使用一个名为 <code>cin</code> (发音为 see-in)的 <code>istream</code> 类型的对象。这个对象也被称为 <strong>标准输入</strong> (standard input)。</li>
<li><code>cout</code>：对于输出，我们使用一个名为 <code>cout</code> (发音为 see-out)的 <code>ostream</code> 类型对象。此对象也被称为 <strong>标准输出</strong> (standard output)。</li>
<li><code>cerr</code>：我们通常用 <code>ostream</code> 对象 <code>cerr</code> (发音为 see-err) 来输出警告和错误消息，因此它也被称为 <strong>标准错误</strong> (standard error)。</li>
<li><code>clog</code>：<code>ostream</code> 对象 <code>clog</code> (发音为 see-log) 用来输出程序运行时一般性信息。</li>
</ol>
<p>系统通常将程序所运行的窗口与这些对象关联起来。因此当我们读取 <code>cin</code>，数据将从程序正在运行的窗口读入，当我们向 <code>cout</code>、<code>cerr</code> 和 <code>clog</code> 写入数据时，将会写到同一个窗口。</p>
<h4 id="一个使用-IO-库的程序"><a class="header-anchor" href="#一个使用-IO-库的程序">¶</a>一个使用 IO 库的程序</h4>
<p>在书店程序中，我们需要将多条记录合并成单一的汇总记录：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::out &lt;&lt; <span class="hljs-string">"Enter two numbers: "</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">int</span> vl = <span class="hljs-number">0</span>, v2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;<br>    <span class="hljs-built_in">std</span>::out &lt;&lt; <span class="hljs-string">"The sum of "</span> &lt;&lt; v1 &lt;&lt; <span class="hljs-string">" and "</span> &lt;&lt; v2 &lt;&lt; <span class="hljs-string">" is "</span> &lt;&lt; v1 + v2 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li><code>#include</code> 指令和头文件的名字必须写在同一行中。</li>
<li>通常情况下，<code>#include</code> 指令必须出现在所有函数之外。</li>
<li>我们一般将一个程序的所有 <code>#include</code> 指令都放在源文件的开始位置。</li>
</ul>
<h4 id="向流写入数据"><a class="header-anchor" href="#向流写入数据">¶</a>向流写入数据</h4>
<ul>
<li><code>main</code> 的函数体第一条语句执行了一个表达式 (expression)。在 C++ 中，一个表达式产生一个计算结果，它由一个或多个运算对象和(通常是)一个运算符组成。</li>
<li>第一个输出运算符给用户打印一条消息。这个消息是一个 <strong>字符串字面值常量</strong> (string literal)，是用一对双引号包围的字符序列。</li>
<li>第二个运算符打印 <code>endl</code>，这是一个被称为 <strong>操纵符</strong> (manipulator) 的特殊值。写入 <code>endl</code> 的效果是结束当前行，<strong>并将与设备关联的 <em>缓冲区</em> (buffer) 中的内容刷到设备中</strong>。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：程序员常常在调度时添加打印语句。这类语句应该保证“一直”刷新流。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。</p>
</blockquote>
<h4 id="使用标准库中的名字"><a class="header-anchor" href="#使用标准库中的名字">¶</a>使用标准库中的名字</h4>
<p>前缀 <code>std::</code> 指出名字 <code>cout</code> 和 <code>endl</code> 是定义在名为 <code>std</code> 的 <strong>命名空间</strong> (namespace)中的。</p>
<p>命名空间可以：</p>
<ul>
<li>帮助我们避免不经意的名字定义冲突。</li>
<li>使用库中相同名字导致的冲突。</li>
</ul>
<blockquote>
<p>标准库定义的所有名字都在命名空间 <code>std</code> 中。</p>
</blockquote>
<h4 id="从流读取数据"><a class="header-anchor" href="#从流读取数据">¶</a>从流读取数据</h4>
<p>略，见 P7。</p>
<h4 id="完成程序"><a class="header-anchor" href="#完成程序">¶</a>完成程序</h4>
<p>略，见 P7。</p>
<h4 id="1-2-节练习"><a class="header-anchor" href="#1-2-节练习">¶</a>1.2 节练习</h4>
<ul>
<li>
<p>练习 1.3：编写程序，在标准输出上打印 Hello, World</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hellow, World"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><img src="images/C++Primer/practice1.3.PNG" alt="习题1.1.1"></p>
</li>
<li>
<p>练习 1.4：我们的程序使用加法运算符 <code>+</code> 来将两个数相加。编写程序使用乘法运算符 <code>*</code>，来打印两个数的积。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> v1 = <span class="hljs-number">1</span>, v2 = <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1 + v2 = "</span> &lt;&lt; v1 + v2 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v1 * v2 = "</span> &lt;&lt; v1 * v2 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><img src="images/C++Primer/practice1.4.PNG" alt="习题1.1.1"></p>
</li>
<li>
<p>练习 1.5：我们将所有输出操作放在一条很长的语句中。重写程序，将每个运算对象的打印操作放在一条独立的语句中。</p>
<p>解：见习题 1.4。</p>
</li>
<li>
<p>练习 1.6：解释下面程序片段是否合法。</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The sum of "</span> &lt;&lt; v1;<br>          &lt;&lt; <span class="hljs-string">" and "</span> &lt;&lt; v2;<br>          &lt;&lt; <span class="hljs-string">" is "</span> &lt;&lt; v1 + v2 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure>
<p>解：不合法。因为：</p>
<ul>
<li>根据 P3：<em>大多数 C++ 语句表示结束。</em> 所以片段第一行语句已结束，第二行和第三行都已是新语句。</li>
<li>又根据 P6：<em><code>&lt;&lt;</code> 运算符接受两个运算对象：左侧是运算对象必须是一个 <code>ostream</code> 对象，右侧对象是要打印的值。</em> 所以第二、三行缺少 <code>ostream</code> 对象。</li>
</ul>
<p>修正：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The sum of "</span> &lt;&lt; v1<br>          &lt;&lt; <span class="hljs-string">" and "</span> &lt;&lt; v2<br>          &lt;&lt; <span class="hljs-string">" is "</span> &lt;&lt; v1 + v2 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure>
<p>或</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The sum of "</span> &lt;&lt; v1;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" and "</span> &lt;&lt; v2;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" is "</span> &lt;&lt; v1 + v2 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="1-3-注释简介"><a class="header-anchor" href="#1-3-注释简介">¶</a>1.3 注释简介</h3>
<h4 id="C-中注释的种类"><a class="header-anchor" href="#C-中注释的种类">¶</a>C++ 中注释的种类</h4>
<p>略，见 P8。</p>
<h4 id="注释界定符不能嵌套"><a class="header-anchor" href="#注释界定符不能嵌套">¶</a>注释界定符不能嵌套</h4>
<p>界定符对形式的注释是以 <code>/*</code> 开始，以 <code>*/</code> 结束的。因此，一个注释不能嵌套在另一个注释之内。例如，在你的系统中编译如下程序，就会产生错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 注释对 /* */</span> 不能嵌套。<br> * “不能嵌套” 几个字会被认为是源码，<br> * 像剩余程序一样处理<br> *<br> */<br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></div></td></tr></table></figure>
<p>我们通常需要在调度期间注释掉一些代码。由于这些代码可能包含界定符形式的注释，因此可能导致注释嵌套错误，因此最好的方式是用 <strong>单行注释</strong> 方式注释掉代码段的每一行：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// /*</span><br><span class="hljs-comment">//  * 单行注释中的任何内容都会被忽略</span><br><span class="hljs-comment">//  * 包括嵌套的注释对也一样会被忽略</span><br><span class="hljs-comment">//  */</span><br></code></pre></div></td></tr></table></figure>
<h4 id="1-3-节练习"><a class="header-anchor" href="#1-3-节练习">¶</a>1.3 节练习</h4>
<ul>
<li>
<p>练习 1.7：编译一个包含不正确的嵌套注释的程序，观察编译器返回的错误信息。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 注释对 /* */</span> 不能嵌套。<br> * “不能嵌套” 几个字会被认为是源码，<br> * 像剩余程序一样处理<br> *<br> */<br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></div></td></tr></table></figure>
<p><img src="images/C++Primer/practice1.7.PNG" alt="习题1.1.1"></p>
</li>
<li>
<p>练习 1.8：指出下列哪些输出语句是合法的（如果有的话）：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"/*"</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"*/"</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-comment">/* "*/</span><span class="hljs-string">" */;</span><br><span class="hljs-string">std::cout &lt;&lt; /* "</span>*/<span class="hljs-string">" /* "</span><span class="hljs-comment">/*" */</span>;<br></code></pre></div></td></tr></table></figure>
<p>预测编译这些语句会产生什么样的结果，实际编译这些语句来验证你的答案（编写一个小程序，每次将上述一条语句作为其主体），改正每个编译错误。</p>
<p>解：</p>
<p>预测：语句一、二和语句四编译通过，语句三编译错误。</p>
<p>验证：</p>
<ol>
<li>
<p>语句一：</p>
 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"/*"</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
 <figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">&#x2F;*<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>语句二：</p>
 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"*/"</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
 <figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams"><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>语句三：</p>
 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-comment">/* "*/</span><span class="hljs-string">" */;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
 <figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.24.28316 版<br>版权所有(C) Microsoft Corporation。保留所有权利。<br><br>prog1.<span class="hljs-keyword">cc</span><br>.\prog1.<span class="hljs-keyword">cc</span>(4): <span class="hljs-keyword">error</span> C2001: 常量中有换行符<br>.\prog1.<span class="hljs-keyword">cc</span>(5): <span class="hljs-keyword">error</span> C2143: 语法错误: 缺少“;”(在“<span class="hljs-keyword">return</span>”的前面)<br></code></pre></div></td></tr></table></figure>
<p>改正：</p>
 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"*/"</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
 <figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams"><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>语句四：</p>
 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-comment">/* "*/</span><span class="hljs-string">" /* "</span><span class="hljs-comment">/*" */</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
 <figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">&#x2F;*<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="1-4-控制流"><a class="header-anchor" href="#1-4-控制流">¶</a>1.4 控制流</h3>
<h4 id="1-4-1-while-语句"><a class="header-anchor" href="#1-4-1-while-语句">¶</a>1.4.1 <code>while</code> 语句</h4>
<p>略，见 P10~P11。</p>
<h5 id="1-4-1-节练习"><a class="header-anchor" href="#1-4-1-节练习">¶</a>1.4.1 节练习</h5>
<ul>
<li>
<p>练习 1.9：编写程序，使用 <code>while</code> 循环将 <code>50</code> 到 <code>100</code> 的整数相加。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> v = <span class="hljs-number">49</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(v &lt; <span class="hljs-number">100</span>) &#123;<br>        sum += (++v);<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The sum of 50 ~ 100 is "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">The sum of <span class="hljs-number">50</span> ~ <span class="hljs-number">100</span> <span class="hljs-keyword">is</span> <span class="hljs-number">3825</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 1.10：除了 <code>++</code> 运算符将运算对象增加 <code>1</code> 之外，还有一个递减运算符 (<code>--</code>) 实现将值减少 <code>1</code>。编写程序，使用递减运算符在循环中顺序打印 <code>10</code> 到 <code>0</code> 之间的整数。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> v = <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">while</span>(v &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; --v &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">10</span><br><span class="hljs-number">9</span><br><span class="hljs-number">8</span><br><span class="hljs-number">7</span><br><span class="hljs-number">6</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 1.11：编写程序，提示用户输入两个整数，打印出这两个整数所指定的范围内的所有整数。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> v_start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> v_end = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Please enter start number: "</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; v_start;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Please enter end number: "</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; v_end;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">"The integers between "</span><br>              &lt;&lt; v_start &lt;&lt; <span class="hljs-string">" and "</span> &lt;&lt; v_end &lt;&lt; <span class="hljs-string">" are: "</span>;<br>    <br>    <span class="hljs-keyword">while</span>(v_end &gt;= v_start) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; v_start &lt;&lt; <span class="hljs-string">" "</span>;<br>        ++v_start;<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">Please enter start number: <span class="hljs-number">1</span><br><br>Please enter end number: <span class="hljs-number">5</span><br><br>The <span class="hljs-built_in">int</span>egers between <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5</span> are: <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="1-4-2-for-语句"><a class="header-anchor" href="#1-4-2-for-语句">¶</a>1.4.2 <code>for</code> 语句</h4>
<p>用 <code>for</code> 语句重写从 <code>1</code> 加到 <code>10</code> 的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 从 1 加到 10</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> val = <span class="hljs-number">1</span>; val &lt;= <span class="hljs-number">10</span>; ++val)<br>        sum += val; <span class="hljs-comment">// 等价于 sum = sum + val</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Sum of 1 to 10 inclusive is "</span><br>              &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>简要重述一下 <code>for</code> 循环的总体执行流程：</p>
<ol>
<li>创建变量 <code>val</code>，将其初始化为 <code>1</code>。</li>
<li>检测 <code>val</code> 是否小于等于 <code>10</code>。若检测成功，执行 <code>for</code> 循环体。若失败，退出循环，继续执行<code>for</code> 循环体之后的第一条语句。</li>
<li>将 <code>val</code> 的值增加 <code>1</code>。</li>
<li>重复第 2 步中的条件检测，只要条件为真就继续执行剩余步骤。</li>
</ol>
<h5 id="1-4-2-节练习"><a class="header-anchor" href="#1-4-2-节练习">¶</a>1.4.2 节练习</h5>
<ul>
<li>
<p>练习 1.12：下面的 <code>for</code> 循环完成了什么功能？<code>sum</code> 的终值是多少？</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">-100</span>; i &lt;= <span class="hljs-number">100</span>; ++i)<br>    sum += <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure>
<p>解：</p>
<p>完成了从 <code>0</code> 到 <code>201</code> 之间的整数遍历。<code>sum</code> 的终值为 <code>201</code>。</p>
</li>
<li>
<p>练习 1.13：使用 <code>for</code> 循环重做 1.4.1 节中的所有练习(第 11 页)。</p>
<p>解：</p>
<ol>
<li></li>
</ol>
<div class="hljs code-wrapper"><pre><code>  <figure class="highlight c++"><table><tr><td class="gutter hljs"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">50</span>; i &lt; <span class="hljs-number">101</span>; ++i) &#123;<br>        sum += i;<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"The sum of 50 ~ 100 is "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</code></pre>
<ol start="2">
<li></li>
</ol>
<div class="hljs code-wrapper"><pre><code>  <figure class="highlight c++"><table><tr><td class="gutter hljs"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v = <span class="hljs-number">10</span>; v &gt;= <span class="hljs-number">0</span>; --v)<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</code></pre>
<ol start="3">
<li></li>
</ol>
<div class="hljs code-wrapper"><pre><code>  <figure class="highlight c++"><table><tr><td class="gutter hljs"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> v_start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> v_end = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Please enter start number: "</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; v_start;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Please enter end number: "</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; v_end;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-string">"The integers between "</span><br>              &lt;&lt; v_start &lt;&lt; <span class="hljs-string">" and "</span> &lt;&lt; v_end &lt;&lt; <span class="hljs-string">" are: "</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = v_start; i &lt;= v_end; i++)<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>;<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</code></pre>
</li>
<li>
<p>练习 1.14：对比 <code>for</code> 循环 <code>while</code> 循环，两种形式的优缺点各是什么？</p>
<p>解：</p>
<p>在 <code>for</code> 循环中，循环控制变量的初始化和修改都放在语句头部分，形式较简洁，且特别适用于循环次数已知的情况。在 <code>while</code> 循环中，循环控制变量的初始化一般放在 <code>while</code> 语句之前，循环控制变量的修改一般放在循环体中，形式上不如 <code>for</code> 语句简洁，但它比较适用于循环次数不易预知的情况（用某一条件控制循环）。两种形式各有优点，但它们在功能上是等价的，可以相互转换。</p>
</li>
<li>
<p>练习 1.15：编写程序，包含第 14 页“再探编译”中讨论的常见错误。熟悉编译器生成的错误信息。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      .\prog1.cc(4): error C2143: 语法错误: 缺少“;”(在“:”的前面)</span><br><span class="hljs-comment">      .\prog1.cc(4): error C2059: 语法错误:“:”</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Read each file."</span> &lt;&lt; <span class="hljs-built_in">endl</span>:<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     .\prog1.cc(4): error C2065: “Update”: 未声明的标识符</span><br><span class="hljs-comment">     .\prog1.cc(4): error C2146: 语法错误: 缺少“;”(在标识符“master”的前面)</span><br><span class="hljs-comment">     .\prog1.cc(4): error C2065: “master”: 未声明的标识符</span><br><span class="hljs-comment">     .\prog1.cc(4): error C2059: 语法错误:“&lt;&lt;”</span><br><span class="hljs-comment">     .\prog1.cc(4): error C2228: “.endl”的左边必须有类/结构/联合</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; Update master. &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     .\prog1.cc(4): error C2143: 语法错误: 缺少“;”(在“std::endl”的前面)</span><br><span class="hljs-comment">     .\prog1.cc(4): error C2143: 语法错误: 缺少“;”(在“:”的前面)</span><br><span class="hljs-comment">     .\prog1.cc(4): warning C4551: 缺少参数列表的函数调用</span><br><span class="hljs-comment">     .\prog1.cc(4): error C2059: 语法错误:“:”</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Write new master."</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>:<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     .\prog1.cc(4): error C2440: “初始化”: 无法从“const char [6]”转换为“int”</span><br><span class="hljs-comment">     .\prog1.cc(4): note: 没有使该转换得以执行的上下文</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">int</span> v0 = <span class="hljs-string">"hello"</span>;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     .\prog1.cc(5): error C2065: “v”: 未声明的标识符</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">int</span> v1 = <span class="hljs-number">0</span>, v2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; v &gt;&gt; v2;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     .\prog1.cc(5): error C2065: “cout”: 未声明的标识符</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; v1 + v2 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="1-4-3-读取数量不定的输入数据"><a class="header-anchor" href="#1-4-3-读取数量不定的输入数据">¶</a>1.4.3 读取数量不定的输入数据</h4>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, value = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; value)<br>        sum += value; <span class="hljs-comment">// 等价于 sum = sum + value</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Sum is: "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输入：</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">Sum <span class="hljs-keyword">is</span>: <span class="hljs-number">18</span><br></code></pre></div></td></tr></table></figure>
<p><strong>当我们使用一个 <code>istream</code> 对象作为条件时，其效果是检测流的状态。如果是流是有效的，即流未遇到错误，那么检测成功。当遇到 <em>文件结束符</em>(end-of-file)，或遇到一个无效输入时 (例如读入的值不是一个整数)，<code>istream</code> 对象的状态会变为无效。处于无效状态的 <code>istream</code> 对象会使条件变为假。</strong></p>
<h5 id="1-4-3-节练习"><a class="header-anchor" href="#1-4-3-节练习">¶</a>1.4.3 节练习</h5>
<ul>
<li>
<p>练习 1.16：编写程序，从 <code>cin</code> 读取一组数，输出其和。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; sum)<br>        result += sum;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输入：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br>^C<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="1-4-4-if-语句"><a class="header-anchor" href="#1-4-4-if-语句">¶</a>1.4.4 <code>if</code> 语句</h4>
<p>略，见 P15~P16。</p>
<h5 id="1-4-4-节练习"><a class="header-anchor" href="#1-4-4-节练习">¶</a>1.4.4 节练习</h5>
<ul>
<li>
<p>练习 1.17：如果输入的所有值都是相等的，本节的程序会输出什么？如果没有重复值，输出又会是怎样的？</p>
<p>解：</p>
<p>输入：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">42</span> <span class="hljs-number">42</span> <span class="hljs-number">42</span> <span class="hljs-number">42</span> <span class="hljs-number">42</span> <span class="hljs-number">42</span> <span class="hljs-number">42</span> <span class="hljs-number">42</span> <span class="hljs-number">42</span> <span class="hljs-number">42</span> <span class="hljs-number">42</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">42 </span>occurs <span class="hljs-number">11</span> times<br></code></pre></div></td></tr></table></figure>
<p>输入：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">42</span> <span class="hljs-number">43</span> <span class="hljs-number">44</span> <span class="hljs-number">45</span> <span class="hljs-number">46</span> <span class="hljs-number">47</span> <span class="hljs-number">48</span> <span class="hljs-number">49</span> <span class="hljs-number">50</span> <span class="hljs-number">51</span> <span class="hljs-number">52</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">42 </span>occurs <span class="hljs-number">1</span> times<br><span class="hljs-symbol">43 </span>occurs <span class="hljs-number">1</span> times<br><span class="hljs-symbol">44 </span>occurs <span class="hljs-number">1</span> times<br><span class="hljs-symbol">45 </span>occurs <span class="hljs-number">1</span> times<br><span class="hljs-symbol">46 </span>occurs <span class="hljs-number">1</span> times<br><span class="hljs-symbol">47 </span>occurs <span class="hljs-number">1</span> times<br><span class="hljs-symbol">48 </span>occurs <span class="hljs-number">1</span> times<br><span class="hljs-symbol">49 </span>occurs <span class="hljs-number">1</span> times<br><span class="hljs-symbol">50 </span>occurs <span class="hljs-number">1</span> times<br><span class="hljs-symbol">51 </span>occurs <span class="hljs-number">1</span> times<br><span class="hljs-symbol">52 </span>occurs <span class="hljs-number">1</span> times<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 1.18：编译并运行本节的程序，给它输入全都相等的值。再次运行程序，输入没有重复的值。</p>
<p>解：</p>
<p>见练习 1.17。</p>
</li>
<li>
<p>练习 1.19：修改你为 1.4.1 节练习 1.10 (第11页) 所编写的程序 (打印一个范围内的数)，使其能处理用户输入的第一个数比第二个数小的情况。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>, second = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Please enter two numbers:"</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; first &gt;&gt; second;<br>    <br>    <span class="hljs-keyword">if</span>(first &lt; second) &#123;<br>        tmp = first;<br>        first = second;<br>        second = tmp;<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">while</span>(first &gt; second) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; --v &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输入：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">Please enter two numbers:<span class="hljs-number">10</span> <span class="hljs-number">22</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">22</span><br><span class="hljs-number">21</span><br><span class="hljs-number">20</span><br><span class="hljs-number">19</span><br><span class="hljs-number">18</span><br><span class="hljs-number">17</span><br><span class="hljs-number">16</span><br><span class="hljs-number">15</span><br><span class="hljs-number">14</span><br><span class="hljs-number">13</span><br><span class="hljs-number">12</span><br><span class="hljs-number">11</span><br><span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="1-5-类简介"><a class="header-anchor" href="#1-5-类简介">¶</a>1.5 类简介</h3>
<p>C++ 最初的一个设计焦点就是能定义使用上像内置类型一样自然的 <strong>类类型</strong> (class type)。</p>
<p>对于书店程序来说，我们假定类名为 <code>Sales_item</code>，头文件 <em>Sales_item.h</em> 中已经定义了这个类。</p>
<p><strong>为了使用标准库设施，我们必须包含相关的头文件。习惯上，头文件根据其中定义的类的名字来命名。</strong></p>
<p><strong>我们通常使用 <em>.h</em> 作为头文件的后缀，但也有一些程序员习惯 <em>.H</em> 、 <em>.hpp</em> 或 <em>.hxx</em> 。标准库头文件通常不带后缀。</strong></p>
<h4 id="1-5-1-Sales-item-类"><a class="header-anchor" href="#1-5-1-Sales-item-类">¶</a>1.5.1 <code>Sales_item</code> 类</h4>
<p>定义类类型的变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">Sales_item item;<br></code></pre></div></td></tr></table></figure>
<p>除了可以定义 <code>Sales_item</code> 类型的变量之外，我们还可以：</p>
<ul>
<li>调用一个名为 <code>isbn</code> 的函数从一个 <code>Sales_item</code> 对象中提取 ISBN 书号。</li>
<li>用输入运算符 (<code>&gt;&gt;</code>) 和输出运算符 (<code>&lt;&lt;</code>) 读、写 <code>Sales_item</code> 类型对象。</li>
<li>用赋值运算符 (<code>=</code>) 将一个 <code>Sales_item</code> 对旬的值赋予另一个 <code>Sales_item</code> 对象。</li>
<li>用加法运算符 (<code>+</code>) 将两个 <code>Sales_item</code> 对象相加。两个对象必须表示同一本书 (相同的 ISBN)。加法结果是一个新的 <code>Sales_item</code> 对象，基 ISBN 与两个运算对象相同，而其总销售额和售出册数则是两个运算对象的对应值之和。</li>
<li>使用复合赋值运算符 (<code>+=</code>) 将一个 <code>Sales_item</code> 对象加到另一个对象上。</li>
</ul>
<h5 id="读写-Sales-item"><a class="header-anchor" href="#读写-Sales-item">¶</a>读写 <code>Sales_item</code></h5>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Sales_item.h"</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Sales_item book;<br>    <span class="hljs-comment">// 读入 ISBN 号、售出的册数以及销售价格</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; book;<br>    <span class="hljs-comment">// 写入 ISBN、售出的册数、总销售额和平均价格</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; book &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输入：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-70353</span>-X <span class="hljs-number">4</span> <span class="hljs-number">24.99</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-70353</span>-X <span class="hljs-number">4</span> <span class="hljs-number">99.96</span> <span class="hljs-number">24.99</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>此程序以两个 <code>#include</code> 指令开始，其中一个使用了新的形式。包含来自标准库的头文件，也应该用尖括号 (<code>&lt;</code> <code>&gt;</code>) 包围头文件名。对于不属于标准库的头文件，则用双引号 (<code>&quot;</code> <code>&quot;</code>) 包围。</p>
</blockquote>
<h5 id="Sales-item-对象的加法"><a class="header-anchor" href="#Sales-item-对象的加法">¶</a><code>Sales_item</code> 对象的加法</h5>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Sales_item.h"</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Sales_item item1, item2;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2;               <span class="hljs-comment">// 读取一对交易记录</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; item1 + item2 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 打印它们的和</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输入：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">3</span> <span class="hljs-number">20.00</span><br><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">2</span> <span class="hljs-number">25.00</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">5</span> <span class="hljs-number">110</span> <span class="hljs-number">22</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>使用文件重定向</strong></p>
<hr>
<p>当你测试程序时，反复从键盘调入这些销售记录作为程序输入，是非常乏味的（<strong>笔记</strong>：用文件作为输入可以避免终端输入的数据和输出的数据混杂在一起引起混淆。）。这种机制允许我们将标准输入和标准输出与命名文件关联起来：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ addItems &lt;infile &gt;outfile<br></code></pre></div></td></tr></table></figure>
<p>假定 <code>$</code> 是操作系统提示符，我们的加法程序已经编译命名为  <em>addItems.exe</em> 的可执行文件 (在 Unix 中是 <em>addItems</em> )，则上述命令会从一个名为 <em>infile</em> 的文件读取销售记录，并将输出结果写入到一个名为 <em>output</em> 的文件中，两个文件都位于当前目录中。</p>
</blockquote>
<h5 id="1-5-1-节练习"><a class="header-anchor" href="#1-5-1-节练习">¶</a>1.5.1 节练习</h5>
<ul>
<li>
<p>练习 1.20：在网站 <a href="http://www.informit.com/title/0321714113" target="_blank" rel="noopener">http://www.informit.com/title/0321714113</a> 上，第 1 章的代码目录中包含了头文件 <em>Sales_item.h</em> 。将它拷贝到你自己的工作目录中。用它编写一个程序，读取一组书籍销售记录，将每条记录打印到标准输出上。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Sales_item.h"</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Sales_item book;<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; book) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; book &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输入：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">3</span> <span class="hljs-number">20.00</span> <span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">2</span> <span class="hljs-number">20.00</span> <span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">5</span> <span class="hljs-number">20.00</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">3</span> <span class="hljs-number">60</span> <span class="hljs-number">20</span><br><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">2</span> <span class="hljs-number">40</span> <span class="hljs-number">20</span><br><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">5</span> <span class="hljs-number">100</span> <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 1.21：编写程序，读取两个 ISBN 相同的 <code>Sales_item</code> 对象，输出它们的和。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Sales_item.h"</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Sales_item item1, item2;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Please enter two Sales_item:"</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; item1 + item2 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输入：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">Please enter two Sales_item:<span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">3</span> <span class="hljs-number">20.00</span> <span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">2</span> <span class="hljs-number">25.00</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">5</span> <span class="hljs-number">110</span> <span class="hljs-number">22</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 1.22：编写程序，读取多个具有相同 ISBN 的销售记录，输出所有记录的和。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Sales_item.h"</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Sales_item book, sum;<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; book)<br>        sum += book;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输入：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">3</span> <span class="hljs-number">20.00</span><br><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">2</span> <span class="hljs-number">20.00</span><br><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">5</span> <span class="hljs-number">20.00</span><br>^Z<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">200</span> <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="1-5-2-初识成员函数"><a class="header-anchor" href="#1-5-2-初识成员函数">¶</a>1.5.2 初识成员函数</h4>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Sales_item.h"</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Sales_item item1, item2;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2;<br>    <span class="hljs-comment">// 首先检查 item1 和 item2 是否表示相同的书</span><br>    <span class="hljs-keyword">if</span>(item1.isbn() == item2.isbn()) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; item1 + item2 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0l</span>;                <span class="hljs-comment">// 表示成功</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Data must refer to same ISBN"</span><br>                  &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;   <span class="hljs-comment">// 表示失败</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h5 id="什么是成员函数"><a class="header-anchor" href="#什么是成员函数">¶</a>什么是成员函数</h5>
<p>当用 <code>.</code> 运算符访问一个成员函数时，通常我们是想 (效果也确实是) 调用该函数。我们使用 <strong>调用运算符</strong> (<code>(</code> <code>)</code>) 来调用一个函数。调用运算符是一对圆括号，里面放置 <strong>实参</strong> (argument) 列表 (<strong>可能为空</strong>)。</p>
<h5 id="1-5-2-节练习"><a class="header-anchor" href="#1-5-2-节练习">¶</a>1.5.2 节练习</h5>
<ul>
<li>
<p>练习 1.23：编写程序，读取多条销售记录，并统计每个 ISBN (每本书) 有几条销售记录。</p>
<p>解：</p>
<blockquote>
<p>提示：使用文件重定向。</p>
</blockquote>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Sales_item.h"</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Sales_item currItem, item;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; currItem) &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; item) &#123;<br>            <span class="hljs-keyword">if</span>(item.isbn() == currItem.isbn())<br>                currItem += item;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Sale amount of "</span> &lt;&lt; currItem.isbn() &lt;&lt; <span class="hljs-string">" is:"</span> &lt;&lt; currItem &lt;&lt; <span class="hljs-built_in">endl</span>;<br>                currItem = item;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Sale amount of "</span> &lt;&lt; currItem.isbn() &lt;&lt; <span class="hljs-string">" is:"</span> &lt;&lt; currItem &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输入：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">4</span> <span class="hljs-number">25.0</span><br><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">1</span> <span class="hljs-number">25.0</span><br><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">2</span> <span class="hljs-number">25.0</span><br><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">9</span> <span class="hljs-number">25.0</span><br><span class="hljs-number">0</span><span class="hljs-number">-207</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">9</span> <span class="hljs-number">31.0</span><br><span class="hljs-number">0</span><span class="hljs-number">-207</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">3</span> <span class="hljs-number">31.0</span><br><span class="hljs-number">0</span><span class="hljs-number">-202</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">3</span> <span class="hljs-number">20.0</span><br><span class="hljs-number">0</span><span class="hljs-number">-202</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">3</span> <span class="hljs-number">20.0</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">Sale amount of <span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-keyword">is</span>:<span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">16</span> <span class="hljs-number">400</span> <span class="hljs-number">25</span><br>Sale amount of <span class="hljs-number">0</span><span class="hljs-number">-207</span><span class="hljs-number">-78345</span>-X <span class="hljs-keyword">is</span>:<span class="hljs-number">0</span><span class="hljs-number">-207</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">12</span> <span class="hljs-number">372</span> <span class="hljs-number">31</span><br>Sale amount of <span class="hljs-number">0</span><span class="hljs-number">-202</span><span class="hljs-number">-78345</span>-X <span class="hljs-keyword">is</span>:<span class="hljs-number">0</span><span class="hljs-number">-202</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">6</span> <span class="hljs-number">120</span> <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 1.24：输入表示多个 ISBN 的多条销售记录来测试上一个程序，每个 ISBN 的记录应该聚在一起。</p>
<p>解：</p>
<p>见练习 1.23。</p>
</li>
</ul>
<h3 id="1-6-书店程序"><a class="header-anchor" href="#1-6-书店程序">¶</a>1.6 书店程序</h3>
<p>我们的程序会将每个 ISBN 的所有数据合并起来，存入名为 <code>total</code> 变量中。我们使用另一个名为 <code>trans</code> 的变量保存读取的每条销售记录。如果 <code>trans</code> 和 <code>total</code> 指向相同的 ISBN，我们会更新 <code>total</code> 的值。否则，我们会打印 <code>total</code> 的值，并将其重置为刚读取的数据 (<code>tran</code>)：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Sales_item.h"</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Sales_item total;  <span class="hljs-comment">// 保存下一条交易记录的变量</span><br>    <span class="hljs-comment">// 读入第一条交易记录，并确保有数据可以处理</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; total) &#123;<br>        Sales_item trans;  <span class="hljs-comment">// 保存和的变量</span><br>        <span class="hljs-comment">// 读入并处理剩余交易记录</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; trans) &#123;<br>            <span class="hljs-comment">// 如果我们仍在处理相同的书</span><br>            <span class="hljs-keyword">if</span>(total.isbn() == trans.isbn())<br>                total += trans;  <span class="hljs-comment">//更新总销售额</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 打印前一本书的结果</span><br>                <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>                total = trans;  <span class="hljs-comment">// total 现在表示下一本书的销售额</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 没有输入！警告读者</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"No data?!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="1-6-节练习"><a class="header-anchor" href="#1-6-节练习">¶</a>1.6 节练习</h4>
<ul>
<li>
<p>练习 1.25：借助网站上的 <em>Sales_item.h</em> 头文件，编译并运行本节给出的书店程序。</p>
<p>解：</p>
<p>输入：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">4</span> <span class="hljs-number">25.0</span><br><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">1</span> <span class="hljs-number">25.0</span><br><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">2</span> <span class="hljs-number">25.0</span><br><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">9</span> <span class="hljs-number">25.0</span><br><span class="hljs-number">0</span><span class="hljs-number">-207</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">9</span> <span class="hljs-number">31.0</span><br><span class="hljs-number">0</span><span class="hljs-number">-207</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">3</span> <span class="hljs-number">31.0</span><br><span class="hljs-number">0</span><span class="hljs-number">-202</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">3</span> <span class="hljs-number">20.0</span><br><span class="hljs-number">0</span><span class="hljs-number">-202</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">3</span> <span class="hljs-number">20.0</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">0</span><span class="hljs-number">-201</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">16</span> <span class="hljs-number">400</span> <span class="hljs-number">25</span><br><span class="hljs-number">0</span><span class="hljs-number">-207</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">12</span> <span class="hljs-number">372</span> <span class="hljs-number">31</span><br><span class="hljs-number">0</span><span class="hljs-number">-202</span><span class="hljs-number">-78345</span>-X <span class="hljs-number">6</span> <span class="hljs-number">120</span> <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer （第五版）》学习笔记 -- 之二</title>
    <url>/2020/02/18/C++-Primer-%E7%AC%AC%E4%BA%94%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1>C++ Primer 第五版学习笔记（二）</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="第二章-变量和基本类型"><a class="header-anchor" href="#第二章-变量和基本类型">¶</a>第二章 变量和基本类型</h2>
<p>C++ 语言支持广泛的数据类型。它定义了几种 <strong>基本内置类型</strong>  (如字符、整型、浮点数等)，同时也为程序员提供了自定义数据类型的机制。基于此，<strong>C++ 标准库定义了一些更加复杂的数据类型</strong> ，比如可变长字符串和向量等。本章将主要讲述内置类型，并带领大家初步了解 C++ 语言是如何支持更复杂的数据类型。</p>
<h3 id="2-1-基本内置类型"><a class="header-anchor" href="#2-1-基本内置类型">¶</a>2.1 基本内置类型</h3>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">                          +--字符（<span class="hljs-keyword">char</span>, <span class="hljs-keyword">wchar_t</span>, <span class="hljs-keyword">char16_t</span>, <span class="hljs-keyword">char32_t</span>）<br>                          |<br>                          +--整型（<span class="hljs-keyword">int</span>, <span class="hljs-keyword">long</span>, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>）<br>                          |<br>               +--算术类型 -+-布尔值<br>               |          |<br>C++ 基本内置类型 +          +--浮点（<span class="hljs-keyword">float</span>, <span class="hljs-keyword">double</span>, <span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>）<br>               |<br>               +--空类型<br></code></pre></div></td></tr></table></figure>
<ul>
<li><strong>一个 <code>int</code> 至少和一个 <code>short</code> 一样大</strong>；</li>
<li><strong>一个 <code>long</code> 到少和一个 <code>int</code> 一样大</strong>；</li>
<li><strong>一个 <code>long long</code> 至少和一个 <code>long</code> 一样大</strong>；</li>
</ul>
<blockquote>
<p><strong>C++11</strong></p>
<hr>
<p><code>long long</code> 是 C++11 中新定义。</p>
</blockquote>
<h4 id="2-1-1-算术类型"><a class="header-anchor" href="#2-1-1-算术类型">¶</a>2.1.1 算术类型</h4>
<p>算术类型分为：</p>
<ul>
<li>整型 (integer type，<strong>包括字符和布尔类型在内</strong>)</li>
<li>浮点型</li>
</ul>
<p><strong>内置类型的机器实现</strong>：</p>
<ul>
<li>
<p>计算机以比特序列存储数据，每个比特非 <code>0</code> 即 <code>1</code>。</p>
</li>
<li>
<p>可寻址的最小内存块称为“字节(byte)”，存储的基本单元称为“字(word)”，它通常由几个字节组成。</p>
</li>
<li>
<p>若一机器字节为 8 比特、字为 32 比特，假如某一内存区域如下所示：</p>
  <table style="border: 0">
      <tr>
          <td style="border: 0">736424</td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
          <td>1</td>
          <td>1</td>
          <td>0</td>
          <td>1</td>
          <td>1</td>
      </tr>
      <tr>
          <td style="border: 0">736425</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
          <td>1</td>
          <td>0</td>
          <td>1</td>
          <td>1</td>
      </tr>
      <tr>
          <td style="border: 0">736426</td>
          <td>0</td>
          <td>1</td>
          <td>1</td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
      </tr>
      <tr>
          <td style="border: 0">736427</td>
          <td>0</td>
          <td>1</td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
      </tr>
  </table>
<p>如果位置 736424 的对象类型是 <code>float</code>，并且该机器中 <code>float</code> 以 32 比特存储，那么这个对象内容占满了整个字。<strong>这个 <code>float</code> 的实际值依赖于该机器是如何存储浮点数的</strong>；若此处的对象是 <code>unsigned char</code>，并且该机器使用 ISO-Latin-1 字符集，则该位置处的字节表示一个分号。</p>
</li>
<li>
<p>若一机器字节为 8 比特、字为 32 比特，则通常 <code>float</code> 以 1 个字 (32 比特) 来表示，<code>double</code> 以 2 个字 (64 比特) 来表示， <code>long double</code> 以 3 或4 个字 (96 或 128 比特) 来表示。<strong>一般来说，类型 <code>float</code> 和 <code>double</code> 分别有 7 和 16 个有效位；类型 <code>long double</code> 则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同</strong>。</p>
</li>
</ul>
<h5 id="带符号类型和无符号类型"><a class="header-anchor" href="#带符号类型和无符号类型">¶</a>带符号类型和无符号类型</h5>
<ul>
<li>
<p>类型 <code>int</code>、<code>short</code>、<code>long</code> 和 <code>long long</code> 都是带符号的，通过在这些类型名前添加 <code>unsigned</code> 就可以得到无符号类型。</p>
</li>
<li>
<p>字符型被分为了 <strong>三种</strong>：</p>
<ol>
<li><code>char</code></li>
<li><code>signed char</code></li>
<li><code>unsigned char</code></li>
</ol>
<p><strong>类型 <code>char</code> 实际上会表现为无符号的和有符号的形式中的某一种，具体是哪种由编译器决定。</strong></p>
</li>
<li>
<p>无符号类型中所有比特都用来存储值，例如：8 比特的 <code>unsigned char</code> 可以表示 0 ~ 255 区间内的值。</p>
</li>
<li>
<p>C++ 标准并未规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。<strong>因此，8 比特的 <code>unsigned char</code> 理论上应该可以表示 -127 ~ 127 区间内的值，大多数现代计算机将实际的表示范围定为 -128 ~ 127</strong>。</p>
</li>
</ul>
<blockquote>
<p><strong>建议：如何选择类型</strong></p>
<hr>
<ol>
<li>尽可能地接近硬件。</li>
<li>当明确知晓数值不可能为负时，选用无符号类型。</li>
<li>使用 <code>int</code> 执行整数运算。在实际应用中， <code>short</code> 常常显得太小而 <strong><code>long</code> 一般和 <code>int</code> 有一样的尺寸</strong>。如果你的数值超过了 <code>int</code> 的表示范围，选用 <code>long long</code>。</li>
<li>在算术表达式中不要使用 <code>char</code> 或 <code>bool</code>。<strong>因为 <code>char</code> 在一些机器上是有符号的，而在另一些机器上又是无符号的</strong>。</li>
<li>如果你需要一个不大的整数，那么明确指定它的类型是 <code>signed char</code> 或者 <code>unsigned char</code>。</li>
<li>执行浮点数运算选用 <code>double</code>，<strong>因为 <code>float</code> 通常精度不够而且双精度浮点和单精度浮点的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。</strong></li>
</ol>
</blockquote>
<h5 id="2-1-1-节练习"><a class="header-anchor" href="#2-1-1-节练习">¶</a>2.1.1 节练习</h5>
<ul>
<li>
<p>练习 2.1：类型 <code>int</code>、<code>long</code>、<code>long long</code> 和 <code>short</code> 的区别是什么？无符号类型和带符号类型的区别是什么？ <code>float</code> 和 <code>double</code> 的区别是什么？</p>
<p>解：</p>
<ol>
<li>
<p>类型 <code>int</code>、<code>long</code>、<code>long long</code> 和 <code>short</code> 的区别：</p>
<ul>
<li>一个 <code>int</code> 至少和一个 <code>short</code> 一样大；</li>
<li>一个 <code>long</code> 到少和一个 <code>int</code> 一样大；</li>
<li>一个 <code>long long</code> 至少和一个 <code>long</code> 一样大；</li>
<li><code>long long</code> 是 C++11 中新定义。</li>
</ul>
</li>
<li>
<p>无符号类型和带符号类型的区别：</p>
<ul>
<li>带符号类型可以表示正数、负数或 0。</li>
<li>无符号类型仅能表示大于等于 0 的值。</li>
<li>无符号类型中所有比特都用来存储值。</li>
<li>C++ 标准约定了带符号类型在表示范围内正值和负值的量应该平衡。</li>
</ul>
</li>
<li>
<p><code>float</code> 和 <code>double</code> 的区别：</p>
<p>若一机器字节为 8 比特、字为 32 比特，则通常</p>
<ul>
<li><code>float</code> 以 1 个字 (32 比特) 来表示，一般来说 <code>float</code> 类型有 7 个有效位。</li>
<li><code>double</code> 以 2 个字 (64 比特) 来表示， 一般来说 <code>double</code> 类型有 16 个有效位。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="2-1-2-类型转换"><a class="header-anchor" href="#2-1-2-类型转换">¶</a>2.1.2 类型转换</h4>
<p>当我们把一种算术类型的值赋给另外一种类型时：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">bool</span> b = <span class="hljs-number">42</span>;             <span class="hljs-comment">// b 为真</span><br><span class="hljs-keyword">int</span> i = b;               <span class="hljs-comment">// i 的值为 1</span><br>i = <span class="hljs-number">3.14</span>;                <span class="hljs-comment">// i 的值为 3</span><br><span class="hljs-keyword">double</span> pi = i;           <span class="hljs-comment">// pi 的值为 3.0</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> c = <span class="hljs-number">-1</span>;    <span class="hljs-comment">// 假设 char 占 8 比特，c 的值为 255</span><br><span class="hljs-keyword">signed</span> <span class="hljs-keyword">char</span> c2 = <span class="hljs-number">256</span>;    <span class="hljs-comment">// 假设 char 占 8 比特，c 的值是未定义的</span><br></code></pre></div></td></tr></table></figure>
<p>类型所能表示的值的范围决定了转换的过程：</p>
<ul>
<li>
<p>当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为 <code>0</code> 则结果为 <code>false</code>，否则结果为 <code>true</code>。</p>
</li>
<li>
<p>当我们把一个布尔值赋给非布尔类型时，初始值为 <code>false</code> 则结果为 <code>0</code>，初始值为 <code>true</code> 则结果为 <code>1</code>。</p>
</li>
<li>
<p>当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。</p>
</li>
<li>
<p>当我们把一个整数值赋给浮点类型时，小数部分记为 <code>0</code>。如果该整数所占空间超过了浮点类型的容量，精确度 <strong>可能</strong> 有损失。</p>
</li>
<li>
<p><strong>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示 <span span style="border-bottom:3px double black">数值总数</span> 取模后的余数。</strong></p>
<p>例如：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 假如 unsigned char 可以表示 0 ~ 255 区间的值，则它能表示的数值总数为 256</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> val = <span class="hljs-number">257</span>; <span class="hljs-comment">// 赋给 unsigned char 类型一个大于 255 的值。</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">int</span>(val) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>val = <span class="hljs-number">-1</span>; <span class="hljs-comment">//赋给 unsigned char 类型一个小于 0 的值。</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">int</span>(val) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">1</span><br><span class="hljs-number">255</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>笔记</strong>：</p>
<hr>
<p>取模运算遵循商取最趋近 -∞ 的整数原则（取余运算为商取最趋近于 0 的整数原则）。所以 -1 % 256 商 -0.00390625，故商取 -1。而 -1 x 256 + 255 = -1，所以模为 255。</p>
</blockquote>
</li>
<li>
<p><strong>当在程序的某处使用了一种算术类型的值而其实所需的是另一种类型的值时，编译器同样会执行上述的类型转换。</strong> 例如，如果我们使用了一个非布尔值作为条件，那么它会被自动地转换成布尔值，这一做法和把非布尔值赋给布尔变量时的操作完全一样。</p>
<p><strong>所以，如果我们把一个布尔值用在算术表达式里，则它的聚会非 <code>0</code> 即 <code>1</code>，所以一般不宜在算术表达式里使用布尔值。</strong></p>
</li>
</ul>
<h5 id="2-1-2-节练习"><a class="header-anchor" href="#2-1-2-节练习">¶</a>2.1.2 节练习</h5>
<ul>
<li>
<p>练习 2.3：读程序写结果。</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">unsigned</span> u = <span class="hljs-number">10</span>, u2 = <span class="hljs-number">42</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; u2 - u &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; u - u2 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>, i2 = <span class="hljs-number">42</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i2 - i &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i - i2 &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i - u &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; u - i &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure>
<p>解：</p>
<p>输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">32</span><br><span class="hljs-number">4294967264</span><br><span class="hljs-number">32</span><br><span class="hljs-number">-32</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 2.4：编写程序检查你的估计是否正确，如果不正确，请仔细研读本节直到弄明白问题所在。</p>
<p>解：</p>
<p>见练习 2.4。</p>
</li>
</ul>
<h4 id="2-1-3-字面值常量"><a class="header-anchor" href="#2-1-3-字面值常量">¶</a>2.1.3 字面值常量</h4>
<h5 id="整型和浮点型字面值"><a class="header-anchor" href="#整型和浮点型字面值">¶</a>整型和浮点型字面值</h5>
<ul>
<li>默认情况下，<strong>十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的</strong>。</li>
<li>十进制字面值的类型是 <code>int</code>、<code>long</code> 和 <code>long long</code> 中尺寸最小的那个，当然前提是这种类型要能容纳下当前值。八进制和十六进制字面值的类型是能容纳其数值的 <code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>long long</code> 和 <code>unsigned long long</code> 中的尺寸最小者。</li>
<li><strong>类型 <code>short</code> 没有对应的字面值。</strong></li>
<li><span style="border-bottom: 3px black double">严格来说</span>，<span style="border-bottom: 3px black double">十进制</span> 字面值 <span style="border-bottom: 3px black double">不会</span> 是负数。例如 -42 的负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。</li>
<li>默认的，浮点型字面值是一个 <code>double</code>。</li>
</ul>
<h5 id="字符和字符串字面值"><a class="header-anchor" href="#字符和字符串字面值">¶</a>字符和字符串字面值</h5>
<ul>
<li>
<p>由单引号括起来的一个字符称为 <code>char</code> 型字面值，双引号括起来的零个或多个字符则构成字符串字面值。</p>
</li>
<li>
<p>字符串字面值 的类型实际上是由常量字符构成的 <strong>数组</strong> (array)。</p>
</li>
<li>
<p>编译器在每个字符串 (笔记：字面值？) 的结尾处添加一个空字符 (<code>\0</code>)。<strong>因此，字符串字面值的实际长度要比它的内容多 1。</strong></p>
</li>
<li>
<p>如果两个字符串字面值位置紧邻且仅由 <strong>空格</strong>、<strong>缩进</strong> 和 <strong>换行符</strong> 分隔，则它们实际上是一个整体。例如：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a really, really long string literal "</span><br>             <span class="hljs-string">"that spans two lines"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h5 id="转义序列"><a class="header-anchor" href="#转义序列">¶</a>转义序列</h5>
<ul>
<li>
<p>C++ 语言规定的转义序列包括：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">换行符</td>
<td style="text-align:center"><code>\n</code></td>
</tr>
<tr>
<td style="text-align:center">纵向制表符</td>
<td style="text-align:center"><code>\v</code></td>
</tr>
<tr>
<td style="text-align:center">反斜线</td>
<td style="text-align:center"><code>\\</code></td>
</tr>
<tr>
<td style="text-align:center">回车符</td>
<td style="text-align:center"><code>\r</code></td>
</tr>
<tr>
<td style="text-align:center">横向制表符</td>
<td style="text-align:center"><code>\t</code></td>
</tr>
<tr>
<td style="text-align:center">退格符</td>
<td style="text-align:center"><code>\b</code></td>
</tr>
<tr>
<td style="text-align:center">问号</td>
<td style="text-align:center"><code>\?</code></td>
</tr>
<tr>
<td style="text-align:center">进纸符</td>
<td style="text-align:center"><code>\f</code></td>
</tr>
<tr>
<td style="text-align:center">报警 (响铃)符</td>
<td style="text-align:center"><code>\a</code></td>
</tr>
<tr>
<td style="text-align:center">双引号</td>
<td style="text-align:center"><code>\&quot;</code></td>
</tr>
<tr>
<td style="text-align:center">单引号</td>
<td style="text-align:center"><code>\'</code></td>
</tr>
</tbody>
</table>
<p>上述转义序列被当作 <strong>一个</strong> 字符使用。</p>
</li>
<li>
<p>我们也可以泛化转义序列，<strong>其形式是 <code>\x</code> 后紧跟 1 个或多个十六进制数字，或者 <code>\</code> 后紧跟 1 个、2 个或 3 个八进制数字，其中数字部分表示的是字符对应的数值</strong>。</p>
<p>例如，假设使用的是 Latin-1 字符集：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">响铃</td>
<td style="text-align:center"><code>\7</code></td>
</tr>
<tr>
<td style="text-align:center">空字符</td>
<td style="text-align:center"><code>\0</code></td>
</tr>
<tr>
<td style="text-align:center">换行符</td>
<td style="text-align:center"><code>\12</code></td>
</tr>
<tr>
<td style="text-align:center">字符 M</td>
<td style="text-align:center"><code>\115</code></td>
</tr>
<tr>
<td style="text-align:center">空格</td>
<td style="text-align:center"><code>\40</code></td>
</tr>
<tr>
<td style="text-align:center">字符 M</td>
<td style="text-align:center"><code>\x4d</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<ul>
<li>
<p>如果 <code>\</code> 后面跟着的八进制数字超过 3 个，则只有前 3 个数字与 <code>\</code> 构成转义序列。</p>
<p>例如：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\1234"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// "\123" 为字符 “S”</span><br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-built_in">S4</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>相反，<code>\x</code> 要用到后面跟着的所有数字。</p>
<p>例如：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\x1234"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure>
<p>编译输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">用于 x64 的 Microsoft (R) C/C++ 优化编译器 <span class="hljs-number">19.24</span><span class="hljs-number">.28316</span> 版<br>版权所有(C) Microsoft Corporation。保留所有权利。<br><br>prog1.cc<br>prog1.cc(<span class="hljs-number">4</span>): error C2022: “<span class="hljs-number">4660</span>”: 对字符来说太大<br></code></pre></div></td></tr></table></figure>
<p>因为大多数机器的 <code>char</code> 型数据占 8 位，所以上面这个例子可能会报错。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="指定字面值的类型"><a class="header-anchor" href="#指定字面值的类型">¶</a>指定字面值的类型</h5>
<ul>
<li>
<p>字符和字符串字面值：</p>
<table>
<thead>
<tr>
<th style="text-align:center">前缀</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>u</code></td>
<td style="text-align:center">Unicode 16 字符</td>
<td style="text-align:center"><code>char16_t</code></td>
</tr>
<tr>
<td style="text-align:center"><code>U</code></td>
<td style="text-align:center">Unicode 32 字符</td>
<td style="text-align:center"><code>char32_t</code></td>
</tr>
<tr>
<td style="text-align:center"><code>L</code></td>
<td style="text-align:center">宽字符</td>
<td style="text-align:center"><code>wchar_t</code></td>
</tr>
<tr>
<td style="text-align:center"><code>u8</code></td>
<td style="text-align:center">UTF-8 (仅用于字符串字面常量)</td>
<td style="text-align:center"><code>char</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>整型字面值：</p>
<table>
<thead>
<tr>
<th style="text-align:center">后缀</th>
<th style="text-align:center">最小匹配类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>u</code> 或 <code>U</code></td>
<td style="text-align:center"><code>unsigned</code></td>
</tr>
<tr>
<td style="text-align:center"><code>l</code> 或 <code>L</code></td>
<td style="text-align:center"><code>long</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ll</code> 或 <code>LL</code></td>
<td style="text-align:center"><code>long long</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>浮点型字面值：</p>
<table>
<thead>
<tr>
<th style="text-align:center">后缀</th>
<th style="text-align:center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>f</code> 或 <code>F</code></td>
<td style="text-align:center"><code>float</code></td>
</tr>
<tr>
<td style="text-align:center"><code>l</code> 或 <code>L</code></td>
<td style="text-align:center"><code>long double</code></td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-string">L'a'</span>     <span class="hljs-comment">// 宽字符型字面值，类型是 wchar_t</span><br><span class="hljs-string">u8"hi!"</span>  <span class="hljs-comment">// utf-8 字符串字面值 (utf-8 用 8 位编码一个 Unicode 字符)</span><br><span class="hljs-number">42U</span>LL    <span class="hljs-comment">// 无符号整型字面值，类型是 unsigned long long</span><br><span class="hljs-number">1E-3</span>F    <span class="hljs-comment">// 单精度浮点型字面值，类型是 float</span><br><span class="hljs-number">3.14159L</span> <span class="hljs-comment">// 扩展精度浮点型字面值，类型是 long double</span><br></code></pre></div></td></tr></table></figure>
<h5 id="布尔字面值和指针字面值"><a class="header-anchor" href="#布尔字面值和指针字面值">¶</a>布尔字面值和指针字面值</h5>
<p><code>true</code> 和 <code>false</code>。</p>
<h5 id="指针字面值"><a class="header-anchor" href="#指针字面值">¶</a>指针字面值</h5>
<p><code>nullptr</code></p>
<h5 id="2-1-3-节练习"><a class="header-anchor" href="#2-1-3-节练习">¶</a>2.1.3 节练习</h5>
<ul>
<li>
<p>练习 2.5：指出下述字面值的数据类型并说明每一组内几种字面值的区别：</p>
<p>(a) <code>'a'</code>，<code>L'a'</code>，<code>&quot;a&quot;</code>，<code>L&quot;a&quot;</code></p>
<p>(b) <code>10</code>，<code>10u</code>，<code>10L</code>，<code>10uL</code>，<code>012</code>，<code>0xC</code></p>
<p>(c) <code>3.14</code>，<code>3.14f</code>，<code>3.14L</code></p>
<p>(d) <code>10</code>，<code>10u</code>，<code>10.</code>，<code>10e-2</code></p>
<p>解：</p>
<p>(a)</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-string">'a'</span>  <span class="hljs-comment">// 字符字面量，类型 char</span><br><span class="hljs-string">L'a'</span> <span class="hljs-comment">// 字符字面量，类型 wchar_t</span><br><span class="hljs-string">"a"</span>  <span class="hljs-comment">// char 类型组成的字符串字面量</span><br><span class="hljs-string">L"a"</span> <span class="hljs-comment">// wchar_t 类型组成的字符串字面量</span><br></code></pre></div></td></tr></table></figure>
<p>(b)</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-number">10</span>   <span class="hljs-comment">// 十进制带符号整型字面量，类型 int</span><br><span class="hljs-number">10u</span>  <span class="hljs-comment">// 十进制无符号整型字面量，类型 usigned int</span><br><span class="hljs-number">10L</span>  <span class="hljs-comment">// 十进制带符号整型字面量，类型 long</span><br><span class="hljs-number">10u</span>L <span class="hljs-comment">// 十进制无符号整型字面量，类型 unsigned long</span><br><span class="hljs-number">012</span>  <span class="hljs-comment">// 八进制带符号整型字面量，类型 int</span><br><span class="hljs-number">0xC</span>  <span class="hljs-comment">// 十六进制带符号整型字面量，类型 int</span><br></code></pre></div></td></tr></table></figure>
<p>(c)</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-number">3.14</span>  <span class="hljs-comment">// double</span><br><span class="hljs-number">3.14f</span> <span class="hljs-comment">// float</span><br><span class="hljs-number">3.14</span>  <span class="hljs-comment">// long double</span><br></code></pre></div></td></tr></table></figure>
<p>(d)</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-number">10</span>    <span class="hljs-comment">// 十进制带符号整型字面量，类型 int</span><br><span class="hljs-number">10u</span>   <span class="hljs-comment">// 十进制无符号整型字面量，类型 usigned int</span><br><span class="hljs-number">10.</span>   <span class="hljs-comment">// double</span><br><span class="hljs-number">10e-2</span> <span class="hljs-comment">// double</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 2.6：下面两组定义是否有区别，如果有，请叙述之：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> month = <span class="hljs-number">9</span>, day = <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> month = <span class="hljs-number">09</span>, day = <span class="hljs-number">07</span>;<br></code></pre></div></td></tr></table></figure>
<p>解：有区别。</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> month = <span class="hljs-number">9</span>, day = <span class="hljs-number">7</span>; <span class="hljs-comment">// 9 和 7 都是十进制带符号整型字面量。</span><br><span class="hljs-keyword">int</span> month = <span class="hljs-number">09</span> <span class="hljs-comment">/* 无法通过编译。因为 09 表面上是八进制带符号整型字面量，但是 9 对于八进制是非法值 */</span>, day = <span class="hljs-number">07</span> <span class="hljs-comment">/* 07 是八进制带符号整型字面量，但与前面定义是 day 值相等。 */</span>;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 2.7：下述字面值表示何种含义？它们各自的数据类型是什么？</p>
<p>(a) <code>&quot;Who goes with F\145rgus?\012&quot;</code></p>
<p>(b) <code>3.13e1L</code></p>
<p>(c) <code>1024f</code></p>
<p>(d) <code>3.14L</code></p>
<p>解：</p>
<p>(a) 相当于 <code>&quot;Who goes with Fergus?\n&quot;</code>，是 <code>char</code> 字符组成的字符串字面值。</p>
<p>(b) 值为 31.4 的 <code>long double</code> 型字面值。</p>
<p>(c) 值为 1024.0 的 <code>float</code> 型字面值。</p>
<p>(d) 值为 3.14 的 <code>long double</code> 型字面值。</p>
</li>
<li>
<p>练习 2.8：请利用转义序列编写一段程序，要求先输出 2M，然后转到新一行。修改程序使其先输出 2，然后输出制表符，再输出 M，最后转到新一行。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2\115\r"</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">2</span>M<br></code></pre></div></td></tr></table></figure>
<hr>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2\t\115\r"</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
  <figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>      M<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-变量"><a class="header-anchor" href="#2-2-变量">¶</a>2.2 变量</h3>
<p>对 C++ 程序员来说，“变量 (variable)”和“对象 (object)”一般可以互换使用。</p>
<h4 id="2-2-1-变量定义"><a class="header-anchor" href="#2-2-1-变量定义">¶</a>2.2.1 变量定义</h4>
<p>本书遵循 <strong>大多数人</strong> 的习惯用法，即认为 <strong>对象是具有某种数据类型的内存空间</strong>。</p>
<h5 id="初始值"><a class="header-anchor" href="#初始值">¶</a>初始值</h5>
<p>当对象在创建时获得了一个特定的值，我们说这个对象被初始化了(initialized)。</p>
<p>在同一条定义语句中，可以用先定义的变量值去初始化后定义的其它变量。</p>
<p><strong>在 C++ 语言中，初始化和赋值是两个完全不同的操作</strong>。然而在很多编程语言中二者的区别几乎可以忽略不计。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>初始化不是赋值， 初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p>
</blockquote>
<h5 id="列表初始化"><a class="header-anchor" href="#列表初始化">¶</a>列表初始化</h5>
<p>C++ 语言定义了初始化的好几种不同形式。例如，要想定义一个名为 <code>units_sold</code> 的 <code>int</code> 变量并初始化 <code>0</code>，以下的 4 条语句都可以实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> units_sold = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> units_sold = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> units_sold&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">units_sold</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>C++11</strong></p>
<hr>
<p>用 <strong>花括号</strong> 来初始化变量在 C++11 标准中得到了全面应用，而在此之前，这种初始化形式仅在某些受限的场合下才能使用。这种初始化的形式被称为 <strong>列表初始化</strong> (list initialization)。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>当用于 <strong>内置类型</strong> 的变量时，这种初始化形式有一个重要特点：<strong>如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错</strong>：</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> ld = <span class="hljs-number">3.1415926536</span>;<br><span class="hljs-keyword">int</span> a&#123;ld&#125;, b = &#123;ld&#125;;  <span class="hljs-comment">// 错误：转换未执行，因为存在丢失信息的危险。其中至少 ld 的小数部分会丢失掉，而且 int 也可能能存不下 ld 的整数部分</span><br>int c(ld), d = ld;    // 正确：转换执行，且确实丢失了部分值<br></code></pre></div></td></tr></table></figure>
<p>编译输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">用于 x64 的 Microsoft (R) C/C++ 优化编译器 <span class="hljs-number">19.24</span><span class="hljs-number">.28316</span> 版<br>版权所有(C) Microsoft Corporation。保留所有权利。<br><br>prog1.cc<br>.\prog1.cc(<span class="hljs-number">5</span>): error C2397: 从“long <span class="hljs-built_in">double</span>”转换到“<span class="hljs-built_in">int</span>”需要收缩转换<br></code></pre></div></td></tr></table></figure>
</blockquote>
<h5 id="默认初始化"><a class="header-anchor" href="#默认初始化">¶</a>默认初始化</h5>
<p>如果定义变量没有指定初始值，则变量被 <strong>默认初始化</strong> (default initialized)，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，<strong>同时定义变量的位置也会对此有影响</strong>：</p>
<ul>
<li>如果是 <strong>内置类型</strong> 的变量未被显式初始化，<strong>它的值由定义的位置决定</strong>。定义于任何函数体之外的变量被初始化为 <code>0</code>。</li>
<li>定义在函数体内部的 <strong>内置类型</strong> 变量将 <strong>不被初始化</strong> (uninitialized)。一个未被初始化的内置类型变量的值是 <strong>未定义的</strong>，如果试图拷贝或以其它形式访问此类值将引发错误。(如 6.1.1 节所示，P185)</li>
<li>每个 <strong>类</strong> 各自决定其初始化对象的方式。而且，<strong>是否允许不经初始化就定义对象也由类自己决定</strong>。<strong>如果类允许这种行为，它将自己决定对象的初始值到底是什么</strong>。</li>
</ul>
<h5 id="2-2-1-节练习"><a class="header-anchor" href="#2-2-1-节练习">¶</a>2.2.1 节练习</h5>
<ul>
<li>
<p>练习 2.9：解释下列定义的含义。对于非法的定义，请说明错误在何处并将其改正。</p>
<p>(a) <code>std::cin &gt;&gt; int input_value;</code></p>
<p>(b) <code>int i = { 3.14 };</code></p>
<p>(c) <code>double salary = wage = 9999.99;</code></p>
<p>(d) <code>int i = 3.14;</code></p>
<p>解：</p>
<p>(a) 该语句试图定义一个整型变量并从标准输入获取用户输入存入其中。此处的变量定义是非法的，因为</p>
<ul>
<li>根据 1.2 节 (P7)，输入运算符 (<code>&gt;&gt;</code>) 接受<span style="border-bottom: 3px black double">一个</span> <strong>对象</strong> 作为其右侧的运算对象。而题干语句输入运算符右侧是一个 <strong>类</strong> 和一个变量，造成语法错误。</li>
<li>且根据 2.2.1 节 (P38)，变量定义的基本形式是：<span style="border-bottom: 3px black double">首先</span> 是类型说明符，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。该语句并不是以类型说明符开始，造成语法错误。</li>
</ul>
<p>编译输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">用于 x64 的 Microsoft (R) C/C++ 优化编译器 <span class="hljs-number">19.24</span><span class="hljs-number">.28316</span> 版<br>版权所有(C) Microsoft Corporation。保留所有权利。<br><br>prog1.cc<br>.\prog1.cc(<span class="hljs-number">4</span>): error C2062: 意外的类型“<span class="hljs-built_in">int</span>”<br></code></pre></div></td></tr></table></figure>
<p>改正：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> input_value;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; input_value;<br></code></pre></div></td></tr></table></figure>
<p>(b) 该语句试图以列表初始化的方式用一个 <code>double</code> 类型的字面值初始化一个 <code>int</code> 类型变量。此语句是非法的，因为根据 2.2.1 节 (P39)：如果我们使用列表初始化且初始值存在丢失的风险，则编译器将报错。在该初始化语句中若赋值成功，则 3.14 的小数部分将丢失，所以编译器将报错。</p>
<p>编译输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">用于 x64 的 Microsoft (R) C/C++ 优化编译器 <span class="hljs-number">19.24</span><span class="hljs-number">.28316</span> 版<br>版权所有(C) Microsoft Corporation。保留所有权利。<br><br>prog1.cc<br>.\prog1.cc(<span class="hljs-number">4</span>): error C2397: 从“<span class="hljs-built_in">double</span>”转换到“<span class="hljs-built_in">int</span>”需要收缩转换<br></code></pre></div></td></tr></table></figure>
<p>改正：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">double</span> i = &#123; <span class="hljs-number">3.14</span> &#125;;<br></code></pre></div></td></tr></table></figure>
<p>(c) 该语句试图同时定义两个 <code>double</code> 型变量  <code>salary</code> 和 <code>wage</code>，并将它们同时初始化为 <code>9999.99</code>。此语句是非法的，因为 <code>salary</code> 在 <code>wage</code> 之前被定义，根据 2.2.1 节 (P39)：在同一条定义语句中，可以用先定义的变量值去初始化后定义的其它变量。在此语句中 <code>salary</code> 定义时 <code>wage</code> 尚未定义，所以无法通过编译。</p>
<p>编译输出：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript">用于 x64 的 Microsoft (R) C/C++ 优化编译器 <span class="hljs-number">19.24</span><span class="hljs-number">.28316</span> 版<br>版权所有(C) Microsoft Corporation。保留所有权利。<br><br>prog1.cc<br>.\prog1.cc(<span class="hljs-number">4</span>): error C2065: “wage”: 未声明的标识符<br></code></pre></div></td></tr></table></figure>
<p>改正：</p>
  <figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> wage = <span class="hljs-number">9999.99</span>, salary = wage;<br></code></pre></div></td></tr></table></figure>
<p>(d) 该语句试图用一个 <code>double</code> 类型的字面值初始化一个 <code>int</code> 类型变量。语句合法，但会丢失 3.14 的小数部分。</p>
</li>
</ul>
<h4 id="2-2-2-变量声明和定义的关系"><a class="header-anchor" href="#2-2-2-变量声明和定义的关系">¶</a>2.2.2 变量声明和定义的关系</h4>
<p>为了允许把程序拆分成多个逻辑部分来编写，C++ 语言支持 <strong>分离式编译</strong> (separate compilation) 机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p>
<p>为了支持分离式编译，C++ 语言将声明和定义区分开来。</p>
<ul>
<li><strong>声明</strong> (declaration) 使得名字为程序所知，<strong>一个文件如果想使用别处定义的名字则必须包含对那个名字的声明</strong>。如果想声明一个变量而非定义它，就在变量名前添加关键字 <code>extern</code>， <span style="border-bottom: 3px black double">而且不要显式地初始化变量</span>。</li>
<li><strong>定义</strong> (definition) 负责创建与名字相关联的实体。</li>
<li>声明和定义的区别：
<ul>
<li>变量声明 <strong>规定了变量的类型和名字</strong>；</li>
<li>变量的定义 <span style="border-bottom: 3px black double">除了规定变量的类型和名字外</span> 还 <strong>申请存储空间</strong>，也 <strong>可能</strong> 会为变量赋一个初始值；</li>
<li><strong>变量能且只能定义一次，但是可以被多次声明</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<ul>
<li>任何包含了显式初始化的声明即成为定义。这么做也就抵消了 <code>extern</code> 的作用。</li>
<li>在函数体内部，如果试图初始化一个由 <code>extern</code> 关键字标记的变量，将引发错误。</li>
</ul>
</blockquote>
<h5 id="2-2-2-节练习"><a class="header-anchor" href="#2-2-2-节练习">¶</a>2.2.2 节练习</h5>
<ul>
<li>
<p>练习 2.11：指出下面的语句是声明还是定义：</p>
<p>(a) <code>extern int ix = 1024;</code></p>
<p>(b) <code>int iy;</code></p>
<p>(c) <code>extern int iz;</code></p>
<p>解：</p>
<p>(a) 定义。</p>
<p>(b) 定义。</p>
<p>(c) 声明。</p>
</li>
</ul>
<h4 id="2-2-3-标识符"><a class="header-anchor" href="#2-2-3-标识符">¶</a>2.2.3 标识符</h4>
<p>C++ 的标识符 (identifier) 由字母、数字和下划线组成，其中 <strong>必须以字母或下划线开头</strong>。</p>
<p>用户自定义的标识符中：</p>
<ul>
<li><strong>不能连续出现两个下划线</strong>。</li>
<li><strong>不能以下划线紧连大写字母开头</strong>。</li>
<li><strong>定义在函数体外的标识符不能以下划线开头</strong>。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>违反上述约定并不能导致编译错误，但上述标识符约定是为编译器预留，用户自定义可能会与编译器预定义标识符冲突。</p>
</blockquote>
<h5 id="变量命名规范"><a class="header-anchor" href="#变量命名规范">¶</a>变量命名规范</h5>
<p>下面的这些规范能有效提高程序的可读性：</p>
<ul>
<li>标识符要能体现实际含义。</li>
<li>变量名一般用小写字母，如 <code>index</code>，不要使用 <code>Index</code> 或 <code>INDEX</code>。</li>
<li>用户自定义的类名一般以大写字母开头，如 <code>Sales_item</code>。</li>
<li>如果标识符由多个单词组成，则单词间应有明显区别，如 <code>student_loan</code> 或 <code>studnetLoan</code>，不要使用 <code>studentloan</code>。</li>
</ul>
<h5 id="2-2-3-节练习"><a class="header-anchor" href="#2-2-3-节练习">¶</a>2.2.3 节练习</h5>
<ul>
<li>
<p>练习 2.12：请指出下面的名字中哪些是非法的？</p>
<p>(a) <code>int double = 3.14</code>;</p>
<p>(b) <code>int _;</code></p>
<p>(c) <code>int catch-22;</code></p>
<p>(d) <code>int 1_or_2 = 1</code>;</p>
<p>(e) <code>double Double = 3.14;</code></p>
<p>解：</p>
<p>(a) 不合法，用户自定义标识符 <code>double</code> 与关键字 <code>double</code> 冲突。</p>
<p>(b) 合法，但若在函数体外定义，则可能存在隐患。</p>
<p>(c) 不合法，标识符只能由字母、数字和下划线组成。</p>
<p>(d) 不合法，标识符只能由字母或下划线开头。</p>
<p>(e) 合法。</p>
</li>
</ul>
<h4 id="2-2-4-名字的作用域"><a class="header-anchor" href="#2-2-4-名字的作用域">¶</a>2.2.4 名字的作用域</h4>
<p>C++ 语言中大多数作用域都以花括号分隔。</p>
<p>名字 <code>main</code> 定义于所有花括号之外，它和其它大多数定义在函数体之外的名字一样拥有 <strong>全局作用域</strong> (global scope)。</p>
<blockquote>
<p><strong>建议</strong>：当你第一次使用变量时再定义它</p>
<hr>
<p>一般来说，在对象第一次使用的地方附近定义它是一种好的选择，因为这样做有助于更容易地找到变量的定义。更重要的是，<strong>当变量的定义与它第一次被使用的地方很近时，我们也会赋给它一个比较合理的初始值</strong>。</p>
</blockquote>
<h5 id="嵌套的作用域"><a class="header-anchor" href="#嵌套的作用域">¶</a>嵌套的作用域</h5>
<p>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时允许在内层作用域中重新定义外层作用域已有的名字：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">int</span> reused = <span class="hljs-number">42</span>; <span class="hljs-comment">// reused 拥有全局作用域</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> unique = <span class="hljs-number">0</span>; <span class="hljs-comment">// unique 拥有块作用域</span><br>    <span class="hljs-comment">// 输出 #1：使用全局变量 reused；输出 42 0</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; reused &lt;&lt; <span class="hljs-string">""</span> &lt;&lt; unique &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">int</span> reused = <span class="hljs-number">0</span>; <span class="hljs-comment">// 新建局部变量 reused，覆盖了全局变量 reused</span><br>    <span class="hljs-comment">// 输出 #2：使用局部变量 reused；输出 0 0</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; reused &lt;&lt; <span class="hljs-string">""</span> &lt;&lt; unique &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">// 输出 #3：显式地访问全局变量 reused；输出 42 0</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; ::reused &lt;&lt; <span class="hljs-string">""</span> &lt;&lt; unique &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。</p>
</blockquote>
<h5 id="2-2-4-节练习"><a class="header-anchor" href="#2-2-4-节练习">¶</a>2.2.4 节练习</h5>
<ul>
<li>
<p>练习 2.13：下面程序中 <code>j</code> 的值是多少？</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">int</span> j = i;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>解：<code>j</code> 的值是 <code>100</code>。因为局部变量 <code>i</code> 的值覆盖了全局同名变量 <code>i</code> 的值。</p>
</li>
<li>
<p>练习 2.14：下面的程序合法吗？如果合法，它将输出什么？</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>, sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)<br>    sum += i;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure>
<p>解：</p>
<p>合法。</p>
<p>输出：</p>
  <figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">100 </span><span class="hljs-number">45</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="2-3-复合类型"><a class="header-anchor" href="#2-3-复合类型">¶</a>2.3 复合类型</h3>
<p><strong>复合类型</strong> (compound type) 是指基于其它类型定义的类型。</p>
<p>本章只涉及两种复合类型：</p>
<ul>
<li>引用</li>
<li>指针</li>
</ul>
<h4 id="2-3-1-引用"><a class="header-anchor" href="#2-3-1-引用">¶</a>2.3.1 引用</h4>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>C++11 中新增了一种引用：“右值引用 (rvalue reference) (第 13.6.1 节，P471)”，这种引用主要用于内置类。<strong>严格来说，当我们使用术语“引用 (reference)”时，指的其实是“左值引用 (lvalue reference)”</strong>。</p>
</blockquote>
<ul>
<li>引用类型引用 (refers to) 另外一种类型。</li>
<li><strong>引用必须初始化</strong>。</li>
<li><strong>引用必须用另一个对象初始化</strong>。</li>
<li>引用的类型要与之绑定的对象严格匹配。（除 2.4.1 节，P55 和 15.2.3 节，P534 两种例外情况外。）</li>
</ul>
<blockquote>
<p><strong>原理</strong>：</p>
<hr>
<p>定义引用时，程序把引用它的初始值 <strong>绑定</strong> (bind) 在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">int</span> &amp;refVal = ival;   <span class="hljs-comment">// refVal 指向 ival (是 ival 的另一个名字)</span><br><span class="hljs-keyword">int</span> &amp;refVal2;         <span class="hljs-comment">// 报错：引用必须被初始化</span><br><span class="hljs-keyword">int</span> &amp;refVal3 = <span class="hljs-number">1024</span>;  <span class="hljs-comment">// 报错：引用必须用另一个对象初始化</span><br><span class="hljs-keyword">double</span> dval = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">int</span> &amp;refVal4 = dval;  <span class="hljs-comment">// 错误：此处引用类型的初始值必须是 int 对象</span><br></code></pre></div></td></tr></table></figure>
<h5 id="引用即别名"><a class="header-anchor" href="#引用即别名">¶</a>引用即别名</h5>
<ul>
<li>
<p>获取引用的值，实际上是获取了与引用绑定的对象的值。所以，**以引用作为初始值，实际上是以与引用绑定的对象作为初始值。</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 正确：refVal5 绑定到了那个与 refVal 绑定的对象上，这里就是绑定到 ival 上</span><br><span class="hljs-keyword">int</span> &amp;refVal5 = refVal;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>引用本身不是一个对象，所以不能 <strong>直接</strong> 定义引用的引用。</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ival = <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">int</span> &amp;refVal = ival;<br>    <span class="hljs-keyword">int</span> &amp;(&amp;refVal2) = refVal; <span class="hljs-comment">// 错误：不能直接定义引用的引用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>但是可以间接定义 (转自<a href="https://www.zhihu.com/question/28023545" target="_blank" rel="noopener">知乎</a>) ：</p>
<ol>
<li>
<p>方法一，使用类型别名：</p>
 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> intRef = <span class="hljs-keyword">int</span> &amp;; <span class="hljs-comment">// 用 typedef 亦可</span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>intRef &amp; rrefa = a;   <span class="hljs-comment">// rrefa 是引用的引用</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>方法二，使用模板：</p>
 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T &amp;&amp;t)</span></span>&#123;&#125;<br><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>func(a);<br><span class="hljs-comment">/***************** 注意 *****************/</span><br><span class="hljs-comment">/* 如果func是普通函数而非函数模板，则这段代码会报错 */</span><br><span class="hljs-comment">/* 因为左值不能绑定到右值引用上 */</span><br><span class="hljs-comment">/* void func(int &amp;&amp; t)&#123;&#125; －－－func(a) --- ERROR!!! */</span><br><br><span class="hljs-comment">/* 函数模板是个特例，此处会触发引用折叠 */</span><br></code></pre></div></td></tr></table></figure>
<p>引用折叠规则：<br>
<code>X&amp; &amp;</code> (引用的引用)、<code>X&amp; &amp;&amp;</code> (右值引用的引用)、<code>X&amp;&amp; &amp;</code> (引用的右值引用) 均折叠为 <code>X &amp;</code>。<br>
<code>X&amp;&amp; &amp;&amp;</code> (右值引用的右值引用) 折叠为 <code>X &amp;&amp;</code>。</p>
<p>上面的类型别名和函数模板均触发了引用折叠。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p><strong>引用折叠的前提必须是类型别名或者模板参数。标准禁止直接定义引用的引用。</strong></p>
</blockquote>
<p>为什么需要引用折叠：<br>
引用折叠是 <code>std::move</code>、<code>std::forward</code> 等的工作基础。</p>
</li>
</ol>
</li>
</ul>
<h5 id="引用的定义"><a class="header-anchor" href="#引用的定义">¶</a>引用的定义</h5>
<p>略，见 P46。</p>
<h5 id="2-3-1-节练习"><a class="header-anchor" href="#2-3-1-节练习">¶</a>2.3.1 节练习</h5>
<ul>
<li>
<p>练习 2.15：下面哪个定义是不合法的？为什么？</p>
<p>(a) <code>int ival = 1.01</code>;</p>
<p>(b) <code>int &amp;rval1 = 1.01;</code></p>
<p>(c) <code>int &amp;rval2 = ival;</code></p>
<p>(d) <code>int &amp;rval3;</code></p>
<p>解：</p>
<p>(a) 合法。但会丢失 <code>1.01</code> 的小数部分。</p>
<p>(b) 不合法。根据第 2.3.1 节 (P46)：引用的对象必须是一个对象。</p>
<p>(c) 合法。</p>
<p>(d) 不合法。根据第 2.3.1 节 (P45)：引用必须被初始化。</p>
</li>
<li>
<p>练习 2.16：考查下面的所有赋值然后回答：哪些赋值是不合法的？为什么？哪些赋值的合法的？它们执行了什么样的操作？</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, &amp;r1 = i;<br><span class="hljs-keyword">double</span> d = <span class="hljs-number">0</span>, &amp;r2 = d;<br></code></pre></div></td></tr></table></figure>
<p>(a) <code>r2 = 3.14159;</code></p>
<p>(b) <code>r2 = r1;</code></p>
<p>(c) <code>i = r2;</code></p>
<p>(d) <code>r1 = d;</code></p>
<p>解：</p>
<p>(a) 合法。此赋值语句将与引用 <code>r2</code> 绑定的对象 <code>d</code> 赋予字面值 <code>3.14159</code>。</p>
<p>(b) 合法。此赋值语句将与引用 <code>r2</code> 绑定的对象 <code>d</code> 赋予与引用 <code>r1</code> 绑定的对象 <code>i</code> 的值。赋值过程中进行了类型转换。</p>
<p>(c) 合法。此赋值语句将对象 <code>i</code> 赋予与引用 <code>r2</code> 绑定的对象 <code>d</code> 的值。但丢失了 <code>3.14159</code> 的小数部分。</p>
<p>(d) 不合法。根据第 2.3.1 节 (P46)：除了 2.4.1 节 (P55) 和第 15.2.3 节 (P534)  介绍的两种例外情况，其它所有引用的类型都要和与之绑定的对象严格匹配。</p>
</li>
<li>
<p>练习 2.17：执行下面的代码段将输出什么结果？</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i, &amp;ri = i;<br>i = <span class="hljs-number">5</span>; ri = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; ri &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br></code></pre></div></td></tr></table></figure>
<p>解：</p>
<p>输出：</p>
  <figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="2-3-2-指针"><a class="header-anchor" href="#2-3-2-指针">¶</a>2.3.2 指针</h4>
<p>指针与引用的区别：</p>
<ul>
<li><strong>指针本身就是一个对象</strong>，允许对指针的赋值和拷贝。</li>
<li>指针无须在定义时赋初值。和其它内置类型一样，<strong><span style="border-bottom: 3px black double">在块作用域内</span> 定义的指针如果没有被初始化，也将拥有一个不确定的值</strong>。</li>
</ul>
<p>定义指针类型的方法将 <strong>声明符</strong> 写成 <code>*d</code> 的形式，<strong>其中 <code>d</code> 是变量名</strong>。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号 <code>*</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> *ip1, *ip2;  <span class="hljs-comment">// ip1 和 ip2 都是指向 int 型对象的指针</span><br><span class="hljs-keyword">double</span> dp, *dp2; <span class="hljs-comment">// dp 是 double 型对象，dp2 是指向 double 型对象的指针</span><br></code></pre></div></td></tr></table></figure>
<h5 id="获取对象的地址"><a class="header-anchor" href="#获取对象的地址">¶</a>获取对象的地址</h5>
<p>除了第 2.4.2 节 (P56) 和第 15.2.3 节 (P534) 介绍的两种例外情况，其它所有指针的类型都要和它所指向的对象严格匹配：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">double</span> dval;<br><span class="hljs-keyword">double</span> *pd = &amp;dval;  <span class="hljs-comment">// 正确：初始值是 double 型对象的地址</span><br><span class="hljs-keyword">double</span> *pd2 = pd;    <span class="hljs-comment">// 正确：初始值是指向 double 对象的指针</span><br><br><span class="hljs-keyword">int</span> *pi = pd;        <span class="hljs-comment">// 错误：指针 pi 的类型和 pd 的类型不匹配</span><br>pi = &amp;dval;          <span class="hljs-comment">// 错误：试图把 double 型对象的地址赋给 int 型指针</span><br></code></pre></div></td></tr></table></figure>
<h5 id="指针值"><a class="header-anchor" href="#指针值">¶</a>指针值</h5>
<p>指针的值 (即地址) 应属下列 4 种状态之一：</p>
<ol>
<li>指向一个对象。</li>
<li>指向紧邻对象所占空间的下一个位置。</li>
<li>空指针，意味着指针没有指向任何对象。</li>
<li>无效指针，也就是上述情况之外的其它值。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<ul>
<li>试图拷贝或以其它方式访问无效指针的值都将引发错误。但 <strong>编译器并不负责检查此类错误</strong>。这一点和试图使用未经初始化的变量是一样的。访问 <strong>无效指针的后果无法预计</strong>。</li>
<li>第 2 种和第 3 种形式的指针同样受到限制。因为这些指针没有指向任何具体对象，所以试图访问此类指针 (假定的) 对象的行为不被允许。</li>
</ul>
</blockquote>
<h5 id="利用指针访问对象"><a class="header-anchor" href="#利用指针访问对象">¶</a>利用指针访问对象</h5>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>解引用操作仅适用于那些 <strong>确实指向了某个对象</strong> (状态 2、3 有可能没有指向任何具体对象)的 <strong>有效指针</strong>。</p>
</blockquote>
<h5 id="空指针"><a class="header-anchor" href="#空指针">¶</a>空指针</h5>
<p><strong>空指针</strong> (null pointer) 不指向任何对象。</p>
<blockquote>
<p><strong>C++11</strong></p>
<hr>
<p>得到空指针最直接的办法就是用字面值 <code>nullptr</code> 来初始化指针，这也是 C++11 标准刚刚引入的一种方法。</p>
</blockquote>
<p><code>nullptr</code> 是一种特殊类型的 <strong>字面值</strong>。<strong>它可以被转换成任意其它的指针类型</strong>。</p>
<p>得到空指针的方法：</p>
<ul>
<li>用字面值 <code>nullptr</code> 初始化指针。</li>
<li>通过将指针初始化为字面值 <code>0</code>。</li>
<li>通过将指针初始化为 <strong>预处理变量</strong> (preprocessor variable) <code>NULL</code> 的值，这个变量在头文件 <em>cstdlib</em> 中定义。它的值就是 <code>0</code>。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<ul>
<li>预处理器是运行于编译过程之前的一段程序。预处理变量不属于命名空间 <code>std</code>，它由预处理器负责管理，因此使用预处理变量时无须在前面加上 <code>std::</code>。<br>
当用到一个预处理变量时，预处理器会自动地将它替换为实际值，因此使用 <code>NULL</code> 初始化指针和用 <code>0</code> 初始化指针是一样的。<strong>在新标准下，现在的 C++ 程序最好使用 <code>nullptr</code>，同时发尽量避免使用 <code>NULL</code></strong>。</li>
<li>把 <code>int</code> 变量 <strong>直接</strong> 赋给指针是错误的操作，编译器将报错，即使 <code>int</code> 变量的值恰好等于 <code>0</code> 也不行。</li>
</ul>
</blockquote>
<h5 id="赋值和指针"><a class="header-anchor" href="#赋值和指针">¶</a>赋值和指针</h5>
<p>略，见 P49。</p>
<h5 id="其它指针操作"><a class="header-anchor" href="#其它指针操作">¶</a>其它指针操作</h5>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>不论是作为条件出现在还是参与比较运算，都必须使用合法指针，<strong>使用非法指针作为条件或进行比较都会引发不可预计的后果</strong>。</p>
</blockquote>
<h5 id="void-指针"><a class="header-anchor" href="#void-指针">¶</a><code>void*</code> 指针</h5>
<p><code>void*</code> 指针是一种特殊的指针类型，可用于存放任意对象的地址。</p>
<ul>
<li>可以拿 <code>void*</code> 指针和别的指针进行比较。</li>
<li>可以拿 <code>void*</code> 指针作为函数的输入或输出。</li>
<li>可以把 <code>void*</code> 指针赋给另个一个 <code>void*</code> 指针。</li>
<li><strong>不能直接</strong> 操作 <code>void*</code> 指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。</li>
</ul>
<h5 id="2-3-2-节练习"><a class="header-anchor" href="#2-3-2-节练习">¶</a>2.3.2 节练习</h5>
<ul>
<li>
<p>练习 2.18：编写代码分别更改指针的值以及指针所指对象的值。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ival = <span class="hljs-number">1024</span>, ival2 = <span class="hljs-number">2048</span>;<br>    <span class="hljs-keyword">int</span> *pi = &amp;ival;<br>    <br>    pi = &amp;ival2; <span class="hljs-comment">// 更改指针的值</span><br>    *pi = <span class="hljs-number">4096</span>;  <span class="hljs-comment">// 更改指针所指对象的值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 2.19：说明指针和引用的主要区别。</p>
<p>解：</p>
<ul>
<li>指针本身就是一个对象，允许对指针的赋值和拷贝；引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象。</li>
<li>指针无须在定义时赋初值。引用在定义时必须指明要绑定的对象。</li>
</ul>
</li>
<li>
<p>练习 2.20：请叙述下面这段代码的作用。</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">int</span> *p1 = &amp;i;<br>*p1 = *p1 * *p1;<br></code></pre></div></td></tr></table></figure>
<p>解：</p>
<p>代码第一行将整型字面值 <code>42</code> 赋给整型变量 <code>i</code>。第二行将整型指针 <code>p</code> 指向变量 <code>i</code>。第三行将指针 <code>p</code> 所指向变量的值进行平方运算后再赋给 <code>p</code> 所指向的变量，即变量 <code>i</code>。</p>
</li>
<li>
<p>练习 2.21： 请解释下术定义。在这些定义中有非法的吗？如果有，为什么。</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>
<p>(a) <code>double* dp = &amp;i;</code></p>
<p>(b) <code>int *ip = i;</code></p>
<p>(c) <code>int *p = &amp;i;</code></p>
<p>解：</p>
<p>(a) 该定义试图将 <code>double</code> 型指针直接指向一个 <code>int</code> 型变量。该定义是非法的，因为根据第 2.3.2 节 (P47)： 除了第 2.4.2 节 (P56) 和第 15.2.3 节 (P534) 介绍的两种例外情况，其它所有指针的类型都要和它所指向的对象严格匹配。该定义中的指针类型与所指向的变量类型不严格匹配。</p>
<p>(b) 该定义试图将一个 <code>int</code> 型变量的值直接赋给一个 <code>int</code> 型指针。该定义是非法的。因为把 <code>int</code> 变量直接赋给指针是错误的操作，编译器将报错，即使 <code>int</code> 变量的值恰好等于 <code>0</code> 也不行 (第 2.3.2 节，P49)。</p>
<p>(c) 该定义试图将 <code>int</code> 型指针直接指向一个 <code>int</code> 型变量。该定义是合法的。</p>
</li>
<li>
<p>练习 2.22：假设 <code>p</code> 是一个 <code>int</code> 型指针，请说明下述代码的含义：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(p)   <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">if</span>(*p)  <span class="hljs-comment">// ...</span><br></code></pre></div></td></tr></table></figure>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(p)   <span class="hljs-comment">// 判断指针 p 的值是否为 nullptr 或 0</span><br><span class="hljs-keyword">if</span>(*p)  <span class="hljs-comment">// 判断指针 p 所指向的 int 变量的值是否是 0</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 2.23：给定指针 <code>p</code>，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，也请说明原因。</p>
<p>解：</p>
<p>不一定能。因为指针的值可以为下列 4 种状态：</p>
<ol>
<li>指向一个对象。</li>
<li>指向紧邻对象所占空间的下一个位置。</li>
<li>空指针，意味着指针没有指向任何对象。</li>
<li>无效指针，也就是上述情况之外的其它值。</li>
</ol>
<p>如果 <code>p</code> 处于状态 3 可以使用 <code>if</code> 语句判断出 <code>p</code> 指向了 <code>nullptr</code> 字面量，或 <code>p</code> 的值为 <code>0</code>。但无法判断 <code>p</code> 是否处于其它三种状态。</p>
</li>
<li>
<p>练习 2.24：在下面这段代码中为什么 <code>p</code> 合法而 <code>lp</code> 非法？</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">void</span> *p = &amp;i;<br><span class="hljs-keyword">long</span> *lp = &amp;i;<br></code></pre></div></td></tr></table></figure>
<p>解：</p>
<p>因为根据第 2.3.2 节 (P50)：<code>void*</code> 是一种特殊的指针类型，可用于存放任意对象的地址。而根据第 2.3.2 节 (P47)：除了第 2.4.2 节 (P56) 和第 15.2.3 节 (P534) 介绍的两种例外情况，其它所有指针的类型都要和它所指向的对象严格匹配。</p>
</li>
</ul>
<h4 id="2-3-3-理解复合类型的声明"><a class="header-anchor" href="#2-3-3-理解复合类型的声明">¶</a>2.3.3 理解复合类型的声明</h4>
<p>变量的定义包括一个基本数据类型 (base type) 和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// i 是一个 int 型的数，p 是一个 int 型指针，r 是一个 int 型引用</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1024</span>, *p = &amp;i, &amp;r = i;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>类型修饰符是声明符的一部分。</p>
</blockquote>
<h5 id="定义多个变量"><a class="header-anchor" href="#定义多个变量">¶</a>定义多个变量</h5>
<p>略，见 P51。</p>
<h5 id="指向指针的指针"><a class="header-anchor" href="#指向指针的指针">¶</a>指向指针的指针</h5>
<p>一般来说，声明符中的修饰符的个数并没有限制。当有多个修饰符连写在一起时，按照其逻辑关系详加解释即可。</p>
<h5 id="指向指针的引用"><a class="header-anchor" href="#指向指针的引用">¶</a>指向指针的引用</h5>
<p>引用本身不是一个对象，因此 <strong>不能定义指向引用的指针</strong>。但指针是对象，所以 <strong>存在对指针的引用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">int</span> p;       <span class="hljs-comment">// p 是一个 int 型指针</span><br><span class="hljs-keyword">int</span> *&amp;r = p; <span class="hljs-comment">// r 是一个对指针 p 的引用</span><br>r = &amp;i;      <span class="hljs-comment">// r 引用了一个指针，因此给 r 赋值 &amp;i 就是令 p 指向 i</span><br>*r = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 解引用了 r 得到 i，也就是 p 指向的对象，将 i 的值改为 0</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong>：</p>
<hr>
<p>面对一条比较复杂的指针或引用的声明语句时，<strong>从右向左读</strong> 有助于弄清它的真实含义。</p>
</blockquote>
<h5 id="2-3-3-节练习"><a class="header-anchor" href="#2-3-3-节练习">¶</a>2.3.3 节练习</h5>
<ul>
<li>
<p>练习 2.25：说明下列变量的类型和值。</p>
<p>(a) <code>int* ip, i, &amp;r = i;</code></p>
<p>(b) <code>int i, *ip = 0;</code></p>
<p>(c) <code>int* ip, ip2;</code></p>
<p>解：</p>
<p>(a)</p>
<ul>
<li><code>ip</code> 是 <code>int</code> 类型指针。如果该定义语句在函数体外，则它的值为 <code>nullptr</code>；如果该定义语句在函数体内，则 <code>ip</code> 是未被初始化的，其值是未定义的。</li>
<li><code>i</code> 是 <code>int</code> 类型变量。如果该定义语句在函数体外，则它的值为 <code>0</code>；如果该定义语句在函数体内，则 <code>i</code> 是未被初始化的，其值是未定义的。</li>
<li><code>r</code> 是绑定到 <code>int</code> 型变量 <code>i</code> 上的 <code>int</code> 型引用。它的值即为此时 <code>i</code> 的值。</li>
</ul>
<p>(b)</p>
<ul>
<li><code>i</code> 是 <code>int</code> 类型变量。如果该定义语句在函数体外，则它的值为 <code>0</code>；如果该定义语句在函数体内，则 <code>i</code> 是未被初始化的，其值是未定义的。</li>
<li><code>ip</code> 是 <code>int</code> 类型的空指针。其值为 <code>0</code>。</li>
</ul>
<p>(c)</p>
<ul>
<li><code>ip</code> 是 <code>int</code> 类型指针。如果该定义语句在函数体外，则它的值为 <code>nullptr</code>；如果该定义语句在函数体内，则 <code>ip</code> 是未被初始化的，其值是未定义的。</li>
<li><code>ip2</code> 是 <code>int</code> 类型变量。如果该定义语句在函数体外，则它的值为 <code>0</code>；如果该定义语句在函数体内，则 <code>ip2</code> 是未被初始化的，其值是未定义的。</li>
</ul>
</li>
</ul>
<h3 id="2-4-const-限定符"><a class="header-anchor" href="#2-4-const-限定符">¶</a>2.4 <code>const</code> 限定符</h3>
<p><strong>因为 <code>const</code> 对象一旦创建后其值就不能再改变，所以 <code>const</code> 对象必须初始化，<span style="border-bottom: 3px black double">初始值可以是任意复杂的表达式</span></strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = get_size();  <span class="hljs-comment">// 正确，运行时初始化</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">42</span>;          <span class="hljs-comment">// 正确：编译时初始化</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k;               <span class="hljs-comment">// 错误：k 是一个未经初始化的常量</span><br></code></pre></div></td></tr></table></figure>
<h4 id="初始化和-const"><a class="header-anchor" href="#初始化和-const">¶</a>初始化和 <code>const</code></h4>
<p><strong>如果利用一个对象去初始化另外一个对象，则它们是不是 <code>const</code> 都无关紧要</strong>。</p>
<h4 id="默认状态下，const-对象仅在文件内有效"><a class="header-anchor" href="#默认状态下，const-对象仅在文件内有效">¶</a>默认状态下，<code>const</code> 对象仅在文件内有效</h4>
<ul>
<li>
<p>当以 <span style="border-bottom: 3px black double">编译时初始化的方式 </span> 定义一个 <code>const</code> 对象时，<strong>编译器将在编译过程中把用到该变量的地方都替换成对象的值</strong>。如果程序包含多个文件，则每个用了 <code>const</code> 对象的文件都必须得能访问到它的初始值才行。要做到这一点，<strong>就必须在每一个用到变量的文件中都有对它的定义</strong>（第 2.2.2 节，P41）。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，<code>const</code> 对象被设定为仅在文件内有效。<strong>当多个文件中出现了同名的 <code>const</code> 变量时，其实等同于在不同文件中分别定义了独立的变量</strong>。</p>
</li>
<li>
<p>当 <span style="border-bottom: 3px black double">它的初始值不是一个常量表达式 (第 2.4.4 节，P58)</span>，但又确实必要要文件间共享，也就是说要在其它多个文件中声明并使用它时。对于 <code>const</code> 变量不管是声明还是定义都添加 <code>extern</code> 关键字，这样只需定义一次就可以了：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// file_1.cc 定义并初始化了一个常量，该常量能被其它文件访问</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize = fcn();<br><span class="hljs-comment">// file_1.h 头文件</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize;  <span class="hljs-comment">// 与 file_1.cc 中定义的 bufSize 是同一个</span><br></code></pre></div></td></tr></table></figure>
<p><em>file_1.cc</em> 定义并初始化了 <code>bufSize</code>。因为这条语句包含了初始值，所以它（显然）是一次定义。然而，因为 <code>bufSize</code> 是一个常量，必须用 <code>extern</code> 加以限定使其它文件使用。</p>
<p><em>file_1.h</em> 头文件中的声明也由 <code>extern</code> 做了限定，其作用是指明 <code>bufSize</code> 并非本文件所独有，它的定义 <strong>将</strong> 在别处出现。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>如果想在多个文件之间共享 <code>const</code> 对象，必须在变量的定义之前添加 <code>extern</code> 关键字。</p>
</blockquote>
<h4 id="2-4-节练习"><a class="header-anchor" href="#2-4-节练习">¶</a>2.4 节练习</h4>
<ul>
<li>
<p>练习 2.26：下面哪些句子是合法的？如果有不合法的句子，请说明为什么？</p>
<p>(a) <code>const int buf; </code></p>
<p>(b) <code>int cnt = 0;</code></p>
<p>(c) <code>const int sz = cnt;</code></p>
<p>(d) <code>++cnt; ++sz;</code></p>
<p>解：</p>
<p>(a) 不合法。因为根据第 2.4节 (P53)：因为 <code>const</code> 对象一旦创建后其值就不能再改变，所以 <code>const</code> 对象必须初始化。此语句中的 <code>const</code> 对象 <code>buf</code> 未初始化。</p>
<p>(b) 合法。<br>
(c) 合法。</p>
<p>(d) 不合法。因为 <code>const</code> 变量的值不能被改变。题干中 <code>++cnt;</code> 试图改变了 <code>const</code> 变量 <code>cnt</code> 的值。</p>
</li>
</ul>
<h4 id="2-4-1-const-的引用"><a class="header-anchor" href="#2-4-1-const-的引用">¶</a>2.4.1 <code>const</code> 的引用</h4>
<p>可以把引用绑定到 <code>const</code> 对象上，就像绑定到其他对象上一样，我们称之为 <strong>对常量的引用</strong> (reference to const)。<strong>对常量的引用不能被用作修改它所绑定的对象</strong>。</p>
<blockquote>
<p><strong>术语</strong>：常量引用是对 <code>const</code> 的引用</p>
<hr>
<p>严格来说，<strong>并不存在常量引用。因为引用不是一个对象</strong>，所以我们没法让引用本身恒定不变。事实上，由于 C++ 语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解所有的引用又都算是常量。</p>
</blockquote>
<h5 id="初始化和对-const-的引用"><a class="header-anchor" href="#初始化和对-const-的引用">¶</a>初始化和对 <code>const</code> 的引用</h5>
<p>第 2.3.1 节 (P46) 提到，引用的类型与其所引用的对象的类型一致，<strong>但是有两个例外</strong>。</p>
<p>其中之一就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能 <strong>转换成</strong> 引用的类型即可。尤其，<strong>允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = i;       <span class="hljs-comment">// 允许将 const int&amp; 绑定到一个普通 int 对象上</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = <span class="hljs-number">42</span>;      <span class="hljs-comment">// 正确：r1 是一个常量引用</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r3 = r1 * <span class="hljs-number">2</span>;  <span class="hljs-comment">// 正常：r3 是一个常量引用</span><br><span class="hljs-keyword">int</span> &amp;r4 = r1 * <span class="hljs-number">2</span>;        <span class="hljs-comment">// 错误：r4 是一个普通的非常量引用</span><br></code></pre></div></td></tr></table></figure>
<p>要想理解这种例外情况的原因，最简单的办法是弄清楚当一个常量引用被绑定到另一种类型上时到底发生了什么：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">double</span> dval = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ri = dval;<br></code></pre></div></td></tr></table></figure>
<p>为了确保让 <code>ri</code> 绑定一个整数，编译器把上述代码变成了如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> temp = dval; <span class="hljs-comment">// 由双精度浮点数生成一个临时的整型常量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ri = temp;  <span class="hljs-comment">// 让 ri 绑定这个临时量</span><br></code></pre></div></td></tr></table></figure>
<ol>
<li>当 <code>ri</code> 绑定的是常量时，<code>ri</code> 绑定了一个 <strong>临时量</strong> (temporary) 对象。</li>
<li>当 <code>ri</code> 不是常量时，如果依旧执行了 1 中的操作，那么由于 <code>ri</code> 不是常量，就允许对 <code>ri</code> 赋值，这样会改变 <code>ri</code> 所引用对象的值。注意，<strong>此时绑定的对象是一个临时量而非 <code>dval</code></strong>。</li>
</ol>
<h5 id="对-const-的引用可能引用一个并非-const-的对象"><a class="header-anchor" href="#对-const-的引用可能引用一个并非-const-的对象">¶</a>对 <code>const</code> 的引用可能引用一个并非 <code>const</code> 的对象</h5>
<p>常量引用仅对引用可参与的操作做出了限定，<strong>对于引用的对象本身是不是一个常量未作限定</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">int</span> &amp;r1 = i;        <span class="hljs-comment">// 引用 ri 绑定对象 i</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = i;  <span class="hljs-comment">// r2 也绑定对象 i，但是不允许通过 r2 修改 i 的值</span><br>r1 = <span class="hljs-number">0</span>;             <span class="hljs-comment">// r1 并非常量，i 的值修改为 0</span><br>r2 = <span class="hljs-number">0</span>;             <span class="hljs-comment">// 错误：r2 是一个常量引用</span><br></code></pre></div></td></tr></table></figure>
<p>不允许通过 <code>r2</code> 修改 <code>i</code> 的值。但 <strong><code>i</code> 的值仍然允许通过其它途径修改，既可以直接给 <code>i</code> 赋值，也可以通过像 <code>r1</code> 一样绑定到 <code>i</code> 的其它引用来修改</strong>。</p>
<h4 id="2-4-2-指针和-const"><a class="header-anchor" href="#2-4-2-指针和-const">¶</a>2.4.2 指针和 <code>const</code></h4>
<p>类似于常量引用 (第 2.4.1 节，P54)，<strong>指向常量的指针</strong> (pointer to const) 不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.14</span>;      <span class="hljs-comment">// pi 是个常量，它的值不能改变</span><br><span class="hljs-keyword">double</span> *ptr = &amp;pi;           <span class="hljs-comment">// 错误：ptr 是一个普通指针</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *cptr = &amp;pi;    <span class="hljs-comment">// 正确：cptr 可以指向一个双精度常量</span><br>*cptr = <span class="hljs-number">42</span>;                  <span class="hljs-comment">// 错误：不能给 *cptr 赋值</span><br></code></pre></div></td></tr></table></figure>
<p>和对常量的引用一样，<strong>指向常量的指针也没有规定其所指的对象必须是一个常量</strong>。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其它途径改变。</p>
<blockquote>
<p><strong>笔记</strong>：</p>
<hr>
<p>对常量的引用的类型可以与被绑定的对象的类型不同，只要被绑定的对象的类型可以转换成对常量的引用的类型就可以。但 <strong>指向常量的指针不可以</strong>。</p>
</blockquote>
<h5 id="const-指针"><a class="header-anchor" href="#const-指针">¶</a><code>const</code> 指针</h5>
<p><strong>指针是对象而引用不是</strong>，因此允许把指针本身定为常量。<strong>常量指针</strong> (const pointer) <span style="border-bottom: 3px black double">必须初始化</span>，而且一但初始化完成，则它的值就不能再改变了。把 <code>*</code> 放在关键字 <code>const</code> 关键字之前用以说明指针是一个常量，<strong>即不变的是指针本身的值而非指向的那个指</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> errNumb = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> curErr = &amp;errNumb;   <span class="hljs-comment">// curErr 将一直指向 errNumb</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.14159</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *<span class="hljs-keyword">const</span> pip = &amp;pi;  <span class="hljs-comment">// pip 是一个指向常量对象的常量指针</span><br></code></pre></div></td></tr></table></figure>
<h5 id="2-4-2-节练习"><a class="header-anchor" href="#2-4-2-节练习">¶</a>2.4.2 节练习</h5>
<ul>
<li>
<p>练习 2.27：下面的哪些初始化是合法的？请说明原因。</p>
<p>(a) <code>int i = -1, &amp;r = 0;</code></p>
<p>(b) <code>int *const p2 = &amp;i2;</code></p>
<p>(c) <code>cosnt int i = -1, &amp;r = 0;</code></p>
<p>(d) <code>const int *const p3 = &amp;i2;</code></p>
<p>(e) <code>const int *p1 = &amp;i2;</code></p>
<p>(f) <code>const int &amp;const r2;</code></p>
<p>(g) <code>const int i2 = i; &amp;r = i</code></p>
<p>解：</p>
<p>(a) 不合法。因为引用必须绑定对象，而 <code>r</code> 绑定到了一个字面值。</p>
<p>(b) 不合法。因为指针可以指向：</p>
<ol>
<li>与指针类型严格相同类型的对象。</li>
<li>与指针类型相同的非常量对象。</li>
</ol>
<p>该指针类型为指向 <code>int</code> 型对象的 <code>int</code> 型的常量指针，而被指向的是对象的类型为指向 <code>int</code> 型常量的 <code>int</code> 型指针，不符合上述任一条件。</p>
<p>(c) 合法。原因参见第 2.4.2 节 (P55)。</p>
<p>(d) 合法。因为指向常量的指针未规定被指向的对象是否是常量，只要基本类型一至即可。</p>
<p>(e) 合法。理由同上。</p>
<p>(f) 不合法。因为：</p>
<ol>
<li>不存在“常量引用”。</li>
<li>引用必须初始化，而 <code>r2</code> 未被初始化。</li>
</ol>
<p>(g) 合法。</p>
</li>
<li>
<p>练习 2.28：说明下面的这些定义是什么意思，挑出其中不合法的。</p>
<p>(a) <code>int i, *const cp;</code></p>
<p>(b) <code>int *p1, *const p2;</code></p>
<p>(c) <code>const int ic, &amp;r = ic;</code></p>
<p>(d) <code>const int *const p3;</code></p>
<p>(e) <code>const int *p;</code></p>
<p>解：</p>
<p>(a) 定义一个 <code>int</code> 型变量和一个 <code>int</code> 型常量指针。该语句不合法，因为根据第 2.4.2 节 (P56)：常量指针必须初始化。</p>
<p>(b) 定义一个指向 <code>int</code> 型变量的 <code>int</code> 型指针，并默认初始化。同时定义一个定义一个指向 <code>int</code> 型变量的 <code>int</code> 型常量指针。该语句不合法，理由同上。</p>
<p>(c) 定义一个 <code>int</code> 型常量，同时定义一个 <code>int</code> 型的引用，并绑定到变量 <code>ic</code>。该语句不合法，因为常量对象必须初始化。</p>
<p>(d) 定义一个指向 <code>int</code> 型常量的 <code>int</code> 型常量指针。该语句不合法，常量指针必须被初始化。</p>
<p>(e) 定义一个指向 <code>int</code> 型常量的指针。该语句合法。</p>
</li>
<li>
<p>练习 2.29：假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的？请说明原因。</p>
<p>(a) <code>i = ic;</code></p>
<p>(b) <code>p1 = p3;</code></p>
<p>(c) <code>p1 = &amp;ic;</code></p>
<p>(d) <code>p3 = &amp;ic;</code></p>
<p>(e) <code>p2 = p1;</code></p>
<p>(f) <code>ic = *p3;</code></p>
<p>解：</p>
<p>(a) 合法。</p>
<p>(b) 不合法，因为 <code>p1</code> 是 <code>int</code> 型指针，而 <code>p3</code> 是指向 <code>int</code> 型常量对象的常量指针。类型不严格相同。</p>
<p>(c) 不合法，原因同 (b)。</p>
<p>(d) 不合法，<code>p3</code> 指向的对象不能再改变。</p>
<p>(e) 不合法，原因同 (d)。</p>
<p>(f) 不合法 <code>const</code> 对象内容不能重新指定。</p>
</li>
</ul>
<h4 id="2-4-3-顶层-const"><a class="header-anchor" href="#2-4-3-顶层-const">¶</a>2.4.3 顶层 <code>const</code></h4>
<ul>
<li><strong>顶层 <code>const</code></strong> (top-level const)：表示对象 (<strong>笔记：原文为“指针”，而下方又有文：更一般的，顶层 <code>const</code> 可以表示任意的对象是常量，这一点对任何数据类型都适用。</strong>) <span style="border-bottom: 3px black double">本身</span> 是个常量。</li>
<li><strong>底层 <code>const</code></strong> (low-level const)：表示指针指的对象是一个常量。</li>
</ul>
<p>当执行对象的拷贝操作时，常量是顶层 <code>const</code> 还是底层 <code>const</code> 区别明显。其中，<strong>顶层 <code>const</code> 不受什么影响</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p1 = &amp;i;       <span class="hljs-comment">// 不能改变 p1 的值，这是一个顶层 const</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">42</span>;        <span class="hljs-comment">// 不能改变 ci 的值，这是一个顶层 const</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p2 = &amp;ci;      <span class="hljs-comment">// 允许改变 p2 的值，这是一个底层 const</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p3 = p2; <span class="hljs-comment">// 靠右的 const 是顶层 const，靠左的是底层 const</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r = ci;        <span class="hljs-comment">// 用于声明引用的 const 都是底层 const</span><br><br>i = ci;   <span class="hljs-comment">// 正确：拷贝 ci 的值，ci 是一个顶层 const，对此操作无影响</span><br>p2 = p3;  <span class="hljs-comment">// 正确：p2 和 p3 指向的对象类型相同，p3 顶层 const 的部分不影响</span><br></code></pre></div></td></tr></table></figure>
<p>当执行拷贝操作时，<strong>拷入和拷出的对象必须具有相同的底层 <code>const</code> 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> *p = p3;          <span class="hljs-comment">// 错误：p3 包含底层 const 的定义，而 p 没有</span><br>p2 = p3;              <span class="hljs-comment">// 正确：p2 和 p3 都是底层 const</span><br>p2 = &amp;i;              <span class="hljs-comment">// 正确： int* 能转换成 const int*</span><br><span class="hljs-keyword">int</span> &amp;r = ci;          <span class="hljs-comment">// 错误：普通的 int&amp; 不能绑定到 int 常量上</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = i;    <span class="hljs-comment">// 正确： const int&amp; 可以绑定到一个普通 int 上</span><br></code></pre></div></td></tr></table></figure>
<h5 id="2-4-3-节练习"><a class="header-anchor" href="#2-4-3-节练习">¶</a>2.4.3 节练习</h5>
<ul>
<li>
<p>练习 2.30：对于下面的这些语句，请说明对象被声明成了顶层 <code>const</code> 还是底层 <code>const</code>？</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> v2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> v1 = v2;<br><span class="hljs-keyword">int</span> *p1 = &amp;v1, &amp;r1 = v1;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p2 = &amp;v2, *<span class="hljs-keyword">const</span> p3 = &amp;i, &amp;r2 = v2;<br></code></pre></div></td></tr></table></figure>
<p>解：</p>
<p><code>p2</code> 是底层 <code>const</code>；<code>p3</code> 的左侧 <code>const</code>  是底层 <code>const</code>， 右侧 <code>const</code> 是顶层 <code>const</code>。</p>
</li>
<li>
<p>练习 2.31：假设已有上一个练习中所做的那些声明，则下面的哪 些语句是合法的？请说明顶层 <code>const</code> 和底层 <code>const</code> 在每个例子中有何体现？</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">    r1 = v2;<br>    p1 = p2;<br>    p2 = p1;<br>    p1 = p3;<br>p2 = p3;<br></code></pre></div></td></tr></table></figure>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">r1 = v2;  <span class="hljs-comment">// 合法</span><br>p1 = p2;  <span class="hljs-comment">// 不合法，p1 为 int 型指针，p2 为指向 int 型常量的 int 型指针。p2 的 const 为底层 const。</span><br>p2 = p1;  <span class="hljs-comment">// 合法，根据第 2.4.3 节 (P58)，底层 const 限制为：当执行对象拷贝时，拷入和拷出的对象必须具有相同的底层 const 资格，可两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不能。因为 p2 是常量，p1 是非常量，所以可以兼容。</span><br>p1 = p3;  <span class="hljs-comment">// 不合法，根据同上，p1 是指向 int 型对象的指针，是非常量，p3 是指向 int 型常量的 int 型常量指针，类型不兼容。</span><br>p2 = p3;  <span class="hljs-comment">// 合法，顶层 const 不影响类型兼容性，而底层 const 是兼容的。</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="2-4-4-constexpr-和常量表达式"><a class="header-anchor" href="#2-4-4-constexpr-和常量表达式">¶</a>2.4.4 <code>constexpr</code> 和常量表达式</h4>
<p><strong>常量表达式</strong> (const expression) 是指值不会改变并且在编译过程就能得到计算结果的表达式。</p>
<p><strong>一个对象 (或表达式) 是不是常量表达式由它的数据类型和初始值共同决定</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> max_files = <span class="hljs-number">20</span>;         <span class="hljs-comment">// max_files 是常量表达式</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> limit = max_files + <span class="hljs-number">1</span>;  <span class="hljs-comment">// limit 是常量表达式</span><br><span class="hljs-keyword">int</span> staff_size = <span class="hljs-number">27</span>;              <span class="hljs-comment">// staff_size 不是常量表达式，尽管 staff_size 的初始值是个字面值常量，但由于它的数据类型只是一个普通 int 而非 const int，所以它不属于常量表达式。</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = get_size();        <span class="hljs-comment">// sz 不是常量表达式，尽管 sz 本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是常量表达式。</span><br></code></pre></div></td></tr></table></figure>
<h5 id="constexpr-变量"><a class="header-anchor" href="#constexpr-变量">¶</a><code>constexpr</code> 变量</h5>
<blockquote>
<p><strong>C++11</strong>：</p>
<hr>
<p>C++11 新标准规定，允许将变量声明为 <code>constexpr</code> 类型以便由编译器来验证变量的值是否是一个常量表达式。</p>
</blockquote>
<p>声明为 <code>constexpr</code> 的变量一定是一个 <strong>常量</strong>，<strong>而且必须用常量表达式初始化</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> mf = <span class="hljs-number">20</span>;           <span class="hljs-comment">// 20 是常量表达式</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> limit = mf + <span class="hljs-number">1</span>;    <span class="hljs-comment">// mf + 1 是常量表达式</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> sz = <span class="hljs-built_in">size</span>();       <span class="hljs-comment">// 只有当 size 是一个 constexpr 函数时才是一条正确的声明语句</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong>：</p>
<hr>
<p>尽管不能使用普通作为 <code>constexpr</code>  变量的初始值，但是正如第 6.5.2 节 (P214) 将要介绍的，新标准允许定义一种特殊的 <code>constexpr</code> 函数。这种函数应该 <strong>足够简单以使得编译时就可以计算其结果</strong>，这样就能用 <code>constexpr</code> 函数去初始化 <code>constexpr</code> 变量了。</p>
</blockquote>
<blockquote>
<p><strong>最佳实践</strong>：</p>
<hr>
<p>一般来说，如果你认定变量是一个常量表达式，那就把它声明成 <code>constexpr</code> 类型。</p>
</blockquote>
<blockquote>
<p><strong>笔记</strong>：<code>const</code> 和 <code>constexpr</code> 区别（<a href="https://www.zhihu.com/question/35614219/answer/63798713" target="_blank" rel="noopener">原贴</a>）</p>
<hr>
<ol>
<li>
<p>修饰对象：</p>
<ul>
<li><code>const</code> 并未区分出编译期常量和运行期常量，<strong>只保证了运行时不直接被修改（但这个东西仍然可能是个动态变量）</strong>。</li>
<li><code>constexpr</code> 限定在了编译期常量。</li>
</ul>
</li>
<li>
<p>修饰函数：</p>
<p><code>constexpr</code> 修饰的函数，<strong>返回值不一定是编译期常量</strong>：</p>
 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, foo(5)&gt; arr; <span class="hljs-comment">// OK</span><br>    <br>    foo(i); <span class="hljs-comment">// Call is Ok</span><br>    <br>    <span class="hljs-comment">// But...</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, foo(i)&gt; arr1; <span class="hljs-comment">// Error</span><br>   <br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>如果其传入的参数可以在编译时期计算出来，那么这个函数就会产生编译时期的值。</li>
<li>如果传入的参数如果不能在编译时期计算出来，那么 <code>constexpr</code> 修饰的函数就和普通函数一样了。</li>
</ul>
</li>
</ol>
</blockquote>
<h5 id="字面值类型"><a class="header-anchor" href="#字面值类型">¶</a>字面值类型</h5>
<p>到目前为止接触过的数据类型中，<strong>算术类型、引用和指针都属于字面值类型 (literal type)</strong>。</p>
<ul>
<li>
<p><strong>自定义类 <code>Sales_item</code>、IO 库、<code>string</code> 类型则不属于字面值类型，<span style="border-bottom: 3px black double">也就不能被定义成 <code>constexpr</code> </span></strong>。</p>
</li>
<li>
<p><strong>尽管指针和引用都能定义成 <code>constexpr</code>，但它们的初始值却受到严格限制：一个 <code>constexpr</code> 指针的初始值必须是 <code>nullptr</code> 或者 <code>0</code>，或者是存储于某个固定地址中的对象</strong>。</p>
</li>
<li>
<p><strong>函数体内定义的</strong> 变量一 般来说并非存放在固定地址中，因此 <code>constexpr</code> 指针 <strong>不能</strong> 指向这样的变量。(第 6.1.1 节，P184)</p>
</li>
<li>
<p>因为允许函数定义一类有效范围超出函数本身的变量 (第 6.1.1 节，P185)，这类变量和定义在函数体之外的变量一样也有固定地址。因此，<code>constexpr</code> 引用能绑定到这样的变量上，<code>constexpr</code> 指针也能指向这样的变量。</p>
</li>
</ul>
<h5 id="指针和-constexpr"><a class="header-anchor" href="#指针和-constexpr">¶</a>指针和 <code>constexpr</code></h5>
<p>在 <code>constexpr</code> 声明中如果定义了一个指针，<strong>限定符 <code>constexpr</code> 仅对指针有效，与指针所指的对象无关</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = <span class="hljs-literal">nullptr</span>;       <span class="hljs-comment">// p 是一个指向整型常量的指针</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> *q = <span class="hljs-literal">nullptr</span>;   <span class="hljs-comment">// q 是一个指向整型的 **常量指针**</span><br></code></pre></div></td></tr></table></figure>
<p><code>cosntexpr</code> 指针既可以指向常量也可以指向一个非常量：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> *np = <span class="hljs-literal">nullptr</span>;    <span class="hljs-comment">// np 是一个指向整数的常量指针，其值为空</span><br><span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;           <span class="hljs-comment">// i 的类型是整型常量</span><br><span class="hljs-comment">// i 和 j 必须定义在函数体之外</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = &amp;i;    <span class="hljs-comment">// p 是常量指针，指向整型常量 i</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> *p1 = &amp;j;         <span class="hljs-comment">// p1 是常量指针，指向整数 j</span><br></code></pre></div></td></tr></table></figure>
<h5 id="2-4-4-节练习"><a class="header-anchor" href="#2-4-4-节练习">¶</a>2.4.4 节练习</h5>
<ul>
<li>
<p>练习 2.32：下面的代码是否合法？如果非法，请设法将其修改正确。</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> null = <span class="hljs-number">0</span>, *p = null;<br></code></pre></div></td></tr></table></figure>
<p>解：不合法。应为：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> null = <span class="hljs-number">0</span>, *p = &amp;null;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="2-5-处理类型"><a class="header-anchor" href="#2-5-处理类型">¶</a>2.5 处理类型</h3>
<h4 id="2-5-1-类型别名"><a class="header-anchor" href="#2-5-1-类型别名">¶</a>2.5.1 类型别名</h4>
<p>有两种方法可用于定义类型别名：</p>
<ul>
<li>
<p>传统的方法是使用关键字 <code>typede</code>：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> wages;    <span class="hljs-comment">// wages 是 double 的同义词</span><br><span class="hljs-keyword">typedef</span> wage base, *p;   <span class="hljs-comment">// base 是 double 的同义词，p 是 double* 的同义词</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>使用 <strong>别名声明</strong> (alias declaration) 来定义类型的别名：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> SI = Sales_item;   <span class="hljs-comment">// SI 是 Sales_item 的同义词</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><strong>C++11</strong>：</p>
<hr>
<p>别名声明是新标准规定的一种新的定义类型别名的方法。</p>
</blockquote>
<h5 id="指针、常量和类型别名"><a class="header-anchor" href="#指针、常量和类型别名">¶</a>指针、常量和类型别名</h5>
<p>如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型 <code>pstring</code>，它实际上是类型 <code>char*</code> 的别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> *pstring;<br><span class="hljs-keyword">const</span> pstring cstr = <span class="hljs-number">0</span>;  <span class="hljs-comment">// cstr 是指向 char 的常量指针</span><br><span class="hljs-keyword">const</span> pstring *ps;       <span class="hljs-comment">// ps 是一个指针，它的对象是指向 char 的常量指针</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>上述两条声明语句的基本数据类型都是 <code>const pstring</code>，和过去一样，<code>const</code> <strong>是对给定类型的修饰</strong>。<code>pstring</code> 实际上是指向 <code>char</code> 的指针，因此，<strong><span style="border-bottom: 3px black double"><code>const pstring</code> 就是指向 <code>char</code> 的常量指针，而非指向常量字符的指针</span></strong>。</p>
</blockquote>
<h4 id="2-5-2-auto-类型说明符"><a class="header-anchor" href="#2-5-2-auto-类型说明符">¶</a>2.5.2 <code>auto</code> 类型说明符</h4>
<p><code>auto</code> 类型说明符能让编译器替我们去分析表达式所属的类型。<strong>显然，<code>auto</code> 定义的变量必须有初始值</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// 由 val1 和 val2 相加的结果可以推断出 item 的类型</span><br><span class="hljs-keyword">auto</span> item = val1 + val2;  <span class="hljs-comment">// item 初始化为 val1 和 val2 相加的结果</span><br></code></pre></div></td></tr></table></figure>
<p>使用 <code>auto</code> 也能在一条语句中声明多个变量。因为<strong>一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>, *p = &amp;i;      <span class="hljs-comment">// 正确：i 是整数、p 是整型指针</span><br><span class="hljs-keyword">auto</span> sz = <span class="hljs-number">0</span>, pi = <span class="hljs-number">3.14</span>;   <span class="hljs-comment">// 错误：sz 和 pi 的类型不一致</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>C++11</strong>：</p>
<hr>
<p><code>auto</code> 类型</p>
</blockquote>
<h5 id="复合类型、常量和-auto"><a class="header-anchor" href="#复合类型、常量和-auto">¶</a>复合类型、常量和 <code>auto</code></h5>
<p>编译器推断出来的 <code>auto</code> 类型有时候和初始值的类型 <strong>并不完全一样</strong>，编译器会适当地改变结果类型使其更符合初始化规则：</p>
<ol>
<li>
<p>使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为 <code>auto</code> 的类型：</p>
 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, &amp;r = i;<br><span class="hljs-keyword">auto</span> a = r;         <span class="hljs-comment">// a 是一个整数 (r 是 i 的别名，而 i 是一个整数)</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><strong><code>auto</code> 一般会忽略掉 <span style="border-bottom: 3px black double">顶层</span> <code>const</code> (第 2.4.3 节，P57)，同时底层 <code>const</code> 则会保留下来</strong>：</p>
 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = i, &amp;cr = ci;<br><span class="hljs-keyword">auto</span> b = ci;    <span class="hljs-comment">// b 是一个整数 (ci 的顶层 const 特性被忽略掉了)</span><br><span class="hljs-keyword">auto</span> c = cr;    <span class="hljs-comment">// c 是一个整数 (cr 是 ci 的别名，ci 本身是一个顶层 const)</span><br><span class="hljs-keyword">auto</span> d = &amp;i;    <span class="hljs-comment">// d 是一个整型指针 (整数的地址就是指向整数的指针)</span><br><span class="hljs-keyword">auto</span> e = &amp;ci;   <span class="hljs-comment">// e 是一个指向整数指针 (对常量对象取地址是一种底层 const)</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>如果希望推断出的 <code>auto</code> 类型是一个顶层 <code>const</code>，需要明确指出：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> f = ci;  <span class="hljs-comment">// ci 的推演类型是 int，f 是 const int</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>笔记</strong>：</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = i, &amp;cr = ci;<br><span class="hljs-keyword">auto</span> b = ci;<br><span class="hljs-keyword">auto</span> c = cr;<br></code></pre></div></td></tr></table></figure>
<p>上面的代码这样理解：</p>
<ul>
<li><code>ci</code> 是 <code>int</code> 型常量，将它赋给 <code>b</code> 后，<code>b</code> 的推断类型为 <code>const int</code>，且此 <code>const</code> 是顶层 <code>const</code> (第 2.4.3 节，P57)。然而根据每 2.5.2 节 (P62)：<code>auto</code> 一般会忽略掉顶层 <code>const</code>。所以 <code>b</code> 的 <code>const</code> 被忽略掉了。</li>
<li><code>cr</code> 是绑定到 <code>int</code> 型常量 <code>ci</code> 上的引用。由于引用即别名 (第 2.3.1 节，P46)，<code>cr</code> 是 <code>ci</code> 的别名，所以 <code>cr</code> 与  <code>ci</code> 类型应当严格相同，都是 <code>const int</code>。据上一条笔记，<code>c</code> 的顶层 <code>const</code> 也被忽略掉了，所以 <code>c</code> 也是 <code>int</code> 型对象。</li>
</ul>
</blockquote>
</li>
<li>
<p>还可以将引用的类型设为 <code>auto</code>，此时原来的初始化规则仍然适用：</p>
 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> &amp;g = ci;         <span class="hljs-comment">// g 是一个整型常量引用，绑定到 ci</span><br><span class="hljs-keyword">auto</span> &amp;h = <span class="hljs-number">42</span>;         <span class="hljs-comment">// 错误：不能为非常量引用绑定字面值</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;j = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 正确：可以为常量引用绑定字面值</span><br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h5 id="2-5-2-节练习"><a class="header-anchor" href="#2-5-2-节练习">¶</a>2.5.2 节练习</h5>
<ul>
<li>
<p>练习 2.33：利用本节定义的变量，判断下列语句的运行结果。</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">a = <span class="hljs-number">42</span>; b = <span class="hljs-number">42</span>; c= <span class="hljs-number">42</span>;<br>d = <span class="hljs-number">42</span>; e = <span class="hljs-number">42</span>; g = <span class="hljs-number">42</span>;<br></code></pre></div></td></tr></table></figure>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++">a = <span class="hljs-number">42</span>;     <span class="hljs-comment">// a 是整型对象，值为 42</span><br>b = <span class="hljs-number">42</span>;     <span class="hljs-comment">// b 是整型对象，值为 42。ci 的顶层 const 特性被忽略了</span><br>c = <span class="hljs-number">42</span>;     <span class="hljs-comment">// c 是整型对象，值为 42。cr 是 ci 的别名，而 ci 本身是一个顶层 const，且它的顶层 const 被忽略掉了</span><br>d = <span class="hljs-number">42</span>;     <span class="hljs-comment">// 错误，d 是指向整型对象的指针，而 42 是整型字面量，类型不同</span><br>e = <span class="hljs-number">42</span>;     <span class="hljs-comment">// 错误，理由同上</span><br>g = <span class="hljs-number">42</span>;     <span class="hljs-comment">// 错误，g 是对 int 型常量的引用，不能改变它所引用的对象的值</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 2.34：基于上一个练习中的变量和语句编写一段程序，输出赋值前后变量的内容，你刚才的推断正确吗？如果不对，请反复研读本节的示例直到你明白错在何处为止。</p>
<p>解：参见练习 2.33 的解。</p>
</li>
<li>
<p>练习 2.35：判断下列定义推断出的类型是什么，然后编写程序进行验证。</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">auto</span> j = i; <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;k = i; <span class="hljs-keyword">auto</span> *p = &amp;i;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> j2 =i, &amp;k2 = i;<br></code></pre></div></td></tr></table></figure>
<p>解：</p>
<ul>
<li>
<p><code>j</code> 为整型常量。</p>
<p>验证：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;typeinfo&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br>    <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">auto</span> j = i;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(j).name() &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出：i</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>k</code> 是整型常量 <code>i</code> 的引用。</p>
<p>验证：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;typeinfo&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;k = i;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(k).name() &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出：i</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>p</code> 是指向整型常量 <code>i</code> 的指针。</p>
<p>验证：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;typeinfo&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">auto</span> *p = &amp;i;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(p).name() &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出：PKi</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>j2</code> 是整型常量，初始值为 42。</p>
<p>验证：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;typeinfo&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> j2 = i;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(j2).name() &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出：i</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>k2</code> 是整型常量 <code>i</code> 的常量引用。</p>
<p>验证：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;typeinfo&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;k2 = i;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(k2).name() &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出：i</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="2-5-2-decltype-类型指示符"><a class="header-anchor" href="#2-5-2-decltype-类型指示符">¶</a>2.5.2 <code>decltype</code> 类型指示符</h4>
<blockquote>
<p><strong>C++11</strong>：</p>
<hr>
<p>有时会遇到这种情况：<strong>希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量</strong>。为了满足这一要求，C++11 新标准引入了第二种类型说明符 <code>decltype</code>。</p>
</blockquote>
<p><code>decltype</code> 的作用的选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却 <strong>不实际计算表达式的值</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">decltype</span>(f()) sum = x; <span class="hljs-comment">// sum 的类型就是函数 f 的返回顾类型</span><br></code></pre></div></td></tr></table></figure>
<p><strong>如果 <code>decltype</code> 使用的表达式是一个变量，则 <code>decltype</code> 返回该变量的类型 (包括 <span style="border-bottom: 3px black double">顶层 <code>const</code> 和引用</span> 在内)</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">0</span>, &amp;cj = ci;<br><span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>;           <span class="hljs-comment">// x 的类型是 const int</span><br><span class="hljs-keyword">decltype</span>(cj) y = x;           <span class="hljs-comment">// y 的类型是 const int&amp;，y 绑定到变量 x</span><br><span class="hljs-keyword">decltype</span>(cj) z;               <span class="hljs-comment">// 错误：z 是一个引用，必须初始化</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>引用从来都作为其所指对象的同义词出现，只有用在 <code>decltype</code> 处是一个例外。</p>
</blockquote>
<h5 id="decltype-和引用"><a class="header-anchor" href="#decltype-和引用">¶</a><code>decltype</code> 和引用</h5>
<p><strong><span style="border-bottom: 3px black double">如果表达式的内容是解引用操作，则 <code>decltype</code> 将得到引用类型：</span></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>, *p = &amp;i, &amp;r = i;<br><span class="hljs-keyword">decltype</span>(r + <span class="hljs-number">0</span>) b;      <span class="hljs-comment">// 正确：加法的结果是 int，因此 b 是一个 (未初始化的) int</span><br><span class="hljs-keyword">decltype</span>(*p) c;         <span class="hljs-comment">// 错误：c 是 int&amp;，必须初始化</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>笔记</strong>：</p>
<hr>
<p>根据 2.3.2 节 (P48)：对指针解引用会得出所指的对象。由此可看出对指针解引用得到的是一个引用。</p>
</blockquote>
<p><strong>如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果给变量加上了一层<span style="border-bottom: 3px black double">或多层括号</span>，编译器就会把它当成是一个表达式。<span style="border-bottom: 3px black double">变量是一种可以作为赋值语句左值的特殊表达式，所以这样的 <code>decltype</code> 就会得到引用类型</span></strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">// decltype 的表达式如果是加上了括号的变量，结果将是引用</span><br><span class="hljs-keyword">decltype</span>((i)) d;  <span class="hljs-comment">// 错误：d 是 int&amp;，必须初始化</span><br><span class="hljs-keyword">decltype</span>(i) e;    <span class="hljs-comment">// 正确：e 是一个 (未初始化的) int</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>切记</strong>：</p>
<hr>
<p><code>decltype((variable))</code> (注意是双层括号) 的结果永远是引用，而 <code>decltype(variable)</code> 结果只有当 <code>variable</code> 本身就是一个引用时才是引用。</p>
</blockquote>
<h5 id="2-5-3-节练习"><a class="header-anchor" href="#2-5-3-节练习">¶</a>2.5.3 节练习</h5>
<ul>
<li>
<p>练习 2.36：关于下面的代码，请指出每一个变量的类型以及程序结束时它们各自的值。</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">decltype</span>(a) c = a;<br><span class="hljs-keyword">decltype</span>((b)) d = a;<br>++c;<br>++d;<br></code></pre></div></td></tr></table></figure>
<p>解：</p>
<ul>
<li><code>a</code>、<code>b</code> 和 <code>c</code> 都为 <code>int</code> 型对象，<code>d</code> 为绑定到 <code>int</code> 型对象 <code>a</code> 上的 <code>int</code> 型引用。</li>
<li>运行结束后 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 的值都为 4。</li>
</ul>
</li>
<li>
<p>练习 2.37：赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，<strong>如果 <code>i</code> 是 <code>int</code>，则表达式 <code>i = x</code> 的类型是 <code>int&amp;</code></strong>。根据这一特点，请指出下面的代码中每一个变量的类型和值。</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">decltype</span>(a) c = a;<br><span class="hljs-keyword">decltype</span>(a = b) d = a;<br></code></pre></div></td></tr></table></figure>
<p>解：</p>
<ul>
<li><code>a</code> <code>b</code> 和 <code>c</code> 为 <code>int</code> 型对象，<code>d</code> 为绑定到 <code>int</code> 型对象 <code>a</code> 的 <code>int</code> 型引用。</li>
<li><code>a</code>、<code>c</code> 和 <code>d</code> 的值为 3，<code>b</code> 的值为 4。</li>
</ul>
</li>
<li>
<p>练习 2.38：说明由 <code>decltype</code> 指定类型和由 <code>auto</code> 指定类型有何区别。请举出一个例子，<code>decltype</code> 指定的类型与 <code>auto</code> 指定的类型一样；再举一个例子，<code>decltype</code> 指定的类型与 <code>auto</code> 指定的类型不一样。</p>
<p>解：</p>
<p>区别：</p>
<ol>
<li>
<p>两者处理顶层 <code>const</code> 方式不同：</p>
 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> a = ci;        <span class="hljs-comment">// a 是 int 型对象，顶层 const 被忽略掉了</span><br><span class="hljs-keyword">decltype</span>(ci) b = <span class="hljs-number">1</span>; <span class="hljs-comment">// b 是 int 型常量，顶层 const 未忽略</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>处理表达式方式不同：</p>
 <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>, &amp;cr = i;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, *p = &amp;a;<br><span class="hljs-keyword">auto</span> j = i + <span class="hljs-number">0</span>;       <span class="hljs-comment">// j 推断为 int 型对象</span><br><span class="hljs-keyword">decltype</span>(cr) k = a;   <span class="hljs-comment">// k 为绑定到 int 型对象 a 上的常量引用。表达式本身是一个引用，那么 decltype 返回对应类型的引用类型</span><br><br><span class="hljs-comment">// 如果 decltype 使用的表达式的结果类型可以作为一条赋值语句的左值，那么 decltype 返回一个引用类型，例如解引用操作和变量加括号的类型</span><br><span class="hljs-keyword">decltype</span>(*p) c = a;   <span class="hljs-comment">// c 为绑定到 int 型对象 a 上的引用</span><br><span class="hljs-keyword">decltype</span>((a)) d = a;  <span class="hljs-comment">// d 为绑定到 int 型对象 a 上的引用</span><br><span class="hljs-keyword">decltype</span>((i)) e = a;  <span class="hljs-comment">// d 为绑定到 int 型对象 a 上的常量引用</span><br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<p>其它情况相同，如：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><br><span class="hljs-comment">// auto 和 decltype 相同的情况</span><br><span class="hljs-keyword">auto</span> j = j;<br><span class="hljs-keyword">decltype</span>(i) k = i;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="2-6-自定义数据结构"><a class="header-anchor" href="#2-6-自定义数据结构">¶</a>2.6 自定义数据结构</h3>
<h4 id="2-6-1-定义-Sales-data-类型"><a class="header-anchor" href="#2-6-1-定义-Sales-data-类型">¶</a>2.6.1 定义 <code>Sales_data</code> 类型</h4>
<p><code>Sales_data</code> 初步定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo;<br>    <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><strong>类体右侧的表示结束的花括号后必须写一个分号</strong>。</p>
<blockquote>
<p><strong>提示</strong>：</p>
<hr>
<p>这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span> &#123;</span> <span class="hljs-comment">/* ... */</span> &#125; accum, trans, *salesptr;<br><br><span class="hljs-comment">// 与上一条语句等价，但可能更好一些</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span> &#123;</span> <span class="hljs-comment">/* ... */</span> &#125;;<br>Sales_data accum, trans, *salesptr;<br></code></pre></div></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>C++11</strong>：</p>
<hr>
<p>C++11 新标准规定，可以为数据成员提供一个 <strong>类内初始值</strong> (in-class initializer)。</p>
</blockquote>
<h5 id="2-6-1-节练习"><a class="header-anchor" href="#2-6-1-节练习">¶</a>2.6.1 节练习</h5>
<ul>
<li>
<p>练习 2.39：编译下面的程序观察其运行结果，注意，如果忘记写类定义体后面的分号会发生什么情况？记录下相关信息，以后可能会有用。</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span> &#123;</span> <span class="hljs-comment">/* 此处为空 */</span> &#125; <span class="hljs-comment">// 注意：没有分号</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>解：</p>
<p>编译输出：</p>
  <figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss">.\prog1.cc:<span class="hljs-number">1</span>:<span class="hljs-number">34</span>: <span class="hljs-built_in">error</span>: expected ';' after <span class="hljs-keyword">struct</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">Foo</span> &#123; <span class="hljs-comment">/* 此处为空 */</span> &#125;<br>                             ^<br>                             ;<br><span class="hljs-number">1</span> <span class="hljs-built_in">error</span> generated.<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>练习 2.40：根据自己的理解写出 <code>Sales_data</code> 类，最好与书中的例子有所区别。</p>
<p>解：</p>
  <figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo = <span class="hljs-string">""</span>;<br>    <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="2-6-2-使用-Sales-data-类"><a class="header-anchor" href="#2-6-2-使用-Sales-data-类">¶</a>2.6.2 使用 <code>Sales_data</code> 类</h4>
<h5 id="添加两个-Sales-data-对象"><a class="header-anchor" href="#添加两个-Sales-data-对象">¶</a>添加两个 <code>Sales_data</code> 对象</h5>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Sales_data.h"</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Sales_data data1, data2;<br>    <span class="hljs-comment">// 读入 data1 和 data2 的代码</span><br>    <span class="hljs-comment">// 检查 data1 和 data2 的 ISBN 是否相同的代码</span><br>    <span class="hljs-comment">// 如果相同，求 data1 和 data2 的总和</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h5 id="Sales-data-对象读入数据"><a class="header-anchor" href="#Sales-data-对象读入数据">¶</a><code>Sales_data</code> 对象读入数据</h5>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">double</span> price = <span class="hljs-number">0</span>; <span class="hljs-comment">// 书的单价，用于计算销售收入</span><br><span class="hljs-comment">// 读入 1 笔交易：ISBN、销售数量、单价</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; data1.bookNo &gt;&gt; data1.units_sold &gt;&gt; price;<br><span class="hljs-comment">// 计算销售收入</span><br>data1.revenue = data1.units_sold * price;<br><span class="hljs-comment">// 读入第 2 笔交易</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; data2.bookNo &gt;&gt; data2.units_sold &gt;&gt; price;<br>data2.revenue = data2.units_sold * price;<br></code></pre></div></td></tr></table></figure>
<h5 id="输出两个-Sales-data-对象的和"><a class="header-anchor" href="#输出两个-Sales-data-对象的和">¶</a>输出两个 <code>Sales_data</code> 对象的和</h5>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(data1.bookNo == data2.bookNo) &#123;<br>    <span class="hljs-keyword">unsigned</span> totalCnt = data1.units_sold + data2.units_sold;<br>    <span class="hljs-keyword">double</span> totalRevenue = data1.revenue + data2.revenue;<br>    <span class="hljs-comment">// 输出：ISBN、总销售量、总销售额、平均价格</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; data1.bookNo &lt;&lt; <span class="hljs-string">""</span> &lt;&lt; totalCnt<br>              &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; totalRevenue &lt;&lt; <span class="hljs-string">" "</span>;<br>    <span class="hljs-keyword">if</span>(totalCnt != <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; totalRevenu / totalCnt &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" (no sales) "</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 标示成功</span><br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 两笔交易的 ISBN 不一样</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Data must refer to the same ISBN"</span><br>              &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 标示失败</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h5 id="2-6-2-节练习"><a class="header-anchor" href="#2-6-2-节练习">¶</a>2.6.2 节练习</h5>
<ul>
<li>
<p>练习 2.41：使用你自己的 <code>Sales_data</code> 类重写 1.5.1 节 (P20)、1.5.2 节 (P21) 和 1.6 节 (P22) 的练习。眼下先把 <code>Sales_data</code> 类的定义和 <code>main</code> 函数放在同一个文件里。</p>
<p>解：略。</p>
</li>
</ul>
<h4 id="2-6-3-编写自己的头文件"><a class="header-anchor" href="#2-6-3-编写自己的头文件">¶</a>2.6.3 编写自己的头文件</h4>
<p>尽管如第 19.7 节 (P754) 所讲 <strong>可以在函数体内定义类</strong>，但是这样的类毕竟受到了一些限制。所以，<strong>类一般都不定义在函数体内</strong>。</p>
<p>为了确保各个文件中类的定义一致，<strong>类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。</strong></p>
<p>头文件通常包含那些只能被定义一次的实体，如类、<code>const</code> 和 <code>constexpr</code> 变量 (参见第 2.4节，P54) 等。</p>
<h5 id="预处理器概述"><a class="header-anchor" href="#预处理器概述">¶</a>预处理器概述</h5>
<p><strong>预处理器</strong> (preprocessor) 是在编译之前执行的一段程序，可以部分地改变我们所写的程序。</p>
<p>C++ 程序会用到的一项预处理功能是 <strong>头文件保护符</strong> (header guard)，头文件保护符依赖于预处理变量 (第 2.3.2 节，P48)。</p>
<p>预处理变量有两种状态：</p>
<ul>
<li>已定义状态：<code>#define</code> 指令把一个名字设定为预处理变量；当且仅当变量已定义时 <code>#ifdef</code> 为真。</li>
<li>未定义状态。当且仅当变量未定义时 <code>#ifndef</code> 为真。</li>
</ul>
<p>一旦检查结果为真，则执行后续操作直到遇到 <code>#endif</code> 指令为止：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SALES_DATA_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SALES_DATA_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span> &#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo;<br>    <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>预处理变量无视 C++ 语言中关于作用域的规则。</p>
</blockquote>
<blockquote>
<p><strong>最佳实践</strong>：</p>
<hr>
<p>头文件即使 (目前还) 没有被包含在任何其它头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要。</p>
</blockquote>
<h5 id="2-6-3-节练习"><a class="header-anchor" href="#2-6-3-节练习">¶</a>2.6.3 节练习</h5>
<ul>
<li>
<p>练习 2.42：根据你自己的理解重写一个 <code>Sales_data.h</code> 头文件，并以此为基础重做 2.6.2 节 ( 第 67 页) 的练习。</p>
<p>解：略。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>python3 创建带虚拟环境的 Windows 服务程序</title>
    <url>/2020/02/10/python3-%E5%88%9B%E5%BB%BA%E5%B8%A6%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84-Windows-%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1>python3 创建带虚拟环境的 Windows 服务程序</h1>
<ol>
<li>
<p>以 <strong>管理员</strong> 权限<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="pywin32 包需要访问注册表，所以 所有 必须使用管理员权限进行。
">[1]</span></a></sup>打开“命令提示符”或 PowerShell，并 <code>cd</code> 至项目根目录。</p>
</li>
<li>
<p>在项目目录建立虚拟环境<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="必须使用 Python 自带的 venv 模块，不能使用 virtualenv。
">[2]</span></a></sup>：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">python <span class="hljs-literal">-m</span> venv .<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>激活虚拟环境：</p>
 <figure class="highlight bat"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bat"><span class="hljs-comment">rem 命令提示符</span><br>.\Scripts\activate.bat<br></code></pre></div></td></tr></table></figure>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">.\Scripts\activate.ps1 <span class="hljs-comment"># powershell</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>安装 pywin32。</p>
</li>
<li>
<p>执行 post-install 脚本<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="不执行此脚本服务无法启动。卸载脚本为 python .\Scripts\pywin32_postinstall.py -uninstall
">[3]</span></a></sup>：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">python .\Scripts\pywin32_postinstall.py <span class="hljs-literal">-install</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>将 <em>\Lib\site-packages\win32\pythonservice.exe</em> 复制到 <em>myvenv\Scripts\pythonservice.exe</em> 。<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="猜测可以跳过此步，pythonservice.exe 应当与服务类中的 _exe_name_ 所指向路径相同即可，未测试。
">[4]</span></a></sup></p>
</li>
<li>
<p>编写服务类及服务管理器：</p>
 <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Service.py</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QBTransportService</span><span class="hljs-params">(win32serviceutil.ServiceFramework)</span>:</span><br>    _svc_name_ = <span class="hljs-string">'服务名称（简称）'</span><br>    _svc_display_name_ = <span class="hljs-string">"服务显示名称"</span><br>    _svc_description_ = <span class="hljs-string">"服务描述"</span><br>    <span class="hljs-comment"># _svc_deps = None # 依赖哪些服务（服务名称）</span><br>    <span class="hljs-comment"># _exe_args = None # 服务参数        </span><br><br>    <span class="hljs-comment"># VIRTUAL_ENV 环境变量并不是在所有阶段都存在，所以需要判断。</span><br>    <span class="hljs-comment"># StackOverflow 上说是 _exe_path_，经测试无效，多次尝试后确定应是 _exe_name_。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> hasattr(sys, <span class="hljs-string">'frozen'</span>) <span class="hljs-keyword">and</span> <span class="hljs-string">'VIRTUAL_ENV'</span> <span class="hljs-keyword">in</span> os.environ:<br>        _exe_name_ = os.path.join(*[os.environ[<span class="hljs-string">'VIRTUAL_ENV'</span>], <span class="hljs-string">'Scripts'</span>, <span class="hljs-string">'pythonservice.exe'</span>])<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, args)</span>:</span><br>        win32serviceutil.ServiceFramework.__init__(self, args)<br>        self.hWaitStop = win32event.CreateEvent(<span class="hljs-literal">None</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">None</span>)<br>        self.isAlive = <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SvcDoRun</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># 在此运行主要任务。</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">pass</span><br><br>        <span class="hljs-comment"># 若在上面启动了一个线程，需要进行 join，否则服务立即退出。</span><br>        <span class="hljs-comment"># self._thread.join()</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SvcStop</span><span class="hljs-params">(self)</span>:</span><br>        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)<br><br>        <span class="hljs-comment"># 执行一些清理工作。</span><br><br>        win32event.SetEvent(self.hWaitStop)<br>        self.isAlive = <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-keyword">if</span> len(sys.argv) == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">try</span>:<br>            servicemanager.Initialize()<br>            servicemanager.PrepareToHostSingle(QBTransportService)<br>            servicemanager.StartServiceCtrlDispatcher()<br>        <span class="hljs-keyword">except</span> win32service.error <span class="hljs-keyword">as</span> details:<br>            <span class="hljs-keyword">if</span> details == winerror.ERROR_FAILED_SERVICE_CONTROLLER_CONNECT:<br>                win32serviceutil.usage()<br>    <span class="hljs-keyword">else</span>:<br>        win32serviceutil.HandleCommandLine(QBTransportService)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>安装并启动服务：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">python .\Service.py install<br>python .\Service.py start<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>附：服务管理。</p>
 <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: UTF8 -*-</span><br><span class="hljs-comment">#</span><br><span class="hljs-keyword">import</span> win32service<br><span class="hljs-keyword">import</span> win32con<br><span class="hljs-keyword">import</span> time, sys<br><span class="hljs-keyword">import</span> datetime<br>reload(sys)<br>sys.setdefaultencoding(<span class="hljs-string">"utf8"</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceManager</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-string">"""管理window服务的类"""</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        name: 服务的名称</span><br><span class="hljs-string">        """</span><br>        self.name = name<br>        <br>        <span class="hljs-comment">#启动或停止服务时等待操作成功等待时间</span><br>        self.wait_time = <span class="hljs-number">0.5</span><br>        <span class="hljs-comment">#启动或停止服务时最大等待时间，超过时返回超时提示</span><br>        self.delay_time = <span class="hljs-number">10</span><br>        self.scm = win32service.OpenSCManager(<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, win32service.SC_MANAGER_ALL_ACCESS)<br><br>        <span class="hljs-keyword">if</span> self.is_exists():<br>            <span class="hljs-keyword">try</span>:<br>                self.handle = win32service.OpenService(self.scm, self.name, win32service.SC_MANAGER_ALL_ACCESS)<br>            <span class="hljs-keyword">except</span> Exception, e:<br>                self.log(e)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">print</span> <span class="hljs-string">'服务 %s 没有安装'</span>.encode(<span class="hljs-string">'gbk'</span>) % self.name<br>            <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_stop</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""检查服务是否停止"""</span><br>        flag = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> self.handle:<br>                ret = win32service.QueryServiceStatus(self.handle)<br>                flag = ret[<span class="hljs-number">1</span>] != win32service.SERVICE_RUNNING<br>        <span class="hljs-keyword">except</span> Exception, e:<br>            self.log(e)<br>        <span class="hljs-keyword">return</span> flag<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""开启服务"""</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> self.handle:<br>                win32service.StartService(self.handle, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">except</span> Exception, e:<br>            self.log(e)<br>        status_info = win32service.QueryServiceStatus(self.handle)<br><br>        <span class="hljs-keyword">if</span> status_info[<span class="hljs-number">1</span>] == win32service.SERVICE_RUNNING:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">'启动服务%s成功'</span>.encode(<span class="hljs-string">'gbk'</span>) % self.name<br>        <span class="hljs-keyword">elif</span> status_info[<span class="hljs-number">1</span>] == win32service.SERVICE_START_PENDING:<br>            <span class="hljs-comment">#如果服务正在启动中则延迟返回启动信息，直到启动成功,或返回启动时间过长信息</span><br>            start_time = datetime.datetime.now()<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-keyword">if</span> (datetime.datetime.now() - start_time).seconds &gt; self.delay_time:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">'启动服务%s时间太长'</span>.encode(<span class="hljs-string">'gbk'</span>) % self.name<br><br>                time.sleep(self.wait_time)<br>                <span class="hljs-keyword">if</span> win32service.QueryServiceStatus(self.handle)[<span class="hljs-number">1</span>] == win32service.SERVICE_RUNNING:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">'启动服务%s成功'</span>.encode(<span class="hljs-string">'gbk'</span>) % self.name<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">'启动服务%s失败'</span>.encode(<span class="hljs-string">'gbk'</span>) % self.name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""停止服务"""</span><br>        <span class="hljs-keyword">try</span>:<br>            status_info = win32service.ControlService(self.handle, win32service.SERVICE_CONTROL_STOP)<br>        <span class="hljs-keyword">except</span> Exception, e:<br>            self.log(e)<br>        <span class="hljs-keyword">if</span> status_info[<span class="hljs-number">1</span>] == win32service.SERVICE_STOPPED:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">'停止服务%s成功'</span>.encode(<span class="hljs-string">'gbk'</span>) % self.name<br>        <span class="hljs-keyword">elif</span> status_info[<span class="hljs-number">1</span>] == win32service.SERVICE_STOP_PENDING:<br>            start_time = datetime.datetime.now()<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-keyword">if</span> (datetime.datetime.now() - start_time).seconds &gt; self.delay_time:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">'停止服务%s时间太长'</span>.encode(<span class="hljs-string">'gbk'</span>) % self.name<br><br>                time.sleep(self.wait_time)<br>                <span class="hljs-keyword">if</span> win32service.QueryServiceStatus(self.handle)[<span class="hljs-number">1</span>] == win32service.SERVICE_STOPPED:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">'停止服务%s成功'</span>.encode(<span class="hljs-string">'gbk'</span>) % self.name<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">'停止服务%s失败'</span>.encode(<span class="hljs-string">'gbk'</span>) % self.name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restart</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""重启服务"""</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_stop():<br>            self.stop()<br>        self.start()<br>        <span class="hljs-keyword">return</span> win32service.QueryServiceStatus(self.handle)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">status</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""获取运行的状态"""</span><br>        <span class="hljs-keyword">try</span>:<br>            status_info = win32service.QueryServiceStatus(self.handle)<br>            status = status_info[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> status == win32service.SERVICE_STOPPED:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">"STOPPED"</span><br>            <span class="hljs-keyword">elif</span> status == win32service.SERVICE_START_PENDING:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">"STARTING"</span><br>            <span class="hljs-keyword">elif</span> status == win32service.SERVICE_STOP_PENDING:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">"STOPPING"</span><br>            <span class="hljs-keyword">elif</span> status == win32service.SERVICE_RUNNING:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">"RUNNING"</span><br>        <span class="hljs-keyword">except</span> Exception, e:<br>            self.log(e)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""释放资源"""</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> self.scm:<br>                win32service.CloseServiceHandle(self.handle)<br>                win32service.CloseServiceHandle(self.scm)<br>        <span class="hljs-keyword">except</span> Exception, e:<br>            self.log(e)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_exists</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""windows服务是否已安装"""</span><br>        statuses = win32service.EnumServicesStatus(self.scm, win32service.SERVICE_WIN32, win32service.SERVICE_STATE_ALL)<br>        <span class="hljs-keyword">for</span> (short_name, desc, status) <span class="hljs-keyword">in</span> statuses:<br>            <span class="hljs-keyword">if</span> short_name == self.name:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span><span class="hljs-params">(self, exception)</span>:</span><br><br>        print(exception)<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:<br><br>    app= ServiceManager(<span class="hljs-string">'AAaservice'</span>)<br>    msg= app.is_exists()  <span class="hljs-comment"># 判断是否安装  （以下操作必须先判断服务是否存在）</span><br>    <span class="hljs-comment">#msg= app.is_stop()  # 判断服务是否停止</span><br>    <span class="hljs-comment">#msg= app.status()  # 查看服务的状态</span><br>    <span class="hljs-comment">#msg= app.start()  # 开启服务</span><br>    <span class="hljs-comment">#msg= app.stop()  # 暂停服务   （服务开启才能停止，else error）</span><br>    <span class="hljs-comment">#msg= app.restart()  # 重启服务</span><br><br>    print(msg)<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>参考：<br>
[StackOverflow]: <a href="https://stackoverflow.com/questions/34696815/using-pythonservice-exe-to-host-python-service-while-using-virtualenv" target="_blank" rel="noopener">https://stackoverflow.com/questions/34696815/using-pythonservice-exe-to-host-python-service-while-using-virtualenv</a><br>
[using pythonservice exe to host python service while using virtualenv（已无法访问，参考 Google 快照）]: <a href="http://xm8z2.icu/questions/34696815/using-pythonservice-exe-to-host-python-service-while-using-virtualenv" target="_blank" rel="noopener">http://xm8z2.icu/questions/34696815/using-pythonservice-exe-to-host-python-service-while-using-virtualenv</a><br>
[Python 写Windows Service服务程序 ]: <a href="https://www.cnblogs.com/dcb3688/p/4496934.html" target="_blank" rel="noopener">https://www.cnblogs.com/dcb3688/p/4496934.html</a><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>pywin32 包需要访问注册表，所以 <strong>所有</strong> 必须使用管理员权限进行。<br>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>必须使用 Python 自带的 venv 模块，不能使用 virtualenv。<br>
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>不执行此脚本服务无法启动。卸载脚本为 <code>python .\Scripts\pywin32_postinstall.py -uninstall</code><br>
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>猜测可以跳过此步，<em>pythonservice.exe</em> 应当与服务类中的 <em>exe_name</em> 所指向路径相同即可，未测试。<br>
<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 下迁移 MariaDB 数据库文件</title>
    <url>/2020/02/07/Windows-%E4%B8%8B%E8%BF%81%E7%A7%BB-MariaDB-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1>Windows 下迁移 MariaDB 数据库文件</h1>
<ol>
<li>
<p>运行 MySQL Client (MariaDB 10.4 (x64))，输入密码后登录。</p>
<p><img src="/images/Move-MariaDB-database-file-on-windows/1.PNG" alt="图1"></p>
</li>
<li>
<p>执行语句 <code>show global variables like &quot;%datadir%&quot;;</code>，查询结果中的 <code>Value</code> 列所示即为 MariaDB 数据库文件存储位置。</p>
<p><img src="/images/Move-MariaDB-database-file-on-windows/2.PNG" alt="图2"></p>
</li>
<li>
<p>停止 MariaDB 服务。</p>
<p><img src="/images/Move-MariaDB-database-file-on-windows/3.png" alt="图3"></p>
</li>
<li>
<p>进入上一步数据库文件存储路径，将以数据库名命名的文件夹及 <em>mysql</em> 文件夹和以 <em>ib</em> 开头的文件复制至将要迁移的目标目录。</p>
<p><img src="/images/Move-MariaDB-database-file-on-windows/4.PNG" alt="图4"></p>
</li>
<li>
<p>(可选) 删除原始目录中上一步相应文件。</p>
</li>
<li>
<p>启动数据库即完成迁移。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>MariaDB</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Hexo Ocean 主题博客搭建</title>
    <url>/2020/02/04/%E5%9F%BA%E4%BA%8E-Hexo-Ocean-%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1>基于 Hexo Ocean 主题博客搭建</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="hexo-的基本命令"><a class="header-anchor" href="#hexo-的基本命令">¶</a>hexo 的基本命令</h2>
<ul>
<li><code>hexo init [folder]</code> ：创建一个存放网站源码的文件夹。</li>
<li><code>hexo new [layout] &lt;title&gt;</code>：新建一篇文章。<br>
<code>layout</code>：默认 <code>post</code>，可以是 <code>page</code>、<code>draft</code>。<br>
<code>title</code>：文章标题，标题包含空格的话，请使用引号括起来。</li>
<li><code>hexo clean</code>：清除缓存文件 <em>db.json</em> 和已生成的静态文件 <em>public</em>,尤其是更换主题后</li>
<li><code>hexo g</code>：生成静态 html 文件</li>
<li><code>hexo s</code>：启动服务器</li>
<li><code>hexo d</code>：部署网站</li>
</ul>
<h2 id="下载主题源码"><a class="header-anchor" href="#下载主题源码">¶</a>下载主题源码</h2>
<p>在 <code>hexo init [folder]</code> 的 <em>folder</em> 目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/zhwangart/hexo-theme-ocean.git themes/ocean<br></code></pre></div></td></tr></table></figure>
<h2 id="参照主题文档进行配置"><a class="header-anchor" href="#参照主题文档进行配置">¶</a>参照主题文档进行配置</h2>
<ul>
<li><a href="https://zhwangart.github.io/2018/11/30/Ocean/" target="_blank" rel="noopener">Ocean 中文文档</a></li>
<li><a href="https://zhwangart.github.io/2019/07/02/Ocean-Issues/" target="_blank" rel="noopener">关于 Ocean 使用中的问题</a></li>
</ul>
<h2 id="个性化主题配置"><a class="header-anchor" href="#个性化主题配置">¶</a>个性化主题配置</h2>
<h3 id="文章自动添加-Read-More"><a class="header-anchor" href="#文章自动添加-Read-More">¶</a>文章自动添加 Read More</h3>
<p>将 _\themes\ocean\layout\<em>partial\article.ejs</em> 文中的 <code>&lt;% if (post.excerpt &amp;&amp; index){ %&gt; </code>的 else 部分替换为如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;% var br &#x3D; post.content.indexOf(&#39;&lt;br&gt;&#39;) %&gt;<br>&lt;% if(br &lt; 0 || !index) &#123; %&gt;<br>  &lt;%- post.more %&gt;<br>&lt;% &#125; else &#123; %&gt;<br>  &lt;%- post.content.substring(0, br) %&gt;&lt;br&#x2F;&gt;<br>  &lt;% if (theme.excerpt_link) &#123; %&gt;<br>	&lt;a class&#x3D;&quot;article-more-link&quot; href&#x3D;&quot;&lt;%- url_for(post.path) %&gt;&quot;&gt;&lt;%&#x3D; theme.excerpt_link %&gt;&lt;&#x2F;a&gt;<br>  &lt;% &#125; %&gt;<br>&lt;% &#125; %&gt;<br></code></pre></div></td></tr></table></figure>
<h3 id="搜索功能不起作用或除开首页不能正常搜索"><a class="header-anchor" href="#搜索功能不起作用或除开首页不能正常搜索">¶</a>搜索功能不起作用或除开首页不能正常搜索</h3>
<p>本地检索需要安装插件</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-generator-searchdb --save<br></code></pre></div></td></tr></table></figure>
<p>另外一个问题：插件搜索函数返回的 url 有问题 ，作者说是因为 “中文字符被URL encode了 ” 。后来我找到一个解决办法：<br>
将 <em>[folder]/node_modules/hexo-generator-searchdb/templates/xml.ejs</em> 文件中的：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;url&gt;&lt;%- encodeURIComponent(config.root + post.path) %&gt;&lt;&#x2F;url&gt;<br></code></pre></div></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;url&gt;&lt;%- encodeURI(config.root + post.path) %&gt;&lt;&#x2F;url&gt;<br></code></pre></div></td></tr></table></figure>
<h3 id="修改导航栏"><a class="header-anchor" href="#修改导航栏">¶</a>修改导航栏</h3>
<p>修改 <em>themes/ocean/source/css/_partial/navbar.styl</em> 文件</p>
<h3 id="文章添加封面图片"><a class="header-anchor" href="#文章添加封面图片">¶</a>文章添加封面图片</h3>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">---<br>title: Post name<br>date: 2019-07-24 22:01:03<br>photos: [<br><span class="hljs-code">        ["/images/相机.jpg"], // themes/ocean/source/images目录下</span><br><span class="hljs-code">        ["https://tuchong.pstatp.com/2716763/f/531173888.jpg"]</span><br> ]<br>---<br></code></pre></div></td></tr></table></figure>
<p>在首页只会显示第一张，详情页会按顺序显示这两张。</p>
<h3 id="为文章添加Gitalk评论"><a class="header-anchor" href="#为文章添加Gitalk评论">¶</a>为文章添加Gitalk评论</h3>
<p>参考：<a href="https://zhwangart.github.io/2018/12/06/Gitalk/" target="_blank" rel="noopener">https://zhwangart.github.io/2018/12/06/Gitalk/</a></p>
<h3 id="在右上角或者左上角实现-fork-me-on-github"><a class="header-anchor" href="#在右上角或者左上角实现-fork-me-on-github">¶</a>在右上角或者左上角实现 fork me on github</h3>
<p>选样式：</p>
<ul>
<li><a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">GitHub Corners-1</a></li>
<li><a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">GitHub Corners-2</a></li>
</ul>
<p>然后粘贴刚才复制的代码到 <em>themes/ocean/layout/index.ejs</em> 文件中，放在 <code>&lt;div id=&quot;landingpage&quot;&gt;&lt;/div&gt;</code> 的第一行，并把 <code>href</code> 改为你的 github 地址。<br>
对样式做出修改：</p>
<p><code>&lt;div id=&quot;landingpage&quot;&gt;</code> 修改为 <code>&lt;div id=&quot;landingpage&quot; style=&quot;position:relative;&quot;&gt;</code></p>
<p>复制的 <code>&lt;a&gt;</code> 标签添加如下样式：<code>style=”position:absolute;left:0;top:100;z-index=1000;”</code></p>
<h3 id="实现点击出现特效"><a class="header-anchor" href="#实现点击出现特效">¶</a>实现点击出现特效</h3>
<ul>
<li>
<p>点击桃心</p>
<p>下载：<a href="https://github.com/andus-top/andus-top.github.io/blob/master/js/love.js" target="_blank" rel="noopener">桃心Js</a><br>
然后将里面的代码 copy 一下，新建 <em>love.js</em> 文件并且将代码复制进去，然后保存。<br>
在 <em>themes/ocean/_config.yml</em> 最后一行写入：</p>
  <figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">lovejs:</span> <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure>
<p>将 <em>love.js</em> 文件放到路径 <em>/themes/ocean/source/js/src</em> 里面，然后打开 <em>\themes\ocean\layout\_partial\after-footer.ejs</em> 文件, 在最后一行写入：</p>
  <figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;% if (theme.lovejs)&#123; %&gt;<br>	&lt;%- js(&#39;&#x2F;js&#x2F;love.js&#39;) %&gt;<br>&lt;% &#125; %&gt;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>爆炸效果</p>
<p>下载：</p>
<ul>
<li><a href="https://github.com/andus-top/andus-top.github.io/blob/master/js/fireworks.js" target="_blank" rel="noopener">fireworks.js</a></li>
<li><a href="https://github.com/andus-top/andus-top.github.io/blob/master/js/anime.min.js" target="_blank" rel="noopener">anime.min.js</a></li>
</ul>
<p>步骤与上面类似保存 js 到 <em>/themes/ocean/source/js/src</em>，最后在 <em>\themes\ocean\layout\_partial\after-footer.ejs</em> 文件内容未写入：</p>
  <figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;% if (theme.fireworks)&#123; %&gt;<br>   &lt;canvas class&#x3D;&quot;fireworks&quot; style&#x3D;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;&#x2F;canvas&gt;<br>   &lt;%- js(&#39;&#x2F;js&#x2F;anime.min.js&#39;) %&gt;<br>   &lt;%- js(&#39;&#x2F;js&#x2F;fireworks.js&#39;) %&gt;<br>&lt;% &#125; %&gt;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="头像旋转效果"><a class="header-anchor" href="#头像旋转效果">¶</a>头像旋转效果</h3>
<p>打开 <em>\themes\ocean\layout\_partial\sidebar.ejs</em>，给 <code>&lt;div class=logo&gt;</code> 下的 <code>img</code> 加上一个 <code>id</code>。然后参考：<a href="https://blog.csdn.net/u011295864/article/details/84773123" target="_blank" rel="noopener">css + js实现图片不停旋转 鼠标悬停停止旋转</a></p>
<p>然后将里面的 js 代码 copy 到一个 <em>my.js</em> 文件中（注意替换 <code>img</code> 的 <code>id</code>），保存到 <em>/themes/ocean/source/js/src</em> 目录。<br>
然后在 <em>\themes\ocean\layout\_partial\after-footer.ejs</em> 中最后一行写入：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;%- js(&#39;&#x2F;js&#x2F;my.js&#39;) %&gt;<br></code></pre></div></td></tr></table></figure>
<h3 id="网站底部加上访问量"><a class="header-anchor" href="#网站底部加上访问量">¶</a>网站底部加上访问量</h3>
<p><em>\themes\ocean\layout\_partial\after-footer.ejs</em> 中默认是导入了统计脚本的(busuanzi-2.3.pure.min.js )</p>
<p>修改访问量统计的样式：<br>
将 _\themes\ocean\layout\<em>partial\post\busuanzi.ejs</em><br>
修改为：</p>
<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"powered-by"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">if</span> (<span class="hljs-attr">is_home</span>()) &#123; %&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_container_site_pv"</span>&gt;</span>访问量:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_value_site_pv"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">%&#125;</span> %&gt;</span><br>	<span class="hljs-symbol">&amp;emsp;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-user-md"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_container_site_uv"</span>&gt;</span>访客数:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_value_site_uv"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-symbol">&amp;emsp;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">if</span> (<span class="hljs-attr">is_post</span>()) &#123; %&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fe fe-bookmark"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>文章访问量:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"busuanzi_value_page_pv"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">%&#125;</span> %&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<h3 id="添加网站字数，阅读时间统计"><a class="header-anchor" href="#添加网站字数，阅读时间统计">¶</a>添加网站字数，阅读时间统计</h3>
<p>在根目录下运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-wordcount –save<br></code></pre></div></td></tr></table></figure>
<p>在 <em>\themes\ocean\_config.yml</em> 主题配置文件中加入：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">post_wordcount:</span><br>  <span class="hljs-attr">item_text:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">wordcount:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">min2read:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">totalcount:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">separated_meta:</span> <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure>
<p>在 <em>\themes\ocean\layout\_partial\footer.ejs</em> 文件中，在 <code>&lt;ul class=&quot;list-inline&quot;&gt;</code> 标签后加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;ul class&#x3D;&quot;list-inline&quot;&gt;<br>	&lt;li&gt;全站共&lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; totalcount(site) %&gt;&lt;&#x2F;span&gt;字&lt;&#x2F;li&gt;<br>&lt;&#x2F;ul&gt;<br></code></pre></div></td></tr></table></figure>
<p>在 <em>\themes\ocean\layout\_partial\article.ejs</em> 文件中，在标签中加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&amp;emsp;&lt;i class&#x3D;&quot;fe fe-bar-chart&quot;&gt;&lt;&#x2F;i&gt; &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%- wordcount(post.content) %&gt;&lt;&#x2F;span&gt;字<br>&amp;emsp;&lt;i class&#x3D;&quot;fe fe-clock&quot;&gt;&lt;&#x2F;i&gt; &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%- min2read(post.content) %&gt;&lt;&#x2F;span&gt;分钟<br></code></pre></div></td></tr></table></figure>
<h3 id="Ocean主题的图标"><a class="header-anchor" href="#Ocean主题的图标">¶</a>Ocean主题的图标</h3>
<p>图标在 <em>\themes\ocean\source\css\_feathericon.styl</em> 中查找<br>
官网：<a href="https://feathericons.com/" target="_blank" rel="noopener">feathericons</a></p>
<h3 id="为博客加上萌萌的宠物"><a class="header-anchor" href="#为博客加上萌萌的宠物">¶</a>为博客加上萌萌的宠物</h3>
<p>在网站根目录下执行</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install -save hexo-helper-live2d<br>npm install live2d-widget-model-haruto(自己选择的萌宠模型)<br></code></pre></div></td></tr></table></figure>
<p>在 hexo 的配置文件中添加：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 萌宠</span><br> <span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">local</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-haruto</span><br>    <span class="hljs-attr">scale:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">hHeadPos:</span> <span class="hljs-number">0.5</span><br>    <span class="hljs-attr">vHeadPos:</span> <span class="hljs-number">0.618</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">superSample:</span> <span class="hljs-number">2</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">150</span><br>    <span class="hljs-attr">height:</span> <span class="hljs-number">300</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">left</span><br>    <span class="hljs-attr">hOffset:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">vOffset:</span> <span class="hljs-number">-20</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">react:</span><br>    <span class="hljs-attr">opacityDefault:</span> <span class="hljs-number">0.5</span><br>    <span class="hljs-attr">opacityOnHover:</span> <span class="hljs-number">0.2</span><br></code></pre></div></td></tr></table></figure>
<p>重启服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></div></td></tr></table></figure>
<h3 id="添加网站运行时间"><a class="header-anchor" href="#添加网站运行时间">¶</a>添加网站运行时间</h3>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"timeDate"</span>&gt;</span>载入天数...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"times"</span>&gt;</span>载入时分秒...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); </span><br><span class="actionscript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createtime</span><span class="hljs-params">()</span> </span>&#123; </span><br><span class="javascript">        <span class="hljs-keyword">var</span> grt= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">"04/26/2019 15:49:00"</span>);<span class="hljs-comment">//此处修改你的建站时间或者网站上线时间 </span></span><br>        now.setTime(now.getTime()+250); <br><span class="javascript">        days = (now - grt ) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> / <span class="hljs-number">24</span>; dnum = <span class="hljs-built_in">Math</span>.floor(days); </span><br><span class="javascript">        hours = (now - grt ) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * dnum); hnum = <span class="hljs-built_in">Math</span>.floor(hours); </span><br><span class="javascript">        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">String</span>(hnum).length ==<span class="hljs-number">1</span> )&#123;hnum = <span class="hljs-string">"0"</span> + hnum;&#125; minutes = (now - grt ) / <span class="hljs-number">1000</span> /<span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * dnum) - (<span class="hljs-number">60</span> * hnum); </span><br><span class="javascript">        mnum = <span class="hljs-built_in">Math</span>.floor(minutes); <span class="hljs-keyword">if</span>(<span class="hljs-built_in">String</span>(mnum).length ==<span class="hljs-number">1</span> )&#123;mnum = <span class="hljs-string">"0"</span> + mnum;&#125; </span><br>        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); <br><span class="javascript">        snum = <span class="hljs-built_in">Math</span>.round(seconds); <span class="hljs-keyword">if</span>(<span class="hljs-built_in">String</span>(snum).length ==<span class="hljs-number">1</span> )&#123;snum = <span class="hljs-string">"0"</span> + snum;&#125; </span><br><span class="javascript">        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"timeDate"</span>).innerHTML = <span class="hljs-string">"本站已安全运行 "</span>+dnum+<span class="hljs-string">" 天 "</span>; </span><br><span class="javascript">        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"times"</span>).innerHTML = hnum + <span class="hljs-string">" 小时 "</span> + mnum + <span class="hljs-string">" 分 "</span> + snum + <span class="hljs-string">" 秒"</span>; </span><br>    &#125; <br><span class="actionscript">	setInterval(<span class="hljs-string">"createtime()"</span>,<span class="hljs-number">250</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>将以上代码保存到 <em>\themes\ocean\layout\_partial\post\runtime.ejs</em></p>
<p>在 <em>\themes\ocean\layout\_partial\footer.ejs</em> 文件中，第一个 <code>&lt;ul class=&quot;list-inline&quot;&gt;&lt;/ul&gt;</code> 标签后加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;div class&#x3D;&quot;float-right&quot;&gt;<br>      &lt;%- partial(&#39;post&#x2F;runtime&#39;) %&gt;<br>&lt;&#x2F;div&gt;<br></code></pre></div></td></tr></table></figure>
<h3 id="添加DaoVoice-在线联系"><a class="header-anchor" href="#添加DaoVoice-在线联系">¶</a>添加DaoVoice 在线联系</h3>
<p>首先在 <a href="https://account.daocloud.io/signin" target="_blank" rel="noopener">https://account.daocloud.io/signin</a>  注册账号<br>
然后点击下方链接<br>
<a href="http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f" target="_blank" rel="noopener">http://dashboard.daovoice.io/get-started?invite_code=0f81ff2f</a><br>
之后会得到一个app_id</p>
<p>在主题配置文件写入：</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Online contact </span><br><span class="hljs-attr">daovoice:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">daovoice_app_id:</span> <span class="hljs-string">这里填你的刚才获得的</span> <span class="hljs-string">app_id</span><br></code></pre></div></td></tr></table></figure>
<p>在 <em>\themes\ocean\layout\_partial\head.ejs</em> 的未尾中写入（<strong>注：原文是“在 <em>\themes\ocean\layout\_partial\footer.ejs</em> 中，<code>&lt;/head&gt;</code> 前写入”，但实际并未在 <em>footer.ejs</em> 中找到 <code>&lt;/head&gt;</code>，所以改为在 <em>head.ejs</em> 未尾写入达到了同样效果。</strong>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;% if (theme.daovoice)&#123; %&gt;<br>  &lt;script&gt;<br>  (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]&#x3D;r;i[r]&#x3D;i[r]||function()&#123;(i[r].q&#x3D;i[r].q||[]).push(arguments)&#125;,i[r].l&#x3D;1*new Date();a&#x3D;s.createElement(o),m&#x3D;s.getElementsByTagName(o)[0];a.async&#x3D;1;a.src&#x3D;g;a.charset&#x3D;&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&#39;https:&#39; &#x3D;&#x3D; document.location.protocol ? &#39;https:&#39; : &#39;http:&#39;) + &quot;&#x2F;&#x2F;widget.daovoice.io&#x2F;widget&#x2F;0f81ff2f.js&quot;,&quot;daovoice&quot;)<br>  daovoice(&#39;init&#39;, &#123;<br>      app_id: &quot;&lt;%- theme.daovoice_app_id %&gt;&quot;<br>    &#125;);<br>  daovoice(&#39;update&#39;);<br>  &lt;&#x2F;script&gt;<br>&lt;% &#125; %&gt;<br></code></pre></div></td></tr></table></figure>
<h3 id="取消文章下面的分享连接，添加本文结束"><a class="header-anchor" href="#取消文章下面的分享连接，添加本文结束">¶</a>取消文章下面的分享连接，添加本文结束</h3>
<p>去掉 <em>\themes\ocean\layout\_partial\article.ejs</em> 中的以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;a data-url&#x3D;&quot;&lt;%- post.permalink %&gt;&quot; data-id&#x3D;&quot;&lt;%&#x3D; post._id %&gt;&quot; class&#x3D;&quot;article-share-link&quot;&gt;&lt;%- theme.share_text %&gt;&lt;&#x2F;a&gt;<br>同时还可以添加本文结束 感谢阅读等说明:<br>如在&lt;%- partial(‘post&#x2F;tag’) %&gt;下面一行添加：<br><br>&lt;% if (!index &amp;&amp; is_post()) &#123; %&gt;<br>	&lt;div style&#x3D;&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;------------- 本文结束&amp;nbsp;&lt;i class&#x3D;&quot;fe fe-smile&quot;&gt;&lt;&#x2F;i&gt;&amp;nbsp;感谢您的阅读 -------------&lt;&#x2F;div&gt;<br>&lt;% &#125; %&gt;<br></code></pre></div></td></tr></table></figure>
<h3 id="博文压缩"><a class="header-anchor" href="#博文压缩">¶</a>博文压缩</h3>
<p>在根目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install gulp -g<br>npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp –save<br></code></pre></div></td></tr></table></figure>
<p>在根目录下新建 <em>gulpfile.js</em>，写入以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp'</span>);<br><span class="hljs-comment">//Plugins模块获取</span><br><span class="hljs-keyword">var</span> minifycss = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-minify-css'</span>);<br><span class="hljs-keyword">var</span> uglify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-uglify'</span>);<br><span class="hljs-keyword">var</span> htmlmin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-htmlmin'</span>);<br><span class="hljs-keyword">var</span> htmlclean = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-htmlclean'</span>);<br><span class="hljs-comment">//压缩css</span><br>gulp.task(<span class="hljs-string">'minify-css'</span>,<br><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> gulp.src(<span class="hljs-string">'./public/**/*.css'</span>).pipe(minifycss()).pipe(gulp.dest(<span class="hljs-string">'./public'</span>));<br>&#125;);<br><span class="hljs-comment">//压缩html</span><br>gulp.task(<span class="hljs-string">'minify-html'</span>,<br><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> gulp.src(<span class="hljs-string">'./public/**/*.html'</span>).pipe(htmlclean()).pipe(htmlmin(&#123;<br>        removeComments: <span class="hljs-literal">true</span>,<br>        minifyJS: <span class="hljs-literal">true</span>,<br>        minifyCSS: <span class="hljs-literal">true</span>,<br>        minifyURLs: <span class="hljs-literal">true</span>,<br>    &#125;))<br>    .pipe(gulp.dest(<span class="hljs-string">'./public'</span>))<br>&#125;);<br><span class="hljs-comment">//压缩js 不压缩min.js</span><br>gulp.task(<span class="hljs-string">'minify-js'</span>,<br><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> gulp.src([<span class="hljs-string">'./public/**/*.js'</span>, <span class="hljs-string">'!./public/**/*.min.js'</span>]).pipe(uglify()).pipe(gulp.dest(<span class="hljs-string">'./public'</span>));<br>&#125;);<br><br><span class="hljs-comment">//4.0以前的写法 </span><br><span class="hljs-comment">//gulp.task('default', [</span><br><span class="hljs-comment">//  'minify-html', 'minify-css', 'minify-js'</span><br><span class="hljs-comment">//]);</span><br><br><span class="hljs-comment">//4.0以后的写法</span><br><span class="hljs-comment">// 执行 gulp 命令时执行的任务</span><br><span class="hljs-comment">//gulp.task('default', gulp.parallel('minify-html', 'minify-css', 'minify-js',</span><br><span class="hljs-comment">//function() &#123;</span><br>    <span class="hljs-comment">// Do something after a, b, and c are finished.</span><br><span class="hljs-comment">//	console.log('success')</span><br><span class="hljs-comment">//&#125;));</span><br><br>gulp.task(<span class="hljs-string">'default'</span>,gulp.series(gulp.parallel(<span class="hljs-string">'minify-html'</span>,<span class="hljs-string">'minify-css'</span>,<span class="hljs-string">'minify-js'</span>)));<br></code></pre></div></td></tr></table></figure>
<p>生成博文时执行</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d<br></code></pre></div></td></tr></table></figure>
<p>就会根据 <em>gulpfile.js</em> 中的配置，对 <em>public</em> 目录中的静态资源文件进行压缩。</p>
<h3 id="修改文章封面图片的引入方式，同时支持相对地址与-http-的图片"><a class="header-anchor" href="#修改文章封面图片的引入方式，同时支持相对地址与-http-的图片">¶</a>修改文章封面图片的引入方式，同时支持相对地址与 http 的图片</h3>
<p>将 <em>\themes\ocean\layout\_partial\post\gallery.ejs</em> 中的 <code>&lt;% if (index){ %&gt;</code> 的上一行写入：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;% var idx &#x3D; url_for(photo).indexOf(&#39;http&#39;) %&gt;<br></code></pre></div></td></tr></table></figure>
<p>将文中两处的：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;img src&#x3D;&quot;&lt;%- url_for(photo) %&gt;&quot; itemprop&#x3D;&quot;image&quot;&gt;<br></code></pre></div></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;% if(idx &lt; 0) &#123; %&gt;<br>	&lt;img src&#x3D;&quot;&lt;%- url_for(post.path)+url_for(photo).substring(1) %&gt;&quot; itemprop&#x3D;&quot;image&quot;&gt;<br>&lt;% &#125; else &#123; %&gt;<br>	&lt;img src&#x3D;&quot;&lt;%- url_for(photo) %&gt;&quot; itemprop&#x3D;&quot;image&quot;&gt;<br>&lt;% &#125; %&gt;<br></code></pre></div></td></tr></table></figure>
<h3 id="设置封面图片不在内容详情页展示"><a class="header-anchor" href="#设置封面图片不在内容详情页展示">¶</a>设置封面图片不在内容详情页展示</h3>
<p>将 <em>\themes\ocean\layout\_partial\article.ejs</em> 中的</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;%- partial(&#39;post&#x2F;gallery&#39;) %&gt;<br></code></pre></div></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;% if (index)&#123; %&gt;<br>	&lt;%- partial(&#39;post&#x2F;gallery&#39;) %&gt;<br>&lt;% &#125; %&gt;<br></code></pre></div></td></tr></table></figure>
<h3 id="去掉-rss-订阅"><a class="header-anchor" href="#去掉-rss-订阅">¶</a>去掉 rss 订阅</h3>
<p>根目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm uninstall hexo-generator-feed –save<br></code></pre></div></td></tr></table></figure>
<p>将 <em>\themes\ocean\_config.yml</em> 文件中修改为：<code>rss: false</code></p>
<h3 id="导航栏图表改为在文字左侧"><a class="header-anchor" href="#导航栏图表改为在文字左侧">¶</a>导航栏图表改为在文字左侧</h3>
<p>修改 <em>\themes\ocean\source\css\_partial\navbar.styl</em></p>
<figure class="highlight styl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs styl">&amp;.nav-main<br>      .nav-item-link<br>        &amp;::before, <span class="hljs-selector-tag">i</span>.fe<br>          <span class="hljs-attribute">display</span> block<br>          <span class="hljs-attribute">line-height</span> <span class="hljs-number">1</span><br>        &amp;::before<br>          <span class="hljs-attribute">font-family</span> <span class="hljs-string">'feathericon'</span><br></code></pre></div></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight styl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs styl">&amp;.nav-main<br>      .nav-item-link<br>        &amp;::before, <span class="hljs-selector-tag">i</span>.fe<br>          <span class="hljs-comment">// display block</span><br>          <span class="hljs-attribute">line-height</span> <span class="hljs-number">1</span><br>		   <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;<br>        &amp;::before<br>          <span class="hljs-attribute">font-family</span> <span class="hljs-string">'feathericon'</span><br></code></pre></div></td></tr></table></figure>
<h3 id="添加-readme-md-不被渲染"><a class="header-anchor" href="#添加-readme-md-不被渲染">¶</a>添加 <em><a href="http://readme.md" target="_blank" rel="noopener">readme.md</a></em> 不被渲染</h3>
<p>在 Hexo 目录下的 <em>source</em> 根目录下添加一个 <em><a href="http://README.md" target="_blank" rel="noopener">README.md</a></em> 。修改 Hexo 目录下的 <em>config.yml</em> 。将 <code>skip_render</code> 参数的值设置为： <code>skip_render: README.md</code>。保存退出即可。</p>
<h3 id="首页视屏换成图片"><a class="header-anchor" href="#首页视屏换成图片">¶</a>首页视屏换成图片</h3>
<p>将 <em>\themes\ocean\layout\_partial\ocean.ejs</em> 中</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;video playsinline&#x3D;&quot;&quot; autoplay&#x3D;&quot;&quot; loop&#x3D;&quot;&quot; muted&#x3D;&quot;&quot; data-autoplay&#x3D;&quot;&quot;<br>   poster&#x3D;&quot;&lt;%- theme.ocean.path %&gt;ocean.png&quot; x5-video-player-type&#x3D;&quot;h5&quot;&gt;<br>  &lt;source src&#x3D;&quot;&lt;%- theme.ocean.path %&gt;ocean.mp4&quot; type&#x3D;&quot;video&#x2F;mp4&quot;&gt;<br>  &lt;source src&#x3D;&quot;&lt;%- theme.ocean.path %&gt;ocean.ogv&quot; type&#x3D;&quot;video&#x2F;ogg&quot;&gt;<br>  &lt;source src&#x3D;&quot;&lt;%- theme.ocean.path %&gt;ocean.webm&quot; type&#x3D;&quot;video&#x2F;webm&quot;&gt;<br>  &lt;p&gt;Your user agent does not support the HTML5 Video element.&lt;&#x2F;p&gt;<br>&lt;&#x2F;video&gt;<br></code></pre></div></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;img src&#x3D;&quot;&lt;%- theme.ocean.path %&gt;ocean.png&quot;&gt;<br></code></pre></div></td></tr></table></figure>
<h3 id="去掉首页视频或图片"><a class="header-anchor" href="#去掉首页视频或图片">¶</a>去掉首页视频或图片</h3>
<p>去掉 <em>themes/ocean/layout/index.ejs</em> 中的</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;%- partial(&#39;_partial&#x2F;ocean&#39;) %&gt;<br></code></pre></div></td></tr></table></figure>
<h3 id="is-home-、is-post-函数判断不正确"><a class="header-anchor" href="#is-home-、is-post-函数判断不正确">¶</a><code>is_home()</code>、<code>is_post()</code> 函数判断不正确</h3>
<p>将 <em>\themes\ocean\layout\layout.ejs</em> 中</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;%- partial(&#39;_partial&#x2F;footer&#39;, null, &#123;cache: !config.relative_link&#125;) %&gt;<br></code></pre></div></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;%- partial(&#39;_partial&#x2F;footer&#39;, null, &#123;cache: config.relative_link&#125;) %&gt;<br></code></pre></div></td></tr></table></figure>
<p>就是将 <code>partial</code> 中的 <code>cache</code> 设置为 <code>false</code>。参考：<a href="https://github.com/zhwangart/hexo-theme-ocean/issues/18" target="_blank" rel="noopener"><code>is_home()</code>、<code>is_post()</code> 函数判断不正确</a>。</p>
<h3 id="视频-or-图片只在pc端显示，不在移动端显示"><a class="header-anchor" href="#视频-or-图片只在pc端显示，不在移动端显示">¶</a>视频 or 图片只在pc端显示，不在移动端显示</h3>
<p>修改 <em>themes\ocean\source\css\_partial\layou.styl</em> 文件</p>
<figure class="highlight styl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs styl"><span class="hljs-comment">// Media Query</span><br>@media (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>)<br>  .jumbotron<br>    <span class="hljs-attribute">margin-bottom</span> <span class="hljs-number">6rem</span><br>    <span class="hljs-attribute">display</span> block   //此处为新增。设备宽度大于等于<span class="hljs-number">768</span>像素时显示视频or图片<br></code></pre></div></td></tr></table></figure>
<p>在文件末尾新增</p>
<figure class="highlight styl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs styl">@media (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>)<br>  .jumbotron<br>    <span class="hljs-attribute">display</span> none  // 设备宽度小于等于<span class="hljs-number">768</span>像素时不显示视频or图片<br></code></pre></div></td></tr></table></figure>
<p>此时会发现移动端左上角有点空旷，则进行如下修改：</p>
<ul>
<li>
<p>修改 <em>themes\ocean\layout_partial\archive.ejs</em> 文件’</p>
  <figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">var title &#x3D; &#39;&#39;;<br>var mobile_title &#x3D; &quot;松林羊 Blog&quot;;  &#x2F;&#x2F; 此处为新增<br>...<br>&lt;h1 class&#x3D;&quot;page-type-title pc&quot;&gt;&lt;%- title %&gt;&lt;&#x2F;h1&gt; &#x2F;&#x2F; 新增类名为pc的样式<br>&lt;h1 class&#x3D;&quot;page-type-title mobile&quot;&gt;&lt;%- mobile_title %&gt;&lt;&#x2F;h1&gt; &#x2F;&#x2F; 此处为新增<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>修改 <em>themes\ocean\source\css_partial\archive.styl</em> 文件</p>
  <figure class="highlight styl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs styl">.page-type-title<br>  <span class="hljs-attribute">margin</span> <span class="hljs-number">0</span><br>  <span class="hljs-attribute">padding</span> <span class="hljs-number">3rem</span> <span class="hljs-number">0</span><br> <span class="hljs-comment">// 以下内容为新增</span><br>  &amp;.pc<br>	@media screen and (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>)<br>	  <span class="hljs-attribute">display</span> none<br>	@media screen and (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>)<br>	  <span class="hljs-attribute">display</span> block<br>  &amp;.mobile<br>	@media screen and (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>)<br>	  <span class="hljs-attribute">display</span> block<br>	  <span class="hljs-attribute">font-family</span> <span class="hljs-string">'STXingkai'</span><br>	@media screen and (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>)<br>	  <span class="hljs-attribute">display</span> none<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="配置-fancybox-展示文章图集"><a class="header-anchor" href="#配置-fancybox-展示文章图集">¶</a>配置 fancybox 展示文章图集</h3>
<p>在 <em>themes\ocean\layout\_partial\after-footer.ejs</em> 文件末尾加入如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;% if (is_post())&#123; %&gt;<br>&lt;script&gt;<br>&#x2F;&#x2F; 使用fancybox来显示post图片集(#andus-head-img为头像id)<br>$(&#39;img:not(#andus-head-img)&#39;).each(function() &#123;<br>  $(this).wrap(&#39;&lt;a class&#x3D;&quot;fancybox&quot; data-fancybox&#x3D;&quot;gallery&quot; href&#x3D;&quot;&#39; + $(this).prop(&quot;src&quot;) + &#39;&quot;&gt;&lt;&#x2F;a&gt;&#39;); <br>&#125;)<br>&lt;&#x2F;script&gt;<br>&lt;% &#125; %&gt;<br></code></pre></div></td></tr></table></figure>
<h3 id="更换评论系统，由gitalk跟换为valine-并增加邮件通知功能"><a class="header-anchor" href="#更换评论系统，由gitalk跟换为valine-并增加邮件通知功能">¶</a>更换评论系统，由gitalk跟换为valine, 并增加邮件通知功能</h3>
<p>依次参考</p>
<ul>
<li><a href="https://ioliu.cn/2017/add-valine-comments-to-your-blog/" target="_blank" rel="noopener">Valine–一款极简的评论系统</a></li>
<li><a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a></li>
<li><a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a></li>
</ul>
<p>在 <em>themes/ocean/_config.yml</em> 文件中新增以下内容，同时确保 <code>gitalk.enable</code> 为 <code>false</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Valine 不能与gitalk同时开启</span><br><span class="hljs-attr">valine:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">app_id:</span>  <span class="hljs-comment"># 这里填写得到的APP ID</span><br>  <span class="hljs-attr">app_key:</span>  <span class="hljs-comment"># 这里填写得到的APP KEY</span><br>  <span class="hljs-attr">placeholder:</span> <span class="hljs-string">记得留下你的昵称和邮箱...可以快速收到回复ヾﾉ≧∀≦)o</span> <span class="hljs-comment"># [v1.0.7 new]留言框占位提示文字</span><br>  <span class="hljs-attr">notify:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 评论回复邮件提醒 。 第三方支持：https://github.com/zhaojun1998/Valine-Admin</span><br>  <span class="hljs-attr">verify:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 验证码 。 开启邮件提醒会默认开启验证码选项</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">monsterid</span> <span class="hljs-comment"># Gravatar头像。可选项：[identicon monsterid  wavatar retro robohash mp ''] ，见 https://valine.js.org/avatar.html</span><br>  <span class="hljs-attr">recordIP:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否记录评论者ip</span><br>  <span class="hljs-attr">visitor:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 阅读量统计 https://valine.js.org/visitor.html</span><br></code></pre></div></td></tr></table></figure>
<p>拷贝 <em>themes\ocean\layout\_partial\post\gitalk.ejs</em> 重命名为 <em>valine.ejs</em>。<br>
全部内容修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;% if (theme.valine.enable) &#123; %&gt;<br>  &lt;div class&#x3D;&quot;comment_headling&quot;  style&#x3D;&quot;margin-top:5rem;&quot;&gt;<br>	&lt;font size&#x3D;&quot;5&quot;&gt;&lt;i class&#x3D;&quot;fe fe-comments&quot;&gt;&lt;&#x2F;i&gt; 评论&lt;&#x2F;font&gt;<br>  &lt;&#x2F;div&gt;<br>  &lt;div class&#x3D;&quot;comment&quot;&gt;&lt;&#x2F;div&gt;<br>  &lt;%- js(&#39;https:&#x2F;&#x2F;cdn1.lncld.net&#x2F;static&#x2F;js&#x2F;3.0.4&#x2F;av-min.js&#39;) %&gt;<br>  &lt;%- js(&#39;js&#x2F;Valine.min.js&#39;) %&gt;<br>  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;<br>  &#x2F;&#x2F; https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;valine&#x2F;1.3.10&#x2F;Valine.min.js<br>  GUEST_INFO &#x3D; [&quot;nick&quot;, &quot;mail&quot;, &quot;link&quot;],<br>  guest_info &#x3D; &quot;nick,mail,link&quot;.split(&quot;,&quot;).filter(function(i) &#123;<br>		return - 1 &lt; GUEST_INFO.indexOf(i)<br>  &#125;);<br>  guest_info &#x3D; 0 &#x3D;&#x3D; guest_info.length ? GUEST_INFO: guest_info,<br>  new Valine(&#123;<br>	 &#x2F;&#x2F; AV 对象来自上面引入av-min.js<br>	 av: AV, <br>	 el: &#39;.comment&#39;,<br>	 app_id: &#39;&lt;%- theme.valine.app_id %&gt;&#39;, <br>	 app_key: &#39;&lt;%- theme.valine.app_key %&gt;&#39;, <br>	 placeholder: &#39;&lt;%- theme.valine.placeholder %&gt;&#39;,<br>	 meta: guest_info,<br>	 notify: &lt;%- theme.valine.notify %&gt;,<br>	 verify: &lt;%- theme.valine.verify %&gt;,<br>	 avatar: &#39;&lt;%- theme.valine.avatar %&gt;&#39;,<br>	 recordIP: &lt;%- theme.valine.recordIP %&gt;,<br>	 visitor: &lt;%- theme.valine.visitor %&gt;,<br>	 lang: &#39;zh-cn&#39;<br>  &#125;);<br>  &lt;&#x2F;script&gt;<br>&lt;% &#125; %&gt;<br></code></pre></div></td></tr></table></figure>
<p>修改 <em>themes\ocean\layout\_partial\article.ejs</em> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;% if (is_post()) &#123; %&gt;<br>	&lt;%- partial(&#39;post&#x2F;gitalk&#39;) %&gt;<br>	&lt;%# 下面为新增内容 %&gt;<br>	&lt;%- partial(&#39;post&#x2F;valine&#39;) %&gt;<br>&lt;%&#125; %&gt;<br></code></pre></div></td></tr></table></figure>
<p>关闭评论时的验证码，将 <em>Valine.min.js</em> 保存到  <em>themes\ocean\source\js</em> 目录下，将其中</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">u.attr(Q, <span class="hljs-string">"style"</span>, <span class="hljs-string">"display:block;"</span>), t &amp;&amp; t.type) &#123;<br>	<span class="hljs-keyword">var</span> o = u.find(Q, <span class="hljs-string">".vsure"</span>);<br>	u.on(<span class="hljs-string">"click"</span>, o,<br>	<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<br>		e.alert.hide(),<br>		t.cb &amp;&amp; t.cb()<br>	&#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">u.attr(Q, <span class="hljs-string">"style"</span>, <span class="hljs-string">"display:none;"</span>), t &amp;&amp; t.type) &#123;<br>	e.alert.hide(),<br>	t.cb &amp;&amp; t.cb()<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>记录(自用)</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;%- page.content.substring(0,tips) %&gt; 显示html的样式结果<br>&lt;%&#x3D; page.content.substring(0,tips) %&gt; 显示html源代码<br></code></pre></div></td></tr></table></figure>
<h2 id="笔记"><a class="header-anchor" href="#笔记">¶</a>笔记</h2>
<ul>
<li>
<p><em>hexo根目录\source</em> 对应发布后 <em>public</em> 目录，故 <em>source\images</em> 对应 <em>public\images</em> 。</p>
</li>
<li>
<p>在 Hexo 配置文件 <em>_config.yaml</em> 中设置 <code>language</code> 为 <code>zh-CN</code> 可设置为中文（前题是主题支持）。</p>
</li>
<li>
<p>实现侧边栏进入文章时半透明：</p>
<ol>
<li>
<p>在 <em>themes\ocean\source\css\_partial\layou.styl</em> 中添加：</p>
 <figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">.sidebar-spector<br>  <span class="hljs-attribute">opacity</span> <span class="hljs-number">0.2</span><br>  &amp;:hover<br>    <span class="hljs-attribute">opacity</span> <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>在 <em>\themes\ocean\source\js</em> 下建立 <em>fade-sidebar.js</em> 文件，内容为：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'main.content &gt; section.jumbotron'</span>)) &#123;<br>    <span class="hljs-keyword">const</span> my_sidebar = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'aside.sidebar'</span>);<br>        <span class="hljs-keyword">if</span>(my_sidebar) &#123;<br>            <span class="hljs-keyword">const</span> my_content = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'main.content'</span>);<br>            <br>            <span class="hljs-comment">// 收窄侧边栏</span><br>            my_content.style.marginRight = <span class="hljs-string">'6rem'</span>;<br>            my_sidebar.style.width = <span class="hljs-string">'6rem'</span>;<br>            <br>            <span class="hljs-keyword">const</span> sidebar_class = my_sidebar.getAttribute(<span class="hljs-string">'class'</span>);<br>            <span class="hljs-keyword">if</span>(sidebar_class.indexOf(<span class="hljs-string">'sidebar-spector'</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>                my_sidebar.setAttribute(<span class="hljs-string">'class'</span>, sidebar_class + <span class="hljs-string">' sidebar-spector'</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>在 <em>themes\ocean\layout\_partial\after-footer.ejs</em> 未尾添加：</p>
 <figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ejs">&lt;%- js(&#39;js&#x2F;fade-sidebar.js&#39;) %&gt;<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>如果不需要去掉 Valine 的验证码，可将 <em>\themes\ocean\layout\_partial\post\valine.ejs</em> 中的 <code>&lt;%- js('js/Valine.min.js') %&gt;</code> 改为 CDN 地址，如： <code>&lt;%- js('https://unpkg.com/valine@1.03.10/dist/Valine.min.js') %&gt;</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>git</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>《Learn Emacs in 21 days》学习笔记</title>
    <url>/2019/10/06/%E3%80%8ALearn-Emacs-in-21-days%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h1>《Learn Emacs in 21 days》学习笔记</h1>
<h2 id="第一天"><a class="header-anchor" href="#第一天">¶</a>第一天</h2>
<h3 id="配置文件-init-el"><a class="header-anchor" href="#配置文件-init-el">¶</a>配置文件(init.el)</h3>
<ul>
<li>
<p>配置文件默认位置为 <em>$HOME/.emacs.d/init.el</em></p>
<blockquote>
<p>Windows 下需要设置环境变量<code>HOME</code>，若不设置，默认为 <em>%USERPROFILE%\.emacs.d\init.el</em> 或 <em>%APPDATA%\.emacs.d\init.el</em>。</p>
</blockquote>
</li>
<li>
<p>手动指定配置文件位置<br>
编辑 <em>$HOME/.emacs.d/init.el</em> (Windows 下为 <em>%USERPROFILE%\.emacs.d\init.el</em> 或 <em>%APPDATA%\.emacs.d\init.el</em>)：</p>
</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp"><span class="hljs-comment">;; This file is only for windows 7/8/8.1</span><br><span class="hljs-comment">;; The only thing it does is to set the HOME directories for emacs,</span><br><span class="hljs-comment">;; then trigger the init.el in the directory specified by HOME to</span><br><span class="hljs-comment">;; accomplish the true initialization</span><br><span class="hljs-comment">;; You should put this file in the default HOME directory right after</span><br><span class="hljs-comment">;; emacs is installed</span><br>(<span class="hljs-name">setenv</span> <span class="hljs-string">"HOME"</span> <span class="hljs-string">"C:/Users/Carzpurzkey"</span>) <span class="hljs-comment">;; you can change this dir to the place you like</span><br>(<span class="hljs-name">load</span> <span class="hljs-string">"~/.emacs.d/init.el"</span>)<br></code></pre></div></td></tr></table></figure>
<ul>
<li>基础配置</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp"><span class="hljs-comment">; 关闭工具栏</span><br>(<span class="hljs-name">tool-bar-mode</span> <span class="hljs-number">-1</span>)<br><span class="hljs-comment">; 关闭滚动条</span><br>(<span class="hljs-name">scroll-bar-mode</span> <span class="hljs-number">-1</span>)<br><br>(<span class="hljs-name">electric-indent-mode</span> <span class="hljs-number">-1</span>)<br><br><span class="hljs-comment">; 关闭欢迎画面</span><br>(<span class="hljs-name">setq</span> inhibit-splash-screen <span class="hljs-literal">t</span>)<br><br><span class="hljs-comment">; 启用全局行号</span><br>(<span class="hljs-name">global-linum-mode</span> <span class="hljs-literal">t</span>)<br><br><span class="hljs-comment">; 启用全局company-mode</span><br>(<span class="hljs-name">global-company-mode</span> <span class="hljs-literal">t</span>)<br><br><span class="hljs-comment">; 启用全局条状光标</span><br>(<span class="hljs-name">setq-default</span> cursor-type 'bar)<br><br><span class="hljs-comment">; 禁用自动文件备份</span><br>(<span class="hljs-name">setq</span> make-backup-files <span class="hljs-literal">nil</span>)<br></code></pre></div></td></tr></table></figure>
<h3 id="前缀键-Leading-Key"><a class="header-anchor" href="#前缀键-Leading-Key">¶</a>前缀键 (Leading Key)</h3>
<ul>
<li>
<p><code>C-x</code> 执行快捷键命令</p>
<ol>
<li><code>C-x C-e</code>
<ul>
<li>立即执行光标所在位置 elisp 脚本（光标必须在 sexp 尾部）。</li>
<li>运行上一个 sexp（即执行 <code>eval-last-sexp</code> 命令）。</li>
</ul>
</li>
<li><code>C-x C-f</code> 打开文件。</li>
<li><code>C-x C-s</code> 保存文件。</li>
<li><code>C-x 2</code> 在下方新建窗口。</li>
<li><code>C-x 3</code> 在右侧新建窗口。</li>
<li><code>C-x 1</code> 关闭当前窗口之外的所有窗口。</li>
<li><code>C-x b</code> 切换 buffers。</li>
<li><code>C-x k</code> 删除当前buffer。</li>
<li><code>C-x o</code> 切换窗口。</li>
</ol>
</li>
<li>
<p><code>C-h</code> 帮助</p>
<ol>
<li><code>C-h v</code> 查询变量信息。</li>
<li><code>C-h f</code> 查询函数信息。</li>
<li><code>C-h k</code> 查询键绑定信息。</li>
</ol>
</li>
<li>
<p><code>C-c</code> 自定义快捷键</p>
<ul>
<li>
<p>org-mode：</p>
<ul>
<li>
<p><code>C-c t</code> 切换 TODO 状态。</p>
</li>
<li>
<p><code>C-c '</code> 当光标处于块</p>
<div class="hljs code-wrapper"><pre><code>  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">#+BEGIN_SRC language<br>#+END_SRC<br></code></pre></div></td></tr></table></figure>
</code></pre>
<p>中间时，按 <code>C-c '</code> 则会在新 <em>buffer</em> 中以 <code>language</code> minar mode 编辑块中内容。</p>
</li>
<li>
<p><code>C-c C-s</code> 制定计划，指定开始时间。</p>
</li>
<li>
<p><code>C-c C-d</code> 制定计划，指定 dead line。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>M-x</code> 在 <em>minibuffer</em> 执行文字命令。</p>
</li>
<li>
<p>其它</p>
<ol>
<li><code>C-a</code> 定位至行首。</li>
<li><code>C-e</code> 定位至行尾。</li>
<li><code>C-f</code> 光标前移一个字符。</li>
<li><code>C-p</code> 光标上移一行。</li>
<li><code>C-n</code> 光标下移一行。</li>
<li><code>C-s</code> 搜索。</li>
<li><code>C-g</code> 终止一切未完成的操作。</li>
<li><code>M-Enter</code> 自动修正序号。</li>
</ol>
</li>
</ul>
<h2 id="第二天"><a class="header-anchor" href="#第二天">¶</a>第二天</h2>
<h3 id="继续定制配置文件"><a class="header-anchor" href="#继续定制配置文件">¶</a>继续定制配置文件</h3>
<ol>
<li>
<p>org-mode：</p>
<ul>
<li>
<p>启用：</p>
<div class="hljs code-wrapper"><pre><code>  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">require</span> 'org)<br></code></pre></div></td></tr></table></figure>
</code></pre>
</li>
<li>
<p>使块 <code>#+BEGIN_SRC</code> <code>#+END_SRC</code> 之间的代码有语法高亮：</p>
<div class="hljs code-wrapper"><pre><code>  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">require</span> 'org)<br>(<span class="hljs-name">setq</span> org-src-fontify-natively <span class="hljs-literal">t</span>)<br></code></pre></div></td></tr></table></figure>
</code></pre>
</li>
<li>
<p><code>&lt;s</code> + <code>tab键</code> 自动插入 <code>#+BEGIN_SRC language</code> <code>#+END_SRC</code> 块。</p>
</li>
<li>
<p>Agenda</p>
<ul>
<li>
<p>启用及配置</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> org-agenda-files '(<span class="hljs-string">"~/org-agenda"</span>))<br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"C-c a"</span>) 'org-agenda)<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>开启“最近打开的文件”功能：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">require</span> 'recentf)<br>(<span class="hljs-name">recentf-mode</span> <span class="hljs-literal">t</span>)<br>(<span class="hljs-name">setq</span> recentf-max-menu-items <span class="hljs-number">25</span>)<br>(<span class="hljs-name">global-set-key</span> <span class="hljs-string">"\C-x\ \C-r"</span> 'recentf-open-files)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>使选中区域切换为替换模式：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">delete-selection-mode</span> <span class="hljs-literal">t</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>打开 Emacs 时自动全屏显示：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> initial-frame-alist (<span class="hljs-name">quote</span> ((fullscreen . maximized))))<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>高亮括号匹配：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">add-hook</span> 'emacs-lisp-mode-hook 'show-parent-mode)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>高亮当前行：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">global-hl-line-mode</span> <span class="hljs-literal">t</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>加载主题：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">load-theme</span> 'dracula <span class="hljs-literal">t</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>hungry delete：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">require</span> 'hungry-delete)<br>(<span class="hljs-name">global-hungry-delete-mode</span> <span class="hljs-literal">t</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>smex：<br>
smex 是 <code>M-x</code> 的扩展</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">require</span> 'smex)<br>(<span class="hljs-name">smex-initialize</span>)<br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"M-x"</span>) 'smex)<br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"M-x"</span>) 'smex-major-mode-commands)<br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"C-c C-c M-x"</span>) 'execute-extended-command)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>swiper：<br>
swiper 是 <code>C-s</code> 的扩展：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">ivy-mode</span> <span class="hljs-literal">t</span>)<br>(<span class="hljs-name">setq</span> ivy-use-virtual-buffers <span class="hljs-literal">t</span>)<br>(<span class="hljs-name">global-set-key</span> <span class="hljs-string">"\C-s"</span> 'swiper)<br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"C-c C-r"</span>) 'ivy-resume)<br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"&lt;f6&gt;"</span>) 'ivy-resume)<br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"M-x"</span>) 'counsel-M-x)<br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"C-x C-f"</span>) 'counsel-find-file)<br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"&lt;f1&gt; f"</span>) 'counsel-describe-function)<br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"&lt;f1&gt; v"</span>) 'counsel-describe-variable)<br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"C-c g"</span>) 'counsel-git)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>smartparens：<br>
smartparens 可以自动补全括号及各种引号：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">smartparens-global-mode</span> <span class="hljs-literal">t</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>find-function</code> 和 <code>find-variable</code> 函数</p>
</li>
</ol>
<ul>
<li>
<p><code>find-function</code> 函数查看函数定义。</p>
</li>
<li>
<p><code>find-variable</code> 函数查看变量定义。</p>
</li>
<li>
<p><code>find-function-on-key</code> 函数查看指定的快捷键绑定在了哪个函数上。</p>
<p>定义以上函数快捷键：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"C-h C-f"</span>) 'find-function)<br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"C-h C-v"</span>) 'find-variable)<br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"C-h C-k"</span>) 'find-function-on-key)<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="require-命令"><a class="header-anchor" href="#require-命令">¶</a><code>require</code> 命令</h3>
<ul>
<li><code>require</code> 命令会从一个文件加载一个特性(feature)。如果未提供文件名，那么 <code>require</code> 命令会将第一个参数同时作为特性名和文件名。</li>
<li><code>require</code> 命令内部调用的是 <code>load</code> 命令。</li>
</ul>
<h3 id="eval-buffer-命令"><a class="header-anchor" href="#eval-buffer-命令">¶</a><code>eval-buffer</code> 命令</h3>
<p><code>eval-buffer</code> 命令会执行当前整个 <em>buffer</em> 中的所有命令。</p>
<h3 id="hook"><a class="header-anchor" href="#hook">¶</a>hook</h3>
<p><code>add-hook</code> 函数：</p>
<p>使用：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">add-hook</span> 'hook-name 'hook-function-or-mode)<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>hook-name</code> 代表将在哪个 mode 中添加 hook。例如 <code>emacs-lisp-mode-hook</code>。</p>
</blockquote>
<h3 id="改进-package-系统"><a class="header-anchor" href="#改进-package-系统">¶</a>改进 package 系统</h3>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">when</span> (<span class="hljs-name">&gt;=</span> emacs-major-version <span class="hljs-number">24</span>)<br>    (<span class="hljs-name">require</span> 'package)<br>    (<span class="hljs-name">package-initialize</span>)<br>    (<span class="hljs-name">setq</span> package-archives '((<span class="hljs-string">"gnu"</span>   . <span class="hljs-string">"http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/"</span>)<br>                             (<span class="hljs-string">"melpa"</span> . <span class="hljs-string">"http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/"</span>))))<br><br><span class="hljs-comment">;; cl - Common Lisp Extension</span><br>(<span class="hljs-name">require</span> 'cl)<br><span class="hljs-comment">;; Add Packages</span><br>(<span class="hljs-name">defvar</span> my/packages '(<br>    ;; --- Auto-completion ---<br>    company<br><br>    ;; --- Better Editor ---<br>    hungry-delete<br>    swiper<br>    counsel<br>    smartparens<br>	smex<br><br>    ;; --- Major Mode ---<br>    js2-mode<br><br>	;; --- Minor Mode ---<br>	nodejs-repl<br>	exec-path-from-shell<br><br>	;; --- Themes ---<br>	;; monokai-theme<br>	;; solarized-theme<br>    dracula-theme<br><br>	) <span class="hljs-string">"Default packages"</span>)<br><br><span class="hljs-comment">;; 添加此行防止 package-autoremove 命令自动删除第三方 package</span><br>(<span class="hljs-name">setq</span> package-selected-packages my/packages)<br><br>(<span class="hljs-name">defun</span> my/packages-installed-p ()<br>    (<span class="hljs-name">loop</span> for pkg in my/packages<br>        when (<span class="hljs-name">not</span> (<span class="hljs-name">package-installed-p</span> pkg)) do (<span class="hljs-name">return</span> <span class="hljs-literal">nil</span>)<br>        finally (<span class="hljs-name">return</span> <span class="hljs-literal">t</span>)))<br><br>(<span class="hljs-name">unless</span> (<span class="hljs-name">my/packages-installed-p</span>)<br>    (<span class="hljs-name">message</span> <span class="hljs-string">"%s"</span> <span class="hljs-string">"Refreshing package database..."</span>)<br>    (<span class="hljs-name">package-refresh-contents</span>)<br>    (<span class="hljs-name">dolist</span> (<span class="hljs-name">pkg</span> my/packages)<br>        (<span class="hljs-name">when</span> (<span class="hljs-name">not</span> (<span class="hljs-name">package-installed-p</span> pkg))<br>            (<span class="hljs-name">package-install</span> pkg))))<br></code></pre></div></td></tr></table></figure>
<h3 id="package-list-packages-命令"><a class="header-anchor" href="#package-list-packages-命令">¶</a><code>package-list-packages</code> 命令</h3>
<p>执行 <code>M-x package-list-packages</code> 命令后，会打开一个新的名为 <em>*Packages*</em> 的 <em>buffer</em> 。</p>
<ul>
<li>在 <em>*Packages*</em> <em>buffer</em> 中，按 <code>I</code> 标记将要被安装的包；按 <code>U</code> 取消被标记为将被安装的包；</li>
<li>在 <em>*Packages*</em> <em>buffer</em> 中，按 <code>D</code> 标记将要卸载的包。</li>
<li>在 <em>*Packages*</em> <em>buffer</em> 中，按 <code>U</code> 标记将要更新的包。</li>
<li>在 <em>*Packages*</em> <em>buffer</em> 中，按 <code>X</code> 执行上述标记。</li>
</ul>
<h3 id="customize-group-命令"><a class="header-anchor" href="#customize-group-命令">¶</a><code>customize-group</code> 命令</h3>
<p><code>customize-group</code> 命令用来以更直观的方式配置插件参数并保存至 emacs 配置文件。</p>
<h3 id="更改默认-mode"><a class="header-anchor" href="#更改默认-mode">¶</a>更改默认 mode</h3>
<p>通过更改 <code>auto-mode-alist</code> 变量可以改变自动加载的 mode：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp"><span class="hljs-comment">;; 将 Javascript 文件默认的 Javascript Major Mode 更改为 js2-mode</span><br>(<span class="hljs-name">setq</span> auto-mode-alist<br>    (<span class="hljs-name">append</span><br>        '((<span class="hljs-string">"\\.js\\'"</span> . js2-mode))<br>        auto-mode-alist))<br></code></pre></div></td></tr></table></figure>
<h2 id="第三天"><a class="header-anchor" href="#第三天">¶</a>第三天</h2>
<h3 id="继续定制配置文件-v2"><a class="header-anchor" href="#继续定制配置文件-v2">¶</a>继续定制配置文件</h3>
<ol>
<li>
<p>自动重新加载外部修改文件：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">global-auto-revert-mode</span> <span class="hljs-literal">t</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>禁用文件自动保存</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> auto-save-default <span class="hljs-literal">nil</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>popwin：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">require</span> 'popwin)<br>(<span class="hljs-name">popwin-mode</span> <span class="hljs-literal">t</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>abbrev-mode</p>
<p>abbrev-mode 可以定义一个用以简化自动补全的缩写。</p>
<ul>
<li>
<p>启用：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">abbrev-mode</span> <span class="hljs-literal">t</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>定义缩写列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">define-abbrev-table</span> 'global-abbrev-table '(<br>	(<span class="hljs-string">"8zl"</span> <span class="hljs-string">"zilongshanren"</span>)))<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>关闭触底/顶声音提示</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> ring-bell-function 'ignore)<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="autoload-魔法注释"><a class="header-anchor" href="#autoload-魔法注释">¶</a><code>;;;###autoload</code> 魔法注释</h3>
<p>当我们调用 <code>(package-initialize)</code> 时，其会遍历 <em>elpa</em> 目录中的 packages、读取该 package 目录下的 <em>*.el</em> 文件。根据 <code>;;;###autoload</code> 注释，<code>(package-initialize)</code> 会生成一个包含所有自动加载项的 el 文件。<br>
通过添加 <code>;;;###autoload</code> 魔法注释，emacs 便可以不调用 <code>(require 'mode-name)</code> 而是直接使用 <code>(global-mode-name t)</code> 来启用 package。</p>
<h3 id="load-命令"><a class="header-anchor" href="#load-命令">¶</a><code>load</code> 命令</h3>
<p><code>load package-name</code> 命令使用如下顺序在 <code>load-path</code> 变量指定的目录中查找一个包并加载：</p>
<blockquote>
<p>package-name.elc -&gt; package-name.el -&gt; package-name.gz</p>
</blockquote>
<p>找不到则报错。</p>
<h3 id="load-file-命令"><a class="header-anchor" href="#load-file-命令">¶</a><code>load-file</code> 命令</h3>
<p>在指定的目录查找并加载 package。</p>
<h3 id="features-变量"><a class="header-anchor" href="#features-变量">¶</a><code>features</code> 变量</h3>
<p>一个 package 可以通过 <code>provide</code> 向 <code>features</code> 变量添加自己的包名来“导出”自己，然后 emacs 便可以通过 <code>require</code> 命令读取 <code>features</code> 变量“导入”这个 package。</p>
<h3 id="多文件存储配置"><a class="header-anchor" href="#多文件存储配置">¶</a>多文件存储配置</h3>
<h4 id="load-path-变量"><a class="header-anchor" href="#load-path-变量">¶</a><code>load-path</code> 变量</h4>
<ul>
<li><code>load-path</code> 是一个 <code>list</code> 型变量且默认不包含 <em>~/.emacs.d</em>。</li>
<li>可以通过 <code>(add-to-list 'load-path &quot;custom-configuration-file-path&quot;)</code> 将自定义配置文件所在目录添加到 <code>load-path</code> 中。</li>
</ul>
<h4 id="指定由-customize-group-生成的配置项存储文件"><a class="header-anchor" href="#指定由-customize-group-生成的配置项存储文件">¶</a>指定由 <code>customize-group</code> 生成的配置项存储文件</h4>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> custom-file (<span class="hljs-name">expand-file-name</span> <span class="hljs-string">"configuration-file-path-relative-to-init.el-path"</span> user-emacs-directory))<br>(<span class="hljs-name">load-file</span> custom-file)<br></code></pre></div></td></tr></table></figure>
<h3 id="major-mode-和-minar-mode"><a class="header-anchor" href="#major-mode-和-minar-mode">¶</a>major mode 和 minar mode</h3>
<p>major mode 分为以下三类：</p>
<ul>
<li>text-mode：普通文本模式。</li>
<li>special-mode：特殊模式。用的较少。</li>
<li>prog-mode：编程语言模式。如上述 js2-mode 便从 prog-mode 继承。</li>
</ul>
<h2 id="第四天"><a class="header-anchor" href="#第四天">¶</a>第四天</h2>
<h3 id="indent-region-命令"><a class="header-anchor" href="#indent-region-命令">¶</a><code>indent-region</code> 命令</h3>
<ul>
<li>
<p>签名：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">indent-region</span> START END <span class="hljs-symbol">&amp;optional</span> COLUMN)<br></code></pre></div></td></tr></table></figure>
<p>当我们选中部分文本后，<code>START</code> 和 <code>END</code> 既为选中区域的开头和结尾。</p>
</li>
<li>
<p>使用示例</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> indent-buffer()<br>	(<span class="hljs-name">interactive</span>)<br>	(<span class="hljs-name">indent-region</span> (<span class="hljs-name">point-min</span>) (<span class="hljs-name">point-max</span>)))<br>	<br>(<span class="hljs-name">defun</span> indent-region-or-buffer()<br>   (<span class="hljs-name">interactive</span>)<br>   (<span class="hljs-name">save-excursion</span>    <span class="hljs-comment">;; save-excursion：保存光标位置，执行子语句后恢复光标位置。</span><br>       (<span class="hljs-name">if</span> (<span class="hljs-name">region-active-p</span>)    <span class="hljs-comment">;; *-p：断言。</span><br>           (<span class="hljs-name">progn</span><br>               (<span class="hljs-name">indent-region</span> (<span class="hljs-name">region-beginning</span>) (<span class="hljs-name">region-end</span>))<br>               (<span class="hljs-name">message</span> <span class="hljs-string">"Indent selected region."</span>))<br>       (<span class="hljs-name">progn</span>    <span class="hljs-comment">;; 等价于 else。</span><br>           (<span class="hljs-name">indent-buffer</span>)<br>           (<span class="hljs-name">message</span> <span class="hljs-string">"Indent buffer."</span>)))))<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="Dired-Mode"><a class="header-anchor" href="#Dired-Mode">¶</a>Dired Mode</h3>
<ul>
<li>
<p>Dired Mode 是一个强大的模式它能让我们完成和文件管理相关的所有操作。<br>
使用 <code>C-x d</code> 就可以进入 Dired Mode。<br>
常用操作：</p>
<ul>
<li><code>+</code> 创建目录</li>
<li><code>g</code> 刷新目录</li>
<li><code>C</code> 拷贝</li>
<li><code>D</code> 删除</li>
<li><code>R</code> 重命名</li>
<li><code>d</code> 标记删除</li>
<li><code>u</code> 取消标记</li>
<li><code>x</code> 执行所有的标记</li>
</ul>
</li>
<li>
<p>优化</p>
<ul>
<li>
<p>删除目录的时候 Emacs 会询问是否递归删除或拷贝， 这也有些麻烦我们可以用下面的配置将其设定为默认递归删除目录。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> dired-recursive-deletes 'always)<br>(<span class="hljs-name">setq</span> dired-recursive-copies 'always)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>每一次你进入一个回车进入一个新的目录中是，一个新的缓冲区就会被建立。这使 得我们的缓冲区列表中充满了大量没有实际意义的记录。我们可以使用下面的代码，让 Emacs 重用唯一的一个缓冲区作为 Dired Mode 显示专用缓冲区。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">put</span> 'dired-find-alternate-file 'disabled <span class="hljs-literal">nil</span>)<br><br><span class="hljs-comment">;; 主动加载 Dired Mode</span><br><span class="hljs-comment">;; (require 'dired)</span><br><span class="hljs-comment">;; (defined-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)</span><br><br><span class="hljs-comment">;; 延迟加载</span><br>(<span class="hljs-name">with-eval-after-load</span> 'dired<br>    (<span class="hljs-name">define-key</span> dired-mode-map (<span class="hljs-name">kbd</span> <span class="hljs-string">"RET"</span>) 'dired-find-alternate-file))<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>使用 <code>(setq dired-dwin-target 1)</code> 则可以使当一个窗口（frame）中存在两个分屏 （window）时，将另一个分屏自动设置成拷贝地址的目标。</p>
</li>
</ul>
</li>
</ul>
<h3 id="org-mode-管理-Emacs-配置"><a class="header-anchor" href="#org-mode-管理-Emacs-配置">¶</a>org-mode 管理 Emacs 配置</h3>
<p>我们也可以使用 org 来管理 Emacs 的配置文件（笔者和他的师傅其实更倾向于模块管理配置文件）。</p>
<p>你需要将下面的代码放入配置入口文件 <em>init.el</em> 中，</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">package-initialize</span>)<br><br>(<span class="hljs-name">require</span> 'org-install)<br>(<span class="hljs-name">require</span> 'ob-tangle)<br>(<span class="hljs-name">org-babel-load-file</span> (<span class="hljs-name">expand-file-name</span> <span class="hljs-string">"org-file-name.org"</span> user-emacs-directory))<br></code></pre></div></td></tr></table></figure>
<p>之后我们需要做的仅仅只是将所有的配置文件放入 Org 模式中的代码块即可，并使用目录 结构来表述你的配置文件再把它保存在与入口文件相同的目录中即可(文件名为 <em><a href="http://org-file-name.org" target="_blank" rel="noopener">org-file-name.org</a></em>)。Emacs 会提取其中的配置并使其生效。这样做的好处是可以使自 己和他人更直观的，理解你的配置文件或者代码。</p>
<h2 id="第五天"><a class="header-anchor" href="#第五天">¶</a>第五天</h2>
<h3 id="继续定制配置文件-v3"><a class="header-anchor" href="#继续定制配置文件-v3">¶</a>继续定制配置文件</h3>
<ol>
<li>
<p>取消引号自动配对：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">sp-local-pair</span> 'emacs-lisp-mode <span class="hljs-string">"'"</span> <span class="hljs-literal">nil</span> <span class="hljs-symbol">:actions</span> <span class="hljs-literal">nil</span>)<br>(<span class="hljs-name">sp-local-pair</span> 'lisp-interaction-mode <span class="hljs-string">"'"</span> <span class="hljs-literal">nil</span> <span class="hljs-symbol">:actions</span> <span class="hljs-literal">nil</span>)<br><br><span class="hljs-comment">;; 也可以把上面两句合起来</span><br>(<span class="hljs-name">sp-local-pair</span> '(emacs-lisp-mode lisp-interaction-mode) <span class="hljs-string">"'"</span> <span class="hljs-literal">nil</span> <span class="hljs-symbol">:actions</span> <span class="hljs-literal">nil</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>show-paren-mode 可以使鼠标在括号上是高亮其所匹配的另一半括号，然而我们想要光标在括号内时就高亮包含内容的两个括号，使用下面的代码就可以做到这一点：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp"><span class="hljs-comment">;; define-advice宏：扩展一个函数，使其在执行过程中 (:around) 执行另外一些操作。</span><br>(<span class="hljs-name">define-advice</span> show-paren-function (<span class="hljs-symbol">:around</span> (<span class="hljs-name">fn</span>) fix-show-paren-function)<br>  <span class="hljs-string">"Highlight enclosing parens."</span><br>  (<span class="hljs-name">cond</span> ((<span class="hljs-name">looking-at-p</span> <span class="hljs-string">"\\s("</span>) (<span class="hljs-name">funcall</span> fn))<br>		(<span class="hljs-name">t</span> (<span class="hljs-name">save-excursion</span><br>	     (<span class="hljs-name">ignore-errors</span> (<span class="hljs-name">backward-up-list</span>))<br>	     (<span class="hljs-name">funcall</span> fn)))))<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>解决在不同系统中的换行符，例如在 DOS 系统下的 <code>\r(^M)</code> 换行符， 这让我们有时候在 Unix 系统中很是头疼，因为它的存在会使版本控制误以为整行的代码都 被修改过而造成不必要的麻烦。（你可以在这里找到更多关于 <a href="http://unix.stackexchange.com/questions/32001/what-is-m-and-how-do-i-get-rid-of-it" target="_blank" rel="noopener">\r(^M)</a> 的信息）。</p>
<ul>
<li>
<p>方法一：隐藏</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> hidden-dos-eol ()<br>  <span class="hljs-string">"Do not show ^M in files containing mixed UNIX and DOS line endings."</span><br>  (<span class="hljs-name">interactive</span>)<br>  (<span class="hljs-name">unless</span> buffer-display-table<br>    (<span class="hljs-name">setq</span> buffer-display-table (<span class="hljs-name">make-display-table</span>)))<br>  (<span class="hljs-name">aset</span> buffer-display-table ?\^M []))<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>方法二：删除</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> remove-dos-eol ()<br>  <span class="hljs-string">"Replace DOS eolns CR LF with Unix eolns CR"</span><br>  (<span class="hljs-name">interactive</span>)<br>  (<span class="hljs-name">goto-char</span> (<span class="hljs-name">point-min</span>))<br>  (<span class="hljs-name">while</span> (<span class="hljs-name">search-forward</span> <span class="hljs-string">"\r"</span> <span class="hljs-literal">nil</span> <span class="hljs-literal">t</span>) (<span class="hljs-name">replace-match</span> <span class="hljs-string">""</span>)))<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="web-mode"><a class="header-anchor" href="#web-mode">¶</a>web-mode</h3>
<ul>
<li>
<p>安装</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defvar</span> xinyang/packages '(<br>			   ;; 你其他的插件在这里<br>			   web-mode<br>			   ) <span class="hljs-string">"Default packages"</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>配置</p>
<ol>
<li>
<p>我们需要做的是将所有的 <em>*.html</em> 文件都使用 web-mode 来打开。</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> auto-mode-alist<br>      (<span class="hljs-name">append</span><br>       '((<span class="hljs-string">"\\.js\\'"</span> . js2-mode))<br>       '((<span class="hljs-string">"\\.html\\'"</span> . web-mode))<br>       auto-mode-alist))<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<p>这样所有的 HTML 代码在 Emacs 中就会之间启用 web-mode 而非默认的 HTML Mode 了。你可以阅读它的<a href="http://web-mode.org/" target="_blank" rel="noopener">文档</a>来学习更多 web-mode 详细的使用方法。</p>
<ol start="2">
<li>
<p>缩进的大小的设置。我们可以对不同的语言的缩减做出设置：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> my-web-mode-indent-setup ()<br>  (<span class="hljs-name">setq</span> web-mode-markup-indent-offset <span class="hljs-number">4</span>) <span class="hljs-comment">; web-mode, html tag in html file</span><br>  (<span class="hljs-name">setq</span> web-mode-css-indent-offset <span class="hljs-number">4</span>)    <span class="hljs-comment">; web-mode, css in html file</span><br>  (<span class="hljs-name">setq</span> web-mode-code-indent-offset <span class="hljs-number">4</span>)   <span class="hljs-comment">; web-mode, js code in html file</span><br>  )<br>(<span class="hljs-name">add-hook</span> 'web-mode-hook 'my-web-mode-indent-setup)<br><br><span class="hljs-comment">;; 下面的函数可以用于在两个空格和四个空格之间进行切换</span><br>(<span class="hljs-name">defun</span> my-toggle-web-indent ()<br>  (<span class="hljs-name">interactive</span>)<br>  <span class="hljs-comment">;; web development</span><br>  (<span class="hljs-name">if</span> (<span class="hljs-name">or</span> (<span class="hljs-name">eq</span> major-mode 'js-mode) (<span class="hljs-name">eq</span> major-mode 'js2-mode))<br>      (<span class="hljs-name">progn</span><br>		(<span class="hljs-name">setq</span> js-indent-level (<span class="hljs-name">if</span> (<span class="hljs-name">=</span> js-indent-level <span class="hljs-number">2</span>) <span class="hljs-number">4</span> <span class="hljs-number">2</span>))<br>		(<span class="hljs-name">setq</span> js2-basic-offset (<span class="hljs-name">if</span> (<span class="hljs-name">=</span> js2-basic-offset <span class="hljs-number">2</span>) <span class="hljs-number">4</span> <span class="hljs-number">2</span>))))<br><br>  (<span class="hljs-name">if</span> (<span class="hljs-name">eq</span> major-mode 'web-mode)<br>      (<span class="hljs-name">progn</span> (<span class="hljs-name">setq</span> web-mode-markup-indent-offset (<span class="hljs-name">if</span> (<span class="hljs-name">=</span> web-mode-markup-indent-offset <span class="hljs-number">2</span>) <span class="hljs-number">4</span> <span class="hljs-number">2</span>))<br>		     (<span class="hljs-name">setq</span> web-mode-css-indent-offset (<span class="hljs-name">if</span> (<span class="hljs-name">=</span> web-mode-css-indent-offset <span class="hljs-number">2</span>) <span class="hljs-number">4</span> <span class="hljs-number">2</span>))<br>		     (<span class="hljs-name">setq</span> web-mode-code-indent-offset (<span class="hljs-name">if</span> (<span class="hljs-name">=</span> web-mode-code-indent-offset <span class="hljs-number">2</span>) <span class="hljs-number">4</span> <span class="hljs-number">2</span>))))<br>  (<span class="hljs-name">if</span> (<span class="hljs-name">eq</span> major-mode 'css-mode)<br>      (<span class="hljs-name">setq</span> css-indent-offset (<span class="hljs-name">if</span> (<span class="hljs-name">=</span> css-indent-offset <span class="hljs-number">2</span>) <span class="hljs-number">4</span> <span class="hljs-number">2</span>)))<br><br>  (<span class="hljs-name">setq</span> indent-tabs-mode <span class="hljs-literal">nil</span>))<br><br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"C-c t i"</span>) 'my-toggle-web-indent)<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="js2-refactor"><a class="header-anchor" href="#js2-refactor">¶</a>js2-refactor</h3>
<ol>
<li>
<p>安装</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defvar</span> xinyang/packages '(<br>			   ;; 你其他的插件在这里<br>			   js2-refactor<br>			   ) <span class="hljs-string">"Default packages"</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>配置</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">add-hook</span> 'js2-mode-hook #'js2-refactor-mode)<br>(<span class="hljs-name">js2r-add-keybindings-with-prefix</span> <span class="hljs-string">"C-c C-m"</span>)<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h3 id="occur-mode"><a class="header-anchor" href="#occur-mode">¶</a>occur-mode</h3>
<p>occur 可以用于显示变量或函数的定义。</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> occur-dwim ()<br>  <span class="hljs-string">"Call `occur' with a sane default."</span><br>  (<span class="hljs-name">interactive</span>)<br>  (<span class="hljs-name">push</span> (<span class="hljs-name">if</span> (<span class="hljs-name">region-active-p</span>)<br>	  (<span class="hljs-name">buffer-substring-no-properties</span><br>		  (<span class="hljs-name">region-beginning</span>)<br>	      (<span class="hljs-name">region-end</span>))<br>		(<span class="hljs-name">let</span> ((<span class="hljs-name">sym</span> (<span class="hljs-name">thing-at-point</span> 'symbol)))<br>		    (<span class="hljs-name">when</span> (<span class="hljs-name">stringp</span> sym)<br>		      (<span class="hljs-name">regexp-quote</span> sym))))<br>		regexp-history)<br>  (<span class="hljs-name">call-interactively</span> 'occur))<br>	(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"C-c C-s o"</span>) 'occur-dwim)<br></code></pre></div></td></tr></table></figure>
<p>occur 与普通的搜索模式不同的是，它可以使用 Occur-Edit Mode (在弹出的窗口中按 <code>e</code> 进入编辑模式) 对搜索到的结果进行之间的编辑。</p>
<h3 id="imenu"><a class="header-anchor" href="#imenu">¶</a>imenu</h3>
<p>imenu 可以显示当前缓冲区所有符号的列表，下面的配置可以让其拥有更精确的跳转：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> js2-imenu-make-index ()<br>	(<span class="hljs-name">interactive</span>)<br>    (<span class="hljs-name">save-excursion</span><br>	<span class="hljs-comment">;; (setq imenu-generic-expression '((nil "describe\\(\"\\(.+\\)\"" 1)))</span><br>	(<span class="hljs-name">imenu--generic-function</span> '((<span class="hljs-string">"describe"</span> <span class="hljs-string">"\\s-*describe\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*"</span> <span class="hljs-number">1</span>)<br>				   (<span class="hljs-string">"it"</span> <span class="hljs-string">"\\s-*it\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*"</span> <span class="hljs-number">1</span>)<br>				   (<span class="hljs-string">"test"</span> <span class="hljs-string">"\\s-*test\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*"</span> <span class="hljs-number">1</span>)<br>				   (<span class="hljs-string">"before"</span> <span class="hljs-string">"\\s-*before\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*"</span> <span class="hljs-number">1</span>)<br>				   (<span class="hljs-string">"after"</span> <span class="hljs-string">"\\s-*after\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*"</span> <span class="hljs-number">1</span>)<br>				   (<span class="hljs-string">"Function"</span> <span class="hljs-string">"function[ \t]+\\([a-zA-Z0-9_$.]+\\)[ \t]*("</span> <span class="hljs-number">1</span>)<br>				   (<span class="hljs-string">"Function"</span> <span class="hljs-string">"^[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*=[ \t]*function[ \t]*("</span> <span class="hljs-number">1</span>)<br>				   (<span class="hljs-string">"Function"</span> <span class="hljs-string">"^var[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*=[ \t]*function[ \t]*("</span> <span class="hljs-number">1</span>)<br>				   (<span class="hljs-string">"Function"</span> <span class="hljs-string">"^[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*()[ \t]*&#123;"</span> <span class="hljs-number">1</span>)<br>				   (<span class="hljs-string">"Function"</span> <span class="hljs-string">"^[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*:[ \t]*function[ \t]*("</span> <span class="hljs-number">1</span>)<br>				   (<span class="hljs-string">"Task"</span> <span class="hljs-string">"[. \t]task([ \t]*['\"]\\([^'\"]+\\)"</span> <span class="hljs-number">1</span>)))))<br>(<span class="hljs-name">add-hook</span> 'js2-mode-hook<br>	    (<span class="hljs-name">lambda</span> ()<br>			(<span class="hljs-name">setq</span> imenu-create-index-function 'js2-imenu-make-index)))<br><br>(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"C-c C-s i"</span>) 'counsel-imenu)<br></code></pre></div></td></tr></table></figure>
<h3 id="expand-region"><a class="header-anchor" href="#expand-region">¶</a>expand-region</h3>
<p>使用这个插件可以使我们更方便的选中一个区域。（更多使用方法和文档可以在<a href="https://github.com/magnars/expand-region.el" target="_blank" rel="noopener">这里</a>找到）。<br>
为其绑定一个快捷键：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"C-="</span>) 'er/expand-region)<br></code></pre></div></td></tr></table></figure>
<h3 id="iedit"><a class="header-anchor" href="#iedit">¶</a>iedit</h3>
<p>iedit 是一个可以同时编辑多个区域的插件，它类似 Sublime Text 中的多光标编辑。<br>
我们将其绑定快捷键以便更快捷的使用这个模式（ <code>C-;</code> 为默认快捷键），</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"C-c C-s e"</span>) 'iedit-mode)<br></code></pre></div></td></tr></table></figure>
<p>我们可以使用 <code>customized-group</code> 来更改其高亮的背景色，将 <code>highlight</code> 改为 <code>region</code>。</p>
<h3 id="org-导出"><a class="header-anchor" href="#org-导出">¶</a>org 导出</h3>
<p>使用 <code>C-c C-e</code> 可以将 org-mode 文档导出为你需要的格式，例如 HTML 或者 PDF 文件。</p>
<h2 id="第六天"><a class="header-anchor" href="#第六天">¶</a>第六天</h2>
<h3 id="org-mode-进阶"><a class="header-anchor" href="#org-mode-进阶">¶</a>org-mode 进阶</h3>
<ol>
<li>
<p>使用 <code>org-capture</code> 命令记笔记。</p>
<p>我们用下面的配置代码来设置一个模板（其中设置了待办事项的优先级还有触发键）：</p>
<div class="hljs code-wrapper"><pre><code> <figure class="highlight lisp"><table><tr><td class="gutter hljs"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> org-capture-templates<br>    '((<span class="hljs-string">"t"</span> <span class="hljs-string">"Todo"</span> entry (file+headline <span class="hljs-string">"~/.emacs.d/gtd.org"</span> <span class="hljs-string">"工作安排"</span>)<br>		 <span class="hljs-string">"* TODO [#B] %?\n  %i\n"</span><br>	 :empty-lines <span class="hljs-number">1</span>)))<br></code></pre></div></td></tr></table></figure>
</code></pre>
<p>我们也可以为其绑定一个快捷键：</p>
<div class="hljs code-wrapper"><pre><code> <figure class="highlight lisp"><table><tr><td class="gutter hljs"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">global-set-key</span> (<span class="hljs-name">kbd</span> <span class="hljs-string">"C-c r"</span>) 'org-capture)<br></code></pre></div></td></tr></table></figure>
</code></pre>
<p>更多有关 <code>org-capture</code> 的内容可以在<a href="http://orgmode.org/manual/Capture.html" target="_blank" rel="noopener">这里</a>找到。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Emacs</tag>
        <tag>笔记</tag>
        <tag>GNU</tag>
      </tags>
  </entry>
  <entry>
    <title>Elisp 学习笔记（二）</title>
    <url>/2019/10/05/Elisp-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h1>Elisp 学习笔记（二）</h1>
<h2 id="求值规则"><a class="header-anchor" href="#求值规则">¶</a>求值规则</h2>
<p>求值是 lisp 解释器的核心，理解了求值过程也就学会了 lisp 编程的一半。正因为这样，我有点担心自己说得不清楚或者理解错误，会误导了你。所以如果真想深入了解的话，还是自己看 info elisp - Evaluation 这一章吧。<br>
一个要求值的 lisp 对象被称为表达式（form）。所有的表达式可以分为三种：符号、列表和其它类型（废话）。下面一一说明各种表达式的求值规则。</p>
<ul>
<li>
<p>第一种表达式是最简单的，自求值表达式。前面说过数字、字符串、向量都是自求值表达式。还有两个特殊的符号 <code>t</code> 和 <code>nil</code> 也可以看成是自求值表达式。</p>
</li>
<li>
<p>第二种表达式是符号。符号的求值结果就是符号的值。如果它没有值，就会出现 void-variable 的错误。</p>
</li>
<li>
<p>第三种表达式是列表表达式。而列表表达式又可以根据第一个元素分为函数调用、宏调用和特殊表达式（special form）三种。列表的第一个表达式如果是一个符号，解释器会查找这个表达式的函数值。</p>
<ul>
<li>
<p>如果函数值是另一个符号，则会继续查找这个符号的函数值。这称为“symbol function indirection”。最后直到某个符号的函数值是一个 lisp 函数（lambda 表达式）、byte-code 函数、原子函数（primitive function）、宏、特殊表达式或 autoload 对象。如果不是这些类型，比如某个符号的函数值是前面出现的某个符号导致无限循环，或者某个符号函数值为空，都会导致一个错误 invalid-function。</p>
<p>这个函数显示 indirection function</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">symbol-function</span> 'car)                  <span class="hljs-comment">; =&gt; #&lt;subr car&gt;</span><br>(<span class="hljs-name">fset</span> 'first 'car)                      <span class="hljs-comment">; =&gt; car</span><br>(<span class="hljs-name">fset</span> 'erste 'first)                    <span class="hljs-comment">; =&gt; first</span><br>(<span class="hljs-name">erste</span> '(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))                        <span class="hljs-comment">; =&gt; 1</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>如果第一个元素是一个宏对象，列表里的其它元素不会立即求值，而是根据宏定义进行扩展。如果扩展后还是一个宏调用，则会继续扩展下去，直到扩展的结果不再是一个宏调用为止。例如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defmacro</span> cadr (<span class="hljs-name">x</span>)<br>  (<span class="hljs-name">list</span> 'car (<span class="hljs-name">list</span> 'cdr x)))<br></code></pre></div></td></tr></table></figure>
<p>这样 <code>(cadr (assq 'handler list))</code> 扩展后成为 <code>(car (cdr (assq 'handler list)))</code>。</p>
</li>
<li>
<p>第一个元素如果是一个特殊表达式时，它的参数可能并不会全求值。这些特殊表达式通常是用于控制结构或者变量绑定。每个特殊表达式都有对应的求值规则。这在下面会提到。</p>
</li>
</ul>
</li>
</ul>
<p>最后用这个伪代码来说明一下 elisp 中的求值规则：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> (<span class="hljs-name">eval</span> exp)<br>  (<span class="hljs-name">cond</span><br>   ((<span class="hljs-name">numberp</span> exp) exp)<br>   ((<span class="hljs-name">stringp</span> exp) exp)<br>   ((<span class="hljs-name">arrayp</span> exp) exp)<br>   ((<span class="hljs-name">symbolp</span> exp) (<span class="hljs-name">symbol-value</span> exp))<br>   ((<span class="hljs-name">special-form-p</span> (<span class="hljs-name">car</span> exp))<br>    (<span class="hljs-name">eval-special-form</span> exp))<br>   ((<span class="hljs-name">fboundp</span> (<span class="hljs-name">car</span> exp))<br>    (<span class="hljs-name">apply</span> (<span class="hljs-name">car</span> exp) (<span class="hljs-name">cdr</span> exp)))<br>   (<span class="hljs-name">t</span><br>    (<span class="hljs-name">error</span> <span class="hljs-string">"Unknown expression type -- EVAL %S"</span> exp))))<br></code></pre></div></td></tr></table></figure>
<h2 id="变量"><a class="header-anchor" href="#变量">¶</a>变量</h2>
<p><strong>当同一个变量名既是全局变量也是局部变量，或者用 <code>let</code> 多层绑定，只有最里层的那个变量是有效的，用 <code>setq</code> 改变的也只是最里层的变量，而不影响外层的变量。</strong><br>
比如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp"><br>(<span class="hljs-name">progn</span><br>  (<span class="hljs-name">setq</span> foo <span class="hljs-string">"I'm global variable!"</span>)<br>  (<span class="hljs-name">let</span> ((<span class="hljs-name">foo</span> <span class="hljs-number">5</span>))<br>    (<span class="hljs-name">message</span> <span class="hljs-string">"foo value is: %S"</span> foo)<br>    (<span class="hljs-name">let</span> (<span class="hljs-name">foo</span>)<br>      (<span class="hljs-name">setq</span> foo <span class="hljs-string">"I'm local variable!"</span>)<br>      (<span class="hljs-name">message</span> foo))<br>    (<span class="hljs-name">message</span> <span class="hljs-string">"foo value is still: %S"</span> foo))<br>  (<span class="hljs-name">message</span> foo))<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>另外需要注意一点的是局部变量的绑定不能超过一定的层数，也就是说，你不能把 <code>foo</code> 用 <code>let</code> 绑定 10000 层。当然普通的函数是不可能写成这样的，但是递归函数就不一定了。限制层数的变量在 <code>max-specpdl-size</code> 中定义。如果你写的递归函数有这个需要的话，可以先设置这个变量的值</p>
</blockquote>
<h3 id="buffer-local-变量"><a class="header-anchor" href="#buffer-local-变量">¶</a>buffer-local 变量</h3>
<p>emacs 能有如此丰富的模式，各个缓冲区之间能不相互冲突，很大程度上要归功于 buffer-local 变量。<br>
声明一个 buffer-local 的变量可以用 <code>make-variable-buffer-local</code> 或用 <code>make-local-variable</code>。这两个函数的区别在于前者是相当于在所有缓冲区中都产生一个 buffer-local 的变量。而后者只在声明时所在的缓冲区内产生一个局部变量，而其它缓冲区仍然使用的是全局变量。一般来说推荐使用 <code>make-local-variable</code>。</p>
<ul>
<li>
<p><code>with-current-buffer</code> 的使用形式是</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">with-current-buffer</span> buffer<br>  body)<br></code></pre></div></td></tr></table></figure>
<p>其中 <code>buffer</code> 可以是一个缓冲区对象，也可以是缓冲区的名字。它的作用是使其中的 <code>body</code> 表达式在指定的缓冲区里执行。</p>
</li>
<li>
<p><code>get-buffer</code> 可以用缓冲区的名字得到对应的缓冲区对象。如果没有这样名字的缓冲区会返回 <code>nil</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Emacs</tag>
        <tag>Lisp</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Elisp 学习笔记（一）</title>
    <url>/2019/10/05/Elisp-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h1>Elisp 学习笔记（一）</h1>
<h2 id="基础知识"><a class="header-anchor" href="#基础知识">¶</a>基础知识</h2>
<h3 id="函数和变量"><a class="header-anchor" href="#函数和变量">¶</a>函数和变量</h3>
<h4 id="函数"><a class="header-anchor" href="#函数">¶</a>函数</h4>
<ul>
<li>
<p>elisp 函数的一般形式：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> function-name (<span class="hljs-name">arguments-list</span>)<br>  <span class="hljs-string">"document string"</span><br>  body)<br></code></pre></div></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> hello-world (<span class="hljs-name">name</span>)<br>  <span class="hljs-string">"Say hello to user whose name is NAME."</span><br>  (<span class="hljs-name">message</span> <span class="hljs-string">"Hello, %s"</span> name))<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>每个函数都有一个返回值。这个返回值一般是函数定义里的最后一个表达式的值。</p>
</li>
<li>
<p>elisp 中函数是全局的。</p>
</li>
</ul>
<h4 id="lambda-表达式"><a class="header-anchor" href="#lambda-表达式">¶</a><code>lambda</code> 表达式</h4>
<p>它的形式和 <code>defun</code> 是完全一样的：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">lambda</span> (<span class="hljs-name">arguments-list</span>)<br>  <span class="hljs-string">"documentation string"</span><br>  body)<br></code></pre></div></td></tr></table></figure>
<p>调用 <code>lambda</code> 方法如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">funcall</span> (<span class="hljs-name">lambda</span> (<span class="hljs-name">name</span>)<br>           (<span class="hljs-name">message</span> <span class="hljs-string">"Hello, %s!"</span> name)) <span class="hljs-string">"Emacser"</span>)<br></code></pre></div></td></tr></table></figure>
<p>你也可以把 <code>lambda</code> 表达式赋值给一个变量，然后用 <code>funcall</code> 调用：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> foo (<span class="hljs-name">lambda</span> (<span class="hljs-name">name</span>)<br>            (<span class="hljs-name">message</span> <span class="hljs-string">"Hello, %s!"</span> name)))<br>(<span class="hljs-name">funcall</span> foo <span class="hljs-string">"Emacser"</span>)                   <span class="hljs-comment">; =&gt; "Hello, Emacser!"</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>lambda</code> 表达式最常用的是作为参数传递给其它函数，比如 <code>mapc</code>。</p>
</blockquote>
<h4 id="变量"><a class="header-anchor" href="#变量">¶</a>变量</h4>
<ul>
<li>
<p>elisp 里的变量使用无需象 C 语言那样需要声明，你可以用 <code>setq</code> 直接对一个变量赋值。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> foo <span class="hljs-string">"I'm foo"</span>)                    <span class="hljs-comment">; =&gt; "I'm foo"</span><br>(<span class="hljs-name">message</span> foo)                           <span class="hljs-comment">; =&gt; "I'm foo"</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>有一个特殊表达式（special form）<code>defvar</code>，它可以声明一个变量，一般的形式是：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defvar</span> variable-name value<br>  <span class="hljs-string">"document string"</span>)<br></code></pre></div></td></tr></table></figure>
<p>它与 <code>setq</code> 的区别：</p>
<ol>
<li>
<p>如果变量在声明之前，这个变量已经有一个值的话，用 <code>defvar</code> 声明的变量值不会改变成声明的那个值。</p>
</li>
<li>
<p><code>defvar</code> 可以为变量提供文档字符串，当变量是在文件中定义的话，<code>C-h v</code> 后能给出变量定义的位置。比如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defvar</span> foo <span class="hljs-string">"Did I have a value?"</span><br>  <span class="hljs-string">"A demo variable"</span>)                    <span class="hljs-comment">; =&gt; foo</span><br>foo                                     <span class="hljs-comment">; =&gt; "I'm foo"</span><br>(<span class="hljs-name">defvar</span> bar <span class="hljs-string">"I'm bar"</span><br>  <span class="hljs-string">"A demo variable named \"bar\""</span>)      <span class="hljs-comment">; =&gt; bar</span><br>bar                                     <span class="hljs-comment">; =&gt; "I'm bar"</span><br></code></pre></div></td></tr></table></figure>
<p>用 <code>C-h v</code> 查看 <code>foo</code> 的文档，可以看到它已经变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">foo&#39;s value is &quot;I&#39;m foo&quot;<br>	<br>Documentation:<br>A demo variable<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>局部作用域的变量</p>
<p>如果没有局部作用域的变量，都使用 <strong>全局变量</strong>，函数会相当难写。elisp 里可以用 <code>let</code> 和 <code>let*</code> 进行局部变量的绑定。</p>
<ul>
<li>
<p><code>let</code> 使用的形式是：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">let</span> (<span class="hljs-name">bindings</span>)<br>  body)<br></code></pre></div></td></tr></table></figure>
<p><code>bingdings</code> 可以是 <code>(var value)</code> 这样对 <code>var</code> 赋初始值的形式，或者用 <code>var</code> 声明一个初始值为 <code>nil</code> 的变量。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> circle-area (<span class="hljs-name">radix</span>)<br>  (<span class="hljs-name">let</span> ((<span class="hljs-name">pi</span> <span class="hljs-number">3.1415926</span>)<br>        area)<br>    (<span class="hljs-name">setq</span> area (<span class="hljs-name">*</span> pi radix radix))<br>    (<span class="hljs-name">message</span> <span class="hljs-string">"直径为 %.2f 的圆面积是 %.2f"</span> radix area)))<br>(<span class="hljs-name">circle-area</span> <span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure>
<p><code>C-h v</code> 查看 <code>area</code> 和 <code>pi</code> 应该没有这两个变量。</p>
</li>
<li>
<p><code>let*</code> 和 <code>let</code> 的使用形式完全相同，唯一的区别是在 <code>let*</code> 声明中就能使用前面声明的变量，比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> circle-area (<span class="hljs-name">radix</span>)<br>  (<span class="hljs-name">let*</span> ((<span class="hljs-name">pi</span> <span class="hljs-number">3.1415926</span>)<br>        (<span class="hljs-name">area</span> (<span class="hljs-name">*</span> pi radix radix)))<br>   (<span class="hljs-name">message</span> <span class="hljs-string">"直径为 %.2f 的圆面积是 %.2f"</span> radix area)))<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="控制结构"><a class="header-anchor" href="#控制结构">¶</a>控制结构</h4>
<ul>
<li>
<p>顺序执行</p>
<p>一般来说程序都是按表达式顺序依次执行的。这在 <code>defun</code> 等特殊环境中是自动进行的。**但是一般情况下都不是这样的。比如你无法用 <code>eval-last-sexp</code> 同时执行两个表达式，在 <code>if</code> 表达式中的条件为真时执行的部分也只能运行一个表达式。**这时就需要用 <code>progn</code> 这个特殊表达式。它的使用形式如下：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">progn</span> A B C ...)<br></code></pre></div></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">progn</span><br>  (<span class="hljs-name">setq</span> foo <span class="hljs-number">3</span>)<br>  (<span class="hljs-name">message</span> <span class="hljs-string">"Square of %d is %d"</span> foo (<span class="hljs-name">*</span> foo foo)))<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>条件判断</p>
<ul>
<li>
<p><code>if</code> ：</p>
<p>形式：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">if</span> condition<br>    then<br>	else)<br></code></pre></div></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> my-max (<span class="hljs-name">a</span> b)<br>  (<span class="hljs-name">if</span> (<span class="hljs-name">&gt;</span> a b)<br>      a b))<br>(<span class="hljs-name">my-max</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>)                            <span class="hljs-comment">; =&gt; 4</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>cond</code> ：</p>
<p>形式：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">cond</span> (<span class="hljs-name">case1</span> do-when-case1)<br>	(<span class="hljs-name">case2</span> do-when-case2)<br>  ...<br>	(<span class="hljs-name">t</span> do-when-none-meet))<br></code></pre></div></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> fib (<span class="hljs-name">n</span>)<br>  (<span class="hljs-name">cond</span> ((<span class="hljs-name">=</span> n <span class="hljs-number">0</span>) <span class="hljs-number">0</span>)<br>       ((<span class="hljs-name">=</span> n <span class="hljs-number">1</span>) <span class="hljs-number">1</span>)<br>       (<span class="hljs-name">t</span> (<span class="hljs-name">+</span> (<span class="hljs-name">fib</span> (<span class="hljs-name">-</span> n <span class="hljs-number">1</span>))<br>	      (<span class="hljs-name">fib</span> (<span class="hljs-name">-</span> n <span class="hljs-number">2</span>))))))<br>(<span class="hljs-name">fib</span> <span class="hljs-number">10</span>)                                <span class="hljs-comment">; =&gt; 55</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>when</code> ：</p>
<p>形式：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">when</span> condition<br>    ...)<br><span class="hljs-comment">;; 等同于</span><br><span class="hljs-comment">;;	(if condition</span><br><span class="hljs-comment">;;	    (progn</span><br><span class="hljs-comment">;;			...))</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>unless</code> ：</p>
<p>等同于：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">when</span> not condition<br>	...)<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>循环</p>
<p>循环使用的是 <code>while</code> 表达式。它的形式是：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">while</span> condition<br>  body)<br></code></pre></div></td></tr></table></figure>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> factorial (<span class="hljs-name">n</span>)<br>  (<span class="hljs-name">let</span> ((<span class="hljs-name">res</span> <span class="hljs-number">1</span>))<br>    (<span class="hljs-name">while</span> (<span class="hljs-name">&gt;</span> n <span class="hljs-number">1</span>)<br>      (<span class="hljs-name">setq</span> res (<span class="hljs-name">*</span> res n)<br>           n (<span class="hljs-name">-</span> n <span class="hljs-number">1</span>)))<br>    res))<br>(<span class="hljs-name">factorial</span> <span class="hljs-number">10</span>)                          <span class="hljs-comment">; =&gt; 3628800</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="逻辑运算"><a class="header-anchor" href="#逻辑运算">¶</a>逻辑运算</h4>
<p>条件的逻辑运算和其它语言都是很类似的，使用 <code>and</code>、<code>or</code>、<code>not</code>。<code>and</code> 和 <code>or</code> 也同样具有短路性质。很多人喜欢在表达式短路时，用 <code>and</code> 代替 <code>when</code>，<code>or</code> 代替 <code>unless</code>。<strong>当然这时一般不关心它们的返回值，而是在于表达式其它子句的副作用</strong>。比如 <code>or</code> 经常用于设置函数的缺省值，而 <code>and</code> 常用于参数检查：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> hello-world (<span class="hljs-name">&amp;optional</span> name)<br>  (<span class="hljs-name">or</span> name (<span class="hljs-name">setq</span> name <span class="hljs-string">"Emacser"</span>))<br>  (<span class="hljs-name">message</span> <span class="hljs-string">"Hello, %s"</span> name))           <span class="hljs-comment">; =&gt; hello-world</span><br>(<span class="hljs-name">hello-world</span>)                           <span class="hljs-comment">; =&gt; "Hello, Emacser"</span><br>(<span class="hljs-name">hello-world</span> <span class="hljs-string">"Ye"</span>)                      <span class="hljs-comment">; =&gt; "Hello, Ye"</span><br><br>(<span class="hljs-name">defun</span> square-number-p (<span class="hljs-name">n</span>)<br>  (<span class="hljs-name">and</span> (<span class="hljs-name">&gt;=</span> n <span class="hljs-number">0</span>)<br>       (<span class="hljs-name">=</span> (<span class="hljs-name">/</span> n (<span class="hljs-name">sqrt</span> n)) (<span class="hljs-name">sqrt</span> n))))<br>(<span class="hljs-name">square-number-p</span> <span class="hljs-number">-1</span>)                    <span class="hljs-comment">; =&gt; nil</span><br>(<span class="hljs-name">square-number-p</span> <span class="hljs-number">25</span>)                    <span class="hljs-comment">; =&gt; t</span><br></code></pre></div></td></tr></table></figure>
<h2 id="基本数据类型"><a class="header-anchor" href="#基本数据类型">¶</a>基本数据类型</h2>
<ul>
<li>
<p>内建的 emacs 数据类型称为 primitive types，包括：</p>
<ul>
<li>整数</li>
<li>浮点数</li>
<li>cons</li>
<li>符号 (symbol)</li>
<li>字符串</li>
<li>向量 (vector)</li>
<li>散列表 (hash-table)</li>
<li>subr（内建函数，比如 <code>cons</code>, <code>if</code>, <code>and</code> 之类）</li>
<li>byte-code function</li>
<li>其它特殊类型，例如缓冲区（buffer）</li>
</ul>
</li>
<li>
<p>读入语法和输出形式</p>
<ul>
<li>
<p>读入语法是让 elisp 解释器明白输入字符所代表的对象。简单的来说，一种数据类型有（也可能没有，比如散列表）对应的规则来让解释器产生这种数据类型，比如 <code>123</code> 产生整数 <code>123</code>，<code>(a . b)</code> 产生一个 cons。</p>
</li>
<li>
<p>所谓输出形式是解释器用产生一个字符串来表示一个数据对象。比如整数 <code>123</code> 的输出形式就是 <code>12</code>3，<code>cons cell (a . b)</code> 的输出形式是 <code>(a . b)</code>。与读入语法不同的是，<strong>数据对象都有输出形式</strong>。比如散列表的输出可能是这样的：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">#&lt;hash-table 'eql <span class="hljs-literal">nil</span> <span class="hljs-number">0/65</span> <span class="hljs-number">0</span>xa7344c8&gt;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="数字"><a class="header-anchor" href="#数字">¶</a>数字</h3>
<p>emacs 的数字分为 <strong>整数</strong> 和 <strong>浮点数</strong>（<strong>和 C 比没有双精度数 double</strong>）。<code>1</code>， <code>1.</code>，<code>+1</code>, <code>-1</code>, <code>536870913</code>, <code>0</code>, <code>-0</code> 这些都是整数。整数的范围是和机器是有关的，一般来最小范围是在 <code>-268435456</code> to <code>268435455</code>（29位，<code>-2**28</code> ~ <code>2**28-1</code>）。<strong>可以从 <code>most-positive-fixnum</code> 和 <code>most-negative-fixnum</code> 两个变量得到整数的范围。</strong></p>
<ul>
<li>
<p>整数</p>
<p>你可以用多种进制来输入一个整数。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp"><span class="hljs-number">#b101100</span> =&gt; <span class="hljs-number">44</span>      <span class="hljs-comment">; 二进制</span><br><span class="hljs-number">#o54</span> =&gt; <span class="hljs-number">44</span>          <span class="hljs-comment">; 八进制</span><br><span class="hljs-number">#x2c</span> =&gt; <span class="hljs-number">44</span>          <span class="hljs-comment">; 十进制</span><br></code></pre></div></td></tr></table></figure>
<p>最神奇的是你可以用 <code>2</code> 到 <code>36</code> 之间任意一个数作为基数，比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">#24r1k =&gt; <span class="hljs-number">44</span>        <span class="hljs-comment">; 二十四进制</span><br></code></pre></div></td></tr></table></figure>
<p>之所以最大是 36，是因为只有 <code>0-9</code> 和 <code>a-z</code> 36 个。</p>
</li>
<li>
<p>浮点数</p>
<p><code>1500.0</code>, <code>15e2</code>, <code>15.0e2</code>, <code>1.5e3</code>, 和 <code>.15e4</code> 都可以用来表示一个浮点数 <code>1500.</code>。遵循 IEEE 标准，elisp 也有一个特殊类型的值称为 <code>NaN</code> (not-a-number)。你可以用 <code>(/ 0.0 0.0)</code> 产生这个数。</p>
</li>
</ul>
<h4 id="测试函数"><a class="header-anchor" href="#测试函数">¶</a>测试函数</h4>
<p>整数类型测试函数是 <code>integerp</code>，浮点数类型测试函数是 <code>floatp</code>。数字类型测试用 <code>numberp</code>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">integerp</span> <span class="hljs-number">1</span>.)                           <span class="hljs-comment">; =&gt; t</span><br>(<span class="hljs-name">integerp</span> <span class="hljs-number">1.0</span>)                          <span class="hljs-comment">; =&gt; nil</span><br>(<span class="hljs-name">floatp</span> <span class="hljs-number">1</span>.)                             <span class="hljs-comment">; =&gt; nil</span><br>(<span class="hljs-name">floatp</span> <span class="hljs-number">-0.0</span>e+NaN)                      <span class="hljs-comment">; =&gt; t</span><br>(<span class="hljs-name">numberp</span> <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure>
<p>还提供一些特殊测试，比如测试是否是零的 <code>zerop</code>，还有非负整数测试的 <code>wholenump</code>。</p>
<blockquote>
<p>注：<strong>elisp 测试函数一般都是用 p 来结尾，p 是 predicate 的第一个字母。如果函数名是一个单词，通常只是在这个单词后加一个 p，如果是多个单词，一般是加 -p</strong>。</p>
</blockquote>
<h4 id="数的比较"><a class="header-anchor" href="#数的比较">¶</a>数的比较</h4>
<p>常用的比较操作符号是我们在其它言中都很熟悉的，比如 <code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>，不一样的是，由于赋值是使用 <code>set</code> 函数，所以 <strong><code>=</code> 不再是一个赋值运算符了，而是测试数字相等符号</strong>。和其它语言类似，<strong>对于浮点数的相等测试都是不可靠的</strong>。比如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> foo (<span class="hljs-name">-</span> (<span class="hljs-name">+</span> <span class="hljs-number">1.0</span> <span class="hljs-number">1.0e-3</span>) <span class="hljs-number">1.0</span>))       <span class="hljs-comment">; =&gt; 0.0009999999999998899</span><br>(<span class="hljs-name">setq</span> bar <span class="hljs-number">1.0e-3</span>)                       <span class="hljs-comment">; =&gt; 0.001</span><br>(<span class="hljs-name">=</span> foo bar)                             <span class="hljs-comment">; =&gt; nil</span><br></code></pre></div></td></tr></table></figure>
<p>所以一定要确定两个浮点数是否相同，是要在一定误差内进行比较。这里给出一个函数：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defvar</span> fuzz-factor <span class="hljs-number">1.0e-6</span>)<br>(<span class="hljs-name">defun</span> approx-equal (<span class="hljs-name">x</span> y)<br>  (<span class="hljs-name">or</span> (<span class="hljs-name">and</span> (<span class="hljs-name">=</span> x <span class="hljs-number">0</span>) (<span class="hljs-name">=</span> y <span class="hljs-number">0</span>))<br>      (<span class="hljs-name">&lt;</span> (<span class="hljs-name">/</span> (<span class="hljs-name">abs</span> (<span class="hljs-name">-</span> x y))<br>            (<span class="hljs-name">max</span> (<span class="hljs-name">abs</span> x) (<span class="hljs-name">abs</span> y)))<br>         fuzz-factor)))<br>(<span class="hljs-name">approx-equal</span> foo bar)                  <span class="hljs-comment">; =&gt; t</span><br></code></pre></div></td></tr></table></figure>
<p>还有一个测试数字是否相等的函数 <code>eql</code>，这是函数不仅测试数字的值是否相等，还测试数字类型是否一致，比如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">=</span> <span class="hljs-number">1.0</span> <span class="hljs-number">1</span>)                               <span class="hljs-comment">; =&gt; t</span><br>(<span class="hljs-name">eql</span> <span class="hljs-number">1.0</span> <span class="hljs-number">1</span>)                             <span class="hljs-comment">; =&gt; nil</span><br></code></pre></div></td></tr></table></figure>
<p><strong>elisp 没有 <code>+=</code>, <code>-=</code>, <code>/=</code>, <code>*=</code> 这样的命令式语言里常见符号</strong>，如果你想实现类似功能的语句，只能用赋值函数 setq 来实现了。 <strong><code>/=</code> 符号被用来作为不等于的测试了</strong>。</p>
<h4 id="数的转换"><a class="header-anchor" href="#数的转换">¶</a>数的转换</h4>
<ul>
<li>
<p>整数向浮点数转换是通过 <code>float</code> 函数进行的。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">float</span> <span class="hljs-number">1</span>)                             <span class="hljs-comment">; =&gt; 1.0</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>浮点数转换成整数有这样几个函数：</p>
<ul>
<li>
<p><code>truncate</code> 转换成靠近 0 的整数：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">truncate</span> <span class="hljs-number">1.2</span>)                      <span class="hljs-comment">; =&gt; 1 (#o1, #x1)</span><br>(<span class="hljs-name">truncate</span> <span class="hljs-number">1.7</span>)                      <span class="hljs-comment">; =&gt; 1 (#o1, #x1)</span><br>(<span class="hljs-name">truncate</span> <span class="hljs-number">-1.2</span>)                     <span class="hljs-comment">; =&gt; 1 (#o3777777777777, #x3ffffffffff)</span><br>(<span class="hljs-name">truncate</span> <span class="hljs-number">-1.7</span>)                     <span class="hljs-comment">; =&gt; 1 (#o3777777777777, #x3ffffffffff)</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>floor</code> 转换成最接近的不比本身大的整数</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">floor</span> <span class="hljs-number">1.2</span>)                      <span class="hljs-comment">; =&gt; 1 (#o1, #x1)</span><br>(<span class="hljs-name">floor</span> <span class="hljs-number">1.7</span>)                      <span class="hljs-comment">; =&gt; 1 (#o1, #x1)</span><br>(<span class="hljs-name">floor</span> <span class="hljs-number">-1.2</span>)                     <span class="hljs-comment">; =&gt; 1 (#o3777777777776, #x3fffffffffe)</span><br>(<span class="hljs-name">floor</span> <span class="hljs-number">-1.7</span>)                     <span class="hljs-comment">; =&gt; 1 (#o3777777777776, #x3fffffffff6)</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>ceiling</code> 转换成最接近的不比本身小的整数</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">ceiling</span> <span class="hljs-number">1.2</span>)                      <span class="hljs-comment">; =&gt; 2 (#o2, #x2)</span><br>(<span class="hljs-name">ceiling</span> <span class="hljs-number">1.7</span>)                      <span class="hljs-comment">; =&gt; 2 (#o2, #x2)</span><br>(<span class="hljs-name">ceiling</span> <span class="hljs-number">-1.2</span>)                     <span class="hljs-comment">; =&gt; -1 (#o3777777777777, #x3ffffffffff)</span><br>(<span class="hljs-name">ceiling</span> <span class="hljs-number">-1.7</span>)                     <span class="hljs-comment">; =&gt; -1 (#o3777777777776, #x3fffffffff6)</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>round</code> 四舍五入后的整数，换句话说和它的差绝对值最小的整数</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">round</span> <span class="hljs-number">1.2</span>)                      <span class="hljs-comment">; =&gt; 1 (#o1, #x1)</span><br>(<span class="hljs-name">round</span> <span class="hljs-number">1.7</span>)                      <span class="hljs-comment">; =&gt; 2 (#o2, #x2)</span><br>(<span class="hljs-name">ceiling</span> <span class="hljs-number">-1.2</span>)                     <span class="hljs-comment">; =&gt; -1 (#o3777777777777, #x3ffffffffff)</span><br>(<span class="hljs-name">ceiling</span> <span class="hljs-number">-1.7</span>)                     <span class="hljs-comment">; =&gt; -2 (#o3777777777776, #x3fffffffff6)</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这里提一个问题，浮点数的范围是无穷大的，而整数是有范围的。如果用前面的函数转换 <code>1e20</code> 将会报错。</p>
</blockquote>
</li>
</ul>
<h4 id="数的运算"><a class="header-anchor" href="#数的运算">¶</a>数的运算</h4>
<ul>
<li>
<p>四则运算 <code>+</code> <code>-</code> <code>*</code> <code>/</code></p>
<p><strong>和 C 语言类似，如果参数都是整数，作除法时要记住 <code>(/ 5 6)</code> 是会等于 <code>0</code> 的。如果参数中有浮点数，整数会自动转换成浮点数进行运算，所以 <code>(/ 5 6.0)</code> 的值才会是 <code>5/6</code>。</strong></p>
</li>
<li>
<p><code>++</code> 和 <code>--</code></p>
<p>没有 <code>++</code> 和 <code>--</code> 操作了，类似的两个函数是 <code>1+</code> 和 <code>1-</code>。可以用 <code>setq</code> 赋值来代替 <code>++</code> 和 <code>--</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> foo <span class="hljs-number">10</span>)                           <span class="hljs-comment">; =&gt; 10</span><br>(<span class="hljs-name">setq</span> foo (<span class="hljs-number">1</span>+ foo))                     <span class="hljs-comment">; =&gt; 11</span><br>(<span class="hljs-name">setq</span> foo (<span class="hljs-number">1</span>- foo))                     <span class="hljs-comment">; =&gt; 10</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>可能有人看过有 <code>incf</code> 和 <code>decf</code> 两个实现 <code>++</code> 和 <code>--</code> 操作。这两个宏是可以用的。这两个宏是 Common Lisp 里的，emacs 有模拟的 Common Lisp 的库 <code>cl</code>。但是 RMS 认为最好不要使用这个库。但是你可以在你的 elisp 包中使用这两个宏，只要在文件头写上：</p>
</blockquote>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">eval-when-compile</span><br>  (<span class="hljs-name">require</span> 'cl))<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>使用 <code>abs</code> 取数的绝对值。</p>
</li>
<li>
<p>取整</p>
<p>有两个取整的函数，一个是符号 <code>%</code>，一个是函数 <code>mod</code>。这两个函数的区别是：</p>
<ol>
<li>
<p><code>%</code> 的第一个参数必须是整数，而 <code>mod</code> 的第一个参数可以是整数也可以是浮点数。</p>
</li>
<li>
<p>即使对相同的参数，两个函数也不一定有相同的返回值：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">+</span> (% DIVIDEND DIVISOR)<br>   (<span class="hljs-name">*</span> (<span class="hljs-name">/</span> DIVIDEND DIVISOR) DIVISOR))<br></code></pre></div></td></tr></table></figure>
<p>和 <code>DIVIDEND</code> 是相同的。而：</p>
 <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">+</span> (<span class="hljs-name">mod</span> DIVIDEND DIVISOR)<br>   (<span class="hljs-name">*</span> (<span class="hljs-name">floor</span> DIVIDEND DIVISOR) DIVISOR))<br></code></pre></div></td></tr></table></figure>
<p>和 <code>DIVIDEND</code> 是相同的。</p>
<blockquote>
<p>注：<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Arithmetic-Operations.html" target="_blank" rel="noopener">原文</a></p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>三角函数</p>
<ul>
<li><code>sin</code></li>
<li><code>cos</code></li>
<li><code>tan</code></li>
<li><code>asin</code></li>
<li><code>acos</code></li>
<li><code>atan</code></li>
</ul>
</li>
<li>
<p>开方</p>
<p><code>sqrt</code></p>
</li>
<li>
<p>指数和对数</p>
<ul>
<li><code>exp</code>：以 e 为底指数运算。</li>
<li><code>expt</code>：指定底数指数运算。</li>
<li><code>log</code>：对数运算，<strong>默认底数是 e</strong>。</li>
<li><code>logb</code>：以 2 为底的对数运算，但<strong>返回的是一个整数</strong>。用于计算数的位。</li>
</ul>
</li>
<li>
<p>随机数</p>
<p><code>random</code> 可以产生随机数。可以用 <code>(random t)</code> 来产生一个新种子。虽然 emacs 每次启动后调用 <code>random</code> 总是产生相同的随机数，但是运行过程中，你不知道调用了多少次，所以使用时还是不需要再调用一次 <code>(random t)</code> 来产生新的种子。</p>
</li>
<li>
<p>整数位运算</p>
<p>位运算在 emacs lisp 中仅适用于整数。</p>
<ul>
<li>
<p><code>(lsh integer1 count)</code>：逻辑位移。如果 <code>count</code> 为正数，则将 <code>integer1</code> 左移 <code>count</code> 位；如果 <code>count</code> 为负数，则将 <code>integer1</code> 右移 <code>-count</code> 位，空位补 <code>0</code>，并且，<code>count</code> 为负数时，<code>lsh</code> 的补 <code>0</code> 方式是在<strong>最高有效位依次插 <code>0</code></strong>。</p>
<p>例（仅考虑低8位，其它位为 0）：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">lsh</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span>)  <span class="hljs-comment">;; 十进制 5 逻辑左移 1 位变为 10；二进制 00000101 变为 00001010</span><br>(<span class="hljs-name">lsh</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span>)  <span class="hljs-comment">;; 十进制 3 逻辑左移 2 位变为 12；二进制 00000011 变为 00001100</span><br>(<span class="hljs-name">lsh</span> <span class="hljs-number">6</span> <span class="hljs-number">-1</span>)  <span class="hljs-comment">;; 十进制 6 逻辑右移 1 位变为 3；二进制 00000110 变为 00000011</span><br></code></pre></div></td></tr></table></figure>
<p>与所有 emacs lisp 算术运算函数一样，位移运算不检查溢出，所以左移操作可能会忽略符号位（significant bits）并改变数的正负。例如在 28 位计算机上将 <code>134217727</code> 左移 1 位将会得到 <code>-2</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">lsh</span> <span class="hljs-number">134217727</span> <span class="hljs-number">1</span>)  <span class="hljs-comment">;; 十进制 134217727 逻辑左移 1 位变为 -2；二进制 0111  1111 1111  1111 1111  1111 1111 变为 1111  1111 1111  1111 1111  1111 1110</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>(ash integer1 count)</code>：算术位移。除非 <code>integer1</code> 和 <code>count</code> 全是负数，否则 <code>ash</code> 和 <code>lsh</code> 返回的结果是一样的。当 <code>integer1</code> 和 <code>count</code> 全为负时，<code>lsh</code> 会在左侧补 <code>0</code>，而 <code>ash</code> 会在左侧补 <code>1</code>。</p>
<p>例：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">ash</span> <span class="hljs-number">-6</span> <span class="hljs-number">-1</span>) <span class="hljs-comment">;; 十进制 -6 算术右移 1 位变为 -3；二进制1111  1111 1111  1111 1111  1111 1010 变为 1111  1111 1111  1111 1111  1111 1101</span><br>(<span class="hljs-name">lsh</span> <span class="hljs-number">-6</span> <span class="hljs-number">-1</span>) <span class="hljs-comment">;; 十进制 -6 逻辑右移 1 位变为 134217725；二进制1111  1111 1111  1111 1111  1111 1010 变为 0111  1111 1111  1111 1111  1111 1101</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>logand</code>、<code>logior</code>、<code>logexor</code> 和 <code>lognot</code> 参考<a href="http://ftp.gnu.org/old-gnu/Manuals/elisp-manual-21-2.8/html_node/elisp_65.html" target="_blank" rel="noopener">这里</a>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="字符和字符串"><a class="header-anchor" href="#字符和字符串">¶</a>字符和字符串</h3>
<p>在 emacs 里<strong>字符串是有序的字符数组</strong>。和 C 语言的字符串数组不同，emacs 的字符串可以容纳任何字符，包括 <code>\0</code>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> foo <span class="hljs-string">"abc\000abc"</span>)                 <span class="hljs-comment">; =&gt; "abc^@abc"</span><br></code></pre></div></td></tr></table></figure>
<h4 id="字符的读入"><a class="header-anchor" href="#字符的读入">¶</a>字符的读入</h4>
<p>构成字符串的字符其实就是一个整数。一个字符 <code>'A'</code> 就是一个整数 <code>65</code>。但是目前字符串中的字符被限制在 0-524287 之间。字符的读入语法是在字符前加上一个问号，比如 <code>?A</code> 代表字符 <code>'A'</code>。<br>
对于标点来说，也可以用同样的语法，但是最好在前面加上转义字符 <code>\</code>，因为有些标点会有岐义，比如 <code>?\(</code>。<code>\</code> 必须用 <code>?\\</code> 表示。控制字符，退格、制表符，换行符，垂直制表符，换页符，空格，回车，删除和 escape 分别表示为 <code>?\a</code>, <code>?\b</code>, <code>?\t</code>, <code>?\n</code>, <code>?\v</code>, <code>?\f</code>, <code>?\s</code>, <code>?\r</code>, <code>?\d</code>, 和 <code>?\e</code>。**对于没有特殊意义的字符，加上转义字符 <code>\</code> 是没有副作用的，比如 <code>?\+</code> 和 <code>?+</code> 是完全一样的。**所以标点还是都用转义字符来表示吧。</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">?\a =&gt; 7                 ; control-g, `C-g'<br>?\b =&gt; 8                 ; backspace, &lt;BS&gt;, `C-h'<br>?\t =&gt; 9                 ; tab, &lt;TAB&gt;, `C-i'<br>?\n =&gt; 10                ; newline, `C-j'<br>?\v =&gt; 11                ; vertical tab, `C-k'<br>?\f =&gt; 12                ; formfeed character, `C-l'<br>?\r =&gt; 13                ; carriage return, &lt;RET&gt;, `C-m'<br>?\e =&gt; 27                ; escape character, &lt;ESC&gt;, `C-['<br>?\s =&gt; 32                ; space character, &lt;SPC&gt;<br>?\\ =&gt; 92                ; backslash character, `\'<br>?\d =&gt; 127               ; delete character, &lt;DEL&gt;<br></code></pre></div></td></tr></table></figure>
<p>控制字符可以有多种表示方式，比如 <code>C-i</code>，这些都是对的：</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">?\^I  ?\^i  ?\C-I  ?\C-i<br></code></pre></div></td></tr></table></figure>
<p>它们都对应数字 <code>9</code>。<br>
meta 字符是用 修饰键（通常就是 Alt 键）输入的字符。之所以称为修饰键，是因为这样输入的字符就是在其修饰字符的第 27 位由 <code>0</code> 变成 <code>1</code> 而成，也就是如下操作：</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">logior</span> (<span class="hljs-name">lsh</span> <span class="hljs-number">1</span> <span class="hljs-number">27</span>) ?A)                  <span class="hljs-comment">; =&gt; 134217793</span><br>?\M-A                                   ; =&gt; 134217793<br></code></pre></div></td></tr></table></figure>
<p>你可以用 <code>\M-</code> 代表 meta 键，加上修饰的字符就是新生成的字符。比如：<code>?\M-A</code>, <code>?\M-\C-b</code>。 后面这个也可以写成 <code>?\C-\M-b</code>。</p>
<p>如果你还记得前面说过字符串里的字符不能超过 524287 的话，这就可以看出字符串是不能放下一个 meta 字符的。所以按键序列在这时只能用 vector 来储存。</p>
<p>其它的修饰键也是类似的。emacs 用 <code>2**25</code> 位来表示 shift 键，<code>2**24</code> 对应 hyper，<code>2**23</code> 对应 super，<code>2**22</code> 对应 alt。</p>
<h4 id="测试函数-v2"><a class="header-anchor" href="#测试函数-v2">¶</a>测试函数</h4>
<ul>
<li>字符串测试使用 <code>stringp</code>，没有 <code>charp</code>，因为字符就是整数。</li>
<li><code>string-or-null-p</code> 当对象是一个字符或 <code>nil</code> 时返回 <code>t</code>。</li>
<li><code>char-or-string-p</code> 测试是否是字符串或者字符类型。</li>
</ul>
<p>比较头疼的是 emacs 没有测试字符串是否为空的函数。这是我用的这个测试函数，使用前要测试字符串是否为 <code>nil</code>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> string-emptyp (<span class="hljs-name">str</span>)<br>  (<span class="hljs-name">not</span> (<span class="hljs-name">string&lt;</span> <span class="hljs-string">""</span> str)))<br></code></pre></div></td></tr></table></figure>
<h4 id="构造函数"><a class="header-anchor" href="#构造函数">¶</a>构造函数</h4>
<ul>
<li>
<p>产生一个字符串可以用 <code>make-string</code>。这样生成的字符串包含的字符都是一样的。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">make-string</span> <span class="hljs-number">5</span> ?x)                      <span class="hljs-comment">; =&gt; "xxxxx"</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>要生成不同的字符串可以用 <code>string</code> 函数。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">string</span> ?a ?b ?c)                       <span class="hljs-comment">; =&gt; "abc"</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>在已有的字符串生成新的字符串的方法有 <code>substring</code>, <code>concat</code>。</p>
<ul>
<li>
<p><code>substring</code> 的后两个参数是起点和终点的位置。如果终点越界或者终点比起点小都会产生一个错误。这个在使用 <code>substring</code> 时要特别小心。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">substring</span> <span class="hljs-string">"0123456789"</span> <span class="hljs-number">3</span>)              <span class="hljs-comment">; =&gt; "3456789"</span><br>(<span class="hljs-name">substring</span> <span class="hljs-string">"0123456789"</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>)            <span class="hljs-comment">; =&gt; "34"</span><br>(<span class="hljs-name">substring</span> <span class="hljs-string">"0123456789"</span> <span class="hljs-number">-3</span> <span class="hljs-number">-1</span>)          <span class="hljs-comment">; =&gt; "78"</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>concat</code> 函数相对简单，就是把几个字符串连接起来：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">concat</span> <span class="hljs-string">"foo"</span> <span class="hljs-string">"bar"</span>)                    <span class="hljs-comment">; =&gt; "foobar"</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="字符串比较"><a class="header-anchor" href="#字符串比较">¶</a>字符串比较</h4>
<ul>
<li>
<p><code>char-equal</code> 可以比较两个字符是否相等。与整数比较不同，这个函数还考虑了大小写。<strong>如果 <code>case-fold-search</code> 变量是 <code>t</code> 时，这个函数的字符比较是忽略大小写的。</strong></p>
<blockquote>
<p>编程时要小心，因为通常 <code>case-fold-search</code> 都是 <code>t</code>，这样如果要考虑字符的大小写时就不能用 <code>char-equal</code> 函数了。</p>
</blockquote>
</li>
<li>
<p>字符串比较使用 <code>string=</code>，<code>string-equal</code> 是一个别名。</p>
</li>
<li>
<p><code>string&lt;</code> 是按字典序比较两个字符串，<code>string-less</code> 是它的别名。**空字符串小于所有字符串，除了空字符串。**前面 <code>string-emptyp</code> 就是用这个特性。当然直接用 <code>length</code> 检测字符串长度应该也可以，还可以省去检测字符串是否为空。</p>
<blockquote>
<p>没有 <code>string&gt;</code> 函数。</p>
</blockquote>
</li>
</ul>
<h4 id="转换函数"><a class="header-anchor" href="#转换函数">¶</a>转换函数</h4>
<ul>
<li>
<p>字符转换成字符串可以用 <code>char-to-string</code> 函数。</p>
</li>
<li>
<p>字符串转换成字符可以用 <code>string-to-char</code>。当然只是返回字符串的第一个字符。</p>
</li>
<li>
<p>数字转换成字符串可以用 <code>number-to-string </code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">number-to-string</span> <span class="hljs-number">256</span>)                  <span class="hljs-comment">; =&gt; "256"</span><br></code></pre></div></td></tr></table></figure>
<p><code>number-to-string</code> 只能转换成十进制的数字。如果要输出八进制或者十六进制，可以用 <code>format</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">format</span> <span class="hljs-string">"%#o"</span> <span class="hljs-number">256</span>)                      <span class="hljs-comment">; =&gt; "0400"</span><br>(<span class="hljs-name">format</span> <span class="hljs-string">"%#x"</span> <span class="hljs-number">256</span>)                      <span class="hljs-comment">; =&gt; "0x100"</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>字符串转换成数字可以用 <code>string-to-number</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">string-to-number</span> <span class="hljs-string">"256"</span>)                <span class="hljs-comment">; =&gt; 256</span><br></code></pre></div></td></tr></table></figure>
<p><code>string-to-number</code> 可以设置字符串的进制，可以从 <code>2</code> 到 <code>16</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">string-to-number</span> <span class="hljs-string">"111000"</span> <span class="hljs-number">2</span>)                <span class="hljs-comment">; =&gt; 56</span><br>(<span class="hljs-name">string-to-number</span> <span class="hljs-string">"256"</span> <span class="hljs-number">8</span>)                   <span class="hljs-comment">; =&gt; 174</span><br>(<span class="hljs-name">string-to-number</span> <span class="hljs-string">"256"</span> <span class="hljs-number">16</span>)                  <span class="hljs-comment">; =&gt; 598</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>concat</code> 可以把一个字符构成的列表或者向量转换成字符串：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">concat</span> '(?a ?b ?c ?d ?e))              <span class="hljs-comment">; =&gt; "abcde"</span><br>(<span class="hljs-name">concat</span> [?a ?b ?c ?d ?e])               <span class="hljs-comment">; =&gt; "abcde"</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>vconcat</code> 可以把一个字符串转换成一个向量：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">vconcat</span> <span class="hljs-string">"abdef"</span>)                       <span class="hljs-comment">; =&gt; [97 98 100 101 102]</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>append</code> 可以把一个字符串转换成一个列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">append</span> <span class="hljs-string">"abcdef"</span> <span class="hljs-literal">nil</span>)                   <span class="hljs-comment">; =&gt; (97 98 99 100 101 102)</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>downcase</code> 可以把一个字符串或者字符转换成小写：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">downcase</span> <span class="hljs-string">"The cat in the hat"</span>)         <span class="hljs-comment">; =&gt; "the cat in the hat"</span><br>(<span class="hljs-name">downcase</span> ?X)                           <span class="hljs-comment">; =&gt; 120</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>upcase</code> 可以把一个字符串或者字符转换成大写：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">upcase</span> <span class="hljs-string">"The cat in the hat"</span>)           <span class="hljs-comment">; =&gt; "THE CAT IN THE HAT"</span><br>(<span class="hljs-name">upcase</span> ?x)                             <span class="hljs-comment">; =&gt; 88</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>capitalize</code> 可以使字符串中单词的第一个字符大写，其它字符小写：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">capitalize</span> <span class="hljs-string">"The CAT in tHe hat"</span>)       <span class="hljs-comment">; =&gt; "The Cat In The Hat"</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code> upcase-initials</code> 只使第一个单词的第一个字符大写，其它字符小写：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">upcase-initials</span> <span class="hljs-string">"The CAT in the hAt"</span>)  <span class="hljs-comment">; =&gt; "The CAT In The HAt"</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="格式化字符串"><a class="header-anchor" href="#格式化字符串">¶</a>格式化字符串</h4>
<p><code>format</code> 类似于 C 语言里的 <code>printf</code> 可以实现对象的字符串化。数字的格式化和 <code>printf</code> 的参数差不多。</p>
<blockquote>
<p>值得一提的是 <code>%S</code> 这个格式化形式，它可以把对象的输出形式转换成字符串，这在调试时是很有用的。</p>
</blockquote>
<h4 id="查找和替换"><a class="header-anchor" href="#查找和替换">¶</a>查找和替换</h4>
<h5 id="查找"><a class="header-anchor" href="#查找">¶</a>查找</h5>
<p>字符串查找的核心函数是 <code>string-match</code>。这个函数可以从指定的位置对字符串进行正则表达式匹配，如果匹配成功，则返回匹配的起点，如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">string-match</span> <span class="hljs-string">"34"</span> <span class="hljs-string">"01234567890123456789"</span>)    <span class="hljs-comment">; =&gt; 3</span><br>(<span class="hljs-name">string-match</span> <span class="hljs-string">"34"</span> <span class="hljs-string">"01234567890123456789"</span> <span class="hljs-number">10</span>) <span class="hljs-comment">; =&gt; 13</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>注意 <code>string-match</code> 的参数是一个正则表达式。emacs 好象没有内建的查找子串的函数。如果你想把 <code>string-match</code> 作为一个查找子串的函数，可以先用 <code>regexp-quote</code> 函数先处理一下子串。比如：</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">string-match</span> <span class="hljs-string">"2*"</span> <span class="hljs-string">"232*3=696"</span>)                <span class="hljs-comment">; =&gt; 0</span><br>(<span class="hljs-name">string-match</span> (<span class="hljs-name">regexp-quote</span> <span class="hljs-string">"2*"</span>) <span class="hljs-string">"232*3=696"</span>) <span class="hljs-comment">; =&gt; 2</span><br></code></pre></div></td></tr></table></figure>
<p><code>string-match</code> 在查找的同时，还会记录下每个要捕捉的字符串的位置。这个位置可以在匹配后用 <code>match-data</code>、<code>match-beginning</code> 和 <code>match-end</code> 等函数来获得。先看一下例子：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">progn</span><br>  (<span class="hljs-name">string-match</span> <span class="hljs-string">"3\\(4\\)"</span> <span class="hljs-string">"01234567890123456789"</span>)<br>  (<span class="hljs-name">match-data</span>))                         <span class="hljs-comment">; =&gt; (3 5 4 5)</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>&quot;3\\(4\\)&quot;</code> 并未在正则表达式中转义括号。参照本文《<a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a>》一章。</p>
</blockquote>
<p>正则表达式捕捉的字符串按括号的顺序对应一个序号，整个模式对应序号 <code>0</code>，第一个括号对应序号 <code>1</code>，第二个括号对应序号 <code>2</code>，以此类推。所以 <code>&quot;3\(4\)&quot;</code> 这个正则表达式中有序号 <code>0</code> 和 <code>1</code>，最后 <code>match-data</code> 返回的一系列数字对应的分别是要捕捉字符串的起点和终点位置，也就是说子串 <code>&quot;34&quot;</code> 起点从位置 <code>3</code> 开始，到位置 <code>5</code> 结束，而捕捉的字符串 <code>&quot;4&quot;</code> 的起点是从 <code>4</code> 开始，到 <code>5</code> 结束。这些位置可以用 <code>match-beginning</code> 和 <code>match-end</code> 函数用对应的序号得到。</p>
<blockquote>
<p>注意：起点位置是捕捉字符串的第一个字符的位置，而终点位置不是捕捉的字符串最后一个字符的位置，而是下一个字符的位置。这个性质对于循环是很方便的。比如要查找上面这个字符串中所有 <code>34</code> 出现的位置：</p>
</blockquote>
<blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">let</span> ((<span class="hljs-name">start</span> <span class="hljs-number">0</span>))<br>  (<span class="hljs-name">while</span> (<span class="hljs-name">string-match</span> <span class="hljs-string">"34"</span> <span class="hljs-string">"01234567890123456789"</span> start)<br>    (<span class="hljs-name">princ</span> (<span class="hljs-name">format</span> <span class="hljs-string">"find at %d\n"</span> (<span class="hljs-name">match-beginning</span> <span class="hljs-number">0</span>)))<br>    (<span class="hljs-name">setq</span> start (<span class="hljs-name">match-end</span> <span class="hljs-number">0</span>))))<br></code></pre></div></td></tr></table></figure>
</blockquote>
<h5 id="替换"><a class="header-anchor" href="#替换">¶</a>替换</h5>
<p>替换使用的函数是 <code>replace-match</code>。这个函数既可以用于字符串的替换，也可以用于缓冲区的文本替换。对于字符串的替换，<code>replace-match</code> 只是按给定的序号把字符串中的那一部分用提供的字符串替换了而已：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">let</span> ((<span class="hljs-name">str</span> <span class="hljs-string">"01234567890123456789"</span>))<br>  (<span class="hljs-name">string-match</span> <span class="hljs-string">"34"</span> str)<br>  (<span class="hljs-name">princ</span> (<span class="hljs-name">replace-match</span> <span class="hljs-string">"x"</span> <span class="hljs-literal">nil</span> <span class="hljs-literal">nil</span> str <span class="hljs-number">0</span>))<br>  (<span class="hljs-name">princ</span> <span class="hljs-string">"\n"</span>)<br>  (<span class="hljs-name">princ</span> str))<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>可以看出 <code>replace-match</code> 返回的字符串是替换后的新字符串，原字符串被没有改变。</p>
</blockquote>
<p>如果你想挑战一下，想想怎样把上面这个字符串中所有的 <code>34</code> 都替换掉？如果想就使用同一个字符串来存储，可能对于固定的字符串，这个还容易一些，如果不是的话，就要花一些脑筋了，<strong>因为替换之后，新的字符串下一个搜索起点的位置就不能用 <code>(match-end 0)</code> 给出来的位置了，而是要扣除替换的字符串和被替换的字符串长度的差值。</strong></p>
<p>emacs 对字符串的替换有一个函数 <code>replace-regexp-in-string</code>。这个函数的实现方法是把每次匹配部分之前的子串收集起来，最后再把所有字符串连接起来。</p>
<p>单字符的替换有 <code>subst-char-in-string</code> 函数。但是 emacs 没有类似 perl函数或者程序 tr 那样进行字符替换的函数。只能自己建表进行循环操作了。</p>
<h3 id="cons-cell-和列表"><a class="header-anchor" href="#cons-cell-和列表">¶</a>cons cell 和列表</h3>
<h4 id="cons-cell"><a class="header-anchor" href="#cons-cell">¶</a>cons cell</h4>
<p>cons cell 其实非常简单的，就是两个有顺序的元素。<br>
cons cell 的读入语法是用 . 分开两个部分，比如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">'(<span class="hljs-number">1</span> . <span class="hljs-number">2</span>)                                <span class="hljs-comment">; =&gt; (1 . 2)</span><br>'(?a . <span class="hljs-number">1</span>)                               <span class="hljs-comment">; =&gt; (97 . 1)</span><br>'(<span class="hljs-number">1</span> . <span class="hljs-string">"a"</span>)                              <span class="hljs-comment">; =&gt; (1 . "a")</span><br>'(<span class="hljs-number">1</span> . nil)                              <span class="hljs-comment">; =&gt; (1)</span><br>'(nil . nil)                            <span class="hljs-comment">; =&gt; (nil)</span><br></code></pre></div></td></tr></table></figure>
<p>上述代码中关于 <code>'</code> 的解释：</p>
<p><code>eval-last-sexp</code> 其实包含了两个步骤，一是读入前一个 S-表达式，二是对读入的 S-表达式求值。这样如果读入的 S-表达式是一个 cons cell 的话，求值时会把这个 cons cell 的第一个元素作为一个函数来调用。而事实上，前面这些例子的第一个元素都不是一个函数，这样就会产生一个错误 invalid-function。之所以前面没有遇到这个问题，<strong>那是因为前面数字和字符串是一类特殊的 S-表达式，它们求值后和求值前是不变，称为自求值表达式（self-evaluating form）</strong>。’ 号其实是一个特殊的函数 <code>quote</code>，它的作用是将它的参数返回而不作求值。<code>'(1 . 2)</code> 等价于 <code>(quote (1 . 2))</code>。为了证明 cons cell 的读入语法确实就是它的输出形式。</p>
<h4 id="列表"><a class="header-anchor" href="#列表">¶</a>列表</h4>
<p>列表包括了 cons cell。但是列表中有一个特殊的元素──空表 <code>nil</code>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp"><span class="hljs-literal">nil</span>                                     <span class="hljs-comment">; =&gt; nil</span><br>'()                                     <span class="hljs-comment">; =&gt; nil</span><br></code></pre></div></td></tr></table></figure>
<p>空表不是一个 cons cell，因为它没有 CAR 和 CDR 两个部分，事实上空表里没有任何内容。<strong>但是为了编程的方便，可以认为 <code>nil</code> 的 CAR 和 CDR 都是 <code>nil</code></strong>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">car</span> <span class="hljs-literal">nil</span>)                               <span class="hljs-comment">; =&gt; nil</span><br>(<span class="hljs-name">cdr</span> <span class="hljs-literal">nil</span>)<br></code></pre></div></td></tr></table></figure>
<p>按列表<strong>最后一个 cons cell</strong> 的 CDR 部分的类型分，可以把列表分为三类：</p>
<ul>
<li>如果它是 <code>nil</code> 的话，这个列表也称为**“真列表”(true list)**。</li>
<li>如果既不是 <code>nil</code> 也不是一个 cons cell，则这个列表称为**“点列表”(dotted list)。**</li>
<li>还有一种可能，它指向列表中之前的一个 cons cell，则称为<strong>环形列表(circular list)。</strong></li>
</ul>
<p>这里分别给出一个例子：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">'(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)                                  <span class="hljs-comment">; =&gt; (1 2 3)</span><br>'(<span class="hljs-number">1</span> <span class="hljs-number">2</span> . <span class="hljs-number">3</span>)                                <span class="hljs-comment">; =&gt; (1 2 . 3)</span><br>'(<span class="hljs-number">1</span> . #1=(<span class="hljs-number">2</span> <span class="hljs-number">3</span> . #1#))                     <span class="hljs-comment">; =&gt; (1 2 3 . #1)</span><br></code></pre></div></td></tr></table></figure>
<p>如果把真列表最后一个 cons cell 的 <code>nil</code> 省略不写，也就是 <code>(1 . nil)</code> 简写成 <code>(1)</code>，把 <code>( obj1 . ( obj2 . list))</code> 简写成 <code>(obj1 obj2 . list)</code>，那么列表最后可以写成一个用括号括起的元素列表：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">'(<span class="hljs-number">1</span> . (<span class="hljs-number">2</span> . (<span class="hljs-number">3</span> . <span class="hljs-literal">nil</span>)))                  <span class="hljs-comment">; =&gt; (1 2 3)</span><br></code></pre></div></td></tr></table></figure>
<h4 id="测试函数-v3"><a class="header-anchor" href="#测试函数-v3">¶</a>测试函数</h4>
<ul>
<li>
<p>测试一个对象是否是 cons cell 用 <code>consp</code>，是否是列表用 <code>listp</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">consp</span> '(<span class="hljs-number">1</span> . <span class="hljs-number">2</span>))                        <span class="hljs-comment">; =&gt; t</span><br>(<span class="hljs-name">consp</span> '(<span class="hljs-number">1</span> . (<span class="hljs-number">2</span> . <span class="hljs-literal">nil</span>)))                <span class="hljs-comment">; =&gt; t</span><br>(<span class="hljs-name">consp</span> <span class="hljs-literal">nil</span>)                             <span class="hljs-comment">; =&gt; nil</span><br>(<span class="hljs-name">listp</span> '(<span class="hljs-number">1</span> . <span class="hljs-number">2</span>))                        <span class="hljs-comment">; =&gt; t</span><br>(<span class="hljs-name">listp</span> '(<span class="hljs-number">1</span> . (<span class="hljs-number">2</span> . <span class="hljs-literal">nil</span>)))                <span class="hljs-comment">; =&gt; t</span><br>(<span class="hljs-name">listp</span> <span class="hljs-literal">nil</span>)                             <span class="hljs-comment">; =&gt; t</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>测试一个对象是否是 <code>nil</code> 用 <code>null</code> 函数。只有当对象是空表时，<code>null</code> 才返回空值。</p>
</li>
</ul>
<h4 id="span-id-constructors-in-list-构造函数-span"><a class="header-anchor" href="#span-id-constructors-in-list-构造函数-span">¶</a><span id="constructors_in_list">构造函数</span></h4>
<ul>
<li>
<p>生成一个 cons cell 可以用 <code>cons</code> 函数。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">cons</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>)                              <span class="hljs-comment">; =&gt; (1 . 2)</span><br>(<span class="hljs-name">cons</span> <span class="hljs-number">1</span> '())                            <span class="hljs-comment">; =&gt; (1)</span><br></code></pre></div></td></tr></table></figure>
<p>也可以使用在列表前面增加元素的方法。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> foo '(a b))                       <span class="hljs-comment">; =&gt; (a b)</span><br>(<span class="hljs-name">cons</span> 'x foo)                           <span class="hljs-comment">; =&gt; (x a b)</span><br></code></pre></div></td></tr></table></figure>
<p><strong>值得注意的是前面这个例子的 <code>foo</code> 值并没有改变。</strong><br>
事实上有一个宏 <code>push</code> 可以加入元素的同时改变列表的值：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">push</span> 'x foo)                           <span class="hljs-comment">; =&gt; (x a b)</span><br>foo                                     <span class="hljs-comment">; =&gt; (x a b)</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>生成一个列表的函数是 <code>list</code>。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">list</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)                            <span class="hljs-comment">; =&gt; (1 2 3)</span><br></code></pre></div></td></tr></table></figure>
<p>可能这时你有一个疑惑，前面产生一个列表，我常用 <code>quote</code>（也就是 <code>'</code> 符号）这个函数，它和这个 <code>cons</code> 和 <code>list</code> 函数有什么区别呢？其实区别是很明显的，<strong><code>quote</code> 是把参数直接返回不进行求值，而 <code>list</code> 和 <code>cons</code> 是对参数求值后再生成一个列表或者 cons cell</strong>。看下面这个例子：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">'((+ <span class="hljs-number">1</span> <span class="hljs-number">2</span>) <span class="hljs-number">3</span>)                            <span class="hljs-comment">; =&gt; ((+ 1 2) 3)</span><br>(<span class="hljs-name">list</span> (<span class="hljs-name">+</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>) <span class="hljs-number">3</span>)                        <span class="hljs-comment">; =&gt; (3 3)</span><br></code></pre></div></td></tr></table></figure>
<p>前一个生成的列表的 CAR 部分是 <code>(+ 1 2)</code> 这个列表，而后一个是先对 <code>(+ 1 2)</code> 求值得到 <code>3</code> 后再生成列表。</p>
</li>
</ul>
<blockquote>
<p>思考题<br>
怎样用 <code>list</code> 函数构造一个 <code>(a b c)</code> 这样的列表呢？<br>
答：<code>(list 'a 'b 'c)</code></p>
</blockquote>
<ul>
<li>
<p><strong>前面提到在列表前端增加元素的方法是用 <code>cons</code></strong>，在列表后端增加元素的函数是用 <code>append</code>。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">append</span> '(a b) '(c))                    <span class="hljs-comment">; =&gt; (a b c)</span><br>(<span class="hljs-name">append</span> '(a b) '(c) '(d))               <span class="hljs-comment">; =&gt; (a b c d)</span><br></code></pre></div></td></tr></table></figure>
<p><code>append</code> 的功能可以认为它是把第一个参数最后一个列表的 <code>nil</code> 换成第二个参数。<br>
一般来说 <code>append</code> 的参数都要是列表，但是最后一个参数可以不是一个列表，这也不违背前面说的，因为 cons cell 的 CDR 部分本来就可以是任何对象：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">append</span> '(a b) 'c)                      <span class="hljs-comment">; =&gt; (a b . c)</span><br></code></pre></div></td></tr></table></figure>
<p><strong>但这样得到的结果就不再是一个真列表了，如果再进行 <code>append</code> 操作就会产生一个错误。</strong></p>
<p><code>append</code> 的参数不限于列表，还可以是字符串或者向量。前面字符串里已经提到可以把一个字符串转换成一个字符列表，同样可能把向量转换成一个列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">append</span> [a b] <span class="hljs-string">"cd"</span> <span class="hljs-literal">nil</span>)                 <span class="hljs-comment">; =&gt; (a b 99 100)</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>注意：前面最后一个参数 <code>nil</code> 是必要的，不然你可以想象得到的结果是什么。</p>
</blockquote>
</li>
</ul>
<h4 id="把列表当数组用"><a class="header-anchor" href="#把列表当数组用">¶</a>把列表当数组用</h4>
<h5 id="访问"><a class="header-anchor" href="#访问">¶</a>访问</h5>
<ul>
<li>
<p>可以用 <code>nth</code> 函数来访问第 <code>n</code> 个元素：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">nth</span> <span class="hljs-number">3</span> '(<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>))                  <span class="hljs-comment">; =&gt; 3</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>取得序列里第 <code>n</code> 个元素也可以用 <code>elt</code> 函数。但是我建议，对于已知类型的序列，还是用对应的函数比较好。也就是说，如果是列表就用 <code>nth</code>，如果是数组就用 <code>aref</code>。这样一方面是省去 <code>elt</code> 内部的判断，另一方面读代码时能很清楚知道序列的类型。</p>
</blockquote>
</li>
<li>
<p><code>nthcdr</code> 函数返回第 <code>n</code> 个元素后的列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">nthcdr</span> <span class="hljs-number">2</span> '(<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>))               <span class="hljs-comment">; =&gt; (2 3 4 5)</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>last</code> 函数返回倒数 <code>n</code> 个长度的列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">last</span> '(<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>) <span class="hljs-number">2</span>)                 <span class="hljs-comment">; =&gt; (4 5)</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>butlast</code> 返回的除了倒数 <code>n</code> 个元素的列表。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">butlast</span> '(<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>) <span class="hljs-number">2</span>)              <span class="hljs-comment">; =&gt; (0 1 2 3)</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>链表这种数据结构是不适合随机访问的，代价比较高，如果你的代码中频繁使用这样的函数或者对一个很长的列表使用这样的函数，就应该考虑是不是应该用数组来实现。</p>
</blockquote>
<h5 id="修改"><a class="header-anchor" href="#修改">¶</a>修改</h5>
<ul>
<li>
<p><code>setcar</code> 和 <code>setcdr</code> 可以修改一个 cons cell 的 CAR 部分和 CDR 部分。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> foo '(a b c))                     <span class="hljs-comment">; =&gt; (a b c)</span><br>(<span class="hljs-name">setcar</span> foo 'x)                         <span class="hljs-comment">; =&gt; x</span><br>foo                                     <span class="hljs-comment">; =&gt; (x b c)</span><br>(<span class="hljs-name">setcdr</span> foo '(y z))                     <span class="hljs-comment">; =&gt; (y z)</span><br>foo                                     <span class="hljs-comment">; =&gt; (x y z)</span><br></code></pre></div></td></tr></table></figure>
<p>要像数组那样直接修改列表。使用 <code>setcar</code> 和 <code>nthcdr</code> 的组合就可以实现了：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> foo '(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))                     <span class="hljs-comment">; =&gt; (1 2 3)</span><br>(<span class="hljs-name">setcar</span> foo 'a)                         <span class="hljs-comment">; =&gt; a</span><br>(<span class="hljs-name">setcar</span> (<span class="hljs-name">cdr</span> foo) 'b)                   <span class="hljs-comment">; =&gt; b</span><br>(<span class="hljs-name">setcar</span> (<span class="hljs-name">nthcdr</span> <span class="hljs-number">2</span> foo) 'c)              <span class="hljs-comment">; =&gt; c</span><br>foo                                     <span class="hljs-comment">; =&gt; (a b c)</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="把列表当堆栈用"><a class="header-anchor" href="#把列表当堆栈用">¶</a>把列表当堆栈用</h4>
<p>前面已经提到过可以用 <code>push</code> 向列表头端增加元素，在结合 <code>pop</code> 函数，列表就可以做为一个堆栈了：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> foo <span class="hljs-literal">nil</span>)                          <span class="hljs-comment">; =&gt; nil</span><br>(<span class="hljs-name">push</span> 'a foo)                           <span class="hljs-comment">; =&gt; (a)</span><br>(<span class="hljs-name">push</span> 'b foo)                           <span class="hljs-comment">; =&gt; (b a)</span><br>(<span class="hljs-name">pop</span> foo)                               <span class="hljs-comment">; =&gt; b</span><br>foo                                     <span class="hljs-comment">; =&gt; (a)</span><br></code></pre></div></td></tr></table></figure>
<h4 id="重排列表"><a class="header-anchor" href="#重排列表">¶</a>重排列表</h4>
<ul>
<li>
<p>列表反序 <code>reverse</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> foo '(a b c))                     <span class="hljs-comment">; =&gt; (a b c)</span><br>(<span class="hljs-name">reverse</span> foo)                           <span class="hljs-comment">; =&gt; (c b a)</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>注意：使用 <code>reverse</code> 后 <code>foo</code> 值并没有改变。<code>nreverse</code> 和 <code>reverse</code> 差别就在于它是一个有破坏性的函数，也就是说它会修改它的参数：</p>
</blockquote>
<blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">nreverse</span> foo)                          <span class="hljs-comment">; =&gt; (c b a)</span><br>foo                                     <span class="hljs-comment">; =&gt; (a)</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
<p>elisp 还有一些是具有破坏性的函数。最常用的就是 <code>sort</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> foo '(<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span>))                 <span class="hljs-comment">; =&gt; (3 2 4 1 5)</span><br>(<span class="hljs-name">sort</span> foo '&lt;)                           <span class="hljs-comment">; =&gt; (1 2 3 4 5)</span><br>foo                                     <span class="hljs-comment">; =&gt; (3 4 5)</span><br></code></pre></div></td></tr></table></figure>
<p>如果我既要保留原列表，又要进行 <code>sort</code> 操作怎么办呢？可以用 <code>copy-sequence</code> 函数。这个函数只对列表进行复制，<strong>返回的列表的元素还是原列表里的元素，不会拷贝列表的元素</strong>。</p>
<blockquote>
<p><code>nconc</code> 和 <code>append</code> 功能相似，但是它会修改除最后一个参数以外的所有的参数，<code>nbutlast</code> 和 <code>butlast</code> 功能相似，也会修改参数。这些函数都是在效率优先时才使用。总而言之，以 <code>n</code> 开头的函数都要慎用。<br>
<code>copy-sequence</code> 不能用于点列表和环形列表。对于点列表可以用 <code>copy-tree</code> 函数。环形列表就没有办法复制了。 好在这样的数据结构很少用到。</p>
</blockquote>
</li>
</ul>
<h4 id="把列表当集合用"><a class="header-anchor" href="#把列表当集合用">¶</a>把列表当集合用</h4>
<p>列表可以作为无序的集合。</p>
<ul>
<li>
<p>合并集合用 <code>append</code> 函数。</p>
</li>
<li>
<p>去除重复的 <code>equal</code> 元素用 <code>delete-dups</code>。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">delete-dups</span> (<span class="hljs-name">list</span> <span class="hljs-string">"foo"</span> <span class="hljs-string">"bar"</span> <span class="hljs-literal">nil</span> <span class="hljs-string">"moo"</span> <span class="hljs-string">"bar"</span> <span class="hljs-string">"moo"</span> <span class="hljs-literal">nil</span> <span class="hljs-string">"affe"</span>)) <span class="hljs-comment">; =&gt; ("foo" "bar" nil "moo" "affe")</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>查找一个元素是否在列表中，返回以此元素开头的列表，如果找不到，则返回 <code>nil</code></p>
<ul>
<li>如果测试函数是用 <code>eq</code>，就用 <code>memq</code>；</li>
<li>如果测试用 <code>equal</code>，可以用 <code>member</code>。</li>
</ul>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">member</span> 'foo '(foo bar quux))           <span class="hljs-comment">; =&gt; non-nil</span><br>(<span class="hljs-name">member</span> <span class="hljs-string">"foo"</span> '(<span class="hljs-string">"foo"</span> <span class="hljs-string">"bar"</span> <span class="hljs-string">"quux"</span>))    <span class="hljs-comment">; =&gt; non-nil</span><br>(<span class="hljs-name">member</span> <span class="hljs-number">111</span> '(<span class="hljs-number">111</span> <span class="hljs-number">222</span> <span class="hljs-number">333</span>))             <span class="hljs-comment">; =&gt; non-nil</span><br><br>(<span class="hljs-name">memq</span>   'foo '(foo bar quux))           <span class="hljs-comment">; =&gt; non-nil</span><br>(<span class="hljs-name">memq</span>   <span class="hljs-string">"foo"</span> '(<span class="hljs-string">"foo"</span> <span class="hljs-string">"bar"</span> <span class="hljs-string">"quux"</span>))    <span class="hljs-comment">; =&gt; nil</span><br>(<span class="hljs-name">memq</span>   <span class="hljs-number">111</span> '(<span class="hljs-number">111</span> <span class="hljs-number">222</span> <span class="hljs-number">333</span>))             <span class="hljs-comment">; =&gt; non-nil</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>删除列表中的指定的元素，删除列表中所有的该元素</p>
<ul>
<li>测试函数为 <code>eq</code> 对应 <code>delq</code> 函数，<strong>原列表被破坏并返回一个新的列表</strong>；</li>
<li>测试函数为 <code>equal</code> 对应 <code>delete</code>，<strong>原列表被破坏并返回一个新的列表</strong>；</li>
<li><code>remove</code> 与 <code>delete</code> 相同，但<strong>不破坏原列表</strong>；</li>
<li><code>remq</code> 与 <code>delq</code> 相同，但<strong>不破坏原列表</strong>。</li>
</ul>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> xx '(<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>))<br><br><span class="hljs-comment">;; always set result to the same var. because original is usually destroyed</span><br>(<span class="hljs-name">setq</span> xx (<span class="hljs-name">delete</span> <span class="hljs-number">4</span> xx)) <span class="hljs-comment">; (3 5)</span><br><br><span class="hljs-comment">;; on vector</span><br>(<span class="hljs-name">setq</span> xx [<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>])<br>(<span class="hljs-name">setq</span> xx (<span class="hljs-name">delete</span> <span class="hljs-number">4</span> xx)) <span class="hljs-comment">; [3 5]</span><br><br>setq xx '(3 4 5))<br>(<span class="hljs-name">remove</span> <span class="hljs-number">4</span> xx) <span class="hljs-comment">;; (3 5)</span><br>xx <span class="hljs-comment">; (3 4 5)</span><br><br>(<span class="hljs-name">setq</span> xx '(<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>))<br><br><span class="hljs-comment">;; always set result to the same var</span><br>(<span class="hljs-name">setq</span> xx (<span class="hljs-name">delq</span> <span class="hljs-number">4</span> xx)) <span class="hljs-comment">; (3 5)</span><br><br>(<span class="hljs-name">setq</span> xx '(<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>))<br>(<span class="hljs-name">remq</span> <span class="hljs-number">4</span> xx) <span class="hljs-comment">; (3 5)</span><br>xx <span class="hljs-comment">; (3 4 5)</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<ul>
<li><code>eq</code> ：当且仅当 <code>x</code> 和 <code>y</code> 是同一个对象 (identical object) 时（笔记：同一个内存地址。并且应该仅应用于结构：conses、数组、结构、对象），返回 <code>t</code>。</li>
<li><code>eql</code> ：当其参数判断为 <code>eq</code>，或它们是相同的非结构化值（即相同类型的数字或字符值的相同数值）时，返回 <code>t</code>。</li>
<li><code>equal</code> ：当其参数为结构相似对象 (structurally similar (isomorphic)) 时，返回 <code>t</code>。粗略地从经验来看就是如果两个对象输出形式一样，那它们就是 <code>equal</code> 的。</li>
<li><code>equalp</code> ：当两个对象是 <code>equal</code> 的，那它们也是 <code>equalp</code> 的。另外如果它们是字符，且是 char-equal 的，即忽略大小写和特定的其它字符属性后是 <code>equal</code> 的，或者说它们是数字且有相同的数字值，而不管它们是否是同的类型，或者说它们的组成部分是 <code>equalp</code> 的，那么它们就是 <code>equalp</code> 的。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="把列表当关联表"><a class="header-anchor" href="#把列表当关联表">¶</a>把列表当关联表</h4>
<p>所谓关联表，就是可以用一个字符串（通常叫关键字，key）来查找对应值的数据结构。由列表实现的关联表有一个专门的名字叫 association list。尽管 elisp 里也有 hash table，但是 hash table 相比于 association list 至少这样几个缺点：</p>
<ul>
<li>hash table 里的关键字（key）是无序的，而 association list 的关键字 可以按想要的顺序排列；</li>
<li>hash table 没有列表那样丰富的函数，只有一个 <code>maphash</code> 函数可以遍历列表。而 association list 就是一个列表，所有列表函数都能适用；</li>
<li>hash table 没有读入语法和输入形式，这对于调试和使用都带来很多不便。</li>
</ul>
<p>只要不对效率要求很高，通常直接用association list。<br>
根据比较方法的不同，有 <code>assq</code> 和 <code>assoc</code> 两个函数，它们分别对应查找使用 <code>eq</code> 和 <code>equal</code> 两种方法。例如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">assoc</span> <span class="hljs-string">"a"</span> '((<span class="hljs-string">"a"</span> <span class="hljs-number">97</span>) (<span class="hljs-string">"b"</span> <span class="hljs-number">98</span>)))        <span class="hljs-comment">; =&gt; ("a" 97)</span><br>(<span class="hljs-name">assq</span> 'a '((a . <span class="hljs-number">97</span>) (b . <span class="hljs-number">98</span>)))          <span class="hljs-comment">; =&gt; (a . 97)</span><br></code></pre></div></td></tr></table></figure>
<p>通常我们只需要查找对应的数据，所以一般来说都要用 <code>cdr</code> 来得到对应的数据：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">cdr</span> (<span class="hljs-name">assoc</span> <span class="hljs-string">"a"</span> '((<span class="hljs-string">"a"</span> <span class="hljs-number">97</span>) (<span class="hljs-string">"b"</span> <span class="hljs-number">98</span>))))  <span class="hljs-comment">; =&gt; (97)</span><br>(<span class="hljs-name">cdr</span> (<span class="hljs-name">assq</span> 'a '((a . <span class="hljs-number">97</span>) (b . <span class="hljs-number">98</span>))))    <span class="hljs-comment">; =&gt; 97</span><br></code></pre></div></td></tr></table></figure>
<p><code>assoc-default</code> 可以一步完成这样的操作：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">assoc-default</span> <span class="hljs-string">"a"</span> '((<span class="hljs-string">"a"</span> <span class="hljs-number">97</span>) (<span class="hljs-string">"b"</span> <span class="hljs-number">98</span>)))          <span class="hljs-comment">; =&gt; (97)</span><br></code></pre></div></td></tr></table></figure>
<p>还可以用 <code>rassoc</code> 和 <code>rassq</code> 来根据数据查找键值：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">rassoc</span> '(<span class="hljs-number">97</span>) '((<span class="hljs-string">"a"</span> <span class="hljs-number">97</span>) (<span class="hljs-string">"b"</span> <span class="hljs-number">98</span>)))     <span class="hljs-comment">; =&gt; ("a" 97)</span><br>(<span class="hljs-name">rassq</span> '<span class="hljs-number">97</span> '((a . <span class="hljs-number">97</span>) (b . <span class="hljs-number">98</span>)))        <span class="hljs-comment">; =&gt; (a . 97)</span><br></code></pre></div></td></tr></table></figure>
<p>如果要修改关键字对应的值</p>
<ul>
<li>
<p>最省事的作法就是用 <code>cons</code> 把新的键值对加到列表的头端。但是这会让列表越来越长，浪费空间。</p>
</li>
<li>
<p>如果要替换已经存在的值，一个想法就是用 <code>setcdr</code> 来更改键值对应的数据。但是在更改之前要先确定这个键值在对应的列表里，否则会产生一个错误。</p>
</li>
<li>
<p>另一个想法是用 <code>assoc</code> 查找到对应的元素，再用 <code>delq</code> 删除这个数据，然后用 <code>cons</code> 加到列表里：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> foo '((<span class="hljs-string">"a"</span> . <span class="hljs-number">97</span>) (<span class="hljs-string">"b"</span> . <span class="hljs-number">98</span>)))     <span class="hljs-comment">; =&gt; (("a" . 97) ("b" . 98))</span><br><br><span class="hljs-comment">;; update value by setcdr</span><br>(<span class="hljs-name">if</span> (<span class="hljs-name">setq</span> bar (<span class="hljs-name">assoc</span> <span class="hljs-string">"a"</span> foo))<br>    (<span class="hljs-name">setcdr</span> bar <span class="hljs-string">"this is a"</span>)<br>  (<span class="hljs-name">setq</span> foo (<span class="hljs-name">cons</span> '(<span class="hljs-string">"a"</span> . <span class="hljs-string">"this is a"</span>) foo))) <span class="hljs-comment">; =&gt; "this is a"</span><br>foo                         <span class="hljs-comment">; =&gt; (("a" . "this is a") ("b" . 98))</span><br><span class="hljs-comment">;; update value by delq and cons</span><br>(<span class="hljs-name">setq</span> foo (<span class="hljs-name">cons</span> '(<span class="hljs-string">"a"</span> . <span class="hljs-number">97</span>)<br>               (<span class="hljs-name">delq</span> (<span class="hljs-name">assoc</span> <span class="hljs-string">"a"</span> foo) foo))) <span class="hljs-comment">; =&gt; (("a" . 97) ("b" . 98))</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<p>如果不对顺序有要求的话，推荐用后一种方法。</p>
<h4 id="把列表当树用"><a class="header-anchor" href="#把列表当树用">¶</a>把列表当树用</h4>
<p>列表的第一个元素如果作为结点的数据，其它元素看作是子节点，就是一个树了。</p>
<h4 id="遍历列表"><a class="header-anchor" href="#遍历列表">¶</a>遍历列表</h4>
<ul>
<li>
<p>遍历列表最常用的函数就是 <code>mapc</code> 和 <code>mapcar</code> 了。它们的第一个参数都是一个函数，这个函数只接受一个参数，每次处理一个列表里的元素。这两个函数唯一的差别是前者返回的还是输入的列表，而 <code>mapcar</code> 返回的函数返回值构成的列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">mapc</span> '<span class="hljs-number">1</span>+ '(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))                     <span class="hljs-comment">; =&gt; (1 2 3)</span><br>(<span class="hljs-name">mapcar</span> '<span class="hljs-number">1</span>+ '(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))                   <span class="hljs-comment">; =&gt; (2 3 4)</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>另一个比较常用的遍历列表的方法是用 <code>dolist</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">dolist</span> (<span class="hljs-name">var</span> list [result]) body...)<br></code></pre></div></td></tr></table></figure>
<p>其中 <code>var</code> 是一个临时变量，在 <code>body</code> 里可以用来得到列表中元素的值。使用 <code>dolist</code> 的好处是不用写 lambda 函数。一般情况下它的返回值是 <code>nil</code>，但是你也可以指定一个值作为返回值（我觉得这个特性没有什么用，只省了一步而已）：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">dolist</span> (<span class="hljs-name">foo</span> '(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>))<br>  (<span class="hljs-name">incf</span> foo))                           <span class="hljs-comment">; =&gt; nil</span><br>(<span class="hljs-name">setq</span> bar <span class="hljs-literal">nil</span>)<br>(<span class="hljs-name">dolist</span> (<span class="hljs-name">foo</span> '(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) bar)<br>  (<span class="hljs-name">push</span> (<span class="hljs-name">incf</span> foo) bar))                <span class="hljs-comment">; =&gt; (4 3 2)</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="散列表"><a class="header-anchor" href="#散列表">¶</a>散列表</h4>
<p>散列表，也就是 hash-table，在编程过程中会经常使用到，它以“关键字–数值”这样的对应关系保存数据，适合用于保存那些需要通过关键字查找数值的数据。</p>
<ul>
<li>
<p>创建散列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> my-hash-t (<span class="hljs-name">make-hash-table</span>))<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>需要获取散列表中某一个关键字对应的数值，可以使用 <code>gethash</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">gethash</span> 'NB001 my-hash-t)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>为了给散列表添加元素，可以直接使用 <code>setq</code> 函数，第一个参数是 <code>gethash</code> 获得的关键字位置，第二个参数是希望添加的数值，如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> (<span class="hljs-name">gethash</span> 'NB002 my-hash-t) <span class="hljs-string">"Tom"</span>)<br></code></pre></div></td></tr></table></figure>
<p>需要注意的是<strong>散列表中一个关键字只能对应一个数值，同一个关键字无法赋予两个不同的值</strong>。如下面的代码会将 <code>NB001</code> 的数值设置为 <code>&quot;Jerry&quot;</code>。后面那句 <code>setq</code> 生效，这个和变量的赋值的类似的：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> (<span class="hljs-name">gethash</span> 'NB001 my-hash-t) <span class="hljs-string">"Mike"</span>)<br> (<span class="hljs-name">setq</span> (<span class="hljs-name">gethash</span> 'NB001 my-hash-t) <span class="hljs-string">"Jerry"</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>散列表的遍历，elisp 中的散列表可以通过 <code>maphash</code> 函数进行迭代，形式如下：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">maphash</span> #'(lambda (key value) <br>	(format *query-io* <span class="hljs-string">"key: ~a  value: ~a  ~%"</span> key value))<br>  my-hash-t)<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h4 id="其它常用函数"><a class="header-anchor" href="#其它常用函数">¶</a>其它常用函数</h4>
<ul>
<li>
<p><code>fold</code> 和 <code>filter</code><br>
如果看过一些函数式语言教程的话，一定对 <code>fold</code>（或叫 <code>accumulate</code>、<code>reduce</code>）和 <code>filter</code> 这些函数记忆深刻。不过 elisp 里好像没有提供这样的函数。<code>remove-if</code> 和 <code>remove-if-not</code> 可以作 <code>filter</code> 函数，但是它们是 cl 里的，自己用用没有关系，不能强迫别人也跟着用，所以不能写到 elisp 里。如果不用这两个函数，也不用别人的函数的话，自己实现不妨用这样的方法：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> my-remove-if (<span class="hljs-name">predicate</span> list)<br>  (<span class="hljs-name">delq</span> <span class="hljs-literal">nil</span> (<span class="hljs-name">mapcar</span> (<span class="hljs-name">lambda</span> (<span class="hljs-name">n</span>)<br>                      (<span class="hljs-name">and</span> (<span class="hljs-name">not</span> (<span class="hljs-name">funcall</span> predicate n)) n))<br>                    list)))<br>(<span class="hljs-name">defun</span> evenp (<span class="hljs-name">n</span>)<br>  (<span class="hljs-name">=</span> (% n <span class="hljs-number">2</span>) <span class="hljs-number">0</span>))<br>(<span class="hljs-name">my-remove-if</span> 'evenp '(<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>))    <span class="hljs-comment">; =&gt; (1 3 5)</span><br></code></pre></div></td></tr></table></figure>
<p><code>fold</code> 的操作只能用变量加循环或 <code>mapc</code> 操作来代替了：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> my-fold-left (<span class="hljs-name">op</span> initial list)<br>  (<span class="hljs-name">dolist</span> (<span class="hljs-name">var</span> list initial)<br>    (<span class="hljs-name">setq</span> initial (<span class="hljs-name">funcall</span> op initial var))))<br>(<span class="hljs-name">my-fold-left</span> '+ <span class="hljs-number">0</span> '(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>))          <span class="hljs-comment">; =&gt; 10</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>产生数列常用的方法是用 <code>number-sequence</code>：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">number-sequence</span> <span class="hljs-number">5</span>)         <span class="hljs-comment">; =&gt; (5)</span><br>(<span class="hljs-name">number-sequence</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span>)       <span class="hljs-comment">; =&gt; (1 2 3 4 5)</span><br>(<span class="hljs-name">number-sequence</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span>)     <span class="hljs-comment">; =&gt; (1 3 5)</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>解析文本时一个很常用的操作是把字符串按分隔符分解，可以用 <code>split-string</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">split-string</span> <span class="hljs-string">"key = val"</span> <span class="hljs-string">"\\s-*=\\s-*"</span>)  <span class="hljs-comment">; =&gt; ("key" "val")</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>与 <code>split-string</code> 对应是把几个字符串用一个分隔符连接起来，这可以用 <code>mapconcat</code> 完成。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">mapconcat</span> 'identity '(<span class="hljs-string">"a"</span> <span class="hljs-string">"b"</span> <span class="hljs-string">"c"</span>) <span class="hljs-string">"\t"</span>) <span class="hljs-comment">; =&gt; "a   b   c"</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><code>identity</code> 是一个特殊的函数，它会直接返回参数。<code>mapconcat</code> 第一个参数是一个函数，可以很灵活的使用。</p>
</blockquote>
</li>
<li>
<p>函数 <code>length</code> 可以得到序列的长度。但是这个函数只对真列表有效。对于一个点列表和环形列表这个函数就不适用了。点列表会出参数类型不对的错误，而环形列表就更危险，会陷入死循环。如果不确定参数类型，不妨用 <code>safe-length</code>。比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">safe-length</span> '(a . b))                  <span class="hljs-comment">; =&gt; 1</span><br>(<span class="hljs-name">safe-length</span> '#1=(<span class="hljs-number">1</span> <span class="hljs-number">2</span> . #1#))           <span class="hljs-comment">; =&gt; 3</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="数组和序列"><a class="header-anchor" href="#数组和序列">¶</a>数组和序列</h3>
<p>序列是列表和数组的统称，也就是说列表和数组都是序列。它们的共性是内部的元素都是有序的。elisp 里的数组包括字符串、向量、char-table 和布尔向量。它们的关系可以用下面图表示：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin"> _____________________________________________<br>|<span class="hljs-string">                                             </span>|<br>|<span class="hljs-string">          Sequence                           </span>|<br>|<span class="hljs-string">  ______   ________________________________  </span>|<br>|<span class="hljs-string"> </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> </span>|<span class="hljs-string">                                </span>|<span class="hljs-string"> </span>|<br>|<span class="hljs-string"> </span>|<span class="hljs-string"> List </span>|<span class="hljs-string"> </span>|<span class="hljs-string">             Array              </span>|<span class="hljs-string"> </span>|<br>|<span class="hljs-string"> </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> </span>|<span class="hljs-string">    ________       ________     </span>|<span class="hljs-string"> </span>|<br>|<span class="hljs-string"> </span>|<span class="hljs-string">______</span>|<span class="hljs-string"> </span>|<span class="hljs-string">   </span>|<span class="hljs-string">        </span>|<span class="hljs-string">     </span>|<span class="hljs-string">        </span>|<span class="hljs-string">    </span>|<span class="hljs-string"> </span>|<br>|<span class="hljs-string">          </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> Vector </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> String </span>|<span class="hljs-string">    </span>|<span class="hljs-string"> </span>|<br>|<span class="hljs-string">          </span>|<span class="hljs-string">   </span>|<span class="hljs-string">________</span>|<span class="hljs-string">     </span>|<span class="hljs-string">________</span>|<span class="hljs-string">    </span>|<span class="hljs-string"> </span>|<br>|<span class="hljs-string">          </span>|<span class="hljs-string">  ____________   _____________  </span>|<span class="hljs-string"> </span>|<br>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">            </span>|<span class="hljs-string"> </span>|<span class="hljs-string">             </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<br>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> Char-table </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> Bool-vector </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<br>|<span class="hljs-string">          </span>|<span class="hljs-string"> </span>|<span class="hljs-string">____________</span>|<span class="hljs-string"> </span>|<span class="hljs-string">_____________</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<br>|<span class="hljs-string">          </span>|<span class="hljs-string">________________________________</span>|<span class="hljs-string"> </span>|<br>|<span class="hljs-string">_____________________________________________</span>|<br></code></pre></div></td></tr></table></figure>
<p>数组有这样一些特性：</p>
<ul>
<li>数组内的元素都对应一个下标，第一个元素下标为 <code>0</code>，接下来是 <code>1</code>。数组内 的元素可以在常数时间内访问。</li>
<li>数组在创建之后就无法改变它的长度。</li>
<li>数组是自求值的。</li>
<li>数组里的元素都可以用 <code>aref</code> 来访问，用 <code>aset</code> 来设置。</li>
</ul>
<h4 id="数组类型"><a class="header-anchor" href="#数组类型">¶</a>数组类型</h4>
<ul>
<li><strong>向量</strong>可以看成是一种通用的数组，它的元素可以是任意的对象。</li>
<li><strong>字符串</strong>是一种特殊的数组，它的元素只能是字符。如果元素是字符时，使用字符串相比向量更好，因为字符串需要的空间更少（只需要向量的 1/4），输出更直观，能用文本属性（text property），能使用 emacs 的 IO 操作。但是有时必须使用向量，比如存储按键序列。</li>
<li><strong>char-table</strong>与向量类似，只不过它的索引是字符码。任何无修改器的字符码都可作为 char-table 的索引。可以通过 <code>aref</code> 和 <code>aset</code> 像访问数组一样访问 char-table。另外，一个 char-table 可以包含一些与特定字符码无关的额外数据。与向量一样，char-table 求值以后（evaluated）就不允许改变。char-table 的元素可以是任意对象。</li>
<li><strong>bool-vector</strong>与向量类似，只不过它只存储 <code>t</code> 和 <code>nil</code>。如果向其中存入任意非 <code>nil</code> 值，则会变为存储 <code>t</code>。与数组一样，bool-vector 的索引是从 <code>0</code> 开始的，并且 bool-vector 一旦生成，它的长度即固定。</li>
</ul>
<h5 id="测试函数-v4"><a class="header-anchor" href="#测试函数-v4">¶</a>测试函数</h5>
<p><code>sequencep</code> 用来测试一个对象是否是一个序列。<code>arrayp</code> 测试对象是否是数组。<code>vectorp</code>、<code>char-table-p</code> 和 <code>bool-vector-p</code> 分别测试对象是否是向量、char-table、bool-vector。</p>
<h5 id="序列的通用函数"><a class="header-anchor" href="#序列的通用函数">¶</a>序列的通用函数</h5>
<ul>
<li>获取数组长度使用 <code>length</code> 或 <code>safe-length</code>。(见<a href="#%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">上一章</a>)</li>
<li>取得数组里第 <code>n</code> 个元素可以用 <code>elt</code> 函数或 <code>aref</code> 函数。(见<a href="#%E8%AE%BF%E9%97%AE">上一章</a>)</li>
<li>复制数组使用 <code>copy-sequence</code> 函数。(见<a href="#%E9%87%8D%E6%8E%92%E5%88%97%E8%A1%A8">上一章</a>)</li>
</ul>
<h5 id="数组操作"><a class="header-anchor" href="#数组操作">¶</a>数组操作</h5>
<ul>
<li>
<p>创建向量</p>
<ul>
<li>
<p>创建向量可以用 <code>vector</code> 函数：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">vector</span> 'foo <span class="hljs-number">23</span> [bar baz] <span class="hljs-string">"rats"</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>当然也可以直接用向量的读入语法创建向量，但是由于 <strong>数组是自求值的</strong>，所以这样得到的向量和原来是一样的，也就是说参数不进行求值，看下面的例子就明白了：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">foo                                     <span class="hljs-comment">; =&gt; (a b)</span><br>[foo]                                   ; =&gt; [foo]<br>(<span class="hljs-name">vector</span> foo)                            <span class="hljs-comment">; =&gt; [(a b)]</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>用 <code>make-vector</code> 可以生成元素相同的向量：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">make-vector</span> <span class="hljs-number">9</span> 'Z)                      <span class="hljs-comment">; =&gt; [Z Z Z Z Z Z Z Z Z]</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>fillarray</code> 可以把整个数组用某个元素填充：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">fillarray</span> (<span class="hljs-name">make-vector</span> <span class="hljs-number">3</span> 'Z) <span class="hljs-number">5</span>)        <span class="hljs-comment">; =&gt; [5 5 5]</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>aref</code> 和 <code>aset</code> 可以用于访问和修改数组的元素。如果使用下标超出数组长度的话，会产生一个错误。所以要先确定数组的长度才能用这两个函数：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> myarray [a b c d e])      <span class="hljs-comment">; =&gt; [a b c d e]</span><br>(<span class="hljs-name">aref</span> myarray <span class="hljs-number">0</span>)                <span class="hljs-comment">; =&gt; a</span><br>(<span class="hljs-name">aref</span> myarray <span class="hljs-number">3</span>)                <span class="hljs-comment">; =&gt; d</span><br>(<span class="hljs-name">aset</span> myarray <span class="hljs-number">2</span> 'guai)          <span class="hljs-comment">; =&gt; guai</span><br>myarray                         <span class="hljs-comment">; =&gt; [a b guai d e]</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p><code>vconcat</code> 可以把多个序列连接成一个向量。但是<strong>这些个序列必须是真列表</strong>。这也是把列表转换成向量的方法。</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">vconcat</span> [A B C] <span class="hljs-string">"aa"</span> '(foo (<span class="hljs-number">6</span> <span class="hljs-number">7</span>)))     <span class="hljs-comment">; =&gt; [A B C 97 97 foo (6 7)]</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>把向量转换成列表可以用 <code>append</code> 函数，这在<a href="#constructors_in_list">上一章</a>中已经提到。</p>
</li>
</ul>
<h3 id="符号"><a class="header-anchor" href="#符号">¶</a>符号</h3>
<p>符号是有名字的对象。可能这么说有点抽象。作个不恰当的比方，<strong>符号可以看作是 C 语言里的指针</strong>。通过符号你可以得到和这个符号相关联的信息，比如值，函数，属性列表等等。</p>
<h4 id="符号的命名规则"><a class="header-anchor" href="#符号的命名规则">¶</a>符号的命名规则</h4>
<ul>
<li>
<p>符号名字可以含有任何字符。</p>
</li>
<li>
<p>名字前缀要足够把符号名和数字区分开来，如果需要的话，可以在前面用 <code>\</code> 表示为符号，比如：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">symbolp</span> '+1)                           <span class="hljs-comment">; =&gt; nil</span><br>(<span class="hljs-name">symbolp</span> '\<span class="hljs-number">+1</span>)                          <span class="hljs-comment">; =&gt; t</span><br>(<span class="hljs-name">symbol-name</span> '\<span class="hljs-number">+1</span>)                      <span class="hljs-comment">; =&gt; "+1"</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>其它字符 <code>_~!@$%^&amp;amp;:&lt;&gt;{}?</code> 用的比较少。但是也可以直接作为符号的名字。</p>
</li>
<li>
<p>任何其它字符都可以用 <code>\</code> 转义后用在符号名字里。</p>
<blockquote>
<p>**注意：**和字符串里字符表示不同，<code>\</code> 转义后只是表示其后的字符，比如 <code>\t</code> 代表的字符 <code>t</code>，而不是制表符。如果要在符号名里使用制表符，必须在 <code>\</code> 后加上制表符本身。</p>
</blockquote>
</li>
<li>
<p>符号名是区分大小写的。</p>
</li>
</ul>
<p>这里有一些符号名的例子：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">foo                 <span class="hljs-comment">; 名为 `foo' 的符号</span><br>FOO                 <span class="hljs-comment">; 名为 `FOO' 的符号，和 `foo' 不同</span><br>char-to-string      <span class="hljs-comment">; 名为 `char-to-string' 的符号</span><br><span class="hljs-number">1</span>+                  <span class="hljs-comment">; 名为 `1+' 的符号 (不是整数 `+1')</span><br>\+1                 ; 名为 `+1' 的符号 (可读性很差的名字)<br>\(*\ 1\ 2\)         ; 名为 `(* 1 2)' 的符号 (更差劲的名字).<br>+-*/_~!@$%^&amp;=:&lt;&gt;&#123;&#125;  ; 名为 `+-*/_~!@$%^&amp;=:&lt;&gt;&#123;&#125;' 的符号.<br>                    <span class="hljs-comment">;   这些字符无须转义</span><br></code></pre></div></td></tr></table></figure>
<h4 id="创建符号"><a class="header-anchor" href="#创建符号">¶</a>创建符号</h4>
<p>符号名要有唯一性，所以一定会有一个表与名字关联，这个表在 elisp 里称为 obarray。从这个名字可以看出这个表是用数组类型，<strong>事实上是一个向量</strong>。</p>
<h5 id="intern"><a class="header-anchor" href="#intern">¶</a><code>intern</code></h5>
<p>当 lisp 读入一个符号时，通常会先查找这个符号是否在 obarray 里出现过，如果没有则会把这个符号加入到 obarray 里。这样查找并加入一个符号的过程称为是 <code>intern</code>。<code>intern</code> 函数可以查找或加入一个名字到 obarray 里，返回对应的符号。默认是全局的 obarray，也可以指定一个 obarray。</p>
<h5 id="intern-soft"><a class="header-anchor" href="#intern-soft">¶</a><code>intern-soft</code></h5>
<p><code>intern-soft</code> 与 <code>intern</code> 不同的是，当名字不在 obarray 里时，<code>intern-soft</code> 会返回 <code>nil</code>，而 <code>intern</code> 会加入到 obarray里。为了不污染 obarray，我下面的例子中尽量在 <code>foo</code> 这个 obarray 里进行。一般来说，去了 <code>foo</code> 参数，则会在 obarray 里进行。其结果应该是相同的：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> foo (<span class="hljs-name">make-vector</span> <span class="hljs-number">10</span> <span class="hljs-number">0</span>))           <span class="hljs-comment">; =&gt; [0 0 0 0 0 0 0 0 0 0]</span><br>(<span class="hljs-name">intern-soft</span> <span class="hljs-string">"abc"</span> foo)                 <span class="hljs-comment">; =&gt; nil</span><br>(<span class="hljs-name">intern</span> <span class="hljs-string">"abc"</span> foo)                      <span class="hljs-comment">; =&gt; abc</span><br>(<span class="hljs-name">intern-soft</span> <span class="hljs-string">"abc"</span> foo)                 <span class="hljs-comment">; =&gt; abc</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>lisp 每读入一个符号都会 <code>intern</code> 到 obarray 里，如果想避免，可以用在符号名前加上 <code>#:</code>：</p>
</blockquote>
<blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">intern-soft</span> <span class="hljs-string">"abc"</span>)                     <span class="hljs-comment">; =&gt; nil</span><br>'abc                                    <span class="hljs-comment">; =&gt; abc</span><br>(<span class="hljs-name">intern-soft</span> <span class="hljs-string">"abc"</span>)                     <span class="hljs-comment">; =&gt; abc</span><br>(<span class="hljs-name">intern-soft</span> <span class="hljs-string">"abcd"</span>)                    <span class="hljs-comment">; =&gt; nil</span><br>'#:abcd                                 ; =&gt; abcd<br>(<span class="hljs-name">intern-soft</span> <span class="hljs-string">"abcd"</span>)                    <span class="hljs-comment">; =&gt; nil</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
<h5 id="unintern"><a class="header-anchor" href="#unintern">¶</a><code>unintern</code></h5>
<p>如果想除去 obarray 里的符号，可以用 <code>unintern</code> 函数。<code>unintern</code> 可以用符号名或符号作参数在指定的 obarray 里去除符号，成功去除则返回 t，如果没有查找到对应的符号则返回 <code>nil</code>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">intern-soft</span> <span class="hljs-string">"abc"</span> foo)                 <span class="hljs-comment">; =&gt; abc</span><br>(<span class="hljs-name">unintern</span> <span class="hljs-string">"abc"</span> foo)                    <span class="hljs-comment">; =&gt; t</span><br>(<span class="hljs-name">intern-soft</span> <span class="hljs-string">"abc"</span> foo)                 <span class="hljs-comment">; =&gt; nil</span><br></code></pre></div></td></tr></table></figure>
<h5 id="mapatoms"><a class="header-anchor" href="#mapatoms">¶</a><code>mapatoms</code></h5>
<p><a href="#%E6%95%A3%E5%88%97%E8%A1%A8">和 hash-table 一样</a>，obarray 也提供一个 <code>mapatoms</code> 函数来遍历整个 obarray。比如要计算 obarray 里所有的符号数量：</p>
<figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">setq</span> count <span class="hljs-number">0</span>)                          <span class="hljs-comment">; =&gt; 0</span><br>(<span class="hljs-name">defun</span> count-syms (<span class="hljs-name">s</span>)<br>  (<span class="hljs-name">setq</span> count (<span class="hljs-number">1</span>+ count)))              <span class="hljs-comment">; =&gt; count-syms</span><br>(<span class="hljs-name">mapatoms</span> 'count-syms)                  <span class="hljs-comment">; =&gt; nil</span><br>count                                   <span class="hljs-comment">; =&gt; 28371</span><br>(<span class="hljs-name">length</span> obarray)                        <span class="hljs-comment">; =&gt; 1511</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>由前面的例子可以看出 elisp 中的向量长度都是有限的，而 obarray 里的符号有成千上万个。那这些符号是怎样放到 obarray 里的呢？<br>
其实<strong>这和散列的的实现是一样的</strong>。obarray 里的每一个元素通常称为 bucket。 一个 bucket 是可以容纳多个相同 hash 值的字符串和它们的数据。</p>
</blockquote>
<h4 id="符号的组成"><a class="header-anchor" href="#符号的组成">¶</a>符号的组成</h4>
<p>每个符号可以对应四个组成部分：名字、值、函数部分和属性列表(property list)。</p>
<h5 id="符号的名字和值"><a class="header-anchor" href="#符号的名字和值">¶</a>符号的名字和值</h5>
<ul>
<li>
<p>符号的名字可以用 <code>symbol-name</code> 访问。符号的值。</p>
</li>
<li>
<p>符号的值可以通过 <code>set</code> 函数来设置，用 <code>symbol-value</code> 来访问：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">set</span> (<span class="hljs-name">intern</span> <span class="hljs-string">"abc"</span> foo) <span class="hljs-string">"I'm abc"</span>)      <span class="hljs-comment">; =&gt; "I'm abc"</span><br>(<span class="hljs-name">symbol-value</span> (<span class="hljs-name">intern</span> <span class="hljs-string">"abc"</span> foo))       <span class="hljs-comment">; =&gt; "I'm abc"</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>可能大家最常见到 <code>setq</code> 函数，而 <code>set</code> 函数确很少见到。<code>setq</code> 可以看成是一个宏，它可以让你用 <code>(setq sym val)</code> 代替 <code>(set (quote sym) val)</code>。事实上这也是它名字的来源 (q 代表 quoted)。但是 <strong><code>setq</code> 只能设置 obarray 里的变量，前面这个例子中就只能用 <code>set</code> 函数</strong>。</p>
</blockquote>
<blockquote>
<p>如果一个符号的值已经有设置过的话，则 <code>boundp</code> 测试返回 <code>t</code>，否则为 <code>nil</code>。对于 <code>boundp</code> 测试返回 <code>nil</code> 的符号，使用符号的值会引起一个变量值为 void 的错误。</p>
</blockquote>
</li>
<li>
<p>符号的第三个组成部分是函数。它可以用 <code>symbol-function</code> 来访问，用 <code>fset</code> 来设置：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">fset</span> (<span class="hljs-name">intern</span> <span class="hljs-string">"abc"</span> foo) (<span class="hljs-name">symbol-function</span> 'car)) <span class="hljs-comment">; =&gt; #&lt;subr car&gt;</span><br>(<span class="hljs-name">funcall</span> (<span class="hljs-name">intern</span> <span class="hljs-string">"abc"</span> foo) '(a . b))            <span class="hljs-comment">; =&gt; a</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>类似的，可以用 <code>fboundp</code> 测试一个符号的函数部分是否有设置。</p>
</blockquote>
</li>
<li>
<p>符号的第四个组成部分是属性列表(property list)。通常属性列表用于存储和符号相关的信息，比如变量和函数的文档，定义的文件名和位置，语法类型。属性名和值可以是任意的 lisp 对象，但是通常名字是符号，可以用 <code>get</code> 和 <code>put</code> 来访问和修改属性值，用 <code>symbol-plist</code> 得到所有的属性列表：</p>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">put</span> (<span class="hljs-name">intern</span> <span class="hljs-string">"abc"</span> foo) 'doc <span class="hljs-string">"this is abc"</span>)      <span class="hljs-comment">; =&gt; "this is abc"</span><br>(<span class="hljs-name">get</span> (<span class="hljs-name">intern</span> <span class="hljs-string">"abc"</span> foo) 'doc)                    <span class="hljs-comment">; =&gt; "this is abc"</span><br>(<span class="hljs-name">symbol-plist</span> (<span class="hljs-name">intern</span> <span class="hljs-string">"abc"</span> foo))                <span class="hljs-comment">; =&gt; (doc "this is abc")</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>关联列表和属性列表很相似。符号的属性列表在内部表示上是用 <code>(prop1 value1 prop2 value2 ...)</code> 的形式，和关联列表也是很相似的。属性列表在查找和这个符号相关的信息时，要比直接用关联列表要简单快捷的多。所以变量的文档等信息都是放在符号的属性列表里。但是关联表在头端加入元素是很快的，而且它可以删除表里的元素。而属性列表则不能删除一个属性。</p>
</blockquote>
<blockquote>
<p>如果已经把属性列表取出，那么还可以用 plist-get 和 plist-put 的方法来访问和设置属性列表</p>
</blockquote>
  <figure class="highlight lisp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lisp">(<span class="hljs-name">plist-get</span> '(foo <span class="hljs-number">4</span>) 'foo)               <span class="hljs-comment">; =&gt; 4</span><br>(<span class="hljs-name">plist-get</span> '(foo <span class="hljs-number">4</span> bad) 'bar)           <span class="hljs-comment">; =&gt; nil</span><br>(<span class="hljs-name">setq</span> my-plist '(bar t foo <span class="hljs-number">4</span>))          <span class="hljs-comment">; =&gt; (bar t foo 4)</span><br>(<span class="hljs-name">setq</span> my-plist (<span class="hljs-name">plist-put</span> my-plist 'foo <span class="hljs-number">69</span>)) <span class="hljs-comment">; =&gt; (bar t foo 69)</span><br>(<span class="hljs-name">setq</span> my-plist (<span class="hljs-name">plist-put</span> my-plist 'quux '(a))) <span class="hljs-comment">; =&gt; (bar t foo 69 quux (a))</span><br></code></pre></div></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Emacs</tag>
        <tag>Lisp</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>davfs2 自动挂载</title>
    <url>/2019/08/14/davfs%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD/</url>
    <content><![CDATA[<h1>davfs2 自动挂载</h1>
<ol>
<li>
<p>安装 davfs2，以 Ubuntu 为例：</p>
<figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># apt install davfs2</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>将用户加入 <code>davfs2</code> 组：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> usermod -aG davfs2 <span class="hljs-variable">$USER</span></span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>创建挂载点：</p>
<figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">$ <span class="hljs-built_in">mkdir</span> /mnt/dav<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>手动挂载一下测试：</p>
 <figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># mount -t davfs http(s)://webdav.dav.com/dav/ /mnt/dav</span><br><span class="hljs-meta"># umount /mnt/dav</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>如果出现 <code>server does not support WebDAV</code>，则编辑文件 <em>/etc/davfs2/davfs2.conf</em>，将 <code>ignore_dav_header</code> 项设为 <code>1</code>。</p>
</blockquote>
</li>
<li>
<p>若服务器需要身份认证，则需配置 WebDAV 自动挂载时的认证信息。编辑文件 <em>/etc/davfs2/secrets</em>。加入：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">http</span><span class="hljs-params">(s)</span></span>:<span class="hljs-comment">//webdav.dav.com/dav/ username password</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>地址或密码中如果有空格，则需用 <code>\</code> 转义，或用双引号包裹。密码中如果有类似 <code>\</code>、<code>#</code> 和 <code>&quot;</code> 之类的特殊符号也要用 <code>\</code> 转义。</p>
</blockquote>
</li>
<li>
<p>编写 systemd 挂载脚本：</p>
<ul>
<li>
<p>mount 脚本。<em>/etc/systemd/system/mnt-dav.mount</em>：</p>
  <figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Mount WebDAV Service<br><span class="hljs-attr">After</span>=network-<span class="hljs-literal">on</span>line.target<br><span class="hljs-attr">Wants</span>=network-<span class="hljs-literal">on</span>line.target<br><br><span class="hljs-section">[Mount]</span><br><span class="hljs-attr">What</span>=http(s)://webdav.dav.com/dav/<br><span class="hljs-attr">Where</span>=/mnt/dav<br><span class="hljs-attr">Options</span>=uid=<span class="hljs-number">1000</span>,file_mode=<span class="hljs-number">0644</span>,dir_mode=<span class="hljs-number">2775</span>,grpid<br><span class="hljs-attr">Type</span>=davfs<br><span class="hljs-attr">TimoutSec</span>=<span class="hljs-number">15</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>automount 脚本，可选，主要用来空闲时 unmount 用。<em>/etc/systemd/system/mnt-dav.automount</em>：</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Mount WebDAV Service<br><span class="hljs-attr">After</span>=network-<span class="hljs-literal">on</span>line.target<br><span class="hljs-attr">Wants</span>=network-<span class="hljs-literal">on</span>line.target<br><br><span class="hljs-section">[Automount]</span><br><span class="hljs-attr">Where</span>=/mnt/dav<br><span class="hljs-attr">TimeoutIdleSec</span>=<span class="hljs-number">300</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=remote-fs.target<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注意：mount 和 automount 脚本文件名必须和文件中的 <code>Where</code> 字段对应。</p>
</blockquote>
</li>
<li>
<p>启用 systemd 脚本：</p>
 <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> systemctl <span class="hljs-built_in">enable</span> mnt-dav.mount</span><br></code></pre></div></td></tr></table></figure>
<p>​	或有 automount 脚本时：</p>
 <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> systemctl <span class="hljs-built_in">enable</span> mnt-dav.automount</span><br></code></pre></div></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>疑难</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>xfce 中 Compiz 无法自动启动时的解决方法</title>
    <url>/2019/08/14/xfce-%E4%B8%AD-Compiz%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1>xfce 中 Compiz无法自动启动时的解决方法</h1>
<ol>
<li>
<p>根据<a href="https://wiki.archlinux.org/index.php/Compiz_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">Archlinux Wiki</a>配置好 Compiz 和 Emerald。</p>
</li>
<li>
<p>将 Archlinux Wiki 中：</p>
<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Client0_Command"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"array"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"string"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"compiz"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Client0_Command"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"array"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"string"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"compiz"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"string"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"ccp"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>疑难</tag>
      </tags>
  </entry>
  <entry>
    <title>使用管理员权限运行 Windows Terminal 并添加“在此打开 Windows Terminal”至上下文菜单</title>
    <url>/2019/08/14/%E4%BD%BF%E7%94%A8%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E8%BF%90%E8%A1%8C-Windows-Terminal-%E5%B9%B6%E6%B7%BB%E5%8A%A0%E2%80%9C%E5%9C%A8%E6%AD%A4%E6%89%93%E5%BC%80%20-Windows-Terminal%E2%80%9D%E8%87%B3%E4%B8%8A%E4%B8%8B%E6%96%87%E8%8F%9C%E5%8D%95/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h1>使用管理员权限运行 Windows Terminal 并添加“在此打开 Windows Terminal”至上下文菜单</h1>
<h2 id="使用管理员权限运行-Windows-Terminal"><a class="header-anchor" href="#使用管理员权限运行-Windows-Terminal">¶</a>使用管理员权限运行 Windows Terminal</h2>
<ol>
<li>
<p>新建一个快捷方式。</p>
</li>
<li>
<p>在快捷方式的“位置”处填写<code>C:\Windows\system32\cmd.exe /c start /b wt</code>。</p>
<blockquote>
<p>Windows Termianl 的可执行程序的软件连接一般位于 <em>%localappdata%\Microsoft\WindowsApps\wt.exe</em></p>
</blockquote>
</li>
<li>
<p>打开快捷方式的“属性”对话框，选择“高级”，选择“以管理员身份运行”。</p>
</li>
</ol>
<h2 id="添加“在此打开-Windows-Terminal”至上下文菜单"><a class="header-anchor" href="#添加“在此打开-Windows-Terminal”至上下文菜单">¶</a>添加“在此打开 Windows Terminal”至上下文菜单</h2>
<ol>
<li>
<p>设置菜单项的图标：</p>
<ul>
<li>(1) 在注册表_HKEY_CLASSES_ROOT\Directory\Background\shell_ 下新建名为“在此打开 Windows Terminal”的项。</li>
<li>(2) 在 (1) 所建项下新建名为“Icon”的 REG_SZ 值，数值数据为图标文件或带图标的可执行文件完整目录。</li>
</ul>
</li>
<li>
<p>设置 Windows Terminal 的启动脚本：</p>
<ul>
<li>
<p>(1) 任意目录新建一个批处理脚本文件，如 <em>launchwt.bat</em>。</p>
</li>
<li>
<p>(2) 在 (1) 所建文件中输入脚本并保存：</p>
  <figure class="highlight cmd"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmd"><span class="hljs-built_in">set</span> wt_powershell_dir=<span class="hljs-variable">%cd%</span><br><span class="hljs-built_in">start</span> <span class="hljs-variable">%LOCALAPPDATA%</span>\\Microsoft\\WindowsApps\\wt.exe<br><span class="hljs-keyword">exit</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>(3) 编辑 Powershell 用户配置文件 <em>~\Documents\WindowsPowershell\Microsoft.PowerShell_profile.ps1</em>：</p>
  <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-keyword">if</span> ((<span class="hljs-operator">-not</span> [<span class="hljs-built_in">String</span>]::IsNullOrEmpty(<span class="hljs-variable">$env:wt_powershell_dir</span>)) <span class="hljs-operator">-and</span> (<span class="hljs-built_in">Test-Path</span> <span class="hljs-variable">$env:wt_powershell_dir</span>)) &#123;<br>   cd <span class="hljs-variable">$env:wt_powershell_dir</span><br>   <span class="hljs-built_in">Remove-Item</span> Env:\wt_powershell_dir<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>(4) 在 1.(1) 中所建项下新建名为“command”的子项，并将其下的“默认”键值的数据数值设置为 (2) 中所建批处理文件的完整路径。</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Windows</tag>
        <tag>疑难</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 编码规范</title>
    <url>/2019/08/02/Python-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h1>Python 编码规范</h1>
<h2 id="代码书写规范"><a class="header-anchor" href="#代码书写规范">¶</a>代码书写规范</h2>
<h3 id="缩进"><a class="header-anchor" href="#缩进">¶</a>缩进</h3>
<p>统一使用 4 个空格进行缩进，不要混合使用制表符和空格来缩进，也不要单独使用制表符 <code>tab</code>。对于行连接的情况，可以垂直对齐换行的元素。</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/07ad07f65bd548b5932f17533b90dfbf" alt="图1"></p>
<h3 id="行宽"><a class="header-anchor" href="#行宽">¶</a>行宽</h3>
<p>每行代码尽量不超过 80 个字符，在特殊情况下可以略微超过 80 ，如长的导入模块语句或注释里的 URL。<br>
Python 会将圆括号、中括号和花括号中的行隐式的连接起来，可以利用这个特点，在表达式外围增加一对额外的圆括号，不要使用反斜杠连接行。<br>
如果条件语句中条件过多，放在一行显得超长，可以使用圆括号来实现隐式连接，如下：</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/ea37480540e54e2ea17ea3877c8a0c22" alt="图2"></p>
<p>如果一个文本字符串放在一行显得超长，可以使用圆括号来实现隐式行连接，如下：</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/86e79eb962b241efa183bc95418db556" alt="图3"></p>
<h3 id="引号"><a class="header-anchor" href="#引号">¶</a>引号</h3>
<p>自然语言使用双引号，机器标示使用单引号，因此代码里多数应该使用单引号。</p>
<ul>
<li>
<p>自然语言使用双引号</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/8d2d82fc19224c2a994fd2f4ddd0f158" alt="图4"></p>
</li>
<li>
<p>机器标识使用单引号</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/dd7cb92873134526b6d2821bb7b1d303" alt="图5"></p>
</li>
<li>
<p>正则表达式使用双引号</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/9651f26cb26d4986aaaab1af8071142b" alt="图6"></p>
</li>
<li>
<p>文档字符串 (Docstring) 使用三双引号</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/35c333c59b894938b9925a4a555843ea" alt="图7"></p>
</li>
</ul>
<h3 id="空行"><a class="header-anchor" href="#空行">¶</a>空行</h3>
<p>模块中类定义与函数之间空两行，类中各函数之间空一行，函数中可以使用空行分隔各逻辑代码块，使其更加清晰。</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/dd582d744d184c61b416a57c2c440974" alt="图8"></p>
<h3 id="模块导入"><a class="header-anchor" href="#模块导入">¶</a>模块导入</h3>
<p>每个独立模块导入应该独占一行，导入代码应该放在文件顶部，置于模块说明、文档字符串之后，全局变量、常量之前，模块导入建议顺序建议参考以一下顺序，每组之间使用一个空行分隔：</p>
<div class="hljs code-wrapper"><pre><code>1. 标准库导入
2. 第三方库导入
3. 自定义库导入
</code></pre></div>
<p><img src="https://p3.pstatp.com/large/pgc-image/7d176cad05ce44de92494779a6f90aac" alt="图9"></p>
<p>同时，导入模块应尽量使用绝对导入。</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/3290579bb9e7438796e24c0cfac61732" alt="图10"></p>
<h3 id="空格"><a class="header-anchor" href="#空格">¶</a>空格</h3>
<p>在二元操作符两边都加上一个空格，如 <code>=, ==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is no，and, or, not</code>。额外注意的是，当 <code>=</code> 用于指示关键字参数或默认参数值时, 不要在其两侧使用空格。</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/cb68241c33c7459b81c454bdfb6b2076" alt="图11"></p>
<p>函数的参数列表中 <code>,</code> 之后要有空格，但左括号之后，右括号之前不要加多余的空格。</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/f56964d2dcae4c08ac34d73207d53bad" alt="图12"></p>
<h2 id="代码注释规范"><a class="header-anchor" href="#代码注释规范">¶</a>代码注释规范</h2>
<h3 id="块注释"><a class="header-anchor" href="#块注释">¶</a>块注释</h3>
<p><code>#</code> 号后空一格，段落间需要用空行分开。</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/cc6ac11b397a456daefe726e205da6f1" alt="图13"></p>
<h3 id="行注释"><a class="header-anchor" href="#行注释">¶</a>行注释</h3>
<p>行注释至少使用两个空格和语句分开。</p>
<p><img src="https://p3.pstatp.com/large/pgc-image/2a8bfadf83894a379d9bfa08a73ce932" alt="图14"></p>
<h3 id="文档注释——文档字符串-Docstring"><a class="header-anchor" href="#文档注释——文档字符串-Docstring">¶</a>文档注释——文档字符串 Docstring</h3>
<p>Python 有一种独一无二的的注释方式：使用文档字符串。文档字符串是包，模块，类或函数里的第一个语句。这些字符串可以通过对象的 doc 成员被自动提取。并且被 pydoc 所用。(你可以在你的模块上运行 pydoc 试一把，看看它长什么样)。我们对文档字符串的惯例是使用三重双引号<code>&quot;&quot;&quot;</code>(PEP-257)。一个文档字符串应该这样组织：首先是一行以句号，问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行)。接着是一个空行。接着是文档字符串剩下的部分，它应该与文档字符串的第一行的第一个引号对齐。下面有更多文档字符串的格式化规范。</p>
<h3 id="模块"><a class="header-anchor" href="#模块">¶</a>模块</h3>
<p>每个文件应该包含一个许可样板。根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板。</p>
<h3 id="函数和方法"><a class="header-anchor" href="#函数和方法">¶</a>函数和方法</h3>
<p>下文所指的函数，包括函数，方法，以及生成器。<br>
一个函数必须要有文档字符串，除非它满足以下条件：</p>
<ul>
<li>外部不可见</li>
<li>非常短小</li>
<li>简单明了</li>
</ul>
<p>文档字符串应该包含函数做什么，以及输入和输出的详细描述。通常，不应该描述“怎么做”， 除非是一些复杂的算法。文档字符串应该提供足够的信息，当别人编写代码调用该函数时，他不需要看一行代码，只要看文档字符串就可以了。对于复杂的代码，在代码旁边加注释会比使用文档字符串更有意义。<br>
关于函数的几个方面应该在特定的小节中进行描述记录，这几个方面如下文所述，每节应该以一个标题行开始。标题行以冒号结尾。除标题行外，节的其他内容应被缩进2个空格。</p>
<h4 id="Args"><a class="header-anchor" href="#Args">¶</a>Args</h4>
<p>列出每个参数的名字，并在名字后使用一个冒号和一个空格，分隔对该参数的描述。如果描述太长超过了单行80字符，使用2或者4个空格的悬挂缩进(与文件其他部分保持一致)。描述应该包括所需的类型和含义。如果一个函数接受foo(可变长度参数列表)或者bar (任意关键字参数)，应该详细列出foo和bar。</p>
<h4 id="Returns-或者-Yields-用于生成器"><a class="header-anchor" href="#Returns-或者-Yields-用于生成器">¶</a>Returns (或者 Yields: 用于生成器)</h4>
<p>描述返回值的类型和语义。如果函数返回 <code>None</code>。这一部分可以省略。</p>
<h4 id="Raises"><a class="header-anchor" href="#Raises">¶</a>Raises</h4>
<p>列出与接口有关的所有异常。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fetch_bigtable_rows</span><span class="hljs-params">(big_table, keys, other_silly_variable=None)</span>:</span><br>    <span class="hljs-string">"""Fetches rows from a Bigtable.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Retrieves rows pertaining to the given keys from the Table instance</span><br><span class="hljs-string">    represented by big_table.  Silly things may happen if</span><br><span class="hljs-string">    other_silly_variable is not None.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        big_table: An open Bigtable Table instance.</span><br><span class="hljs-string">        keys: A sequence of strings representing the key of each table row</span><br><span class="hljs-string">            to fetch.</span><br><span class="hljs-string">        other_silly_variable: Another optional variable, that has a much</span><br><span class="hljs-string">            longer name than the other args, and which does nothing.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">        A dict mapping keys to the corresponding table row data</span><br><span class="hljs-string">        fetched. Each row is represented as a tuple of strings. For</span><br><span class="hljs-string">        example:</span><br><span class="hljs-string"></span><br><span class="hljs-string">        &#123;'Serak': ('Rigel VII', 'Preparer'),</span><br><span class="hljs-string">         'Zim': ('Irk', 'Invader'),</span><br><span class="hljs-string">         'Lrrr': ('Omicron Persei 8', 'Emperor')&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">        If a key from the keys argument is missing from the dictionary,</span><br><span class="hljs-string">        then that row was not found in the table.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Raises:</span><br><span class="hljs-string">        IOError: An error occurred accessing the bigtable.Table object.</span><br><span class="hljs-string">    """</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></div></td></tr></table></figure>
<h3 id="类"><a class="header-anchor" href="#类">¶</a>类</h3>
<p>类应该在其定义下有一个用于描述该类的文档字符串。如果你的类有公共属性(Attributes)，那么文档中应该有一个属性(Attributes)段。并且应该遵守和函数参数相同的格式。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleClass</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-string">"""Summary of class here.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Longer class information....</span><br><span class="hljs-string">    Longer class information....</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Attributes:</span><br><span class="hljs-string">        likes_spam: A boolean indicating if we like SPAM or not.</span><br><span class="hljs-string">        eggs: An integer count of the eggs we have laid.</span><br><span class="hljs-string">    """</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, likes_spam=False)</span>:</span><br>        <span class="hljs-string">"""Inits SampleClass with blah."""</span><br>        self.likes_spam = likes_spam<br>        self.eggs = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">public_method</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""Performs operation blah."""</span><br></code></pre></div></td></tr></table></figure>
<h3 id="块注释和行注释"><a class="header-anchor" href="#块注释和行注释">¶</a>块注释和行注释</h3>
<p>最需要写注释的是代码中那些技巧性的部分。如果你在下次代码审查的时候必须解释一下。那么你应该现在就给它写注释。对于复杂的操作，应该在其操作开始前写上若干行注释。对于不是一目了然的代码，应在其行尾添加注释。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># We use a weighted dictionary search to find out where i is in</span><br><span class="hljs-comment"># the array.  We extrapolate position based on the largest num</span><br><span class="hljs-comment"># in the array and the array size and then do binary search to</span><br><span class="hljs-comment"># get the exact number.</span><br><br><span class="hljs-keyword">if</span> i &amp; (i<span class="hljs-number">-1</span>) == <span class="hljs-number">0</span>:        <span class="hljs-comment"># true iff i is a power of 2</span><br></code></pre></div></td></tr></table></figure>
<p>为了提高可读性。注释应该至少离开代码2个空格。<br>
另一方面，绝不要描述代码。假设阅读代码的人比你更懂Python，他只是不知道你的代码要做什么。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># BAD COMMENT: Now go through the b array and make sure whenever i occurs</span><br><span class="hljs-comment"># the next element is i+1</span><br></code></pre></div></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask IIS部署</title>
    <url>/2019/04/24/Flask-IIS%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1>方案一：无 virtual environment (原文链接：<a href="https://segmentfault.com/a/1190000008909201" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008909201</a>)</h1>
<h2 id="安装-IIS，启用-CGI"><a class="header-anchor" href="#安装-IIS，启用-CGI">¶</a>安装 IIS，启用 CGI</h2>
<p>在控制面板中找到打开或者关闭 Windows 功能，安装 IIS 和 CGI，如下图。</p>
<p><img src="https://image-static.segmentfault.com/525/408/525408382-58e616a6eb691_articlex" alt="图1"></p>
<h2 id="安装-URL-重写组件"><a class="header-anchor" href="#安装-URL-重写组件">¶</a>安装 URL 重写组件</h2>
<p>IIS 需要安装 URL 重写组件，这个可以通过<a href="https://www.microsoft.com/web/downloads/platform.aspx" target="_blank" rel="noopener">Microsoft Web Platform Installer</a>搜索 <code>url</code> 来安装。也可以下载<a href="https://www.iis.net/downloads/microsoft/url-rewrite" target="_blank" rel="noopener">离线安装包</a>来安装。</p>
<p><img src="https://image-static.segmentfault.com/314/450/3144503439-58e616a70556a_articlex" alt="Microsoft Web Platform Installer"></p>
<blockquote>
<p><em>注：据说 Windows10 上的 IIS 10 现在不支持 url 重写？待验证</em></p>
</blockquote>
<h2 id="安装-wfastcgi"><a class="header-anchor" href="#安装-wfastcgi">¶</a>安装 wfastcgi</h2>
<p>通过pip就可以安装：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">python <span class="hljs-literal">-m</span> pip install wfastcgi<br></code></pre></div></td></tr></table></figure>
<h2 id="启用-wfastcgi"><a class="header-anchor" href="#启用-wfastcgi">¶</a>启用 wfastcgi</h2>
<p>剩下的事情就只有一些配置了。首先以管理员身份运行 <code>wfastcgi-enable</code> 来在IIS上启用wfastcgi，这个命令位于_c:\python_dir\scripts_，也就是你需要确保此目录在系统的PATH里，或者你需要cd到这个目录后再执行。</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># cd to python_dir\scripts if it is not in PATH</span><br>wfastcgi<span class="hljs-literal">-enable</span><br></code></pre></div></td></tr></table></figure>
<p>记住命令执行成功后返回的信息：</p>
<blockquote>
<p>C:\Python34\Scripts&gt; wfastcgi-enable<br>
Applied configuration changes to section “system.webServer/fastCgi” for “MACHINE/WEBROOT/APPHOST” at configuration commit path “MACHINE/WEBROOT/APPHOST”<br>
“C:\Python34\python.exe|C:\Python34\lib\site-packages\<a href="http://wfastcgi.py" target="_blank" rel="noopener">wfastcgi.py</a>” can now be used as a FastCGI script processor<br>
“C:\Python34python.exe|C:\<a href="http://Python34libsite-packageswfastcgi.py" target="_blank" rel="noopener">Python34libsite-packageswfastcgi.py</a>” 在下文的配置文件中需要使用。</p>
</blockquote>
<blockquote>
<p>Tips:</p>
<ol>
<li>使用命令 <code>wfastcgi-disable</code> 可以将其移除。</li>
<li>待验证：如果不使用 <code>wfastcgi-enable</code> 命令配置IIS，而用下面的 web.config 配置，并在其中将 <code>C:\\Python34python.exe|C:\\Python34libsite-packageswfastcgi.py</code> 部分换成 virtual environment 的目录，便可使用 virtual environment。</li>
</ol>
</blockquote>
<h2 id="创建-web-config-文件"><a class="header-anchor" href="#创建-web-config-文件">¶</a>创建 web.config 文件</h2>
<p>下面是一个 <em>web.config</em> 文件的例子，你只需要修改对应部分就可以使用。</p>
<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">system.webServer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">handlers</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- scriptProcessor 的值来自命令行工具 wfastcgi-enable --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"FlaskFastCGI"</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"*"</span> <span class="hljs-attr">verb</span>=<span class="hljs-string">"*"</span> <span class="hljs-attr">modules</span>=<span class="hljs-string">"FastCgiModule"</span> <span class="hljs-attr">scriptProcessor</span>=<span class="hljs-string">"C:\Python34\python.exe|C:\Python34\lib\site-packages\wfastcgi.py"</span> <span class="hljs-attr">resourceType</span>=<span class="hljs-string">"Unspecified"</span> <span class="hljs-attr">requireAccess</span>=<span class="hljs-string">"Script"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">handlers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">security</span>&gt;</span> <br>        <span class="hljs-comment">&lt;!-- URL 重写中的特殊字符，比如加号+等等 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">requestFiltering</span> <span class="hljs-attr">allowDoubleEscaping</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">requestFiltering</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">security</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">system.webServer</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appSettings</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Required settings --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 在这里指定Falsk app在模块中的具体位置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"WSGI_HANDLER"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"hello.app"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"PYTHONPATH"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"~/"</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Optional settings --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 需要先创建日志目录，否则报错 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"WSGI_LOG"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"C:\logs\oboeqa_web.log"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"WSGI_RESTART_FILE_REGEX"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">appSettings</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<h2 id="配置-IIS-目录及权限"><a class="header-anchor" href="#配置-IIS-目录及权限">¶</a>配置 IIS 目录及权限</h2>
<p>假设你的 Flask 程序将部署在 <em>C:\websitehello</em> 下面，那么你的目录结构大致如此。</p>
<blockquote>
<p>C:\WEBSITE<br>
└───hello<br>
              <a href="http://hello.py" target="_blank" rel="noopener">hello.py</a><br>
              web.config</p>
</blockquote>
<p>现在你需要让IIS用户拥有访问和执行你的网站脚本的权限，进入 <em>C:\website</em> 目录，执行下面两条命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">cd C:\website<br>icacls . /grant <span class="hljs-string">"NT AUTHORITY\IUSR:(OI)(CI)(RX)"</span><br>icacls . /grant <span class="hljs-string">"Builtin\IIS_IUSRS:(OI)(CI)(RX)"</span><br></code></pre></div></td></tr></table></figure>
<h2 id="创建并访问你的网站"><a class="header-anchor" href="#创建并访问你的网站">¶</a>创建并访问你的网站</h2>
<p>现在你离成功只差一步之遥，打开 IIS 管理面板，新建一个网站。</p>
<p><img src="https://image-static.segmentfault.com/219/794/2197942092-58e6163fa0835_articlex" alt="图3"></p>
<p>你只需要填上网站名称，物理地址和相应的端口号，点击确认。</p>
<p><img src="https://image-static.segmentfault.com/199/581/1995815946-58e6163f99194_articlex" alt="图4"></p>
<p>打开浏览器，就可以访问你配置好的网站。如果有错误，可以去检查 <em>web.config</em> 中配置的日志文件。</p>
<p><img src="https://image-static.segmentfault.com/124/003/124003068-58e6163f7048d_articlex" alt="图5"></p>
<h2 id="简单总结"><a class="header-anchor" href="#简单总结">¶</a>简单总结</h2>
<p>写完之后发现其实要完成的步骤并不是特别复杂，但是从摸索到实践的过程确实不易。本文仅讨论了部署的主要步骤，其实真正的生产环境你要考虑的问题可能更多，比如使用 virtualenv 对网站进行隔离，安全问题，静态文件解析等等。</p>
<h2 id="最后的惊喜"><a class="header-anchor" href="#最后的惊喜">¶</a>最后的惊喜</h2>
<p><strong>据说</strong> 部署Python 网站到 IIS 还有更简单的办法，那就是安装宇宙最强的IDE - <a href="https://www.visualstudio.com/" target="_blank" rel="noopener">Visual Studio 2015</a> （VS2017 暂不支持 Python 开发），个人开发者可以免授权使用社区版。在 VS 中你可以使用 <a href="https://microsoft.github.io/PTVS/" target="_blank" rel="noopener">PTVS</a> 来快捷开发并部署Python 程序，真正让你一键无忧。</p>
<p><img src="https://image-static.segmentfault.com/234/190/2341908542-58e61641a5209_articlex" alt="图6"></p>
<p>PTVS 支持了常见的 Python Web 框架，比如 Flask，Django，Bottle，Jade 等等，调试的时候只需要按 F5，部署右键选择 publish，跟着向导一步两步你就可以完成魔鬼的步伐。</p>
<h2 id="参考链接"><a class="header-anchor" href="#参考链接">¶</a>参考链接</h2>
<ul>
<li><a href="http://stackoverflow.com/questions/5072166/how-do-i-deploy-a-flask-application-in-iis" target="_blank" rel="noopener">http://stackoverflow.com/questions/5072166/how-do-i-deploy-a-flask-application-in-iis</a></li>
<li><a href="http://stackoverflow.com/questions/20134329/how-to-deploy-a-flask-application-in-iis-8-windows-server-2012" target="_blank" rel="noopener">http://stackoverflow.com/questions/20134329/how-to-deploy-a-flask-application-in-iis-8-windows-server-2012</a></li>
<li><a href="http://blog.csdn.net/firefox1/article/details/46438769" target="_blank" rel="noopener">http://blog.csdn.net/firefox1/article/details/46438769</a></li>
<li><a href="http://www.cnblogs.com/liulixiang/p/4999608.html" target="_blank" rel="noopener">http://www.cnblogs.com/liulixiang/p/4999608.html</a></li>
<li><a href="http://www.cnblogs.com/xiaolecn/p/5111076.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaolecn/p/5111076.html</a></li>
</ul>
<h1>方案二：有 virtual environment (原文链接：<a href="https://www.cnblogs.com/liluping860122/p/9203908.html" target="_blank" rel="noopener">https://www.cnblogs.com/liluping860122/p/9203908.html</a>)</h1>
<h2 id="一、项目部署"><a class="header-anchor" href="#一、项目部署">¶</a>一、项目部署</h2>
<ol>
<li>
<p>服务器安装 python3.6：根据自己系统位数下载安装： <a href="https://www.python.org/downloads/windows/" target="_blank" rel="noopener">https://www.python.org/downloads/windows/</a></p>
<p><strong>由于 python3.6 已经安装好了 pip，所以剩下的工作就简单了。</strong></p>
</li>
<li>
<p>安装 virtualenv 虚拟环境：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">pip install virtualenv<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>创建虚拟环境：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">virtualenv env_36<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>配置虚拟环境模块：先激活虚拟环境，然后安装项目需要的模块。</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">pip install <span class="hljs-literal">-r</span> requirements.txt<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>代码迁移，此处省略，然后在虚拟环境检查是否正常：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">python manage.py runserver -<span class="hljs-literal">-host</span> <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span> -<span class="hljs-literal">-port</span> <span class="hljs-number">8000</span><br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><strong><font color="red">注：如果检查正常说明项目这些都没问题了，下面可以进行IIS相关的配置。</font></strong></p>
</blockquote>
<h2 id="二、IIS-和-wgastcgi-配置"><a class="header-anchor" href="#二、IIS-和-wgastcgi-配置">¶</a>二、IIS 和 wgastcgi 配置</h2>
<ol>
<li>
<p>安装 wfastcgi：</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">pip install wfastcgi<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><font color="red">注：这里是全局安装，不是在虚拟环境安装。</font></p>
</blockquote>
</li>
<li>
<p>在 python3.6 的安装目录：  <em>Lib/site-packages</em> 文件夹下，找到：<em><a href="http://wfastcgi.py" target="_blank" rel="noopener">wfastcgi.py</a></em> 这个文件。如图：</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620144521735-971439039.png" alt="图1"></p>
</li>
</ol>
<p>把这个文件拷贝到你的项目根目录。如图：</p>
<div class="hljs code-wrapper"><pre><code>![图2](/images/Flask-IIS部署/35314-20180620144615996-205738701.png)
</code></pre></div>
<ol start="3">
<li>
<p>IIS 添加应用：</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620144823448-748090275.png" alt="图3"></p>
</li>
<li>
<p>在你的网站下面找到【处理程序映射】如图：双击打开：</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620144945315-1193833752.png" alt="图4"></p>
</li>
<li>
<p>添加模块映射：<font color="red">大家注意图片中标注的第2条。(<em>D:\Python\ENV\DEV_36\Scripts\python.exe|D:\Python\PRO\cms\<a href="http://wfastcgi.py" target="_blank" rel="noopener">wfastcgi.py</a></em>) 前面部分为虚拟环境路径，<code>|</code> 号后面是项目里的 <em><a href="http://wfastcig.py" target="_blank" rel="noopener">wfastcig.py</a></em> 路径。</font></p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620145449414-1255307354.png" alt="图5"></p>
</li>
<li>
<p>请求限制中把（映射下面的 “√” 去掉）</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620145614871-1826673338.png" alt="图6"></p>
</li>
<li>
<p>确认添加模块</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620145705313-916636073.png" alt="图7"></p>
</li>
<li>
<p>这个时候你应该可以看见你的 FlaskFastCGI 程序了</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620145809096-27445421.png" alt="图8"></p>
</li>
<li>
<p>回到 IIS 控制台，进入【FastCGI设置】如图：</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620145924073-706250573.png" alt="图9"></p>
</li>
<li>
<p>双击打开你应该可以看见刚才添加的 FastCGI:</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620150050654-141759257.png" alt="图10"></p>
</li>
<li>
<p>双击，编辑 —【环境变量】</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620150635034-1010093138.png" alt="图11"></p>
<p>这里添加2个变量：<br>
<code>PYTHONPATH</code>    值为：  项目路径：（如：<em>D:\Python\PRO\cms</em>）<br>
<code>WSGI_HANDLER</code>  值为： 项目启动文件中的 <code>app</code>，如图，因为我是通过 <code>manage</code>启动。</p>
</li>
<li>
<p>回收应用程序池，重启 IIS。</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620150948097-591061574.png" alt="图12"></p>
</li>
<li>
<p>输入地址测试，不出问题应该是可以正常访问了。</p>
<p><img src="/images/Flask-IIS%E9%83%A8%E7%BD%B2/35314-20180620151138737-242388206.png" alt="图13"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
        <tag>Windows</tag>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移Win10的Linux子系统</title>
    <url>/2019/04/24/%E8%BF%81%E7%A7%BBWin10%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1>问题</h1>
<p>Win10 安装的 Linux 子系统默认安装在 C 盘，对于需要在 Linux 系统中使用大文件的用户来说不方便。下面记录一种方法可以将 Linux 文件系统迁移出 C 盘。</p>
<blockquote>
<p>如果要查看 Linux 安装目录， 在文件管理器地址栏输入 <em>%localappdata%\Packages</em>，找到一个文件夹 以 <em>CanonicalGroupLimited.UbuntuonWindows</em> 开头的，就是 Linux 安装目录。Linux 文件在该目录的 <em>LocalState\rootfs</em></p>
</blockquote>
<h1>解决</h1>
<ol>
<li>
<p>查看当前用户名，我的用户名是 <strong>lingl</strong>：</p>
<p><img src="https://img-blog.csdn.net/2018091113394579?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E1NzEyOTMyNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图1"></p>
</li>
<li>
<p>在迁移目标磁盘创建一个文件夹 ，并设置权限。<br>
例如创建 <em>E:\Ubuntu.windows</em> 文件夹后，执行如下命令（lingl 替换成自己的用户名）:</p>
 <figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">icacls E:\Ubuntu.windows /grant <span class="hljs-string">"lingl:(OI)(CI)(F)"</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>下载 LxRunOffline（<a href="https://github.com/DDoSolitary/LxRunOffline/releases" target="_blank" rel="noopener">点此下载</a>）。</p>
</li>
<li>
<p><code>lxrunoffline list</code> 查看已安装的 Linux 发行版本：</p>
<p><img src="https://img-blog.csdn.net/20180911134611768?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E1NzEyOTMyNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图2"></p>
</li>
<li>
<p><code>lxrunoffline move</code> 迁移 Linux 文件：</p>
<p><img src="https://img-blog.csdn.net/20180911134740420?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E1NzEyOTMyNTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图3"></p>
</li>
<li>
<p>确认迁移完成，使用 <code>lxrunoffline get-dir -n Ubuntu</code> 查看安装目录。</p>
</li>
<li>
<p>可以删除原 <em>LocalState\rootfs</em> 目录。</p>
</li>
</ol>
<blockquote>
<p>原贴地址：<a href="https://blog.csdn.net/starhosea/article/details/82624629" target="_blank" rel="noopener">https://blog.csdn.net/starhosea/article/details/82624629</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 程序设计语言学习笔记（二）</title>
    <url>/2019/03/03/Rust-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1>Rust 程序设计语言学习笔记（二）</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="6-枚举与模式匹配"><a class="header-anchor" href="#6-枚举与模式匹配">¶</a>6. 枚举与模式匹配</h2>
<h3 id="6-1-定义枚举"><a class="header-anchor" href="#6-1-定义枚举">¶</a>6.1 定义枚举</h3>
<h4 id="枚举值"><a class="header-anchor" href="#枚举值">¶</a>枚举值</h4>
<p>仅仅使用枚举并将数据直接放进每一个枚举成员而不是将枚举作为结构体的一部分。<code>IpAddr</code> 枚举的新定义表明了 <code>V4</code> 和 <code>V6</code> 成员都关联了 <code>String</code> 值：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">IpAddr</span></span> &#123;<br>    V4(<span class="hljs-built_in">String</span>),<br>    V6(<span class="hljs-built_in">String</span>),<br>&#125;<br><br><span class="hljs-keyword">let</span> home = IpAddr::V4(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"127.0.0.1"</span>));<br><br><span class="hljs-keyword">let</span> loopback = IpAddr::V6(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"::1"</span>));<br></code></pre></div></td></tr></table></figure>
<p>我们直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了。</p>
<p>来看看下面另一个枚举的例子：它的成员中内嵌了多种多样的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Message</span></span> &#123;<br>    Quit,<br>    Move &#123; x: <span class="hljs-built_in">i32</span>, y: <span class="hljs-built_in">i32</span> &#125;,<br>    Write(<span class="hljs-built_in">String</span>),<br>    ChangeColor(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>),<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这个枚举有四个含有不同类型的成员：</p>
<ul>
<li><code>Quit</code> 没有关联任何数据。</li>
<li><code>Move</code> 包含一个匿名结构体。</li>
<li><code>Write</code> 包含单独一个 <code>String</code>。</li>
<li><code>ChangeColor</code> 包含三个 <code>i32</code>。</li>
</ul>
<p>就像可以使用 <code>impl</code> 来为结构体定义方法那样，也可以在枚举上定义方法。这是一个定义于我们 <code>Message</code> 枚举上的叫做 <code>call</code> 的方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">impl</span> Message &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-comment">// 在这里定义方法体</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> m = Message::Write(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"hello"</span>));<br>m.call();<br></code></pre></div></td></tr></table></figure>
<p>方法体使用了 <code>self</code> 来获取调用方法的值。这个例子中，创建了一个值为 <code>Message::Write(String::from(&quot;hello&quot;))</code> 的变量 <code>m</code>，而且这就是当 <code>m.call()</code> 运行时 <code>call</code> 方法中的 <code>self</code> 的值。</p>
<h4 id="Option-枚举和其相对于空值的优势"><a class="header-anchor" href="#Option-枚举和其相对于空值的优势">¶</a><code>Option</code> 枚举和其相对于空值的优势</h4>
<p>空值尝试表达的概念仍然是有意义的：空值是一个因为某种原因目前无效或缺失的值。<br>
问题不在于概念而在于具体的实现。为此，Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 <code>Option&lt;T&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Option</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-literal">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>只要一个值不是 <code>Option&lt;T&gt;</code> 类型，你就 <strong>可以</strong> 安全的认定它的值不为空。</p>
</blockquote>
<h3 id="6-2-match-控制流运算符"><a class="header-anchor" href="#6-2-match-控制流运算符">¶</a>6.2 <code>match</code> 控制流运算符</h3>
<p>一个枚举和一个以枚举成员作为模式的 <code>match</code> 表达式的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Coin</span></span> &#123;<br>    Penny,<br>    Nickel,<br>    Dime,<br>    Quarter,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="hljs-built_in">u32</span> &#123;<br>    <span class="hljs-keyword">match</span> coin &#123;<br>        Coin::Penny =&gt; <span class="hljs-number">1</span>,<br>        Coin::Nickel =&gt; <span class="hljs-number">5</span>,<br>        Coin::Dime =&gt; <span class="hljs-number">10</span>,<br>        Coin::Quarter =&gt; <span class="hljs-number">25</span>,<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果分支代码较短的话通常不使用大括号，正如上例 中的每个分支都只是返回一个值。如果想要在分支中运行多行代码，可以使用大括号。例如，如下代码在每次使用<code>Coin::Penny</code> 调用时都会打印出 “Lucky penny!”，同时仍然返回代码块最后的值，<code>1</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="hljs-built_in">u32</span> &#123;<br>    <span class="hljs-keyword">match</span> coin &#123;<br>        Coin::Penny =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Lucky penny!"</span>);<br>            <span class="hljs-number">1</span><br>        &#125;,<br>        Coin::Nickel =&gt; <span class="hljs-number">5</span>,<br>        Coin::Dime =&gt; <span class="hljs-number">10</span>,<br>        Coin::Quarter =&gt; <span class="hljs-number">25</span>,<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="匹配是穷尽的"><a class="header-anchor" href="#匹配是穷尽的">¶</a>匹配是穷尽的</h3>
<p>match 还有另一方面需要讨论。考虑一下 <code>plus_one</code> 函数的这个版本，它有一个 bug 并不能编译：<br>
这些代码不能编译！</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">plus_one</span></span>(x: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt;) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt; &#123;<br>    <span class="hljs-keyword">match</span> x &#123;<br>        <span class="hljs-literal">Some</span>(i) =&gt; <span class="hljs-literal">Some</span>(i + <span class="hljs-number">1</span>),<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>我们没有处理 <code>None</code> 的情况，所以这些代码会造成一个 bug。幸运的是，这是一个 Rust 知道如何处理的 bug。如果尝试编译这段代码，会得到这个错误：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey"><span class="hljs-title">error[E0004]: non-exhaustive patterns:</span> `None` <span class="hljs-literal">not</span> covered<br> --&gt;<br>  |<br><span class="hljs-number">6</span> |         match x &#123;<br>  |               ^ pattern `None` <span class="hljs-literal">not</span> covered<br></code></pre></div></td></tr></table></figure>
<p>Rust 知道我们没有覆盖所有可能的情况甚至知道哪些模式被忘记了！Rust 中的匹配是 穷尽的（<em>exhaustive</em>）：必须穷举到最后的可能性来使代码有效。特别的在这个 <code>Option&lt;T&gt;</code> 的例子中，Rust 防止我们忘记明确的处理 <code>None</code> 的情况，这使我们免于假设拥有一个实际上为空的值。</p>
<h4 id="通配符"><a class="header-anchor" href="#通配符">¶</a><code>_</code> 通配符</h4>
<p>Rust 也提供了一个模式用于不想列举出所有可能值的场景：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> some_u8_value = <span class="hljs-number">0u8</span>;<br><span class="hljs-keyword">match</span> some_u8_value &#123;<br>    <span class="hljs-number">1</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"one"</span>),<br>    <span class="hljs-number">3</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"three"</span>),<br>    <span class="hljs-number">5</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"five"</span>),<br>    <span class="hljs-number">7</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"seven"</span>),<br>    _ =&gt; (),<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>_</code> 模式会匹配所有的值。通过将其放置于其他分支之后，<code>_</code> 将会匹配所有之前没有指定的可能的值。<code>()</code> 就是 <code>unit</code> 值，所以 <code>_</code> 的情况什么也不会发生。</p>
<h3 id="6-3-if-let-简洁控制流"><a class="header-anchor" href="#6-3-if-let-简洁控制流">¶</a>6.3 <code>if let</code> 简洁控制流</h3>
<p>为了满足 <code>match</code> 表达式（穷尽性）的要求，必须在处理完这唯一的成员后加上 <code>_ =&gt; ()</code>，这样也要增加很多样板代码。<br>
我们可以使用 <code>if let</code> 这种更短的方式编写：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-number">3</span>) = some_u8_value &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"three"</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>可以在 <code>if let</code> 中包含一个 <code>else</code>。<code>else</code> 块中的代码与 <code>match</code> 表达式中的 <code>_</code> 分支块中的代码相同，这样的 <code>match</code> 表达式就等同于 <code>if let</code> 和 <code>else</code>。这样一个 match 表达式：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">match</span> coin &#123;<br>    Coin::Quarter(state) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"State quarter from &#123;:?&#125;!"</span>, state),<br>    _ =&gt; count += <span class="hljs-number">1</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> Coin::Quarter(state) = coin &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"State quarter from &#123;:?&#125;!"</span>, state);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    count += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="7-包、crate-与模块"><a class="header-anchor" href="#7-包、crate-与模块">¶</a>7. 包、crate 与模块</h2>
<h3 id="7-1-包和-crate-用来创建库和二进制项目"><a class="header-anchor" href="#7-1-包和-crate-用来创建库和二进制项目">¶</a>7.1 包和 crate 用来创建库和二进制项目</h3>
<ul>
<li><em>crate</em> 是一个二进制或库项目。</li>
<li><strong>crate 根</strong>（<em>crate root</em>）是一个用来描述如何构建 crate 的文件。</li>
<li>带有 <em>Cargo.toml</em> 文件的 <strong>包</strong> 用以描述如何构建一个或多个 crate。一个包中至多可以有一个库项目。</li>
</ul>
<p>所以当运行 <code>cargo new</code> 时是在创建一个包：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cargo new my-project<br>     Created binary (application) `my-project` package<br>$ ls my-project<br>Cargo.toml<br>src<br>$ ls my-project/src<br>main.rs<br></code></pre></div></td></tr></table></figure>
<blockquote>
<ul>
<li>Cargo 的约定是如果在代表包的 <em>Cargo.toml</em> 的同级目录下包含 <em>src</em> 目录且其中包含 <em><a href="http://main.rs" target="_blank" rel="noopener">main.rs</a></em> 文件的话，Cargo 就知道这个包带有一个与包同名的二进制 crate，且 <em>src/main.rs</em> 就是 crate 根。</li>
<li>另一个约定如果包目录中包含 <em>src/lib.rs</em>，则包带有与其同名的库 crate，且 <em>src/lib.rs</em> 是 crate 根。crate 根文件将由 Cargo 传递给 <code>rustc</code> 来实际构建库或者二进制项目。</li>
</ul>
</blockquote>
<h3 id="7-2-模块系统用来控制作用域和私有性"><a class="header-anchor" href="#7-2-模块系统用来控制作用域和私有性">¶</a>7.2 模块系统用来控制作用域和私有性</h3>
<h4 id="使用-super-开始相对路径"><a class="header-anchor" href="#使用-super-开始相对路径">¶</a>使用 <code>super</code> 开始相对路径</h4>
<p>可以使用 <code>super</code> 开头来构建相对路径。这么做类似于文件系统中以 <code>..</code> 开头：该路径从 <strong>父</strong> 模块开始而不是当前模块。这在下面示例这样的情况下有用处，在这里 clarinet 函数通过指定以 <code>super</code> 开头的路径调用 <code>breathe_in</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">mod</span> instrument &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet</span></span>() &#123;<br>        super::breathe_in();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">breathe_in</span></span>() &#123;<br>    <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>clarinet</code> 函数位于 <code>instrument</code> 模块中，所以可以使用 <code>super</code> 进入 <code>instrument</code> 的父模块，也就是根 <code>crate</code>。从这里可以找到 <code>breathe_in</code>。成功！</p>
<h4 id="对结构体和枚举使用-pub"><a class="header-anchor" href="#对结构体和枚举使用-pub">¶</a>对结构体和枚举使用 <code>pub</code></h4>
<p>如果在结构体定义中使用 <code>pub</code>，可以使结构体公有。然而结构体的字段仍是私有的。可以在每一个字段的基准上选择其是否公有：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">mod</span> plant &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vegetable</span></span> &#123;<br>        <span class="hljs-keyword">pub</span> name: <span class="hljs-built_in">String</span>,<br>        id: <span class="hljs-built_in">i32</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> Vegetable &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(name: &amp;<span class="hljs-built_in">str</span>) -&gt; Vegetable &#123;<br>            Vegetable &#123;<br>                name: <span class="hljs-built_in">String</span>::from(name),<br>                id: <span class="hljs-number">1</span>,<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = plant::Vegetable::new(<span class="hljs-string">"squash"</span>);<br><br>    v.name = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"butternut squash"</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;&#125; are delicious"</span>, v.name);<br><br>    <span class="hljs-comment">// 如果将如下行取消注释代码将无法编译:</span><br>    <span class="hljs-comment">// println!("The ID is &#123;&#125;", v.id);</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>相反，如果有一个公有枚举，其所有成员都是公有。只需在 <code>enum</code> 关键词前加上 <code>pub</code>。</p>
<h4 id="使用-use-关键字将名称引入作用域"><a class="header-anchor" href="#使用-use-关键字将名称引入作用域">¶</a>使用 <code>use</code> 关键字将名称引入作用域</h4>
<p>有一次性将路径引入作用域然后就像调用本地项那样的方法：使用 <code>use</code> 关键字。</p>
<p>如果希望通过 use 和相对路径来将项引入作用域，则与直接通过相对路径调用项有些小的区别：不同于从当前作用域的名称开始，use 中的路径必须以 self</p>
<h4 id="use-函数路径使用习惯-VS-其他项"><a class="header-anchor" href="#use-函数路径使用习惯-VS-其他项">¶</a><code>use</code> 函数路径使用习惯 VS 其他项</h4>
<ul>
<li>
<p>对于函数来说，通过 <code>use</code> 指定函数的父模块接着指定父模块来调用方法被认为是习惯用法。这么做而不是像下面示例那样通过 <code>use</code> 指定函数的路径，清楚的表明了函数不是本地定义的，同时仍最小化了指定全路径时的重复：</p>
  <figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">mod</span> sound &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> instrument &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet</span></span>() &#123;<br>            <span class="hljs-comment">// 函数体</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">use</span> crate::sound::instrument::clarinet;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    clarinet();<br>    clarinet();<br>    clarinet();<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>对于结构体、枚举和其它项，通过 <code>use</code> 指定项的全路径是习惯用法。例如，下面示例展示了将标准库中 <code>HashMap</code> 结构体引入作用域的习惯用法。</p>
  <figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br>    <br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> map = HashMap::new();<br>    map.insert(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>这个习惯的一个例外是如果 <code>use</code> 语句会将两个同名的项引入作用域时，这是不允许的。下面示例展示了如何将两个不同父模块的 <code>Result</code> 类型引入作用域并引用它们。</p>
  <figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-keyword">use</span> std::io;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">function1</span></span>() -&gt; fmt::<span class="hljs-built_in">Result</span> &#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">function2</span></span>() -&gt; io::<span class="hljs-built_in">Result</span>&lt;()&gt; &#123;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>因为如果我们指定 <code>use std::fmt::Result</code> 和 <code>use std::io::Result</code>，则作用域中会有两个 <code>Result</code> 类型，Rust 无法知道我们想用哪个 <code>Result</code>。</p>
</li>
</ul>
<h4 id="使用-pub-use-重导出名称"><a class="header-anchor" href="#使用-pub-use-重导出名称">¶</a>使用 <code>pub use</code> 重导出名称</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">mod</span> sound &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> instrument &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet</span></span>() &#123;<br>            <span class="hljs-comment">// 函数体</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">mod</span> performance_group &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> crate::sound::instrument;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet_trio</span></span>() &#123;<br>        instrument::clarinet();<br>        instrument::clarinet();<br>        instrument::clarinet();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    performance_group::clarinet_trio();<br>    performance_group::instrument::clarinet();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>通过 <code>pub use</code>，现在 <code>main</code> 函数可以通过新路径 <code>performance_group::instrument::clarinet</code> 来调用 <code>clarinet</code> 函数。如果没有指定 <code>pub use</code>，<code>clarinet_trio</code> 函数可以在其作用域中调用 <code>instrument::clarinet</code> 但 <code>main</code> 则不允许使用这个新路径。</p>
<h4 id="嵌套路径来消除大量的-use-行"><a class="header-anchor" href="#嵌套路径来消除大量的-use-行">¶</a>嵌套路径来消除大量的 <code>use</code> 行</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::&#123;cmp::Ordering, io&#125;;<br></code></pre></div></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::cmp:Ordering;<br><span class="hljs-keyword">use</span> std::io;<br></code></pre></div></td></tr></table></figure>
<p>另外：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, Write&#125;;<br></code></pre></div></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io:Write;<br></code></pre></div></td></tr></table></figure>
<h4 id="通过-glob-运算符将所有的公有定义引入作用域"><a class="header-anchor" href="#通过-glob-运算符将所有的公有定义引入作用域">¶</a>通过 <code>glob</code> 运算符将所有的公有定义引入作用域</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::collections::*;<br></code></pre></div></td></tr></table></figure>
<p>这个 <code>use</code> 语句将 <code>std::collections</code> 中定义的所有公有项引入当前作用域。</p>
<blockquote>
<p>使用 glob 运算符时请多加小心！<strong>如此难以推导作用域中有什么名称和它们是在何处定义的</strong>。<br>
glob 运算符经常用于测试模块 <code>tests</code> 中，这时会将所有内容引入作用域。</p>
</blockquote>
<h4 id="将模块分割进不同文件"><a class="header-anchor" href="#将模块分割进不同文件">¶</a>将模块分割进不同文件</h4>
<p><em>src/sound/instrument.rs</em> 中：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clarinet</span></span>() &#123;<br>    <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><em>src/sound.rs</em> 中：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> instrument;<br></code></pre></div></td></tr></table></figure>
<p><em>src/main.rs</em> 中：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">mod</span> sound;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// 绝对路径</span><br>    crate::sound::instrument::clarinet();<br><br>    <span class="hljs-comment">// 相对路径</span><br>    sound::instrument::clarinet();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="8-通用集合类型"><a class="header-anchor" href="#8-通用集合类型">¶</a>8. 通用集合类型</h2>
<h3 id="8-1-vector"><a class="header-anchor" href="#8-1-vector">¶</a>8.1 vector</h3>
<h4 id="新建-vector"><a class="header-anchor" href="#新建-vector">¶</a>新建 vector</h4>
<p>为了创建一个新的空 vector，可以调用 <code>Vec::new</code> 函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">Vec</span>::new();<br></code></pre></div></td></tr></table></figure>
<p>在更实际的代码中，一旦插入值 Rust 就可以推断出想要存放的类型，所以你很少会需要这些类型注解。更常见的做法是使用初始值来创建一个 <code>Vec</code>，而且为了方便 Rust 提供了 <code>vec!</code> 宏。这个宏会根据我们提供的值来创建一个新的 <code>Vec</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></div></td></tr></table></figure>
<h4 id="更新-vector"><a class="header-anchor" href="#更新-vector">¶</a>更新 vector</h4>
<p>对于新建一个 vector 并向其增加元素，可以使用 <code>push</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">Vec</span>::new();<br><br>v.push(<span class="hljs-number">5</span>);<br>v.push(<span class="hljs-number">6</span>);<br>v.push(<span class="hljs-number">7</span>);<br>v.push(<span class="hljs-number">8</span>);<br></code></pre></div></td></tr></table></figure>
<p>放入其中的所有值都是 <code>i32</code> 类型的，而且 Rust 也根据数据做出如此判断，所以不需要 <code>Vec&lt;i32&gt;</code> 注解。</p>
<h4 id="读取-vector-的元素"><a class="header-anchor" href="#读取-vector-的元素">¶</a>读取 vector 的元素</h4>
<p>有两种方法引用 vector 中储存的值，索引语法或者 <code>get</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> third: &amp;<span class="hljs-built_in">i32</span> = &amp;v[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"The third element is &#123;&#125;"</span>, third);<br><br><span class="hljs-keyword">match</span> v.get(<span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-literal">Some</span>(third) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"The third element is &#123;&#125;"</span>, third),<br>    <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"There is no third element."</span>),<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这里有两个需要注意的地方：</p>
<blockquote>
<ul>
<li>我们使用索引值 <code>2</code> 来获取第三个元素，索引是从 <code>0</code> 开始的。</li>
<li>这两个不同的获取第三个元素的方式分别为：使用 <code>&amp;</code> 和 <code>[]</code> 返回一个引用；或者使用 <code>get</code> 方法以索引作为参数来返回一个 <code>Option&lt;&amp;T&gt;</code>。</li>
</ul>
</blockquote>
<p>一旦程序获取了一个有效的引用，借用检查器将会执行所有权和借用规则来确保 vector 内容的这个引用和任何其他引用保持有效。回忆一下不能在相同作用域中同时存在可变和不可变引用的规则。当我们获取了 vector 的 <strong>第一个元素</strong> 的不可变引用并尝试在 vector 末尾增加一个元素的时候，这是行不通的：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> first = &amp;v[<span class="hljs-number">0</span>];<br><br>v.push(<span class="hljs-number">6</span>);<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"The first element is: &#123;&#125;"</span>, first);<br></code></pre></div></td></tr></table></figure>
<p>编译会给出这个错误：</p>
<figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">error[E0502]: cannot borrow `v` <span class="hljs-built_in">as</span> mutable because it is also borrowed <span class="hljs-built_in">as</span> immutable<br>  --&gt; src/main.rs:<span class="hljs-number">10</span>:<span class="hljs-number">5</span><br>   |<span class="hljs-type"></span><br><span class="hljs-type">8</span>  |     <span class="hljs-type">let</span> <span class="hljs-built_in">first</span> = &amp;v[<span class="hljs-number">0</span>];<br>   |                  <span class="hljs-type">- immutable</span> borrow occurs here<br><span class="hljs-number">9</span>  |<span class="hljs-type"></span><br><span class="hljs-type">10</span> |     <span class="hljs-type">v</span>.push(<span class="hljs-number">6</span>);<br>   |     <span class="hljs-type">^^^^^^^^^ mutable</span> borrow occurs here<br><span class="hljs-number">11</span> |<span class="hljs-type"></span><br><span class="hljs-type">12</span> |     <span class="hljs-type">println</span>!(<span class="hljs-string">"The first element is: &#123;&#125;"</span>, <span class="hljs-built_in">first</span>);<br>   |                                          <span class="hljs-type">----- borrow</span> later used here<br></code></pre></div></td></tr></table></figure>
<p>为什么第一个元素的引用会关心 vector 结尾的变化？不能这么做的原因是由于 vector 的工作方式：在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况。</p>
<h4 id="遍历-vector-中的元素"><a class="header-anchor" href="#遍历-vector-中的元素">¶</a>遍历 vector 中的元素</h4>
<p>使用 <code>for</code> 循环来获取 <code>i32</code> 值的 vector 中的每一个元素的不可变引用并将其打印：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">100</span>, <span class="hljs-number">32</span>, <span class="hljs-number">57</span>];<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &amp;v &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;&#125;"</span>, i);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>我们也可以遍历可变 vector 的每一个元素的可变引用以便能改变他们：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">100</span>, <span class="hljs-number">32</span>, <span class="hljs-number">57</span>];<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;<br>    *i += <span class="hljs-number">50</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="使用枚举来储存多种类型"><a class="header-anchor" href="#使用枚举来储存多种类型">¶</a>使用枚举来储存多种类型</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SpreadsheetCell</span></span> &#123;<br>    Int(<span class="hljs-built_in">i32</span>),<br>    Float(<span class="hljs-built_in">f64</span>),<br>    Text(<span class="hljs-built_in">String</span>),<br>&#125;<br><br><span class="hljs-keyword">let</span> row = <span class="hljs-built_in">vec!</span>[<br>    SpreadsheetCell::Int(<span class="hljs-number">3</span>),<br>    SpreadsheetCell::Text(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"blue"</span>)),<br>    SpreadsheetCell::Float(<span class="hljs-number">10.12</span>),<br>];<br></code></pre></div></td></tr></table></figure>
<h3 id="8-2-字符串"><a class="header-anchor" href="#8-2-字符串">¶</a>8.2 字符串</h3>
<h4 id="什么是字符串"><a class="header-anchor" href="#什么是字符串">¶</a>什么是字符串</h4>
<p><strong>Rust 的核心语言中只有一种字符串类型：<code>str</code>，字符串 slice，它通常以被借用的形式出现，<code>&amp;str</code>。</strong></p>
<h4 id="新建字符串"><a class="header-anchor" href="#新建字符串">¶</a>新建字符串</h4>
<p>很多 <code>Vec</code> 可用的操作在 <code>String</code> 中同样可用，从以 <code>new</code> 函数创建字符串开始：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::new();<br></code></pre></div></td></tr></table></figure>
<p>这新建了一个叫做 <code>s</code> 的空的字符串，接着我们可以向其中装载数据。通常字符串会有初始数据，因为我们希望一开始就有这个字符串。为此，可以使用 <code>to_string</code> 方法，<strong>它能用于任何实现了 <code>Display</code> trait 的类型，字符串字面值也实现了它 </strong>。</p>
<p>使用 <code>to_string</code> 方法从字符串字面值创建 <code>String</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> data = <span class="hljs-string">"initial contents"</span>;<br><br><span class="hljs-keyword">let</span> s = data.to_string();<br><br><span class="hljs-comment">// 该方法也可直接用于字符串字面值：</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">"initial contents"</span>.to_string();<br></code></pre></div></td></tr></table></figure>
<p>也可以使用 <code>String::from</code> 函数来从字符串字面值创建 <code>String</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"initial contents"</span>);<br></code></pre></div></td></tr></table></figure>
<h4 id="更新字符串"><a class="header-anchor" href="#更新字符串">¶</a>更新字符串</h4>
<p><code>String</code> 的大小可以增长其内容也可以改变，就像可以放入更多数据来改变 <code>Vec</code> 的内容一样。另外，可以方便的使用 <code>+</code> 运算符或 <code>format!</code> 宏来拼接 <code>String</code> 值。</p>
<h5 id="使用-push-str-和-push-附加字符串"><a class="header-anchor" href="#使用-push-str-和-push-附加字符串">¶</a>使用 <code>push_str</code> 和 <code>push</code> 附加字符串</h5>
<p><code>push_str</code> 方法获取字符串 slice，因为我们<strong>并不需要获取参数的所有权</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"foo"</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-string">"bar"</span>;<br>s1.push_str(s2);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"s2 is &#123;&#125;"</span>, s2);<br></code></pre></div></td></tr></table></figure>
<p><code>push</code> 方法被定义为获取一个单独的字符作为参数，并附加到 <code>String</code> 中：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"lo"</span>);<br>s.push(<span class="hljs-string">'l'</span>);<br></code></pre></div></td></tr></table></figure>
<h5 id="使用-运算符或-format-宏拼接字符串"><a class="header-anchor" href="#使用-运算符或-format-宏拼接字符串">¶</a>使用 <code>+</code> 运算符或 <code>format!</code> 宏拼接字符串</h5>
<p>通常你会希望将两个已知的字符串合并在一起。一种办法是像这样使用 <code>+</code> 运算符：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Hello, "</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"world!"</span>);<br><span class="hljs-keyword">let</span> s3 = s1 + &amp;s2; <span class="hljs-comment">// 注意 s1 被移动了，不能继续使用</span><br></code></pre></div></td></tr></table></figure>
<h4 id="索引字符串"><a class="header-anchor" href="#索引字符串">¶</a>索引字符串</h4>
<p>Rust 的字符串不支持索引。</p>
<h5 id="内部表现"><a class="header-anchor" href="#内部表现">¶</a>内部表现</h5>
<p><code>String</code> 是一个 <code>Vec&lt;u8&gt;</code> 的封装。为了避免返回意想不到值并造成不能立刻发现的 bug。Rust 选择不编译这些代码并及早杜绝了误会的发生。</p>
<h5 id="字节、标量值和字形簇！天呐！"><a class="header-anchor" href="#字节、标量值和字形簇！天呐！">¶</a>字节、标量值和字形簇！天呐！</h5>
<p>最后一个 Rust 不允许使用索引获取 <code>String</code> 字符的原因是索引操作预期总是需要常数时间 (O(1))。但是对于 <code>String</code> 不可能保证这样的性能，因为 Rust 不得不检查从字符串的开头到索引位置的内容来确定这里有多少有效的字符。</p>
<h4 id="字符串-slice"><a class="header-anchor" href="#字符串-slice">¶</a>字符串 slice</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> hello = <span class="hljs-string">"Здравствуйте"</span>;<br><br><span class="hljs-keyword">let</span> s = &amp;hello[<span class="hljs-number">0</span>..<span class="hljs-number">4</span>];<br></code></pre></div></td></tr></table></figure>
<p>这里，<code>s</code> 会是一个 <code>&amp;str</code>，它包含字符串的头四个字节。早些时候，我们提到了这些字母都是两个字节长的，所以这意味着 <code>s</code> 将会是 “Зд”。</p>
<p>如果获取 <code>&amp;hello[0..1]</code> 会发生什么呢？答案是：在运行时会 <code>panic</code>，就跟访问 vector 中的无效索引时一样：</p>
<figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">thread <span class="hljs-symbol">'main</span>' panicked <span class="hljs-keyword">at</span> <span class="hljs-symbol">'byte</span> index <span class="hljs-number">1</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a char boundary; it <span class="hljs-keyword">is</span> inside <span class="hljs-string">'З'</span> (bytes <span class="hljs-number">0</span>..<span class="hljs-number">2</span>) <span class="hljs-keyword">of</span> `Здравствуйте`', src/libcore/str/<span class="hljs-keyword">mod</span>.rs:<span class="hljs-number">2188</span>:<span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure>
<h4 id="遍历字符串的方法"><a class="header-anchor" href="#遍历字符串的方法">¶</a>遍历字符串的方法</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">"नमस्ते"</span>.chars() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;&#125;"</span>, c);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这些代码会打印出如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain">न<br>म<br>स<br>्<br>त<br>े<br></code></pre></div></td></tr></table></figure>
<p><code>bytes</code> 方法返回每一个原始字节，这可能会适合你的使用场景：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-string">"नमस्ते"</span>.bytes() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;&#125;"</span>, b);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这些代码会打印出组成 <code>String</code> 的 18 个字节：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">224</span><br><span class="hljs-number">164</span><br><span class="hljs-comment">// --snip--</span><br><span class="hljs-number">165</span><br><span class="hljs-number">135</span><br></code></pre></div></td></tr></table></figure>
<h3 id="8-3-哈希-map"><a class="header-anchor" href="#8-3-哈希-map">¶</a>8.3 哈希 map</h3>
<h4 id="新建一个哈希-map"><a class="header-anchor" href="#新建一个哈希-map">¶</a>新建一个哈希 map</h4>
<p>可以使用 <code>new</code> 创建一个空的 <code>HashMap</code>，并使用 <code>insert</code> 增加元素：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scores = HashMap::new();<br><br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Blue"</span>), <span class="hljs-number">10</span>);<br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Yellow"</span>), <span class="hljs-number">50</span>);<br></code></pre></div></td></tr></table></figure>
<p>另一个构建哈希 map 的方法是使用一个元组的 vector 的 <code>collect</code> 方法，其中每个元组包含一个键值对。<code>collect</code> 方法可以将数据收集进一系列的集合类型，包括 <code>HashMap</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> teams  = <span class="hljs-built_in">vec!</span>[<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Blue"</span>), <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Yellow"</span>)];<br><span class="hljs-keyword">let</span> initial_scores = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">10</span>, <span class="hljs-number">50</span>];<br><br><span class="hljs-keyword">let</span> scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();<br></code></pre></div></td></tr></table></figure>
<p>这里 <code>HashMap&lt;_, _&gt;</code> 类型注解是必要的，因为可能 <code>collect</code> 很多不同的数据结构，而除非显式指定否则 Rust 无从得知你需要的类型。但是对于键和值的类型参数来说，可以使用下划线占位，而 Rust 能够根据 vector 中数据的类型推断出 <code>HashMap</code> 所包含的类型。</p>
<h4 id="哈希-map-和所有权"><a class="header-anchor" href="#哈希-map-和所有权">¶</a>哈希 map 和所有权</h4>
<p>对于像 <code>i32</code> 这样的实现了 <code>Copy</code> trait 的类型，其值可以拷贝进哈希 map。对于像 <code>String</code> 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> field_name = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Favorite color"</span>);<br><span class="hljs-keyword">let</span> field_value = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Blue"</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> map = HashMap::new();<br>map.insert(field_name, field_value);<br><span class="hljs-comment">// 这里 field_name 和 field_value 不再有效，</span><br><span class="hljs-comment">// 尝试使用它们看看会出现什么编译错误！</span><br></code></pre></div></td></tr></table></figure>
<h4 id="访问哈希-map-中的值"><a class="header-anchor" href="#访问哈希-map-中的值">¶</a>访问哈希 map 中的值</h4>
<p>可以通过 <code>get</code> 方法并提供对应的键来从哈希 map 中获取值：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scores = HashMap::new();<br><br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Blue"</span>), <span class="hljs-number">10</span>);<br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Yellow"</span>), <span class="hljs-number">50</span>);<br><br><span class="hljs-keyword">let</span> team_name = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Blue"</span>);<br><span class="hljs-keyword">let</span> score = scores.get(&amp;team_name);<br></code></pre></div></td></tr></table></figure>
<p>这里，<code>score</code> 是与蓝队分数相关的值，应为 <code>Some(10)</code>。因为 <code>get</code> 返回 <code>Option&lt;V&gt;</code>，所以结果被装进 <code>Some</code>；如果某个键在哈希 map 中没有对应的值，<code>get</code> 会返回 <code>None</code>。</p>
<h4 id="更新哈希-map"><a class="header-anchor" href="#更新哈希-map">¶</a>更新哈希 map</h4>
<h5 id="覆盖一个值"><a class="header-anchor" href="#覆盖一个值">¶</a>覆盖一个值</h5>
<p><strong>如果我们插入了一个键值对，接着用相同的键插入一个不同的值，与这个键相关联的旧值将被替换：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scores = HashMap::new();<br><br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Blue"</span>), <span class="hljs-number">10</span>);<br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Blue"</span>), <span class="hljs-number">25</span>);<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, scores);<br></code></pre></div></td></tr></table></figure>
<p>这会打印出 <code>{&quot;Blue&quot;: 25}</code>。原始的值 <code>10</code> 则被覆盖了。</p>
<h5 id="只在键没有对应值时插入"><a class="header-anchor" href="#只在键没有对应值时插入">¶</a>只在键没有对应值时插入</h5>
<p>我们经常会检查某个特定的键是否有值，如果没有就插入一个值。为此哈希 map 有一个特有的 API，叫做 <code>entry</code>，它获取我们想要检查的键作为参数。<code>entry</code> 函数的返回值是一个枚举，<code>Entry</code>，它代表了可能存在也可能不存在的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scores = HashMap::new();<br>scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Blue"</span>), <span class="hljs-number">10</span>);<br><br>scores.entry(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Yellow"</span>)).or_insert(<span class="hljs-number">50</span>);<br>scores.entry(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Blue"</span>)).or_insert(<span class="hljs-number">50</span>);<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, scores);<br></code></pre></div></td></tr></table></figure>
<p><code>Entry</code> 的 <code>or_insert</code> 方法在键对应的值存在时就返回这个值的 <code>Entry</code>，如果不存在则将参数作为新值插入并返回修改过的 <code>Entry</code>。这比编写自己的逻辑要简明的多，另外也与借用检查器结合得更好。</p>
<h5 id="根据旧值更新一个值"><a class="header-anchor" href="#根据旧值更新一个值">¶</a>根据旧值更新一个值</h5>
<p>另一个常见的哈希 map 的应用场景是找到一个键对应的值并根据旧的值更新它。</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> text = <span class="hljs-string">"hello world wonderful world"</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> map = HashMap::new();<br><br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> text.split_whitespace() &#123;<br>    <span class="hljs-keyword">let</span> count = map.entry(word).or_insert(<span class="hljs-number">0</span>);<br>    *count += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, map);<br></code></pre></div></td></tr></table></figure>
<h2 id="9-错误处理"><a class="header-anchor" href="#9-错误处理">¶</a>9. 错误处理</h2>
<h3 id="9-1-panic-与不可恢复的错误"><a class="header-anchor" href="#9-1-panic-与不可恢复的错误">¶</a>9.1 <code>panic!</code> 与不可恢复的错误</h3>
<h4 id="对应-panic-时的栈展开或终止"><a class="header-anchor" href="#对应-panic-时的栈展开或终止">¶</a>对应 panic 时的栈展开或终止</h4>
<p>当出现 panic 时，程序默认会开始 <strong>展开</strong>（<em>unwinding</em>），这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。另一种选择是直接 <strong>终止</strong>（<em>abort</em>），这会不清理数据就退出程序。那么程序所使用的内存需要由操作系统来清理。如果你需要项目的最终二进制文件越小越好，panic 时通过在 <em>Cargo.toml</em> 的 <code>[profile]</code> 部分增加 <code>panic = 'abort'</code>，可以由展开切换为终止。例如，如果你想要在release模式中 panic 时直接终止：</p>
<figure class="highlight toml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs toml"><span class="hljs-section">[profile.release]</span><br><span class="hljs-attr">panic</span> = <span class="hljs-string">'abort'</span><br></code></pre></div></td></tr></table></figure>
<h4 id="使用-panic-的-backtrace"><a class="header-anchor" href="#使用-panic-的-backtrace">¶</a>使用 <code>panic!</code> 的 backtrace</h4>
<p>我们可以设置 <code>RUST_BACKTRACE</code> 环境变量来得到一个 backtrace <em>backtrace</em> 是一个执行到目前位置所有被调用的函数的列表。</p>
<p>你实际看到的输出可能因不同的操作系统和 Rust 版本而有所不同。为了获取带有这些信息的 backtrace，必须启用 debug 标识。当不使用 <code>--release</code> 参数运行 cargo build 或 cargo run 时 debug 标识会默认启用。</p>
<h4 id="失败时-panic-的简写：unwrap-和-expect"><a class="header-anchor" href="#失败时-panic-的简写：unwrap-和-expect">¶</a>失败时 panic 的简写：<code>unwrap</code> 和 <code>expect</code></h4>
<p><code>unwrap</code> 实现就类似于 <code>match</code> 语句。如果 <code>Result</code> 值是成员 <code>Ok</code>，<code>unwrap</code> 会返回 <code>Ok</code> 中的值。如果 <code>Result</code> 是成员 <code>Err</code>，<code>unwrap</code> 会为我们调用 <code>panic!</code>。这里是一个实践 <code>unwrap</code> 的例子：</p>
<p>如果调用这段代码时不存在 <em>hello.txt</em> 文件，我们将会看到一个 <code>unwrap</code> 调用 <code>panic!</code> 时提供的错误信息：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">thread <span class="hljs-symbol">'main</span>' panicked at <span class="hljs-symbol">'called</span> `<span class="hljs-built_in">Result</span>::unwrap()` on an `<span class="hljs-literal">Err</span>` value: Error &#123;<br>repr: Os &#123; code: <span class="hljs-number">2</span>, message: <span class="hljs-string">"No such file or directory"</span> &#125; &#125;',<br>src/libcore/result.rs:<span class="hljs-number">906</span>:<span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure>
<p>还有另一个类似于 <code>unwrap</code> 的方法它还允许我们选择 <code>panic!</code> 的错误信息：<code>expect</code>。使用 <code>expect</code> 而不是 <code>unwrap</code> 并提供一个好的错误信息可以表明你的意图并更易于追踪 panic 的根源。<code>expect</code> 的语法看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> f = File::open(<span class="hljs-string">"hello.txt"</span>).expect(<span class="hljs-string">"Failed to open hello.txt"</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>它看起来像这样：</p>
<figure class="highlight ocaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ocaml">thread <span class="hljs-symbol">'main'</span> panicked at <span class="hljs-symbol">'Failed</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">open</span> hello.txt: <span class="hljs-type">Error</span> &#123; repr: <span class="hljs-type">Os</span> &#123; code:<br><span class="hljs-number">2</span>, message: <span class="hljs-string">"No such file or directory"</span> &#125; &#125;<span class="hljs-string">', src/libcore/result.rs:906:4</span><br></code></pre></div></td></tr></table></figure>
<h4 id="传播错误的简写："><a class="header-anchor" href="#传播错误的简写：">¶</a>传播错误的简写：<code>?</code></h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read_username_from_file</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> f = File::open(<span class="hljs-string">"hello.txt"</span>)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::new();<br>    f.read_to_string(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-literal">Ok</span>(s)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果 <code>Result</code> 的值是 <code>Ok</code>，这个表达式将会返回 <code>Ok</code> 中的值而程序将继续执行。如果值是 <code>Err</code>，<code>Err</code> 中的值将作为整个函数的返回值，就好像使用了 return 关键字一样，这样错误值就被传播给了调用者。</p>
<blockquote>
<p><code>?</code> 所使用的错误值被传递给了 from 函数，它定义于标准库的 <code>From</code> trait 中，其用来将错误从一种类型转换为另一种类型。当 <code>?</code> 调用 <code>from</code> 函数时，收到的错误类型被转换为定义为当前函数返回的错误类型。</p>
</blockquote>
<p><code>?</code> 消除了大量样板代码并使得函数的实现更简单。我们甚至可以在 <code>?</code> 之后直接使用链式方法调用来进一步缩短代码，：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::io::Read;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read_username_from_file</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::new();<br><br>    File::open(<span class="hljs-string">"hello.txt"</span>)?.read_to_string(&amp;<span class="hljs-keyword">mut</span> s)?;<br><br>    <span class="hljs-literal">Ok</span>(s)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>甚至还有一个更短的写法：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::fs;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read_username_from_file</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">String</span>, io::Error&gt; &#123;<br>    fs::read_to_string(<span class="hljs-string">"hello.txt"</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>将文件读取到一个字符串是相当常见的操作，所以 Rust 提供了名为 <code>fs::read_to_string</code> 的函数，它会打开文件、新建一个 <code>String</code>、读取文件的内容，并将内容放入 <code>String</code>，接着返回它。当然，这样做就没有展示所有这些错误处理的机会了，所以我们最初就选择了艰苦的道路。</p>
<h4 id="只能被用于返回-Result-的函数"><a class="header-anchor" href="#只能被用于返回-Result-的函数">¶</a><code>?</code> 只能被用于返回 <code>Result</code> 的函数</h4>
<p><code>?</code> 只能被用于返回值类型为 <code>Result</code> 的函数。<br>
在 <code>main</code> 函数中使用 <code>?</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> f = File::open(<span class="hljs-string">"hello.txt"</span>)?;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>会得到如下错误信息：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">error[E0277]: the `?` operator can only be used <span class="hljs-keyword">in</span> a function that returns `<span class="hljs-built_in">Result</span>` or `<span class="hljs-built_in">Option</span>` (or another <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">that</span></span> implements `std::ops::Try`)<br> --&gt; src/main.rs:<span class="hljs-number">4</span>:<span class="hljs-number">13</span><br>  |<br><span class="hljs-number">4</span> |     <span class="hljs-keyword">let</span> f = File::open(<span class="hljs-string">"hello.txt"</span>)?;<br>  |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot <span class="hljs-keyword">use</span> the `?` operator <span class="hljs-keyword">in</span> a function that returns `()`<br>  |<br>  = help: the <span class="hljs-class"><span class="hljs-keyword">trait</span> `<span class="hljs-title">std</span></span>::ops::Try` is not implemented <span class="hljs-keyword">for</span> `()`<br>  = note: required by `std::ops::Try::from_error`<br></code></pre></div></td></tr></table></figure>
<p>不过 <code>main</code> 函数可以返回一个 <code>Result&lt;T, E&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;(), <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> f = File::open(<span class="hljs-string">"hello.txt"</span>)?;<br><br>    <span class="hljs-literal">Ok</span>(())<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="10-泛型、trait-与生命周期"><a class="header-anchor" href="#10-泛型、trait-与生命周期">¶</a>10. 泛型、trait 与生命周期</h2>
<h3 id="10-1-泛型数据类型"><a class="header-anchor" href="#10-1-泛型数据类型">¶</a>10.1 泛型数据类型</h3>
<h4 id="方法定义中的泛型"><a class="header-anchor" href="#方法定义中的泛型">¶</a>方法定义中的泛型</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">x</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.x<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> p = Point &#123; x: <span class="hljs-number">5</span>, y: <span class="hljs-number">10</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"p.x = &#123;&#125;"</span>, p.x());<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>注意必须在 <code>impl</code> 后面声明 <code>T</code>，这样就可以在 <code>Point&lt;T&gt;</code> 上实现的方法中使用它了。在 <code>impl</code> 之后声明泛型 <code>T</code> ，这样 Rust 就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型。</p>
<p>例如，可以选择为 <code>Point&lt;f32&gt;</code> 实例实现方法，而不是为泛型 <code>Point</code> 实例。下面示例展示了一个没有在 <code>impl</code> 之后（的尖括号）声明泛型的例子，这里使用了一个具体类型，<code>f32</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">impl</span> Point&lt;<span class="hljs-built_in">f32</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">distance_from_origin</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">f32</span> &#123;<br>        (<span class="hljs-keyword">self</span>.x.powi(<span class="hljs-number">2</span>) + <span class="hljs-keyword">self</span>.y.powi(<span class="hljs-number">2</span>)).sqrt()<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="10-2-trait：定义共享的行为"><a class="header-anchor" href="#10-2-trait：定义共享的行为">¶</a>10.2 trait：定义共享的行为</h3>
<h4 id="为类型实现-trait"><a class="header-anchor" href="#为类型实现-trait">¶</a>为类型实现 trait</h4>
<blockquote>
<p>实现 trait 时需要注意的是，只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait。例如，可以为多媒体聚合库 crate 的自定义类型 <code>Tweet</code> 实现如标准库中的 <code>Display</code> trait，这是因为 <code>Tweet</code> 类型位于多媒体聚合库 crate 本地的作用域中。类似地，也可以在多媒体聚合库 crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Summary</code>，这是因为 <code>Summary</code> trait 位于多媒体聚合库 crate 本地作用域中。</p>
</blockquote>
<blockquote>
<p>但是不能为外部类型实现外部 trait。例如，不能在多媒体聚合库 crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Display</code> trait。这是因为 <code>Display</code> 和 Vec<T> 都定义于标准库中，它们并不位于多媒体聚合库的 crate 本地作用域中。这个限制是被称为 <strong>相干性</strong>（<em>coherence</em>） 的程序属性的一部分，或者更具体的说是 <strong>孤儿规则</strong>（<em>orphan rule</em>），其得名于不存在父类型。这条规则确保了其他人编写的代码不会破坏你代码，反之亦然。没有这条规则的话，两个 crate 可以分别对相同类型实现相同的 trait，而 Rust 将无从得知应该使用哪一个实现。</p>
</blockquote>
<h4 id="默认实现"><a class="header-anchor" href="#默认实现">¶</a>默认实现</h4>
<p>有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Summary</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">summarize</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span> &#123;<br>        <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"(Read more...)"</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果想要对 <code>NewsArticle</code> 实例使用这个默认实现，而不是定义一个自己的实现，则可以通过 <code>impl Summary for NewsArticle {}</code> 指定一个空的 <code>impl</code> 块。</p>
<blockquote>
<p>注意无法从相同方法的重载实现中调用默认方法。</p>
</blockquote>
<h4 id="trait-作为参数"><a class="header-anchor" href="#trait-作为参数">¶</a>trait 作为参数</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>(item: <span class="hljs-keyword">impl</span> Summary) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Breaking news! &#123;&#125;"</span>, item.summarize());<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在 <code>notify</code> 函数体中，可以调用任何来自 <code>Summary</code> trait 的方法，比如 <code>summarize</code>。</p>
<h5 id="Trait-Bounds"><a class="header-anchor" href="#Trait-Bounds">¶</a>Trait Bounds</h5>
<p><code>impl Trait</code> 语法适用于短小的例子，它不过是一个较长形式的语法糖。这被称为 <em>trait bound</em>，这看起来像：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>&lt;T: Summary&gt;(item: T) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Breaking news! &#123;&#125;"</span>, item.summarize());<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>虽然 <code>impl Trait</code> 适用于短小的例子，trait bound 则适用于更复杂的场景。例如，比如需要获取两个实现了 <code>Summary</code> 的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>(item1: <span class="hljs-keyword">impl</span> Summary, item2: <span class="hljs-keyword">impl</span> Summary) &#123;<br></code></pre></div></td></tr></table></figure>
<p>这适用于 <code>item1</code> 和 <code>item2</code> 允许是不同类型的情况（只要它们都实现了 <code>Summary</code>）。不过如果你希望强制它们都是相同类型呢？这只有在使用 trait bound 时才有可能：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>&lt;T: Summary&gt;(item1: T, item2: T) &#123;<br></code></pre></div></td></tr></table></figure>
<h5 id="通过-指定多个-trait"><a class="header-anchor" href="#通过-指定多个-trait">¶</a>通过 <code>+</code> 指定多个 trait</h5>
<p>如果 <code>notify</code> 需要显示 <code>item</code> 的格式化形式，同时也要使用 <code>summarize</code> 方法，那么 <code>item</code> 就需要同时实现两个不同的 trait：<code>Display</code> 和 <code>Summary</code>。这可以通过 <code>+</code> 语法实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>(item: <span class="hljs-keyword">impl</span> Summary + Display) &#123;<br></code></pre></div></td></tr></table></figure>
<p>这个语法也适用于泛型的 trait bound：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>&lt;T: Summary + Display&gt;(item: T) &#123;<br></code></pre></div></td></tr></table></figure>
<h5 id="通过-where-简化代码"><a class="header-anchor" href="#通过-where-简化代码">¶</a>通过 <code>where</code> 简化代码</h5>
<p>Rust 有另一个在函数签名之后的 <code>where</code> 从句中指定 trait bound 的语法。所以除了这么写：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">some_function</span></span>&lt;T: Display + <span class="hljs-built_in">Clone</span>, U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span>&gt;(t: T, u: U) -&gt; <span class="hljs-built_in">i32</span> &#123;<br></code></pre></div></td></tr></table></figure>
<p>还可以像这样使用 <code>where</code> 从句：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">some_function</span></span>&lt;T, U&gt;(t: T, u: U) -&gt; <span class="hljs-built_in">i32</span><br>    <span class="hljs-keyword">where</span> T: Display + <span class="hljs-built_in">Clone</span>,<br>          U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span><br>&#123;<br></code></pre></div></td></tr></table></figure>
<h4 id="返回-trait"><a class="header-anchor" href="#返回-trait">¶</a>返回 trait</h4>
<p>也可以在返回值中使用 impl Trait 语法，来返回实现了某个 trait 的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">returns_summarizable</span></span>() -&gt; <span class="hljs-keyword">impl</span> Summary &#123;<br>    Tweet &#123;<br>        username: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"horse_ebooks"</span>),<br>        content: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"of course, as you probably already know, people"</span>),<br>        reply: <span class="hljs-literal">false</span>,<br>        retweet: <span class="hljs-literal">false</span>,<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>不过这只适用于返回 <strong>单一类型</strong> 的情况。例如，这样就 <strong>不行</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">returns_summarizable</span></span>(switch: <span class="hljs-built_in">bool</span>) -&gt; <span class="hljs-keyword">impl</span> Summary &#123;<br>    <span class="hljs-keyword">if</span> switch &#123;<br>        NewsArticle &#123;<br>            headline: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Penguins win the Stanley Cup Championship!"</span>),<br>            location: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Pittsburgh, PA, USA"</span>),<br>            author: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Iceburgh"</span>),<br>            content: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"The Pittsburgh Penguins once again are the best</span><br><span class="hljs-string">            hockey team in the NHL."</span>),<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Tweet &#123;<br>            username: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"horse_ebooks"</span>),<br>            content: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"of course, as you probably already know, people"</span>),<br>            reply: <span class="hljs-literal">false</span>,<br>            retweet: <span class="hljs-literal">false</span>,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="使用-trait-bound-有条件地实现方法"><a class="header-anchor" href="#使用-trait-bound-有条件地实现方法">¶</a>使用 trait bound 有条件地实现方法</h4>
<p>下面示例中的类型 <code>Pair&lt;T&gt;</code> 总是实现了 <code>new</code> 方法，不过只有那些为 <code>T</code> 类型实现了 <code>PartialOrd</code> trait （来允许比较） 和 <code>Display</code> trait （来启用打印）的 <code>Pair&lt;T&gt;</code> 才会实现 <code>cmp_display</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pair</span></span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(x: T, y: T) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            x,<br>            y,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: Display + <span class="hljs-built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cmp_display</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.x &gt;= <span class="hljs-keyword">self</span>.y &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"The largest member is x = &#123;&#125;"</span>, <span class="hljs-keyword">self</span>.x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"The largest member is y = &#123;&#125;"</span>, <span class="hljs-keyword">self</span>.y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>也可以对任何实现了特定 trait 的类型有条件地实现 trait。例如，标准库为任何实现了 <code>Display</code> trait 的类型实现了 <code>ToString</code> trait。这个 <code>impl</code> 块看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">impl</span>&lt;T: Display&gt; <span class="hljs-built_in">ToString</span> <span class="hljs-keyword">for</span> T &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>对任何满足特定 trait bound 的类型实现 trait 被称为 <em>blanket implementations</em>。</p>
</blockquote>
<h3 id="10-3-生命周期与引用有效期"><a class="header-anchor" href="#10-3-生命周期与引用有效期">¶</a>10.3 生命周期与引用有效期</h3>
<h4 id="生命周期省略（Lifetime-Elision）"><a class="header-anchor" href="#生命周期省略（Lifetime-Elision）">¶</a>生命周期省略（Lifetime Elision）</h4>
<p>函数或方法的参数的生命周期被称为 <strong>输入生命周期</strong>（<em>input lifetimes</em>），而返回值的生命周期被称为 <strong>输出生命周期</strong>（<em>output lifetimes</em>）。</p>
<p>编译器采用三条规则来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误：</p>
<ol>
<li>每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>，有两个引用参数的函数有两个不同的生命周期参数，<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>，依此类推。</li>
<li>如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>。</li>
<li>如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那么 <code>self</code> 的生命周期被赋给所有输出生命周期参数。这使得方法更容易读写，因为只需更少的符号。</li>
</ol>
<h4 id="方法定义中的生命周期注解"><a class="header-anchor" href="#方法定义中的生命周期注解">¶</a>方法定义中的生命周期注解</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">'a</span>&gt; ImportantExcerpt&lt;<span class="hljs-symbol">'a</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">level</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">i32</span> &#123;<br>        <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>impl</code> 之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注 <code>self</code> 引用的生命周期。</p>
<h4 id="静态生命同期"><a class="header-anchor" href="#静态生命同期">¶</a>静态生命同期</h4>
<p>这里有一种特殊的生命周期值得讨论：<code>'static</code>，其生命周期存活于整个程序期间。所有的字符串字面值都拥有 <code>'static</code> 生命周期，我们也可以选择像下面这样标注出来：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> s: &amp;<span class="hljs-symbol">'static</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">"I have a static lifetime."</span>;<br></code></pre></div></td></tr></table></figure>
<h4 id="结合泛型类型参数、trait-bounds-和生命周期"><a class="header-anchor" href="#结合泛型类型参数、trait-bounds-和生命周期">¶</a>结合泛型类型参数、trait bounds 和生命周期</h4>
<p>让我们简要的看一下在同一函数中指定泛型类型参数、trait bounds 和生命周期的语法！</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">longest_with_an_announcement</span></span>&lt;<span class="hljs-symbol">'a</span>, T&gt;(x: &amp;<span class="hljs-symbol">'a</span> <span class="hljs-built_in">str</span>, y: &amp;<span class="hljs-symbol">'a</span> <span class="hljs-built_in">str</span>, ann: T) -&gt; &amp;<span class="hljs-symbol">'a</span> <span class="hljs-built_in">str</span><br>    <span class="hljs-keyword">where</span> T: Display<br>&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Announcement! &#123;&#125;"</span>, ann);<br>    <span class="hljs-keyword">if</span> x.len() &gt; y.len() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这个是示例中那个返回两个字符串 slice 中较长者的 <code>longest</code> 函数，不过带有一个额外的参数 <code>ann</code>。<code>ann </code>的类型是泛型 <code>T</code>，它可以被放入任何实现了 <code>where</code> 从句中指定的 <code>Display</code> trait 的类型。这个额外的参数会在函数比较字符串 slice 的长度之前被打印出来，这也就是为什么 <code>Display</code> trait bound 是必须的。因为生命周期也是泛型，所以生命周期参数 <code>'a</code> 和泛型类型参数 <code>T</code> 都位于函数名后的同一尖括号列表中。</p>
<h2 id="11-测试"><a class="header-anchor" href="#11-测试">¶</a>11. 测试</h2>
<h3 id="11-1-编写测试"><a class="header-anchor" href="#11-1-编写测试">¶</a>11.1. 编写测试</h3>
<p>Rust 中的测试函数是用来验证非测试代码是否按照期望的方式运行的。测试函数体通常执行如下三种操作：</p>
<ol>
<li>设置任何所需的数据或状态</li>
<li>运行需要测试的代码</li>
<li>断言其结果是我们所期望的</li>
</ol>
<h4 id="测试函数剖析"><a class="header-anchor" href="#测试函数剖析">¶</a>测试函数剖析</h4>
<p>我们创建一个新的库项目 <code>adder</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cargo new adder --lib<br>     Created library `adder` project<br>$ <span class="hljs-built_in">cd</span> adder<br></code></pre></div></td></tr></table></figure>
<p>由 cargo new 自动生成的测试模块和函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">it_works</span></span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">2</span> + <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="自定义失败信息"><a class="header-anchor" href="#自定义失败信息">¶</a>自定义失败信息</h4>
<p>让我们为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 greeting 函数的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">greeting_contains_name</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> result = greeting(<span class="hljs-string">"Carol"</span>);<br>    <span class="hljs-built_in">assert!</span>(<br>        result.contains(<span class="hljs-string">"Carol"</span>),<br>        <span class="hljs-string">"Greeting did not contain name, value was `&#123;&#125;`"</span>, result<br>    );<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="使用-should-panic-检查-panic"><a class="header-anchor" href="#使用-should-panic-检查-panic">¶</a>使用 <code>should_panic</code> 检查 panic</h4>
<p>下面示例展示了一个检查 Guess::new 是否按照我们的期望出错的测试：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Guess</span></span> &#123;<br>    value: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Guess &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(value: <span class="hljs-built_in">i32</span>) -&gt; Guess &#123;<br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">1</span> || value &gt; <span class="hljs-number">100</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"Guess value must be between 1 and 100, got &#123;&#125;."</span>, value);<br>        &#125;<br><br>        Guess &#123;<br>            value<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[should_panic]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">greater_than_100</span></span>() &#123;<br>        Guess::new(<span class="hljs-number">200</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>#[should_panic]</code> 属性位于 <code>#[test]</code> 之后，对应的测试函数之前。<br>
一个会带有特定错误信息的 <code>panic!</code> 条件的测试：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">impl</span> Guess &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(value: <span class="hljs-built_in">i32</span>) -&gt; Guess &#123;<br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"Guess value must be greater than or equal to 1, got &#123;&#125;."</span>,<br>                   value);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">100</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"Guess value must be less than or equal to 100, got &#123;&#125;."</span>,<br>                   value);<br>        &#125;<br><br>        Guess &#123;<br>            value<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[should_panic(expected = <span class="hljs-meta-string">"Guess value must be less than or equal to 100"</span>)]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">greater_than_100</span></span>() &#123;<br>        Guess::new(<span class="hljs-number">200</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="将-Result-T-E-用于测试"><a class="header-anchor" href="#将-Result-T-E-用于测试">¶</a>将 Result&lt;T, E&gt; 用于测试</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">it_works</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;(), <span class="hljs-built_in">String</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span> == <span class="hljs-number">4</span> &#123;<br>            <span class="hljs-literal">Ok</span>(())<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-literal">Err</span>(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"two plus two does not equal four"</span>))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这里我们将 <code>it\_works</code> 改为返回 Result。同时在函数体中，在成功时返回 <code>Ok(())</code> 而不是 <code>assert_eq!</code>，而失败时返回带有 <code>String</code> 的 <code>Err</code>。跟之前一样，这个测试可能成功或失败，不过不再通过 panic，可以通过 <code>Result&lt;T, E&gt;</code> 来判断结果。为此不能在对这些函数使用 <code>#[should_panic]</code>；而是应该返回 <code>Err</code>！</p>
<h3 id="11-2-运行测试"><a class="header-anchor" href="#11-2-运行测试">¶</a>11.2 运行测试</h3>
<h4 id="并行或连续的运行测试"><a class="header-anchor" href="#并行或连续的运行测试">¶</a>并行或连续的运行测试</h4>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cargo <span class="hljs-built_in">test</span> -- --<span class="hljs-built_in">test</span>-threads=1<br></code></pre></div></td></tr></table></figure>
<p>这里将测试线程设置为 <code>1</code>，告诉程序不要使用任何并行机制。这也会比并行运行花费更多时间，不过在有共享的状态时，测试就不会潜在的相互干扰了。</p>
<h4 id="显示函数输出"><a class="header-anchor" href="#显示函数输出">¶</a>显示函数输出</h4>
<p>默认情况下，当测试通过时，Rust 的测试库会截获打印到标准输出的所有内容。比如在测试中调用了 <code>println!</code> 而测试通过了，我们将不会在终端看到 <code>println!</code> 的输出：只会看到说明测试通过的提示行。如果测试失败了，则会看到所有标准输出和其他错误信息：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">prints_and_returns_10</span></span>(a: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"I got the value &#123;&#125;"</span>, a);<br>    <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">this_test_will_pass</span></span>() &#123;<br>        <span class="hljs-keyword">let</span> value = prints_and_returns_10(<span class="hljs-number">4</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">10</span>, value);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">this_test_will_fail</span></span>() &#123;<br>        <span class="hljs-keyword">let</span> value = prints_and_returns_10(<span class="hljs-number">8</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, value);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>运行 cargo test 将会看到这些测试的输出：</p>
<figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">running 2 tests<br><span class="hljs-keyword">test test</span>s::this_test_will_pass ... ok<br><span class="hljs-keyword">test test</span>s::this_test_will_fail ... FAILED<br><br>failures:<br><br>---- tests::this_test_will_fail stdout ----<br>        I got the value 8<br>thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`<br>  left: `5`,<br> right: `10`', src/lib.rs:19:8<br>note: Run with `RUST_BACKTRACE=1` for a backtrace.<br><br>failures:<br>    tests::this_test_will_fail<br><br><span class="hljs-keyword">test </span>result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out<br></code></pre></div></td></tr></table></figure>
<h4 id="通过指定名字来运行部分测试"><a class="header-anchor" href="#通过指定名字来运行部分测试">¶</a>通过指定名字来运行部分测试</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add_two</span></span>(a: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> &#123;<br>    a + <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add_two_and_two</span></span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">4</span>, add_two(<span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add_three_and_two</span></span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, add_two(<span class="hljs-number">3</span>));<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">one_hundred</span></span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">102</span>, add_two(<span class="hljs-number">100</span>));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h5 id="运行单个测试"><a class="header-anchor" href="#运行单个测试">¶</a>运行单个测试</h5>
<p>可以向 <code>cargo test</code> 传递任意测试的名称来只运行这个测试：</p>
<figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">$ cargo test one_hundred<br>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br>     Running target/debug/deps/adder<span class="hljs-string">-06</span>a75b4a1f2515e9<br><br>running 1 test<br><span class="hljs-keyword">test test</span>s::one_hundred ... ok<br><br><span class="hljs-keyword">test </span>result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out<br></code></pre></div></td></tr></table></figure>
<h5 id="过滤运行多个测试"><a class="header-anchor" href="#过滤运行多个测试">¶</a>过滤运行多个测试</h5>
<p>我们可以指定部分测试的名称，任何名称匹配这个名称的测试会被运行。例如，因为头两个测试的名称包含 <code>add</code>，可以通过 <code>cargo test add</code> 来运行这两个测试：</p>
<figure class="highlight subunit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs subunit">$ cargo test add<br>    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs<br>     Running target/debug/deps/adder<span class="hljs-string">-06</span>a75b4a1f2515e9<br><br>running 2 tests<br><span class="hljs-keyword">test test</span>s::add_two_and_two ... ok<br><span class="hljs-keyword">test test</span>s::add_three_and_two ... ok<br><br><span class="hljs-keyword">test </span>result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out<br></code></pre></div></td></tr></table></figure>
<p>这运行了所有名字中带有 <code>add</code> 的测试，也过滤掉了名为 <code>one_hundred</code> 的测试。</p>
<blockquote>
<p><strong>同时注意测试所在的模块也是测试名称的一部分，所以可以通过模块名来运行一个模块中的所有测试。</strong></p>
</blockquote>
<h4 id="忽略某些测试"><a class="header-anchor" href="#忽略某些测试">¶</a>忽略某些测试</h4>
<p>对于想要排除的测试，我们在 <code>#[test]</code> 之后增加了 <code>#[ignore]</code> 行：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">it_works</span></span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">2</span> + <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-meta">#[ignore]</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">expensive_test</span></span>() &#123;<br>    <span class="hljs-comment">// code that takes an hour to run</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>如果我们只希望运行被忽略的测试，可以使用 <code>cargo test -- --ignored</code>。</p>
</blockquote>
<h3 id="11-3-测试的组织结构"><a class="header-anchor" href="#11-3-测试的组织结构">¶</a>11.3 测试的组织结构</h3>
<h4 id="单元测试"><a class="header-anchor" href="#单元测试">¶</a>单元测试</h4>
<h5 id="测试模块和-cfg-test"><a class="header-anchor" href="#测试模块和-cfg-test">¶</a>测试模块和 <code>cfg(test)</code></h5>
<p>测试模块的 <code>#[cfg(test)]</code> 注解告诉 Rust 只在执行 <code>cargo test</code> 时才编译和运行测试代码，而在运行 <code>cargo build</code> 时不这么做。</p>
<blockquote>
<p>与之对应的集成测试因为位于另一个文件夹，所以它们并不需要 <code>#[cfg(test)]</code> 注解。</p>
</blockquote>
<h5 id="测试私有函数"><a class="header-anchor" href="#测试私有函数">¶</a>测试私有函数</h5>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add_two</span></span>(a: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> &#123;<br>    internal_adder(a, <span class="hljs-number">2</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">internal_adder</span></span>(a: <span class="hljs-built_in">i32</span>, b: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> &#123;<br>    a + b<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">internal</span></span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">4</span>, internal_adder(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>));<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>注意 <code>internal_adder</code> 函数并没有标记为 <code>pub</code>，不过因为测试也不过是 Rust 代码同时 <code>tests</code> 也仅仅是另一个模块，我们完全可以在测试中导入和调用 <code>internal_adder</code>。</p>
<h4 id="集成测试"><a class="header-anchor" href="#集成测试">¶</a>集成测试</h4>
<p>在 Rust 中，集成测试对于你需要测试的库来说完全是外部的。同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 API 。为了创建集成测试，你需要先创建一个 <em>tests</em> 目录。</p>
<h5 id="tests-目录"><a class="header-anchor" href="#tests-目录">¶</a><em>tests</em> 目录</h5>
<p>为了编写集成测试，需要在项目根目录创建一个 <em>tests</em> 目录，与 <em>src</em> 同级。Cargo 知道如何去寻找这个目录中的集成测试文件。接着可以随意在这个目录中创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译。</p>
<p>创建一个 <em>tests</em> 目录，新建一个文件 <em>tests/integration_test.rs</em>。一个 <code>adder</code> crate 中函数的集成测试：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> adder;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">it_adds_two</span></span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">4</span>, adder::add_two(<span class="hljs-number">2</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>与单元测试不同，我们需要在文件顶部添加 <code>use adder</code>。这是因为每一个 <em>tests</em> 目录中的测试文件都是完全独立的 crate，所以需要在每一个文件中导入库。</p>
<h2 id="12-一个I-O项目：构建命令行程序"><a class="header-anchor" href="#12-一个I-O项目：构建命令行程序">¶</a>12. 一个I/O项目：构建命令行程序</h2>
<h3 id="12-1-接受命令行参数"><a class="header-anchor" href="#12-1-接受命令行参数">¶</a>12.1. 接受命令行参数</h3>
<h4 id="读取参数"><a class="header-anchor" href="#读取参数">¶</a>读取参数</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::env;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> args: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt; = env::args().collect();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;:?&#125;"</span>, args);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong><code>args</code> 函数和无效的 Unicode</strong><br>
注意 <code>std::env::args</code> 在其任何参数包含无效 Unicode 字符时会 panic。如果你需要接受包含无效 Unicode 字符的参数，使用 <code>std::env::args_os</code> 代替。这个函数返回 <code>OsString</code> 值而不是 <code>String</code> 值。这里出于简单考虑使用了 <code>std::env::args</code>，因为 <code>OsString</code> 值每个平台都不一样而且比 <code>String</code> 值处理起来更为复杂。</p>
</blockquote>
<h4 id="将参数保存进变量"><a class="header-anchor" href="#将参数保存进变量">¶</a>将参数保存进变量</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::env;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> args: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt; = env::args().collect();<br><br>    <span class="hljs-keyword">let</span> query = &amp;args[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> filename = &amp;args[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Searching for &#123;&#125;"</span>, query);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"In file &#123;&#125;"</span>, filename);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="12-2-读取文件"><a class="header-anchor" href="#12-2-读取文件">¶</a>12.2. 读取文件</h3>
<p>poem.txt：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">I&#39;m nobody! Who are you?<br>Are you nobody, too?<br>Then there&#39;s a pair of us - don&#39;t tell!<br>They&#39;d banish us, you know.<br><br>How dreary to be somebody!<br>How public, like a frog<br>To tell your name the livelong day<br>To an admiring bog!<br></code></pre></div></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::env;<br><span class="hljs-keyword">use</span> std::fs;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> args: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt; = env::args().collect();<br><br>    <span class="hljs-keyword">let</span> query = &amp;args[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> filename = &amp;args[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Searching for &#123;&#125;"</span>, query);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"In file &#123;&#125;"</span>, filename);<br><br>    <span class="hljs-keyword">let</span> contents = fs::read_to_string(filename)<br>        .expect(<span class="hljs-string">"Something went wrong reading the file"</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"With text:\n&#123;&#125;"</span>, contents);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="12-3-重构以改进模块化错误处理"><a class="header-anchor" href="#12-3-重构以改进模块化错误处理">¶</a>12.3. 重构以改进模块化错误处理</h3>
<h4 id="二进制项目的关注分离"><a class="header-anchor" href="#二进制项目的关注分离">¶</a>二进制项目的关注分离</h4>
<p><code>main</code> 函数负责多个任务的组织问题在许多二进制项目中很常见。所以 Rust 社区开发出一类在 <code>main</code> 函数开始变得庞大时进行二进制程序的关注分离的指导性过程。这些过程有如下步骤：</p>
<ol>
<li>将程序拆分成 <em><a href="http://main.rs" target="_blank" rel="noopener">main.rs</a></em> 和 <em><a href="http://lib.rs" target="_blank" rel="noopener">lib.rs</a></em> 并将程序的逻辑放入 <em><a href="http://lib.rs" target="_blank" rel="noopener">lib.rs</a></em> 中。</li>
<li>当命令行解析逻辑比较小时，可以保留在 <em><a href="http://main.rs" target="_blank" rel="noopener">main.rs</a></em> 中。</li>
<li>当命令行解析开始变得复杂时，也同样将其从 <em><a href="http://main.rs" target="_blank" rel="noopener">main.rs</a></em> 提取到 <em><a href="http://lib.rs" target="_blank" rel="noopener">lib.rs</a></em> 中。</li>
<li>经过这些过程之后保留在 <code>main</code> 函数中的责任应该被限制为：
<ul>
<li>使用参数值调用命令行解析逻辑</li>
<li>设置任何其他的配置</li>
<li>调用 <em><a href="http://lib.rs" target="_blank" rel="noopener">lib.rs</a></em> 中的 <code>run</code> 函数</li>
<li>如果 <code>run</code> 返回错误，则处理这个错误</li>
</ul>
</li>
</ol>
<h4 id="提取参数解析器"><a class="header-anchor" href="#提取参数解析器">¶</a>提取参数解析器</h4>
<p>从 <code>main</code> 中提取出 <code>parse_config</code> 函数:</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> args: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt; = env::args().collect();<br><br>    <span class="hljs-keyword">let</span> (query, filename) = parse_config(&amp;args);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Searching for &#123;&#125;"</span>, query);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"In file &#123;&#125;"</span>, filename);<br><br>    <span class="hljs-keyword">let</span> contents = fs::read_to_string(filename)<br>        .expect(<span class="hljs-string">"Something went wrong reading the file"</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"With text:\n&#123;&#125;"</span>, contents);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse_config</span></span>(args: &amp;[<span class="hljs-built_in">String</span>]) -&gt; (&amp;<span class="hljs-built_in">str</span>, &amp;<span class="hljs-built_in">str</span>) &#123;<br>    <span class="hljs-keyword">let</span> query = &amp;args[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> filename = &amp;args[<span class="hljs-number">2</span>];<br><br>    (query, filename)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="组合配置值"><a class="header-anchor" href="#组合配置值">¶</a>组合配置值</h4>
<blockquote>
<p>将在复杂类型更为合适的场景下使用基本类型的反模式称为 <strong>基本类型偏执</strong>（<em>primitive obsession</em>）。</p>
</blockquote>
<p>下面示例展示了新定义的结构体 <code>Config</code>，它有字段 <code>query</code> 和 <code>filename</code>。我们也改变了 <code>parse_config</code> 函数来返回一个 <code>Config</code> 结构体的实例，并更新 <code>main</code> 来使用结构体字段而不是单独的变量：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> args: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt; = env::args().collect();<br><br>    <span class="hljs-keyword">let</span> config = parse_config(&amp;args);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Searching for &#123;&#125;"</span>, config.query);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"In file &#123;&#125;"</span>, config.filename);<br><br>    <span class="hljs-keyword">let</span> contents = fs::read_to_string(config.filename)<br>        .expect(<span class="hljs-string">"Something went wrong reading the file"</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"With text:\n&#123;&#125;"</span>, contents);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Config</span></span> &#123;<br>    query: <span class="hljs-built_in">String</span>,<br>    filename: <span class="hljs-built_in">String</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse_config</span></span>(args: &amp;[<span class="hljs-built_in">String</span>]) -&gt; Config &#123;<br>    <span class="hljs-keyword">let</span> query = args[<span class="hljs-number">1</span>].clone();<br>    <span class="hljs-keyword">let</span> filename = args[<span class="hljs-number">2</span>].clone();<br><br>    Config &#123; query, filename &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>parse_config</code> 的签名表明它现在返回一个 <code>Config</code> 值。在之前的 <code>parse_config</code> 函数体中，我们返回了引用 <code>args</code> 中 <code>String</code> 值的字符串 slice，现在我们定义 <code>Config</code>来包含拥有所有权的 <code>String</code> 值。<code>main</code> 中的 <code>args</code> 变量是参数值的所有者并只允许 <code>parse_config</code> 函数借用他们，这意味着如果 <code>Config</code> 尝试获取 <code>args</code> 中值的所有权将违反 Rust 的借用规则。</p>
<h4 id="创建一个-Config-构造函数"><a class="header-anchor" href="#创建一个-Config-构造函数">¶</a>创建一个 Config 构造函数</h4>
<p>将 <code>parse_config</code> 变为 <code>Config::new</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> args: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt; = env::args().collect();<br><br>    <span class="hljs-keyword">let</span> config = Config::new(&amp;args);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Searching for &#123;&#125;"</span>, config.query);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"In file &#123;&#125;"</span>, config.filename);<br><br>    <span class="hljs-keyword">let</span> contents = fs::read_to_string(config.filename)<br>        .expect(<span class="hljs-string">"Something went wrong reading the file"</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"With text:\n&#123;&#125;"</span>, contents);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Config</span></span> &#123;<br>    query: <span class="hljs-built_in">String</span>,<br>    filename: <span class="hljs-built_in">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Config &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(args: &amp;[<span class="hljs-built_in">String</span>]) -&gt; Config &#123;<br>        <span class="hljs-keyword">let</span> query = args[<span class="hljs-number">1</span>].clone();<br>        <span class="hljs-keyword">let</span> filename = args[<span class="hljs-number">2</span>].clone();<br><br>        Config &#123; query, filename &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="修复错误处理"><a class="header-anchor" href="#修复错误处理">¶</a>修复错误处理</h4>
<h5 id="改善错误信息"><a class="header-anchor" href="#改善错误信息">¶</a>改善错误信息</h5>
<p>增加一个参数数量检查：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-comment">// --snip--</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(args: &amp;[<span class="hljs-built_in">String</span>]) -&gt; Config &#123;<br>    <span class="hljs-keyword">if</span> args.len() &lt; <span class="hljs-number">3</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"not enough arguments"</span>);<br>    &#125;<br>    <span class="hljs-comment">// --snip--</span><br></code></pre></div></td></tr></table></figure>
<h5 id="从-new-中返回-Result-而不是调用-panic"><a class="header-anchor" href="#从-new-中返回-Result-而不是调用-panic">¶</a>从 <code>new</code> 中返回 <code>Result</code> 而不是调用 <code>panic!</code></h5>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">impl</span> Config &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(args: &amp;[<span class="hljs-built_in">String</span>]) -&gt; <span class="hljs-built_in">Result</span>&lt;Config, &amp;<span class="hljs-symbol">'static</span> <span class="hljs-built_in">str</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> args.len() &lt; <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(<span class="hljs-string">"not enough arguments"</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">let</span> query = args[<span class="hljs-number">1</span>].clone();<br>        <span class="hljs-keyword">let</span> filename = args[<span class="hljs-number">2</span>].clone();<br><br>        <span class="hljs-literal">Ok</span>(Config &#123; query, filename &#125;)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h5 id="Config-new-调用并处理错误"><a class="header-anchor" href="#Config-new-调用并处理错误">¶</a><code>Config::new</code> 调用并处理错误</h5>
<p>如果新建 <code>Config</code> 失败则使用错误码退出：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::process;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> args: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt; = env::args().collect();<br><br>    <span class="hljs-keyword">let</span> config = Config::new(&amp;args).unwrap_or_else(|err| &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Problem parsing arguments: &#123;&#125;"</span>, err);<br>        process::exit(<span class="hljs-number">1</span>);<br>    &#125;);<br><br>    <span class="hljs-comment">// --snip--</span><br></code></pre></div></td></tr></table></figure>
<h4 id="从-main-提取逻辑"><a class="header-anchor" href="#从-main-提取逻辑">¶</a>从 <code>main</code> 提取逻辑</h4>
<p>下面示例展示了提取出来的 <code>run</code> 函数。目前我们只进行小的增量式的提取函数的改进：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// --snip--</span><br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Searching for &#123;&#125;"</span>, config.query);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"In file &#123;&#125;"</span>, config.filename);<br><br>    run(config);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">run</span></span>(config: Config) &#123;<br>    <span class="hljs-keyword">let</span> contents = fs::read_to_string(config.filename)<br>        .expect(<span class="hljs-string">"something went wrong reading the file"</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"With text:\n&#123;&#125;"</span>, contents);<br>&#125;<br><br><span class="hljs-comment">// --snip--</span><br></code></pre></div></td></tr></table></figure>
<h5 id="从-run-函数中返回错误"><a class="header-anchor" href="#从-run-函数中返回错误">¶</a>从 <code>run</code> 函数中返回错误</h5>
<p>下面示例展示了 run 签名和函数体中的改变：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::error::Error;<br><br><span class="hljs-comment">// --snip--</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">run</span></span>(config: Config) -&gt; <span class="hljs-built_in">Result</span>&lt;(), <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> contents = fs::read_to_string(config.filename)?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"With text:\n&#123;&#125;"</span>, contents);<br><br>    <span class="hljs-literal">Ok</span>(())<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这里我们做出了三个明显的修改：</p>
<ol>
<li>将 <code>run</code> 函数的返回类型变为 R<code>esult&lt;(), Box&lt;Error&gt;&gt;</code>。之前这个函数返回 unit 类型 <code>()</code>，现在它仍然保持作为 <code>Ok</code> 时的返回值。<br>
对于错误类型，使用了 trait 对象 <code>Box&lt;dyn Error&gt;</code>（在开头使用了 <code>use</code> 语句将 <code>std::error::Error</code> 引入作用域）。目前只需知道 <code>Box&lt;dyn Error&gt;</code> 意味着函数会返回实现了 <code>Error</code> trait 的类型，不过无需指定具体将会返回的值的类型。这提供了在不同的错误场景可能有不同类型的错误返回值的灵活性。这也就是 <code>dyn</code>，它是 “动态的”（“dynamic”）的缩写。</li>
<li>第二个改变是去掉了 <code>expect</code> 调用并替换为第九章讲到的 <code>?</code>。不同于遇到错误就 <code>panic!</code>，<code>?</code> 会从函数中返回错误值并让调用者来处理它。</li>
<li>第三个修改是现在成功时这个函数会返回一个 <code>Ok</code> 值。因为 <code>run</code> 函数签名中声明成功类型返回值是 <code>()</code>，这意味着需要将 unit 类型值包装进 <code>Ok</code> 值中。<code>Ok(())</code> 一开始看起来有点奇怪，不过这样使用 <code>()</code> 是表明我们调用 <code>run</code> 只是为了它的副作用的惯用方式；它并没有返回什么有意义的值。</li>
</ol>
<h5 id="处理-main-中-run-返回的错误"><a class="header-anchor" href="#处理-main-中-run-返回的错误">¶</a>处理 <code>main</code> 中 <code>run</code> 返回的错误</h5>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// --snip--</span><br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Searching for &#123;&#125;"</span>, config.query);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"In file &#123;&#125;"</span>, config.filename);<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Err</span>(e) = run(config) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Application error: &#123;&#125;"</span>, e);<br><br>        process::exit(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>我们只关心检测错误，所以并不需要 <code>unwrap_or_else</code> 来返回未封装的值，因为它只会是 <code>()</code>。</p>
<h4 id="将代码拆分到库-crate"><a class="header-anchor" href="#将代码拆分到库-crate">¶</a>将代码拆分到库 crate</h4>
<p>让我们将所有不是 <code>main</code> 函数的代码从 <em>src/main.rs</em> 移动到新文件 <em>src/lib.rs</em> 中：</p>
<ul>
<li><code>run</code> 函数定义</li>
<li>相关的 <code>use</code> 语句</li>
<li><code>Config</code> 的定义</li>
<li><code>Config::new</code> 函数定义</li>
</ul>
<p>现在代码还不能编译：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> std::fs;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Config</span></span> &#123;<br>    <span class="hljs-keyword">pub</span> query: <span class="hljs-built_in">String</span>,<br>    <span class="hljs-keyword">pub</span> filename: <span class="hljs-built_in">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Config &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(args: &amp;[<span class="hljs-built_in">String</span>]) -&gt; <span class="hljs-built_in">Result</span>&lt;Config, &amp;<span class="hljs-symbol">'static</span> <span class="hljs-built_in">str</span>&gt; &#123;<br>        <span class="hljs-comment">// --snip--</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">run</span></span>(config: Config) -&gt; <span class="hljs-built_in">Result</span>&lt;(), <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>将 <code>minigrep</code> crate 引入 <em>src/main.rs</em> 的作用域中：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> std::env;<br><span class="hljs-keyword">use</span> std::process;<br><br><span class="hljs-keyword">use</span> minigrep;<br><span class="hljs-keyword">use</span> minigrep::Config;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// --snip--</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Err</span>(e) = minigrep::run(config) &#123;<br>        <span class="hljs-comment">// --snip--</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="12-6-将错误信息输出到标准错误而不是标准输出"><a class="header-anchor" href="#12-6-将错误信息输出到标准错误而不是标准输出">¶</a>12.6. 将错误信息输出到标准错误而不是标准输出</h3>
<h4 id="将错误打印到标准错误"><a class="header-anchor" href="#将错误打印到标准错误">¶</a>将错误打印到标准错误</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> args: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt; = env::args().collect();<br><br>    <span class="hljs-keyword">let</span> config = Config::new(&amp;args).unwrap_or_else(|err| &#123;<br>        eprintln!(<span class="hljs-string">"Problem parsing arguments: &#123;&#125;"</span>, err);<br>        process::exit(<span class="hljs-number">1</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Err</span>(e) = minigrep::run(config) &#123;<br>        eprintln!(<span class="hljs-string">"Application error: &#123;&#125;"</span>, e);<br><br>        process::exit(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>将 <code>println!</code> 改为 <code>eprintln!</code> 之后，让我们再次尝试用同样的方式运行程序，不使用任何参数并通过 <code>&gt;</code> 重定向标准输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cargo run &gt; output.txt<br>Problem parsing arguments: not enough arguments<br></code></pre></div></td></tr></table></figure>
<p>现在我们看到了屏幕上的错误信息，同时 <em>output.txt</em> 里什么也没有，这正是命令行程序所期望的行为。<br>
如果使用不会造成错误的参数再次运行程序，不过仍然将标准输出重定向到一个文件，像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cargo run to poem.txt &gt; output.txt<br></code></pre></div></td></tr></table></figure>
<p>我们并不会在终端看到任何输出，同时 <em>output.txt</em> 将会包含其结果：</p>
<figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">Are</span> <span class="hljs-string">you nobody, too?</span><br><span class="hljs-attr">How</span> <span class="hljs-string">dreary to be somebody!</span><br></code></pre></div></td></tr></table></figure>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 程序设计语言学习笔记（一）</title>
    <url>/2019/02/23/Rust-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1>Rust 程序设计语言学习笔记（一）</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="1-入门指南"><a class="header-anchor" href="#1-入门指南">¶</a>1. 入门指南</h2>
<h3 id="1-3-Hello-Cargo"><a class="header-anchor" href="#1-3-Hello-Cargo">¶</a>1.3 Hello, Cargo!</h3>
<h4 id="使用Cargo创建项目"><a class="header-anchor" href="#使用Cargo创建项目">¶</a>使用Cargo创建项目</h4>
<p>我们使用 Cargo 创建一个新项目，然后看看与上面的 Hello, world! 项目有什么不同。回到 <em>projects</em> 目录（或者你存放代码的目录）。接着，可在任何操作系统下运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cargo new hello_cargo<br>$ <span class="hljs-built_in">cd</span> hello_cargo<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>注意：Git 是一个常用的版本控制系统（version control system， VCS）。可以通过 <code>--vcs</code> 参数使 <code>cargo new</code> 切换到其它版本控制系统（VCS），或者不使用 VCS。运行 <code>cargo new --help</code> 参看可用的选项。</p>
</blockquote>
<p>第一行命令新建了名为 <em>hello_cargo</em> 的目录。我们将项目命名为 <em>hello_cargo</em>，同时 Cargo 在一个同名目录中创建项目文件。</p>
<p>进入 <em>hello_cargo</em> 目录并列出文件。将会看到 Cargo 生成了两个文件和一个目录：一个 Cargo.toml 文件，一个 <em>src</em> 目录，以及位于 <em>src</em> 目录中的 <em><a href="http://main.rs" target="_blank" rel="noopener">main.rs</a></em> 文件。它也在 <em>hello_cargo</em> 目录初始化了一个 git 仓库，以及一个 <em>.gitignore</em> 文件。</p>
<p>Cargo.toml 示例：</p>
<figure class="highlight toml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">"hello_cargo"</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">"0.1.0"</span><br><span class="hljs-attr">authors</span> = [<span class="hljs-string">"Your Name &lt;you@example.com&gt;"</span>]<br><span class="hljs-attr">edition</span> = <span class="hljs-string">"2018"</span><br><br><span class="hljs-section">[dependencies]</span><br></code></pre></div></td></tr></table></figure>
<p>Cargo 还提供了一个叫 <code>cargo check</code> 的命令。该命令快速检查代码确保其可以编译，但并不产生可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cargo check<br>   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.32 secs<br></code></pre></div></td></tr></table></figure>
<h4 id="发布（release）构建"><a class="header-anchor" href="#发布（release）构建">¶</a>发布（release）构建</h4>
<p>当项目最终准备好发布时，可以使用 <code>cargo build --release</code> 来优化编译项目。这会在 <em>target/release</em> 而不是 <em>target/debug</em> 下生成可执行文件。这些优化可以让 Rust 代码运行的更快，不过启用这些优化也需要消耗更长的编译时间。这也就是为什么会有两种不同的配置：一种是为了开发，你需要经常快速重新构建；另一种是为用户构建最终程序，它们不会经常重新构建，并且希望程序运行得越快越好。如果你在测试代码的运行时间，请确保运行 <code>cargo build --release</code> 并使用 <em>target/release</em> 下的可执行文件进行测试。</p>
<h2 id="2-猜猜看游戏教程"><a class="header-anchor" href="#2-猜猜看游戏教程">¶</a>2. 猜猜看游戏教程</h2>
<h4 id="使用变量储存值"><a class="header-anchor" href="#使用变量储存值">¶</a>使用变量储存值</h4>
<p>关联函数 == 静态方法</p>
<h4 id="生成一个随机数"><a class="header-anchor" href="#生成一个随机数">¶</a>生成一个随机数</h4>
<p>你不可能凭空就知道应该 <code>use</code> 哪个 <code>trait</code> 以及该从 <code>crate</code> 中调用哪个方法。<code>crate</code> 的使用说明位于其文档中。Cargo 有一个很棒的功能是：运行 <code>cargo doc --open</code> 命令来构建所有本地依赖提供的文档，并在浏览器中打开。例如，假设你对 <code>rand</code> crate 中的其他功能感兴趣，你可以运行 <code>cargo doc --open</code> 并点击左侧导航栏中的 <code>rand</code>。</p>
<h2 id="3-通用编程概念"><a class="header-anchor" href="#3-通用编程概念">¶</a>3. 通用编程概念</h2>
<h3 id="3-2-数据类型"><a class="header-anchor" href="#3-2-数据类型">¶</a>3.2 数据类型</h3>
<p>记住，Rust 是 <strong>静态类型</strong>（<em>statically typed</em>）语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时，比如第二章的 “比较猜测的数字和秘密数字” 使用 <code>parse</code> 将 <code>String</code> 转换为数字时，必须增加类型注解，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> guess: <span class="hljs-built_in">u32</span> = <span class="hljs-string">"42"</span>.parse().expect(<span class="hljs-string">"Not a number!"</span>);<br></code></pre></div></td></tr></table></figure>
<h4 id="标量类型"><a class="header-anchor" href="#标量类型">¶</a>标量类型</h4>
<p><strong>标量</strong>（<em>scalar</em>）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。你可能其他语言中见过它们。</p>
<h4 id="复合类型"><a class="header-anchor" href="#复合类型">¶</a>复合类型</h4>
<p><strong>复合类型</strong>（<em>Compound types</em>）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<h5 id="元组类型"><a class="header-anchor" href="#元组类型">¶</a>元组类型</h5>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> tup: (<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">f64</span>, <span class="hljs-built_in">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>tup</code> 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> tup = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">let</span> (x, y, z) = tup;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"The value of y is: &#123;&#125;"</span>, y);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>程序首先创建了一个元组并绑定到 <code>tup</code> 变量上。接着使用了 <code>let</code> 和一个模式将 <code>tup</code> 分成了三个不同的变量，<code>x</code>、<code>y</code> 和 <code>z</code>。这叫做 <strong>解构</strong>（<em>destructuring</em>）。</p>
<p>除了使用模式匹配解构外，也可以使用点号（.）后跟值的索引来直接访问它们。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> x: (<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">f64</span>, <span class="hljs-built_in">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">let</span> five_hundred = x.<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">let</span> six_point_four = x.<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">let</span> one = x.<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h5 id="数组类型"><a class="header-anchor" href="#数组类型">¶</a>数组类型</h5>
<p>数组的类型比较有趣；它看起来像 [type; number]。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> a: [<span class="hljs-built_in">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br></code></pre></div></td></tr></table></figure>
<h3 id="3-3-函数如何工作"><a class="header-anchor" href="#3-3-函数如何工作">¶</a>3.3 函数如何工作</h3>
<h4 id="包含语句和表达式的函数体"><a class="header-anchor" href="#包含语句和表达式的函数体">¶</a>包含语句和表达式的函数体</h4>
<p>我们用来创建新作用域的大括号（代码块），<code>{}</code>，也是一个表达式，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">let</span> y = &#123;<br>        <span class="hljs-keyword">let</span> x = <span class="hljs-number">3</span>;<br>        x + <span class="hljs-number">1</span><br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"The value of y is: &#123;&#125;"</span>, y);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这个表达式：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust">&#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">3</span>;<br>    x + <span class="hljs-number">1</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>是一个代码块，它的值是 <code>4</code>。这个值作为 <code>let</code> 语句的一部分被绑定到 <code>y</code> 上。注意结尾没有分号的那一行 <code>x+1</code>，与你见过的大部分代码行不同。表达式的结尾没有分号。<strong>如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。在接下来探索具有返回值的函数和表达式时要谨记这一点。</strong></p>
<h3 id="3-5-控制流"><a class="header-anchor" href="#3-5-控制流">¶</a>3.5 控制流</h3>
<h4 id="if-表达式"><a class="header-anchor" href="#if-表达式">¶</a><code>if</code> 表达式</h4>
<p>值得注意的是代码中的条件 <em>必须</em> 是 <code>bool</code> 值。如果条件不是 <code>bool</code> 值，我们将得到一个错误。</p>
<h5 id="在-let-语句中使用-if"><a class="header-anchor" href="#在-let-语句中使用-if">¶</a>在 <code>let</code> 语句中使用 <code>if</code></h5>
<p>因为 <code>if</code> 是一个表达式，我们可以在 <code>let</code> 语句的右侧使用它，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> condition = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">let</span> number = <span class="hljs-keyword">if</span> condition &#123;<br>        <span class="hljs-number">5</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-number">6</span><br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"The value of number is: &#123;&#125;"</span>, number);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="使用循环重复执行"><a class="header-anchor" href="#使用循环重复执行">¶</a>使用循环重复执行</h4>
<h5 id="从循环返回"><a class="header-anchor" href="#从循环返回">¶</a>从循环返回</h5>
<p>如果将返回值加入你用来停止循环的 <code>break</code> 表达式，它会被停止的循环返回：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> counter = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">loop</span> &#123;<br>        counter += <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> counter == <span class="hljs-number">10</span> &#123;<br>            <span class="hljs-keyword">break</span> counter * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">assert_eq!</span>(result, <span class="hljs-number">20</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="4-认识所有权"><a class="header-anchor" href="#4-认识所有权">¶</a>4. 认识所有权</h2>
<h3 id="4-1-什么是所有权"><a class="header-anchor" href="#4-1-什么是所有权">¶</a>4.1 什么是所有权</h3>
<h4 id="栈-Stack-与堆-Heap"><a class="header-anchor" href="#栈-Stack-与堆-Heap">¶</a>栈(Stack)与堆(Heap)</h4>
<ul>
<li>栈中的所有数据都必须占用已知且固定的大小。</li>
<li>在编译时大小未知或大小可能变化的数据，要改为存储在堆上。</li>
</ul>
<h4 id="内存与分配"><a class="header-anchor" href="#内存与分配">¶</a>内存与分配</h4>
<h5 id="只在栈上的数据：拷贝"><a class="header-anchor" href="#只在栈上的数据：拷贝">¶</a>只在栈上的数据：拷贝</h5>
<p>那么什么类型是 <code>Copy</code> 的呢？可以查看给定类型的文档来确认，不过作为一个通用的规则，任何简单标量值的组合可以是 <code>Copy</code> 的，不需要分配内存或某种形式资源的类型是 <code>Copy</code> 的。如下是一些 <code>Copy</code> 的类型：</p>
<ul>
<li>所有整数类型，比如 <code>u32</code>。</li>
<li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li>
<li>所有浮点数类型，比如 <code>f64</code>。</li>
<li>字符类型，<code>char</code>。</li>
<li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是。</li>
</ul>
<h3 id="4-2-引用与借用"><a class="header-anchor" href="#4-2-引用与借用">¶</a>4.2 引用与借用</h3>
<p>函数签名使用 <code>&amp;</code> 来表明参数 <code>s</code> 的类型是一个引用。让我们增加一些解释性的注释：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">calculate_length</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">usize</span> &#123; <span class="hljs-comment">// s 是对 String 的引用</span><br>    s.len()<br>&#125; <span class="hljs-comment">// 这里，s 离开了</span><br></code></pre></div></td></tr></table></figure>
<p>正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。</p>
<h5 id="可变引用"><a class="header-anchor" href="#可变引用">¶</a>可变引用</h5>
<p>在特定作用域中的特定数据有且只有一个可变引用。这些代码会失败：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"hello"</span>);<br><br><span class="hljs-keyword">let</span> r1 = &amp;<span class="hljs-keyword">mut</span> s;<br><span class="hljs-keyword">let</span> r2 = &amp;<span class="hljs-keyword">mut</span> s;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;&#125;, &#123;&#125;"</span>, r1, r2);<br></code></pre></div></td></tr></table></figure>
<p>错误如下：</p>
<figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">error[E0499]: cannot borrow `s` <span class="hljs-built_in">as</span> mutable more than <span class="hljs-built_in">once</span> <span class="hljs-built_in">at</span> a <span class="hljs-built_in">time</span><br> --&gt; src/main.rs:<span class="hljs-number">5</span>:<span class="hljs-number">10</span><br>  |<span class="hljs-type"></span><br><span class="hljs-type">4</span> | <span class="hljs-type">let</span> r1 = &amp;mut s;<br>  |          <span class="hljs-type">------ first</span> mutable borrow occurs here<br><span class="hljs-number">5</span> | <span class="hljs-type">let</span> r2 = &amp;mut s;<br>  |          <span class="hljs-type">^^^^^^ second</span> mutable borrow occurs here<br><span class="hljs-number">6</span> | <span class="hljs-type">println</span>!(<span class="hljs-string">"&#123;&#125;, &#123;&#125;"</span>, r1, r2);<br>  |                    <span class="hljs-type">-- borrow</span> later used here<br></code></pre></div></td></tr></table></figure>
<p>可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 同时 拥有：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"hello"</span>);<br><br>&#123;<br>    <span class="hljs-keyword">let</span> r1 = &amp;<span class="hljs-keyword">mut</span> s;<br><br>&#125; <span class="hljs-comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span><br><br><span class="hljs-keyword">let</span> r2 = &amp;<span class="hljs-keyword">mut</span> s;<br></code></pre></div></td></tr></table></figure>
<p>类似的规则也存在于同时使用可变与不可变引用中。这些代码会导致一个错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"hello"</span>);<br><br><span class="hljs-keyword">let</span> r1 = &amp;s; <span class="hljs-comment">// no problem</span><br><span class="hljs-keyword">let</span> r2 = &amp;s; <span class="hljs-comment">// no problem</span><br><span class="hljs-keyword">let</span> r3 = &amp;<span class="hljs-keyword">mut</span> s; <span class="hljs-comment">// BIG PROBLEM</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;&#125;, &#123;&#125;, and &#123;&#125;"</span>, r1, r2, r3);<br></code></pre></div></td></tr></table></figure>
<p>错误如下：</p>
<figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">error[E0502]: cannot borrow `s` <span class="hljs-built_in">as</span> mutable because it is also borrowed <span class="hljs-built_in">as</span> immutable<br> --&gt; src/main.rs:<span class="hljs-number">6</span>:<span class="hljs-number">10</span><br>  |<span class="hljs-type"></span><br><span class="hljs-type">4</span> | <span class="hljs-type">let</span> r1 = &amp;s; // no problem<br>  |          <span class="hljs-type">-- immutable</span> borrow occurs here<br><span class="hljs-number">5</span> | <span class="hljs-type">let</span> r2 = &amp;s; // no problem<br><span class="hljs-number">6</span> | <span class="hljs-type">let</span> r3 = &amp;mut s; // BIG PROBLEM<br>  |          <span class="hljs-type">^^^^^^ mutable</span> borrow occurs here<br><span class="hljs-number">7</span> |<span class="hljs-type"></span><br><span class="hljs-type">8</span> | <span class="hljs-type">println</span>!(<span class="hljs-string">"&#123;&#125;, &#123;&#125;, and &#123;&#125;"</span>, r1, r2, r3);<br>  |                            <span class="hljs-type">-- borrow</span> later used here<br></code></pre></div></td></tr></table></figure>
<p>哇哦！我们也 <strong>不能在拥有不可变引用的同时拥有可变引用</strong>。不可变引用的用户可不希望在他们的眼皮底下值就被意外的改变了！然而，<strong>多个不可变引用是可以的</strong>，因为没有哪个只能读取数据的人有能力影响其他人读取到的数据。</p>
<h3 id="4-3-Slices"><a class="header-anchor" href="#4-3-Slices">¶</a>4.3 Slices</h3>
<h4 id="字符串slice"><a class="header-anchor" href="#字符串slice">¶</a>字符串slice</h4>
<p><code>start..end</code> 语法代表一个以 <code>start</code> 开头并一直持续到但不包含 <code>end</code> 的 range。如果需要包含 <code>end</code>，可以使用 <code>..=</code> 而不是 <code>..</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"hello world"</span>);<br><br><span class="hljs-keyword">let</span> hello = &amp;s[<span class="hljs-number">0</span>..=<span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> world = &amp;s[<span class="hljs-number">6</span>..=<span class="hljs-number">10</span>];<br></code></pre></div></td></tr></table></figure>
<p><code>=</code> 意味着包含最后的数字。</p>
<blockquote>
<p>String不能直接取索引，如：</p>
</blockquote>
<blockquote>
   <figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Hello, world!"</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;&#125;"</span>, s[..]);<br></code></pre></div></td></tr></table></figure>
</blockquote>
<blockquote>
<p>只能如此形式：</p>
</blockquote>
<blockquote>
   <figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Hello, world!"</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"&#123;&#125;"</span>, &amp;s[..]);<br></code></pre></div></td></tr></table></figure>
</blockquote>
<blockquote>
<p>所以字符串字面值是&amp;str类型</p>
</blockquote>
<blockquote>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> s = <span class="hljs-string">"Hello, world!"</span>; <span class="hljs-comment">// s 是&amp;str类型</span><br></code></pre></div></td></tr></table></figure>
</blockquote>
<h2 id="5-使用结构体来组织相关联的数据"><a class="header-anchor" href="#5-使用结构体来组织相关联的数据">¶</a>5. 使用结构体来组织相关联的数据</h2>
<h3 id="5-1-定义并实例化结构体"><a class="header-anchor" href="#5-1-定义并实例化结构体">¶</a>5.1 定义并实例化结构体</h3>
<p>结构体定义示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span></span> &#123;<br>    username: <span class="hljs-built_in">String</span>,<br>    email: <span class="hljs-built_in">String</span>,<br>    sign_in_count: <span class="hljs-built_in">u64</span>,<br>    active: <span class="hljs-built_in">bool</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>创建结构体实例：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> user1 = User &#123;<br>    email: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"someone@example.com"</span>),<br>    username: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"someusername123"</span>),<br>    active: <span class="hljs-literal">true</span>,<br>    sign_in_count: <span class="hljs-number">1</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="变量与字段同名时的字段初始化简写语法"><a class="header-anchor" href="#变量与字段同名时的字段初始化简写语法">¶</a>变量与字段同名时的字段初始化简写语法</h4>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">build_user</span></span>(email: <span class="hljs-built_in">String</span>, username: <span class="hljs-built_in">String</span>) -&gt; User &#123;<br>    User &#123;<br>        email,<br>        username,<br>        active: <span class="hljs-literal">true</span>,<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="使用结构体更新语法从其他实例创建实例"><a class="header-anchor" href="#使用结构体更新语法从其他实例创建实例">¶</a>使用结构体更新语法从其他实例创建实例</h4>
<p>使用结构体更新语法，我们可以通过更少的代码来达到相同的效果。 <code>..</code> 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> user2 = User &#123;<br>    email: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"another@example.com"</span>),<br>    username: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"anotherusername567"</span>),<br>    ..user1<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h4 id="使用没有命名字段的元组结构体来创建不同的类型"><a class="header-anchor" href="#使用没有命名字段的元组结构体来创建不同的类型">¶</a>使用没有命名字段的元组结构体来创建不同的类型</h4>
<p>定义元组结构体，以 <code>struct</code> 关键字和结构体名开头并后跟元组中的类型。例如，下面是两个分别叫做 <code>Color</code> 和 <code>Point</code> 元组结构体的定义和用法：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Color</span></span>(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span>(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>);<br><br><span class="hljs-keyword">let</span> black = Color(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">let</span> origin = Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure>
<p>注意 <code>black</code> 和 <code>origin</code> 值的类型 <strong>不同</strong>，因为它们是不同的元组结构体的实例。你定义的每一个结构体有其自己的类型，即使结构体中的字段有着相同的类型。</p>
<h4 id="没有任何字段的类单元结构体"><a class="header-anchor" href="#没有任何字段的类单元结构体">¶</a>没有任何字段的类单元结构体</h4>
<p>我们也可以定义一个没有任何字段的结构体！它们被称为 <strong>类单元结构体</strong>（<em>unit-like structs</em>）因为它们类似于 <code>()</code>，即 <code>unit</code> 类型。类单元结构体常常在你想要在某个类型上实现 <code>trait</code> 但不需要在类型中存储数据的时候发挥作用。</p>
<h4 id="通过派生-trait-增加实用功能"><a class="header-anchor" href="#通过派生-trait-增加实用功能">¶</a>通过派生 trait 增加实用功能</h4>
<p>尝试打印出 <code>Rectangle</code> 实例：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span></span> &#123;<br>    width: <span class="hljs-built_in">u32</span>,<br>    height: <span class="hljs-built_in">u32</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> rect1 = Rectangle &#123; width: <span class="hljs-number">30</span>, height: <span class="hljs-number">50</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"rect1 is &#123;&#125;"</span>, rect1);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>当我们运行这个代码时，会出现带有如下核心信息的错误：</p>
<figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-builtin-name">error</span>[E0277]: the trait bound `Rectangle: std::fmt::Display` is <span class="hljs-keyword">not</span> satisfied<br>`Rectangle` cannot be formatted with the<span class="hljs-built_in"> default </span>formatter; try using<br>`:?` instead <span class="hljs-keyword">if</span> you are using a format string<br></code></pre></div></td></tr></table></figure>
<p>上述错误说明结构体没实现 <code>std::fmt::Display</code> 方法，按照提示尝试<code>println!(&quot;rect1 is {:?}&quot;, rect1);</code>，但仍能看到另一个错误：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey"><span class="hljs-title">error[E0277]: the trait bound `Rectangle: std::fmt::</span>Debug` is <span class="hljs-literal">not</span> satisfied<br>`Rectangle` cannot be formatted using `:?`; if it is defined in your<br><span class="hljs-built_in">crate,</span> add `#[derive(Debug)]` <span class="hljs-literal">or</span> manually implement it<br></code></pre></div></td></tr></table></figure>
<p>我们必须为结构体显式选择这个功能。为此，在结构体定义之前加上 #[derive(Debug)] 注解：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span></span> &#123;<br>    width: <span class="hljs-built_in">u32</span>,<br>    height: <span class="hljs-built_in">u32</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> rect1 = Rectangle &#123; width: <span class="hljs-number">30</span>, height: <span class="hljs-number">50</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"rect1 is &#123;:?&#125;"</span>, rect1);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="5-3-方法语法"><a class="header-anchor" href="#5-3-方法语法">¶</a>5.3 方法语法</h3>
<h4 id="关联函数"><a class="header-anchor" href="#关联函数">¶</a>关联函数</h4>
<p><code>impl</code> 块的另一个有用的功能是：允许在 <code>impl</code> 块中定义 不 以 <code>self</code> 作为参数的函数。这被称为 关联函数（<em>associated functions</em>），因为它们与结构体相关联。它们仍是函数而不是方法，因为它们并不作用于一个结构体的实例。你已经使用过 <code>String::from</code> 关联函数了。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>ibus-rime设置候选词横排</title>
    <url>/2019/01/12/ibus-rime%E8%AE%BE%E7%BD%AE%E5%80%99%E9%80%89%E8%AF%8D%E6%A8%AA%E6%8E%92/</url>
    <content><![CDATA[<h1>ibus-rime 设置候选词横排</h1>
<p>************—</p>
<p>[TOC]</p>
<hr>
<ul>
<li>当ibus-setup和设置<code>gsettings set org.freedesktop.ibus.panel lookup-table-orientation 0</code>都无效时，临时办法是创建 <code>~/.config/ibus/rime/build/ibus_rime.yaml</code>，添加如下内容：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">style:</span><br>    <span class="hljs-attr">horizontal:</span> <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>原贴：<a href="https://www.bountysource.com/issues/67221114-ibus-rime%E3%80%82" target="_blank" rel="noopener">https://www.bountysource.com/issues/67221114-ibus-rime。</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>rime</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables文档</title>
    <url>/2018/11/22/iptables%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1>iptables文档</h1>
<hr>
<p>[TOC]</p>
<hr>
<p>iptabels是与Linux内核集成的包过滤防火墙系统，几乎所有的linux发行版本都会包含iptables的功能。如果 Linux 系统连接到因特网或 LAN、服务器或连接 LAN 和因特网的代理服务器， 则iptables有利于在 Linux 系统上更好地控制 IP 信息包过滤和防火墙配置。</p>
<p>netfilter/iptables过滤防火墙系统是一种功能强大的工具，可用于添加、编辑和除去规则，这些规则是在做信息包过滤决定时，防火墙所遵循和组成的规则。这些规则存储在专用的信 息包过滤表中，而这些表集成在 Linux 内核中。在信息包过滤表中，规则被分组放在我们所谓的链（chain）中。</p>
<p>虽然netfilter/iptables包过滤系统被称为单个实体，但它实际上由两个组件netfilter 和 iptables 组成。</p>
<p>netfilter 组件也称为内核空间（kernelspace），是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。</p>
<p>iptables 组件是一种工具，也称为用户空间（userspace），它使插入、修改和除去信息包过滤表中的规则变得容易。</p>
<h2 id="优点"><a class="header-anchor" href="#优点">¶</a>优点</h2>
<p>netfilter/iptables的最大优点是它可以配置有状态的防火墙。有状态的防火墙能够指定并记住为发送或接收信息包所建立的连接的状态。防火墙可以从信息包的连接跟踪状态获得该信 息。在决定新的信息包过滤时，防火墙所使用的这些状态信息可以增加其效率和速度。这里有四种有效状态，名称分别为 <code>ESTABLISHED</code>、 <code>INVALID</code>、 <code>NEW</code> 和 <code>RELATED</code>。</p>
<p>状态 <code>ESTABLISHED</code> 指出该信息包属于已建立的连接，该连接一直用于发送和接收信息包并且完全有效。<code>INVALID</code> 状态指出该信息包与任何已知的流或连接都不相关联，它可能包含错误的数据或头。状态 <code>NEW</code> 意味着该信息包已经或将启动新的连接，或者它与尚未用于发送和接收信息包的连接相关联。最后， <code>RELATED</code> 表示该信息包正在启动新连接，以及它与已建立的连接相关联。</p>
<p>netfilter/iptables的另一个重要优点是，它使用户可以完全控制防火墙配置和信息包过滤。您可以定制自己的规则来满足您的特定需求，从而只允许您想要的网络流量进入系统。</p>
<p>另外，netfilter/iptables是免费的，这对于那些想要节省费用的人来说十分理想，它可以代替昂贵的防火墙解决方案。</p>
<h2 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h2>
<p>iptables的原理主要是对数据包的控制，看下图：</p>
<p><img src="http://img.blog.csdn.net/20131023184402031" alt="图1"></p>
<ol>
<li>一个数据包进入网卡时，它首先进入<code>PREROUTING</code>链，内核根据数据包目的IP判断是否需要转发出去。</li>
<li>如果数据包就是进入本机的，它就会沿着图向下移动，到达<code>INPUT</code>链。数据包到了<code>INPUT</code>链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经 过<code>OUTPUT</code>链，然后到达<code>POSTROUTING</code>链输出。</li>
<li>如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过 <code>FORWARD</code>链，然后到达<code>POSTROUTING</code>链输出。</li>
</ol>
<h2 id="规则、表和链"><a class="header-anchor" href="#规则、表和链">¶</a>规则、表和链</h2>
<h3 id="1-规则（rules）"><a class="header-anchor" href="#1-规则（rules）">¶</a>1. 规则（rules）</h3>
<p>规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如<code>TCP</code>、<code>UDP</code>、<code>ICMP</code>）和服务类型（如<code>HTTP</code>、<code>FTP</code>和<code>SMTP</code>）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（<code>ACCEPT</code>）、拒绝（<code>REJECT</code>）和丢弃（<code>DROP</code>）等。配置防火墙的主要工作就是添加、修改和删除这些规则。</p>
<h3 id="2-链（chains）"><a class="header-anchor" href="#2-链（chains）">¶</a>2. 链（chains）</h3>
<p>链（chains）是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定义的默认策略来处理数据包。</p>
<h3 id="3-表（tables）"><a class="header-anchor" href="#3-表（tables）">¶</a>3. 表（tables）</h3>
<p>表（tables）提供特定的功能，iptables内置了4个表，即<code>RAW</code>表、<code>FILTER</code>表、<code>NAT</code>表和<code>MANGLE</code>表，分别用于实现包过滤，网络地址转换和包重构的功能。</p>
<p><img src="http://img.blog.csdn.net/20131023184415343" alt="图2"></p>
<ol>
<li><code>raw</code>表<br>
只使用在<code>PREROUTING</code>链和<code>OUTPUT</code>链上,因为优先级最高，从而可以对收到的数据包在连接跟踪前进行处理。一但用户使用了<code>RAW</code>表,在 某个链上,<code>RAW</code>表处理完后,将跳过<code>NAT</code>表和 ip_conntrack处理,即不再做地址转换和数据包的链接跟踪处理了。</li>
<li><code>FILTER</code>表<br>
主要用于过滤数据包，该表根据系统管理员预定义的一组规则过滤符合条件的数据包。对于防火墙而言，主要利用在<code>FILTER</code>表中指定的规则来实现对数据包的过滤。<code>FILTER</code>表是默认的表，如果没有指定哪个表，iptables 就默认使用<code>FILTER</code>表来执行所有命令，<code>FILTER</code>表包含了<code>INPUT</code>链（处理进入的数据包），<code>FORWARD</code>链（处理转发的数据包），<code>OUTPUT</code>链（处理本地生成的数据包）在<code>FILTER</code>表中只能允许对数据包进行接受，丢弃的操作，而无法对数据包进行更改。</li>
<li><code>NAT</code>表<br>
主要用于网络地址转换<code>NAT</code>，该表可以实现一对一，一对多，多对多等<code>NAT</code> 工作，iptables就是使用该表实现共享上网的，<code>NAT</code>表包含了<code>PREROUTING</code>链（修改即将到来的数据包），<code>POSTROUTING</code>链（修改即将出去的数据包），<code>OUTPUT</code>链（修改路由之前本地生成的数据包）。</li>
<li><code>MANGLE</code>表<br>
主要用于对指定数据包进行更改，在内核版本2.4.18 后的linux版本中该表包含的链为：<code>INPUT</code>链（处理进入的数据包），<code>FORWARD</code>链（处理转发的数据包），<code>OUTPUT</code>链（处理本地生成的数据包）<code>POSTROUTING</code>链（修改即将出去的数据包），<code>PREROUTING</code>链（修改即将到来的数据包）。</li>
</ol>
<h3 id="4-规则表之间的优先顺序"><a class="header-anchor" href="#4-规则表之间的优先顺序">¶</a>4. 规则表之间的优先顺序</h3>
<p>RAW —&gt; MANGE —&gt; NAT ——&gt; FILTER</p>
<p>规则链之间的优先顺序（分三种情况）：</p>
<h4 id="第一种情况：入站数据流向"><a class="header-anchor" href="#第一种情况：入站数据流向">¶</a>第一种情况：入站数据流向</h4>
<p>从外界到达防火墙的数据包，先被<code>PREROUTING</code>规则链处理（是否修改数据包地址等），之后会进行路由选择（判断该数据包应该发往何处），如果数据包 的目标主机是防火墙本机（比如说Internet用户访问防火墙主机中的web服务器的数据包），那么内核将其传给<code>INPUT</code>链进行处理（决定是否允许通 过等），通过以后再交给系统上层的应用程序（比如Apache服务器）进行响应。</p>
<h4 id="第二冲情况：转发数据流向"><a class="header-anchor" href="#第二冲情况：转发数据流向">¶</a>第二冲情况：转发数据流向</h4>
<p>来自外界的数据包到达防火墙后，首先被<code>PREROUTING</code>规则链处理，之后会进行路由选择，如果数据包的目标地址是其它外部地址（比如局域网用户通过网 关访问QQ站点的数据包），则内核将其传递给<code>FORWARD</code>链进行处理（是否转发或拦截），然后再交给<code>POSTROUTING</code>规则链（是否修改数据包的地 址等）进行处理。</p>
<h4 id="第三种情况：出站数据流向"><a class="header-anchor" href="#第三种情况：出站数据流向">¶</a>第三种情况：出站数据流向</h4>
<p>防火墙本机向外部地址发送的数据包（比如在防火墙主机中测试公网DNS服务器时），首先被<code>OUTPUT</code>规则链处理，之后进行路由选择，然后传递给<code>POSTROUTING</code>规则链（是否修改数据包的地址等）进行处理。</p>
<p>iptables是采用规则堆栈的方式来进行过滤，当一个封包进入网卡，会先检查 <code>PREROUTING</code>，然后检查目的IP判断是否需要转送出去，接着就会跳到<code>INPUT</code>或<code>FORWORD</code> 进行过滤，如果封包需转送处理则检查 <code>POSTROUTING</code>，如果是来自本机封包，则检查 <code>OUTPUT</code>以及<code>POSTROUTING</code>。过程中如果符合某条规则将会进行处理，处理动作除了 <code>ACCEPT</code>、<code>REJECT</code>、<code>DROP</code>、<code>REDIRECT</code> 和<code>MASQUERADE</code>以外，还多出 <code>LOG</code>、<code>ULOG</code>、<code>DNAT</code>、<code>SNAT</code>、<code>MIRROR</code>、<code>QUEUE</code>、<code>RETURN</code>、<code>TOS</code>、<code>TTL</code>、<code>MARK</code>等，其中某些处理动作不会中断过滤程序，某些处理动作则会中断同一规则链的过滤，并依照前述流程继续进行下一个规则链的过滤（注意：这一点与ipchains不同），一直到堆栈中的规则检查完毕为止。透过这种机制所带来的好处是，我们可以进行复杂、多重的封包过滤，简单的说，iptables可以进行纵横交错式的过滤（tables）而非链状过滤（chains）。<code>ACCEPT</code>将封包放行，进行完此处理动作后，将不再比对其它规则，直接跳往下一个规则链（<code>NAT</code>:<code>POSTROUTING</code>）。</p>
<p>那么如何使用iptables在以上流程中控制对数据包的处理行为呢？当然是使用iptables与其相关的参数了。</p>
<h2 id="iptables命令格式"><a class="header-anchor" href="#iptables命令格式">¶</a>iptables命令格式</h2>
<p>iptables的命令格式较为复杂，一般的格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables [-t 表] -命令 匹配   操作<br></code></pre></div></td></tr></table></figure>
<p>说明</p>
<ol>
<li>
<p>-t 表<br>
表选项用于指定命令应用于哪个iptables内置表。</p>
</li>
<li>
<p>命令<br>
命令选项用于指定iptables的执行方式，包括插入规则，删除规则和添加规则，如下表所示：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-P  --policy &lt;链名&gt;</td>
<td style="text-align:left">定义默认策略</td>
</tr>
<tr>
<td style="text-align:left">-L  --list &lt;链名&gt;</td>
<td style="text-align:left">查看iptables规则列表</td>
</tr>
<tr>
<td style="text-align:left">-A  --append &lt;链名&gt;</td>
<td style="text-align:left">在规则列表的最后增加1条规则</td>
</tr>
<tr>
<td style="text-align:left">-I  --insert &lt;链名&gt;</td>
<td style="text-align:left">在指定的位置插入1条规则</td>
</tr>
<tr>
<td style="text-align:left">-D  --delete &lt;链名&gt;</td>
<td style="text-align:left">从规则列表中删除1条规则</td>
</tr>
<tr>
<td style="text-align:left">-R  --replace &lt;链名&gt;</td>
<td style="text-align:left">替换规则列表中的某条规则</td>
</tr>
<tr>
<td style="text-align:left">-F  --flush &lt;链名&gt;</td>
<td style="text-align:left">删除表中所有规则</td>
</tr>
<tr>
<td style="text-align:left">-Z  --zero &lt;链名&gt;</td>
<td style="text-align:left">将表中数据包计数器和流量计数器归零</td>
</tr>
<tr>
<td style="text-align:left">-X  --delete-chain &lt;链名&gt;</td>
<td style="text-align:left">删除自定义链</td>
</tr>
<tr>
<td style="text-align:left">-v  --verbose &lt;链名&gt;</td>
<td style="text-align:left">与<code>-L</code>他命令一起使用显示更多更详细的信息</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>匹配规则<br>
匹配选项指定数据包与规则匹配所具有的特征，包括源地址，目的地址，传输协议和端口号，如下表所示：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">匹配</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-i --in-interface &lt;网络接口名&gt;</td>
<td style="text-align:left">指定数据包从哪个网络接口进入</td>
</tr>
<tr>
<td style="text-align:left">-o --out-interface   &lt;网络接口名&gt;</td>
<td style="text-align:left">指定数据包从哪个网络接口输出</td>
</tr>
<tr>
<td style="text-align:left">-p —proto 协议类型</td>
<td style="text-align:left">指定数据包匹配的协议，如<code>TCP</code>、<code>UDP</code>和<code>ICMP</code>等</td>
</tr>
<tr>
<td style="text-align:left">-s --source &lt;源地址或子网&gt;</td>
<td style="text-align:left">指定数据包匹配的源地址</td>
</tr>
<tr>
<td style="text-align:left">–sport &lt;源端口号&gt;</td>
<td style="text-align:left">指定数据包匹配的源端口号</td>
</tr>
<tr>
<td style="text-align:left">–dport &lt;目的端口号&gt;</td>
<td style="text-align:left">指定数据包匹配的目的端口号</td>
</tr>
<tr>
<td style="text-align:left">-m --match 匹配的模块</td>
<td style="text-align:left">指定数据包规则所使用的过滤模块</td>
</tr>
</tbody>
</table>
<p>iptables执行规则时，是从规则表中从上至下顺序执行的，如果没遇到匹配的规则，就一条一条往下执行，如果遇到匹配的规则后，那么就执行本规则，执行后根据本规则的动作(<code>ACCEPT</code>，<code>REJECT</code>，<code>LOG</code>，<code>DROP</code>等)，决定下一步执行的情况，后续执行一般有三种情况。</p>
<ul>
<li>一种是继续执行当前规则队列内的下一条规则。比如执行过<code>FILTER</code>队列内的<code>LOG</code>后，还会执行<code>FILTER</code>队列内的下一条规则。</li>
<li>一种是中止当前规则队列的执行，转到下一条规则队列。比如从执行过<code>ACCEPT</code>后就中断<code>FILTER</code>队列内其它规则，跳到<code>NAT</code>队列规则去执行</li>
<li>一种是中止所有规则队列的执行。</li>
</ul>
<h2 id="iptables规则的动作"><a class="header-anchor" href="#iptables规则的动作">¶</a>iptables规则的动作</h2>
<p>前面我们说过iptables处理动作除了 <code>ACCEPT</code>、<code>REJECT</code>、<code>DROP</code>、<code>REDIRECT</code> 、<code>MASQUERADE</code> 以外，还多出 <code>LOG</code>、<code>ULOG</code>、<code>DNAT</code>、<code>RETURN</code>、<code>TOS</code>、<code>SNAT</code>、<code>MIRROR</code>、<code>QUEUE</code>、<code>TTL</code>、<code>MARK</code>等。我们只说明其中最常用的动作：</p>
<p><strong>REJECT</strong> 拦阻该数据包，并返回数据包通知对方，可以返回的数据包有几个选择：<code>ICMP port-unreachable</code>、<code>ICMP echo-reply</code> 或是<code>tcp-reset</code>（这个数据包包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。 范例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A  INPUT -p TCP --dport 22 -j REJECT --reject-with ICMP <span class="hljs-built_in">echo</span>-reply<br></code></pre></div></td></tr></table></figure>
<p><strong>DROP</strong> 丢弃数据包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</p>
<p><strong>REDIRECT</strong> 将封包重新导向到另一个端口（<code>PNAT</code>），进行完此处理动作后，将会继续比对其它规则。这个功能可以用来实作透明代理 或用来保护web 服务器。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT--to-ports 8081<br></code></pre></div></td></tr></table></figure>
<p><strong>MASQUERADE</strong> 改写封包来源IP为防火墙的IP，可以指定<code>port</code> 对应的范围，进行完此处理动作后，直接跳往下一个规则链（<code>MANGLE</code>:<code>POSTROUTING</code>）。这个功能与 <code>SNAT</code> 略有不同，当进行IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读取，当使用拨接连线时，IP 通常是由 ISP 公司的 DHCP服务器指派的，这个时候 <code>MASQUERADE</code> 特别有用。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE --to-ports 21000-31000<br></code></pre></div></td></tr></table></figure>
<p><strong>LOG</strong> 将数据包相关信息纪录在 <code>/var/lo</code>g 中，详细位置请查阅 <code>/etc/syslog.conf</code> 配置文件，进行完此处理动作后，将会继续比对其它规则。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -p tcp -j LOG --<span class="hljs-built_in">log</span>-prefix <span class="hljs-string">"input packet"</span><br></code></pre></div></td></tr></table></figure>
<p><strong>SNAT</strong> 改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 <code>port</code> 对应的范围，进行完此处理动作后，将直接跳往下一个规则链（<code>MANGLE</code>:<code>POSTROUTING</code>）。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT --to-source 192.168.10.15-192.168.10.160:2100-3200<br></code></pre></div></td></tr></table></figure>
<p><strong>DNAT</strong> 改写数据包包目的地 IP 为某特定 IP 或 IP 范围，可以指定 <code>port</code> 对应的范围，进行完此处理动作后，将会直接跳往下一个规则链（<code>FILTER</code>:<code>INPUT</code> 或 <code>FILTER</code>:<code>FORWORD</code>）。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 --dport 80 -j DNAT --to-destination 192.168.10.1-192.168.10.10:80-100<br></code></pre></div></td></tr></table></figure>
<p><strong>MIRROR</strong> 镜像数据包，也就是将来源 IP与目的地IP对调后，将数据包返回，进行完此处理动作后，将会中断过滤程序。</p>
<p><strong>QUEUE</strong> 中断过滤程序，将封包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，例如：计算联机费用…等。</p>
<p><strong>RETURN</strong> 结束在目前规则链中的过滤程序，返回主规则链继续过滤，如果把自订规则炼看成是一个子程序，那么这个动作，就相当于提早结束子程序并返回到主程序中。</p>
<p><strong>MARK</strong> 将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --<span class="hljs-built_in">set</span>-mark 22<br></code></pre></div></td></tr></table></figure>
<p>看了本文是不是对iptables参数有所了解了，下文我会使用实例来更详细的说明iptables的参数的用法。</p>
<h3 id="保存规则"><a class="header-anchor" href="#保存规则">¶</a>保存规则</h3>
<p>使用iptables程序建立的规则只会保存在内存中，通常我们在修改了iptables的规则重启 iptables 后，之前修改的规则又消失了。那么如何保存新建立的规则呢？</p>
<ol>
<li>
<p>对于RHEL和ceontos系统可以使用<code>service iptables save</code>将当前内存中的规则保存到<code>/etc/sysconfig/iptables</code>文件中</p>
 <figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">[root@lampbo ~]#<span class="hljs-built_in"> service </span>iptables save<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>修改<code>/etc/sysconfig/iptables-config</code> 将里面的<code>IPTABLES_SAVE_ON_STOP=&quot;no&quot;</code>, 这一句的<code>no</code>改为<code>yes</code>这样每次服务在停止之前会自动将现有的规则保存在 <code>/etc/sysconfig/iptables</code>这个文件中去。</p>
</li>
</ol>
<h2 id="规则示例"><a class="header-anchor" href="#规则示例">¶</a>规则示例</h2>
<p>先回顾下iptables的格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables [-t table] <span class="hljs-built_in">command</span> [match] [-j target/jump]<br></code></pre></div></td></tr></table></figure>
<p>-t 参数用来指定规则表，内建的规则表有三个，分别是：<code>NAT</code>、<code>MANGLE</code> 和 <code>FILTER</code>，当未指定规则表时，则一律视为是 <code>FILTER</code>。</p>
<p>各个规则表的功能如下：</p>
<p><strong>NAT</strong> 此规则表拥有 <code>PREROUTING</code> 和 <code>POSTROUTING</code> 两个规则链，主要功能为进行一对一、一对多、多对多等网址转换工作（<code>SNAT</code>，<code>DNAT</code>），由于转换的特性，需进行目的地网址转换的数据包，就不需要进行来源网址转换，反之亦然，因此为了提升改写封包的效率，在防火墙运作时，每个封包只会经过这个规则表一次。如果我们把数据包过滤的规则定义在这个数据表里，将会造成无法对同一包进行多次比对，因此这个规则表除了作网址转换外，请不要做其它用途。mangle 此规则表拥有 <code>PREROUTING</code>、<code>FORWARD</code> 和 <code>POSTROUTING</code> 三个规则链。</p>
<p>除了进行网址转译工作会改写封包外，在某些特殊应用可能也必须去改写数据包（<code>TTL</code>、<code>TOS</code>）或者是设定 <code>MARK</code>（将数据包作记号，以进行后续的过滤），这时就必须将这些工作定义在 <code>MANGLE</code> 规则表中。</p>
<p><strong>MANGLE</strong> 表主要用于对指定数据包进行更改，在内核版本2.4.18 后的linux版本中该表包含的链为：<code>INPUT</code>链（处理进入的数据包），<code>FORWARD</code>链（处理转发的数据包），<code>OUTPUT</code>链（处理本地生成的数据包）<code>POSTROUTING</code>链（修改即将出去的数据包），<code>PREROUTING</code>链（修改即将到来的数据包）。</p>
<p><strong>FILTER</strong> 这个规则表是预设规则表，拥有 <code>INPUT</code>、<code>FORWARD</code> 和 <code>OUTPUT</code> 三个规则链，这个规则表顾名思义是用来进行封包过滤的动作（例如：DROP、 LOG、 ACCEPT<code>或</code>REJECT`），我们会将基本规则都建立在此规则表中。</p>
<h3 id="常用命令示例"><a class="header-anchor" href="#常用命令示例">¶</a>常用命令示例</h3>
<ol>
<li>
<p>命令 -A, --append<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -p tcp --dport 80 -j ACCEPT<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明 ：新增规则到<code>INPUT</code>规则链中，规则时接到所有目的端口为80的数据包的流入连接，该规则将会成为规则链中的最后一条规则。</p>
</blockquote>
</li>
<li>
<p>命令 -D, --delete<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -D INPUT -p tcp --dport 80 -j ACCEPT<br></code></pre></div></td></tr></table></figure>
<p>或：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -D INPUT 1<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：从<code>INPUT</code>规则链中删除上面建立的规则，可输入完整规则，或直接指定规则编号加以删除。</p>
</blockquote>
</li>
<li>
<p>命令 -R, --replace<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -R INPUT 1 -s 192.168.0.1 -j DROP<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：取代现行第一条规则，规则被取代后并不会改变顺序。</p>
</blockquote>
</li>
<li>
<p>命令 -I, --insert<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -I INPUT 1 -p tcp --dport 80 -j ACCEPT<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：在第一条规则前插入一条规则，原本该位置上的规则将会往后移动一个顺位。</p>
</blockquote>
</li>
<li>
<p>命令 -L, --list<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -L INPUT<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：列出<code>INPUT</code>规则链中的所有规则。</p>
</blockquote>
</li>
<li>
<p>命令 -F, --flush<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -F INPUT<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明： 删除<code>INPUT</code>规则链中的所有规则。</p>
</blockquote>
</li>
<li>
<p>命令 -Z, --zero<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -Z INPUT<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：将<code>INPUT</code>链中的数据包计数器归零。它是计算同一数据包出现次数，过滤阻断式攻击不可少的工具。</p>
</blockquote>
</li>
<li>
<p>命令 -N, --new-chain<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -N denied<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：定义新的规则链。</p>
</blockquote>
</li>
<li>
<p>命令 -X, --delete-chain<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -X denied<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：删除某个规则链。</p>
</blockquote>
</li>
<li>
<p>命令 -P, --policy<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -P INPUT DROP<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：定义默认的过滤策略。 数据包没有找到符合的策略，则根据此预设方式处理。</p>
</blockquote>
</li>
<li>
<p>命令 -E, --rename-chain<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -E denied disallowed<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：修改某自订规则链的名称。</p>
</blockquote>
</li>
</ol>
<h3 id="常用封包比对参数"><a class="header-anchor" href="#常用封包比对参数">¶</a>常用封包比对参数</h3>
<ol>
<li>
<p>参数 -p, --protocol<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -p tcp<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：比对通讯协议类型是否相符，可以使用 <code>!</code> 运算子进行反向比对，例如：<code>-p ! tcp</code> ，意思是指除 tcp 以外的其它类型，包含udp、icmp …等。如果要比对所有类型，则可以使用 <code>all</code> 关键词，例如：<code>-p all</code>。</p>
</blockquote>
</li>
<li>
<p>参数 -s, --src, --source<br>
范例:</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -s 192.168.1.100<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对数据包的来源IP，可以比对单机或网络，比对网络时请用数字来表示屏蔽，例如：<code>-s 192.168.0.0/24</code>，比对 IP 时可以使用<code>!</code>运算子进行反向比对，例如：<code>-s ! 192.168.0.0/24</code>。</p>
</blockquote>
</li>
<li>
<p>参数 -d, --dst, --destination<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -d 192.168.1.100<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对封包的目的地 IP，设定方式同上。</p>
</blockquote>
</li>
<li>
<p>参数 -i, --in-interface<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -i  lo<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明:用来比对数据包是从哪个网卡进入，可以使用通配字符 <code>+</code> 来做大范围比对，如：<code>-i eth+</code> 表示所有的 ethernet 网卡，也可以使用 <code>!</code> 运算子进行反向比对，如：<code>-i ! eth0</code>。这里<code>lo</code>指本地换回接口。</p>
</blockquote>
</li>
<li>
<p>参数 -o, --out-interface<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A FORWARD -o eth0<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对数据包要从哪个网卡流出，设定方式同上。</p>
</blockquote>
</li>
<li>
<p>参数 --sport, --source-port<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -p tcp --sport 22<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对数据的包的来源端口号，可以比对单一端口，或是一个范围，例如：<code>--sport 22:80</code>，表示从 22 到 80 端口之间都算是符合件，如果要比对不连续的多个端口，则必须使用 <code>--multiport</code> 参数，详见后文。比对端口号时，可以使用 <code>!</code> 运算子进行反向比对。</p>
</blockquote>
</li>
<li>
<p>参数 --dport, --destination-port<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -p tcp --dport 22<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对封包的目的地端口号，设定方式同上。</p>
</blockquote>
</li>
<li>
<p>参数 --tcp-flags<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -p tcp --tcp-flags SYN,FIN,ACK SYN<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：比对 TCP 封包的状态标志号，参数分为两个部分，第一个部分列举出想比对的标志号，第二部分则列举前述标志号中哪些有被设，未被列举的标志号必须是空的。TCP 状态标志号包括：<code>SYN</code>（同步）、<code>ACK</code>（应答）、<code>FIN</code>（结束）、<code>RST</code>（重设）、<code>URG</code>（紧急）、<code>PSH</code>（强迫推送） 等均可使用于参数中，除此之外还可以使用关键词 <code>ALL</code> 和 <code>NONE</code> 进行比对。比对标志号时，可以使用 <code>!</code> 运算子行反向比对。</p>
</blockquote>
</li>
<li>
<p>参数 --syn<br>
范例：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -p tcp --syn<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对是否为要求联机之TCP 封包，与 <code>iptables -p tcp --tcp-flags SYN,FIN,ACK SYN</code> 的作用完全相同，如果使用 <code>!</code>运算子，可用来比对非要求联机封包。</p>
</blockquote>
</li>
<li>
<p>参数 -m multiport --source-port<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -p tcp -m multiport --<span class="hljs-built_in">source</span>-port 22,53,80,110 -j ACCEPT<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对不连续的多个来源端口号，一次最多可以比对 15 个端口，可以使用 <code>!</code> 运算子进行反向比对。</p>
</blockquote>
</li>
<li>
<p>参数 -m multiport --destination-port<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -p tcp -m multiport --destination-port 22,53,80,110 -j ACCEPT<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对不连续的多个目的地端口号，设定方式同上。</p>
</blockquote>
</li>
<li>
<p>参数 -m multiport --port<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -p tcp -m multiport --port 22,53,80,110 -j ACCEPT<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：这个参数比较特殊，用来比对来源端口号和目的端口号相同的数据包，设定方式同上。注意：在本范例中，如果来源端口号为 80，目的地端口号为 110，这种数据包并不算符合条件。</p>
</blockquote>
</li>
<li>
<p>参数 --icmp-type<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -p icmp --icmp-type 8 -j DROP<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对 ICMP 的类型编号，可以使用代码或数字编号来进行比对。请打 <code>iptables -p icmp --help</code> 来查看有哪些代码可用。这里是指禁止ping如，但是可以从该主机ping出。</p>
</blockquote>
</li>
<li>
<p>参数 -m limit --limit<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -m <span class="hljs-built_in">limit</span> --<span class="hljs-built_in">limit</span> 3/hour<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对某段时间内数据包的平均流量，上面的例子是用来比对：每小时平均流量是否超过一次3个数据包。 除了每小时平均次外，也可以每秒钟、每分钟或每天平均一次，默认值为每小时平均一次，参数如后： <code>/second</code>、 <code>/minute</code>、<code>/day</code>。 除了进行数据包数量的比对外，设定这个参数也会在条件达成时，暂停数据包的比对动作，以避免因洪水攻击法，导致服务被阻断。</p>
</blockquote>
</li>
<li>
<p>参数 --limit-burst<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -m <span class="hljs-built_in">limit</span> --<span class="hljs-built_in">limit</span>-burst 5<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对瞬间大量封包的数量，上面的例子是用来比对一次同时涌入的封包是否超过 5 个（这是默认值），超过此上限的封将被直接丢弃。使用效果同上。</p>
</blockquote>
</li>
<li>
<p>参数 -m mac --mac-source<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -m mac --mac-source 00:00:00:00:00:01 -j ACCEPT<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对数据包来源网络接口的硬件地址，这个参数不能用在 <code>OUTPUT</code> 和 <code>POSTROUTING</code> 规则链上，这是因为封包要送出到网后，才能由网卡驱动程序透过 ARP 通讯协议查出目的地的 MAC 地址，所以 iptables 在进行封包比对时，并不知道封包会送到个网络接口去。</p>
</blockquote>
</li>
<li>
<p>参数 --mark<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -t mangle -A INPUT -m mark --mark 1<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对封包是否被表示某个号码，当封包被比对成功时，我们可以透过 <code>MARK</code> 处理动作，将该封包标示一个号码，号码最不可以超过 4294967296。</p>
</blockquote>
</li>
<li>
<p>参数 -m owner --uid-owner<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A OUTPUT -m owner --uid-owner 500<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对来自本机的封包，是否为某特定使用者所产生的，这样可以避免服务器使用 root 或其它身分将敏感数据传送出，可以降低系统被骇的损失。可惜这个功能无法比对出来自其它主机的封包。</p>
</blockquote>
</li>
<li>
<p>参数 -m owner --gid-owner<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A OUTPUT -m owner --gid-owner 0<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对来自本机的数据包，是否为某特定使用者群组所产生的，使用时机同上。</p>
</blockquote>
</li>
<li>
<p>参数 -m owner --pid-owner<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A OUTPUT -m owner --pid-owner 78<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明：用来比对来自本机的数据包，是否为某特定行程所产生的，使用时机同上。</p>
</blockquote>
</li>
<li>
<p>参数 -m owner --sid-owner<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A OUTPUT -m owner --sid-owner 100<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明： 用来比对来自本机的数据包，是否为某特定联机（Session ID）的响应封包，使用时机同上。</p>
</blockquote>
</li>
<li>
<p>参数 -m state --state<br>
范例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>说明： 用来比对联机状态，联机状态共有四种：<code>INVALID</code>、<code>ESTABLISHED</code>、<code>NEW</code> 和 <code>RELATED</code>。</p>
</blockquote>
</li>
<li>
<p><code>iptables -L -n -v</code>  可以查看计数器<br>
<code>INVALID</code> 表示该数据包的联机编号（Session ID）无法辨识或编号不正确。<code>ESTABLISHED</code> 表示该数据包属于某个已经建立的联机。<code>NEW</code> 表示该数据包想要起始一个联机（重设联机或将联机重导向）。<code>RELATED</code> 表示该数据包是属于某个已经建立的联机，所建立的新联机。例如：<code>FTP-DATA</code> 联机必定是源自某个 FTP 联机。</p>
</li>
</ol>
<h3 id="常用的处理动作"><a class="header-anchor" href="#常用的处理动作">¶</a>常用的处理动作</h3>
<p>-j 参数用来指定要进行的处理动作，常用的处理动作包括：<code>ACCEPT</code>、<code>REJECT</code>、<code>DROP</code>、<code>REDIRECT</code>、<code>MASQUERADE</code>、<code>LOG</code>、<code>DNAT</code>、<code>SNAT</code>、<code>MIRROR</code>、<code>QUEUE</code>、<code>RETURN</code>、<code>MARK</code>。</p>
<p>分别说明如下：</p>
<p><strong>ACCEPT</strong> 将数据包放行，进行完此处理动作后，将不再比对其它规则，直接跳往下一个规则链（<code>NAT</code>:<code>POSTROUTING</code>）。</p>
<p><strong>REJECT</strong> 拦阻该数据包，并传送数据包通知对方，可以传送的数据包有几个选择：<code>ICMP port-unreachable</code>、<code>ICMP echo-reply</code> 或是<code>tcp-reset</code>（这个数据包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接 中断过滤程序。 范例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A FORWARD -p TCP --dport 22 -j REJECT --reject-with tcp-reset<br></code></pre></div></td></tr></table></figure>
<p><strong>DROP</strong> 丢弃包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</p>
<p><strong>REDIRECT</strong> 将包重新导向到另一个端口（PNAT），进行完此处理动作后，将会继续比对其它规则。 这个功能可以用来实作通透式porxy 或用来保护 web 服务器。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080<br></code></pre></div></td></tr></table></figure>
<p><strong>MASQUERADE</strong> 改写数据包来源 IP为防火墙 NIC IP，可以指定 port 对应的范围，进行完此处理动作后，直接跳往下一个规则（<code>MANGLE</code>:<code>POSTROUTING</code>）。这个功能与 <code>SNAT</code> 略有不同，当进行 IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读取，当使用拨号连接时，IP 通常是由 ISP 公司的 DHCP 服务器指派的，这个时候 <code>MASQUERADE</code> 特别有用。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE --to-ports 1024-31000<br></code></pre></div></td></tr></table></figure>
<p><strong>LOG</strong> 将封包相关讯息纪录在 <code>/var/log</code> 中，详细位置请查阅 <code>/etc/syslog.conf</code> 配置文件，进行完此处理动作后，将会继续比对其规则。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -A INPUT -p tcp -j LOG --<span class="hljs-built_in">log</span>-prefix <span class="hljs-string">"INPUT packets"</span><br></code></pre></div></td></tr></table></figure>
<p><strong>SNAT</strong> 改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将直接跳往下一个规则（<code>MANGLE</code>:<code>POSTROUTING</code>）。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT --to-source 194.236.50.155-194.236.50.160:1024-32000<br></code></pre></div></td></tr></table></figure>
<p><strong>DNAT</strong> 改写封包目的地 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将会直接跳往下一个规炼（<code>FILTER</code>:<code>INPUT</code> 或 <code>FILTER</code>:<code>FORWARD</code>）。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 --dport 80 -j DNAT --to-destination<br>192.168.1.1-192.168.1.10:80-100<br></code></pre></div></td></tr></table></figure>
<p><strong>MIRROR</strong> 镜像数据包，也就是将来源 IP 与目的地 IP 对调后，将数据包送回，进行完此处理动作后，将会中断过滤程序。</p>
<p><strong>QUEUE</strong> 中断过滤程序，将数据包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，例如：计算联机费…等。</p>
<p><strong>RETURN</strong> 结束在目前规则链中的过滤程序，返回主规则链继续过滤，如果把自订规则链看成是一个子程序，那么这个动作，就相当提早结束子程序并返回到主程序中。</p>
<p><strong>MARK</strong> 将数据包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。范例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --<span class="hljs-built_in">set</span>-mark 2<br></code></pre></div></td></tr></table></figure>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>bash 教程</title>
    <url>/2018/10/30/Shell%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1>Shell教程</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="Shell-变量"><a class="header-anchor" href="#Shell-变量">¶</a>Shell 变量</h2>
<ul>
<li><font color=red><strong>变量名和等号之间不能有空格。</strong></font></li>
<li>定义变量时，变量名不加美元符号（$，PHP语言中变量需要）。</li>
<li>使用一个定义过的变量，只要在变量名前面加美元符号即可。</li>
<li>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> skill <span class="hljs-keyword">in</span> Ada Coffe Action Java; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"I am good at <span class="hljs-variable">$&#123;skill&#125;</span>Script"</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>
<h3 id="只读变量"><a class="header-anchor" href="#只读变量">¶</a>只读变量</h3>
<p>使用<code>readonly</code>命令可以将变量 定义为只读变量，只读变量的值不能被改变。<br>
下面的例子尝试更改只读变量，结果报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>myUrl=<span class="hljs-string">"http://www.google.com"</span><br><span class="hljs-built_in">readonly</span> myUrl<br>myUrl=<span class="hljs-string">"http://www.runoob.com"</span><br></code></pre></div></td></tr></table></figure>
<p>运行脚本，结果如下：</p>
<blockquote>
<p>/bin/sh: NAME: This variable is read only.</p>
</blockquote>
<h3 id="删除变量"><a class="header-anchor" href="#删除变量">¶</a>删除变量</h3>
<p>使用<code>unset</code>命令可以删除变量。语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">unset</span> variable_name<br></code></pre></div></td></tr></table></figure>
<p><strong><code>unset</code>命令不能删除只读变量。</strong></p>
<h3 id="变量类型"><a class="header-anchor" href="#变量类型">¶</a>变量类型</h3>
<p>运行shell时，会同时存在三种变量：</p>
<ol>
<li><strong>局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell中有效，其它shell启动的程序不能访问局部变量。</li>
<li><strong>环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
<li><strong>shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。</li>
</ol>
<hr>
<h2 id="Shell字符串"><a class="header-anchor" href="#Shell字符串">¶</a>Shell字符串</h2>
<ul>
<li>
<p>字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
</li>
<li>
<p><font color=red><strong>单引号把内容当成纯文本，不会经过翻译。而双引号则与此相反。里面的内容会经过处理。</strong></font>举个简单的例子：</p>
  <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$foo</span>=<span class="hljs-string">"data"</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">'$foo'</span>    <span class="hljs-comment">#单引号输出$foo</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$foo</span>"</span>    <span class="hljs-comment">#双引号输出data</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>单引号不能处理变量和黑底字符<font color=red><strong>（除了\\和\'这两个）</strong></font></p>
</li>
</ul>
<h3 id="单引号"><a class="header-anchor" href="#单引号">¶</a>单引号</h3>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li><font color=red><strong>单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</strong></font></li>
</ul>
<h3 id="双引号"><a class="header-anchor" href="#双引号">¶</a>双引号</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">your_name=<span class="hljs-string">'runoob'</span><br>str=<span class="hljs-string">"Hello, I know you are \"<span class="hljs-variable">$your_name</span>\"! \n"</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$str</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果为：</p>
<blockquote>
<p>Hello, I know you are “runoob”!</p>
</blockquote>
<p>双绰号的优点：</p>
<ul>
<li>双引号里可以有变量。</li>
<li>双引号里可以出现转义字符。</li>
</ul>
<h3 id="拼接字符串"><a class="header-anchor" href="#拼接字符串">¶</a>拼接字符串</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">your_name=<span class="hljs-string">"runoob"</span><br><span class="hljs-comment">#使用双引号</span><br>greeting=<span class="hljs-string">"hello, "</span><span class="hljs-variable">$your_name</span><span class="hljs-string">" !"</span><br>greeting_1=<span class="hljs-string">"hello, <span class="hljs-variable">$&#123;your_name&#125;</span> !"</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$greeting</span> <span class="hljs-variable">$greeting_1</span><br><span class="hljs-comment">#使用单引号拼接</span><br>greeting_2=<span class="hljs-string">'hello, '</span><span class="hljs-variable">$your_name</span><span class="hljs-string">' !'</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果为：</p>
<blockquote>
<p>hello, runoob ! hello, runob !<br>
hello, runoob ! hello, ${your_name} !</p>
</blockquote>
<h3 id="获取字符串长度"><a class="header-anchor" href="#获取字符串长度">¶</a>获取字符串长度</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">string=<span class="hljs-string">"abcd"</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#string&#125;</span> <span class="hljs-comment">#输出4</span><br></code></pre></div></td></tr></table></figure>
<h3 id="提取子字符串"><a class="header-anchor" href="#提取子字符串">¶</a>提取子字符串</h3>
<p>以下实例从字符串第2个字符开始截取4个字符：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">string=<span class="hljs-string">"runoob is a great site"</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;string:1:4&#125;</span> <span class="hljs-comment">#输出unoo</span><br></code></pre></div></td></tr></table></figure>
<h3 id="查找子字符串"><a class="header-anchor" href="#查找子字符串">¶</a>查找子字符串</h3>
<p>查找字符i或o的位置（哪个字母先出现就计算哪个）：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">string=<span class="hljs-string">"runoob is a great site"</span><br><span class="hljs-built_in">echo</span> `expr index <span class="hljs-string">"<span class="hljs-variable">$string</span>"</span> io`<br></code></pre></div></td></tr></table></figure>
<hr>
<h2 id="Shell数组"><a class="header-anchor" href="#Shell数组">¶</a>Shell数组</h2>
<p>bash不支持多维数组。</p>
<h3 id="定义数组"><a class="header-anchor" href="#定义数组">¶</a>定义数组</h3>
<p>在shell中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">数组名=(值1 值2 ... 值n)<br></code></pre></div></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">array_name=(value0 value1 value2 value3)<br></code></pre></div></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">array_name=(<br>value0<br>value1<br>value2<br>value3<br>)<br></code></pre></div></td></tr></table></figure>
<p>还可以单独定义数组的各个分量：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">array_name[0]=value0<br>array_name[1]=value1<br>array_name[2]=value2<br></code></pre></div></td></tr></table></figure>
<p>可以不使用连续的下标，而且下标的范围没有限制。</p>
<h3 id="读取数组"><a class="header-anchor" href="#读取数组">¶</a>读取数组</h3>
<p>读取数组元素值的一般格式是：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;数组名[下标]&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">valuen=<span class="hljs-variable">$&#123;array_name[n]&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>可以使用<code>@</code>符号可以获取数组中的所有元素，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array_name[@]&#125;</span><br></code></pre></div></td></tr></table></figure>
<h3 id="获取数组的长度"><a class="header-anchor" href="#获取数组的长度">¶</a>获取数组的长度</h3>
<p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#取得数组元素的个数</span><br>length=<span class="hljs-variable">$&#123;#array_name[@]&#125;</span><br><span class="hljs-comment">#或者</span><br>length=<span class="hljs-variable">$&#123;#array_name[*]&#125;</span><br><span class="hljs-comment">#取得数组单个元素的长度</span><br>lengthn=<span class="hljs-variable">$&#123;#array_name[n]&#125;</span><br></code></pre></div></td></tr></table></figure>
<hr>
<h2 id="Shell注释"><a class="header-anchor" href="#Shell注释">¶</a>Shell注释</h2>
<h3 id="多行注释"><a class="header-anchor" href="#多行注释">¶</a>多行注释</h3>
<ul>
<li>
<p>用一对花括号括起来。</p>
</li>
<li>
<p>定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p>
</li>
<li>
<p>还可以使用以下格式：</p>
  <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">:&lt;&lt;EOF<br>注释内容...<br>注释内容...<br>注释内容...<br>EOF<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<p>EOF也可以使用其它符号：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">:&lt;&lt;<span class="hljs-string">'</span><br><span class="hljs-string">注释内容...</span><br><span class="hljs-string">注释内容...</span><br><span class="hljs-string">注释内容...</span><br><span class="hljs-string">'</span><br><br>:&lt;&lt;!<br>注释内容...<br>注释内容...<br>注释内容<br>!<br></code></pre></div></td></tr></table></figure>
<hr>
<h2 id="Shell传递参数"><a class="header-anchor" href="#Shell传递参数">¶</a>Shell传递参数</h2>
<p>脚本内获取参数的格式为：<code>$n</code>。n代表一个数字，1为执行脚本的第一个参数，2为执行脚本的第二个参数，以此类推……</p>
<h3 id="实例"><a class="header-anchor" href="#实例">¶</a>实例</h3>
<p>以下实例我们向脚本传递三个参数，并分别输出，其中$0为执行的文件名：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">#author: 菜鸟教程</span><br><span class="hljs-comment">#url: www.runoob.com</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"Shell 传递参数实例！"</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"执行的文件名：<span class="hljs-variable">$0</span>"</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"第一个参数为：<span class="hljs-variable">$1</span>"</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"第二个参数为：<span class="hljs-variable">$2</span>"</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"第三个参数为：<span class="hljs-variable">$3</span>"</span>;<br></code></pre></div></td></tr></table></figure>
<p>为脚本设置可以执行权限，并执行脚本，输出结果如下所示：</p>
<blockquote>
<p>$ chmod +x <a href="http://test.sh" target="_blank" rel="noopener">test.sh</a><br>
$ ./test.sh 1 2 3<br>
Shell传递参数实例！<br>
执行的文件名：./test.sh<br>
第一个参数为：1<br>
第二个参数为：2<br>
第三个参数为：3</p>
</blockquote>
<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数处理</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$#</td>
<td style="text-align:left">传递到脚本的参数个数</td>
</tr>
<tr>
<td style="text-align:left">$^</td>
<td style="text-align:left">以一个单字符串显示所有向脚本传递的参数。<br>如&quot;$*“用「”」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。</td>
</tr>
<tr>
<td style="text-align:left">$$</td>
<td style="text-align:left">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td style="text-align:left">$!</td>
<td style="text-align:left">后台运行的最后一个进程ID号</td>
</tr>
<tr>
<td style="text-align:left">$@</td>
<td style="text-align:left">与$*相同，但是使用时加引号，并在引号中返回每个参数。<br>如&quot;$@“用「”」括起来的情况、以&quot;$1&quot; “$2” … &quot;$n&quot;的形式输出所有参数。</td>
</tr>
<tr>
<td style="text-align:left">$-</td>
<td style="text-align:left">显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td style="text-align:left">$?</td>
<td style="text-align:left">显示最后命令的退出状态。0表示没有错误，其它任何值表明有错误。</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">#author: 菜鸟教程</span><br><span class="hljs-comment">#url: www.runoob.com</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"Shell传递参数实例！"</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"第一个参数为：<span class="hljs-variable">$1</span>"</span>;<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"参数个数为：<span class="hljs-variable">$#</span>"</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"传递的参数作为一个字符串显示：$*"</span>;<br></code></pre></div></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>$ chmod +x <a href="http://test.sh" target="_blank" rel="noopener">test.sh</a><br>
./test/sh 1 2 3<br>
Shell传递参数实例！<br>
第一个参数为：1<br>
参数个数为：3<br>
传递参数作为一个字符串显示：1 2 3</p>
</blockquote>
<p><code>$*</code>与<code>$@</code>区别：</p>
<ul>
<li>相同点：都是引用所有参数。</li>
<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数1、2、3,则<code>$*</code>等价于“1 2 3”（传递了一个参数），而<code>$@</code>等价于&quot;1&quot; “2” “3”（传递了三个参数）。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">#author: 菜鸟教程</span><br><span class="hljs-comment">#url: www.runoob.com</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"-- \$* 演示 ---"</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">"$*"</span>; <span class="hljs-keyword">do</span><br>	<span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"-- \$@ 演示 ---"</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>; <span class="hljs-keyword">do</span><br>	<span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>
<hr>
<h2 id="Shell数组-v2"><a class="header-anchor" href="#Shell数组-v2">¶</a>Shell数组</h2>
<p>数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。<br>
与大部分编程语言类似，数组元素的下标由0开始。<br>
Shell 数组用括号来表示，元素用&quot;空格&quot;符号分割开，语法格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">array_name=(value1 ... valuen)<br></code></pre></div></td></tr></table></figure>
<h4 id="实例-v2"><a class="header-anchor" href="#实例-v2">¶</a>实例</h4>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br><br>my_array=(A B <span class="hljs-string">"C"</span> D)<br></code></pre></div></td></tr></table></figure>
<p>我们也可以使用下标来定义数组:</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">array_name[0]=value0<br>array_name[1]=value1<br>array_name[2]=value2<br></code></pre></div></td></tr></table></figure>
<h3 id="读取数组-v2"><a class="header-anchor" href="#读取数组-v2">¶</a>读取数组</h3>
<p>读取数组元素值的一般格式是：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;array_name[index]&#125;</span><br></code></pre></div></td></tr></table></figure>
<h4 id="实例-v3"><a class="header-anchor" href="#实例-v3">¶</a>实例</h4>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br><br>my_array=(A B <span class="hljs-string">"C"</span> D)<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"第一个元素为: <span class="hljs-variable">$&#123;my_array[0]&#125;</span>"</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"第二个元素为: <span class="hljs-variable">$&#123;my_array[1]&#125;</span>"</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"第三个元素为: <span class="hljs-variable">$&#123;my_array[2]&#125;</span>"</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"第四个元素为: <span class="hljs-variable">$&#123;my_array[3]&#125;</span>"</span><br></code></pre></div></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>$ chmod +x <a href="http://test.sh" target="_blank" rel="noopener">test.sh</a><br>
$ ./test.sh<br>
第一个元素为: A<br>
第二个元素为: B<br>
第三个元素为: C<br>
第四个元素为: D</p>
</blockquote>
<h3 id="获取数组中的所有元素"><a class="header-anchor" href="#获取数组中的所有元素">¶</a>获取数组中的所有元素</h3>
<p>使用<code>@</code> 或 <code>*</code> 可以获取数组中的所有元素，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br><br>my_array[0]=A<br>my_array[1]=B<br>my_array[2]=C<br>my_array[3]=D<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"数组的元素为: <span class="hljs-variable">$&#123;my_array[*]&#125;</span>"</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"数组的元素为: <span class="hljs-variable">$&#123;my_array[@]&#125;</span>"</span><br></code></pre></div></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>$ chmod +x <a href="http://test.sh" target="_blank" rel="noopener">test.sh</a><br>
$ ./test.sh<br>
数组的元素为: A B C D<br>
数组的元素为: A B C D</p>
</blockquote>
<h3 id="获取数组的长度-v2"><a class="header-anchor" href="#获取数组的长度-v2">¶</a>获取数组的长度</h3>
<p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br><br>my_array[0]=A<br>my_array[1]=B<br>my_array[2]=C<br>my_array[3]=D<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"数组元素个数为: <span class="hljs-variable">$&#123;#my_array[*]&#125;</span>"</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"数组元素个数为: <span class="hljs-variable">$&#123;#my_array[@]&#125;</span>"</span><br></code></pre></div></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>$ chmod +x <a href="http://test.sh" target="_blank" rel="noopener">test.sh</a><br>
$ ./test.sh<br>
数组元素个数为: 4<br>
数组元素个数为: 4</p>
</blockquote>
<hr>
<h2 id="Shell-基本运算符"><a class="header-anchor" href="#Shell-基本运算符">¶</a>Shell 基本运算符</h2>
<p>Shell 和其他编程语言一样，支持多种运算符，包括：</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符</li>
</ul>
<p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 <code>awk</code> 和 <code>expr</code>，<code>expr</code> 最常用。<br>
<code>expr</code> 是一款表达式计算工具，使用它能完成表达式的求值操作。<br>
例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ')：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>val=`expr 2 + 2`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"两数之和为 : <span class="hljs-variable">$val</span>"</span><br></code></pre></div></td></tr></table></figure>
<p><a href="http://www.runoob.com/try/runcode.php?filename=add2data&amp;type=bash" target="_blank" rel="noopener">运行实例 »</a></p>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>两数之和为 : 4</p>
</blockquote>
<p>两点注意：</p>
<ul>
<li><font color=red><strong>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</strong></font></li>
<li>完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li>
</ul>
<h3 id="算术运算符"><a class="header-anchor" href="#算术运算符">¶</a>算术运算符</h3>
<p>下表列出了常用的算术运算符，假定变量 <code>a</code> 为 10，变量 <code>b</code> 为 20：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">加法</td>
<td style="text-align:left">`expr $a + $b` 结果为 30。</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">减法</td>
<td style="text-align:left">`expr $a - $b` 结果为 -10。</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">乘法</td>
<td style="text-align:left">`expr $a * $b` 结果为  200。</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:left">除法</td>
<td style="text-align:left">`expr $b / $a` 结果为 2。</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">取余</td>
<td style="text-align:left">`expr $b % $a` 结果为 0。</td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">赋值</td>
<td style="text-align:left">a=$b 将把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">相等。用于比较两个数字，相同则返回 <code>true。</code></td>
<td style="text-align:left">[ $a == $b ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">不相等。用于比较两个数字，不相同则返回 <code>true</code>。</td>
<td style="text-align:left">[ $a != $b ] 返回 <code>true</code>。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：<strong>条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成<font color=red></strong>[ $a == $b ]</strong></font>。</p>
</blockquote>
<h4 id="实例-v4"><a class="header-anchor" href="#实例-v4">¶</a>实例</h4>
<p>算术运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br><br>a=10<br>b=20<br><br>val=`expr <span class="hljs-variable">$a</span> + <span class="hljs-variable">$b</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"a + b : <span class="hljs-variable">$val</span>"</span><br><br>val=`expr <span class="hljs-variable">$a</span> - <span class="hljs-variable">$b</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"a - b : <span class="hljs-variable">$val</span>"</span><br><br>val=`expr <span class="hljs-variable">$a</span> \* <span class="hljs-variable">$b</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"a * b : <span class="hljs-variable">$val</span>"</span><br><br>val=`expr <span class="hljs-variable">$b</span> / <span class="hljs-variable">$a</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"b / a : <span class="hljs-variable">$val</span>"</span><br><br>val=`expr <span class="hljs-variable">$b</span> % <span class="hljs-variable">$a</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"b % a : <span class="hljs-variable">$val</span>"</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> == <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"a 等于 b"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"a 不等于 b"</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>a + b : 30<br>
a - b : -10<br>
a * b : 200<br>
b / a : 2<br>
b % a : 0<br>
a 不等于 b</p>
</blockquote>
<hr>
<blockquote>
<p>注意：</p>
<ul>
<li><font color=red><strong>乘号(*)前边必须加反斜杠(\)才能实现乘法运算</strong></font>；</li>
<li><code>if</code>…<code>then.</code>…<code>fi</code> 是条件语句，后续将会讲解。</li>
<li>在 MAC 中 shell 的 <code>expr</code> 语法是：<code>$((表达式))</code>，此处表达式中的 “*” 不需要转义符号 “” 。</li>
</ul>
</blockquote>
<h3 id="关系运算符"><a class="header-anchor" href="#关系运算符">¶</a>关系运算符</h3>
<p><font color=red><strong>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</strong></font></p>
<p>下表列出了常用的关系运算符，假定变量 <code>a</code> 为 10，变量 <code>b</code> 为 20：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-eq</td>
<td style="text-align:left">检测两个数是否相等，相等返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -eq $b ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-ne</td>
<td style="text-align:left">检测两个数是否不相等，不相等返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -ne $b ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-gt</td>
<td style="text-align:left">检测左边的数是否大于右边的，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -gt $b ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-lt</td>
<td style="text-align:left">检测左边的数是否小于右边的，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -lt $b ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-ge</td>
<td style="text-align:left">检测左边的数是否大于等于右边的，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -ge $b ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-le</td>
<td style="text-align:left">检测左边的数是否小于等于右边的，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -le $b ] 返回 <code>true</code>。</td>
</tr>
</tbody>
</table>
<h4 id="实例-v5"><a class="header-anchor" href="#实例-v5">¶</a>实例</h4>
<p>关系运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br><br>a=10<br>b=20<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -eq <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> -eq <span class="hljs-variable">$b</span> : a 等于 b"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> -eq <span class="hljs-variable">$b</span>: a 不等于 b"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -ne <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> -ne <span class="hljs-variable">$b</span>: a 不等于 b"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> -ne <span class="hljs-variable">$b</span> : a 等于 b"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span>: a 大于 b"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span>: a 不大于 b"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span>: a 小于 b"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span>: a 不小于 b"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -ge <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> -ge <span class="hljs-variable">$b</span>: a 大于或等于 b"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> -ge <span class="hljs-variable">$b</span>: a 小于 b"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -le <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> -le <span class="hljs-variable">$b</span>: a 小于或等于 b"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> -le <span class="hljs-variable">$b</span>: a 大于 b"</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>10 -eq 20: a 不等于 b<br>
10 -ne 20: a 不等于 b<br>
10 -gt 20: a 不大于 b<br>
10 -lt 20: a 小于 b<br>
10 -ge 20: a 小于 b<br>
10 -le 20: a 小于或等于 b</p>
</blockquote>
<h3 id="布尔运算符"><a class="header-anchor" href="#布尔运算符">¶</a>布尔运算符</h3>
<p>下表列出了常用的布尔运算符，假定变量 <code>a</code> 为 10，变量 <code>b</code> 为 20：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">!</td>
<td style="text-align:left">非运算，表达式为 <code>true</code> 则返回 <code>false</code>，否则返回 <code>true</code>。</td>
<td style="text-align:left">[ ! false ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-o</td>
<td style="text-align:left">或运算，有一个表达式为 <code>true</code> 则返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -lt 20 -o $b -gt 100 ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-a</td>
<td style="text-align:left">与运算，两个表达式都为 <code>true</code> 才返回 <code>true</code>。</td>
<td style="text-align:left">[ $a -lt 20 -a $b -gt 100 ] 返回 <code>false</code>。</td>
</tr>
</tbody>
</table>
<h4 id="实例-v6"><a class="header-anchor" href="#实例-v6">¶</a>实例</h4>
<p>布尔运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br><br>a=10<br>b=20<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> : a 不等于 b"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span>: a 等于 b"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -lt 100 -a <span class="hljs-variable">$b</span> -gt 15 ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> 小于 100 且 <span class="hljs-variable">$b</span> 大于 15 : 返回 true"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> 小于 100 且 <span class="hljs-variable">$b</span> 大于 15 : 返回 false"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -lt 100 -o <span class="hljs-variable">$b</span> -gt 100 ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> 小于 100 或 <span class="hljs-variable">$b</span> 大于 100 : 返回 true"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> 小于 100 或 <span class="hljs-variable">$b</span> 大于 100 : 返回 false"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -lt 5 -o <span class="hljs-variable">$b</span> -gt 100 ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> 小于 5 或 <span class="hljs-variable">$b</span> 大于 100 : 返回 true"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> 小于 5 或 <span class="hljs-variable">$b</span> 大于 100 : 返回 false"</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>10 != 20 : a 不等于 b<br>
10 小于 100 且 20 大于 15 : 返回 true<br>
10 小于 100 或 20 大于 100 : 返回 true<br>
10 小于 5 或 20 大于 100 : 返回 false</p>
</blockquote>
<h3 id="逻辑运算符"><a class="header-anchor" href="#逻辑运算符">¶</a>逻辑运算符</h3>
<p>以下介绍 Shell 的逻辑运算符，假定变量 <code>a</code> 为 10，变量 <code>b</code> 为 20:</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&amp;&amp;</td>
<td style="text-align:left">逻辑的 AND</td>
<td style="text-align:left">[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 <code>false</code></td>
</tr>
<tr>
<td style="text-align:left">||</td>
<td style="text-align:left">逻辑的 OR</td>
<td style="text-align:left">[[ $a -lt 100 || $b -gt 100 ]] 返回 <code>true</code></td>
</tr>
</tbody>
</table>
<h4 id="实例-v7"><a class="header-anchor" href="#实例-v7">¶</a>实例</h4>
<p>逻辑运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br><br>a=10<br>b=20<br><br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$a</span> -lt 100 &amp;&amp; <span class="hljs-variable">$b</span> -gt 100 ]]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"返回 true"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"返回 false"</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$a</span> -lt 100 || <span class="hljs-variable">$b</span> -gt 100 ]]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"返回 true"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"返回 false"</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>返回 false<br>
返回 true</p>
</blockquote>
<h3 id="字符串运算符"><a class="header-anchor" href="#字符串运算符">¶</a>字符串运算符</h3>
<p>下表列出了常用的字符串运算符，假定变量 <code>a</code> 为 “abc”，变量 <code>b</code> 为 “efg”：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">检测两个字符串是否相等，相等返回 <code>true</code>。</td>
<td style="text-align:left">[ $a = $b ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">检测两个字符串是否相等，不相等返回 <code>true</code>。</td>
<td style="text-align:left">[ $a != $b ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-z</td>
<td style="text-align:left">检测字符串长度是否为0，为0返回 <code>true</code>。</td>
<td style="text-align:left">[ -z $a ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-n</td>
<td style="text-align:left">检测字符串长度是否为0，不为0返回 <code>true</code>。</td>
<td style="text-align:left">[ -n “$a” ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">str</td>
<td style="text-align:left">检测字符串是否为空，不为空返回 <code>true</code>。</td>
<td style="text-align:left">[ $a ] 返回 <code>true</code>。</td>
</tr>
</tbody>
</table>
<h4 id="实例-v8"><a class="header-anchor" href="#实例-v8">¶</a>实例</h4>
<p>字符串运算符实例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br><br>a=<span class="hljs-string">"abc"</span><br>b=<span class="hljs-string">"efg"</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> = <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> = <span class="hljs-variable">$b</span> : a 等于 b"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> = <span class="hljs-variable">$b</span>: a 不等于 b"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> : a 不等于 b"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span>: a 等于 b"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-variable">$a</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"-z <span class="hljs-variable">$a</span> : 字符串长度为 0"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"-z <span class="hljs-variable">$a</span> : 字符串长度不为 0"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">"<span class="hljs-variable">$a</span>"</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"-n <span class="hljs-variable">$a</span> : 字符串长度不为 0"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"-n <span class="hljs-variable">$a</span> : 字符串长度为 0"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> : 字符串不为空"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$a</span> : 字符串为空"</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>abc = efg: a 不等于 b<br>
abc != efg : a 不等于 b<br>
-z abc : 字符串长度不为 0<br>
-n abc : 字符串长度不为 0<br>
abc : 字符串不为空</p>
</blockquote>
<h3 id="文件测试运算符"><a class="header-anchor" href="#文件测试运算符">¶</a>文件测试运算符</h3>
<p>文件测试运算符用于检测 Unix 文件的各种属性。<br>
属性检测描述如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-b file</td>
<td style="text-align:left">检测文件是否是块设备文件，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -b $file ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-c file</td>
<td style="text-align:left">检测文件是否是字符设备文件，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -c $file ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-d file</td>
<td style="text-align:left">检测文件是否是目录，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -d $file ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-f file</td>
<td style="text-align:left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -f $file ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-g file</td>
<td style="text-align:left">检测文件是否设置了 <code>SGID</code> 位，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -g $file ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-k file</td>
<td style="text-align:left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -k $file ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-p file</td>
<td style="text-align:left">检测文件是否是有名管道，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -p $file ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-u file</td>
<td style="text-align:left">检测文件是否设置了 <code>SUID</code> 位，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -u $file ] 返回 <code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left">-r file</td>
<td style="text-align:left">检测文件是否可读，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -r $file ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-w file</td>
<td style="text-align:left">检测文件是否可写，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -w $file ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-x file</td>
<td style="text-align:left">检测文件是否可执行，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -x $file ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-s file</td>
<td style="text-align:left">检测文件是否为空（文件大小是否大于0），不为空返回 <code>true</code>。</td>
<td style="text-align:left">[ -s $file ] 返回 <code>true</code>。</td>
</tr>
<tr>
<td style="text-align:left">-e file</td>
<td style="text-align:left">检测文件（包括目录）是否存在，如果是，则返回 <code>true</code>。</td>
<td style="text-align:left">[ -e $file ] 返回 <code>true</code>。</td>
</tr>
</tbody>
</table>
<h4 id="实例-v9"><a class="header-anchor" href="#实例-v9">¶</a>实例</h4>
<p>变量 file 表示文件&quot;/var/www/runoob/test.sh&quot;，它的大小为100字节，具有 <code>rwx</code> 权限。下面的代码，将检测该文件的各种属性：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br><br>file=<span class="hljs-string">"/var/www/runoob/test.sh"</span><br><span class="hljs-keyword">if</span> [ -r <span class="hljs-variable">$file</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"文件可读"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"文件不可读"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -w <span class="hljs-variable">$file</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"文件可写"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"文件不可写"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -x <span class="hljs-variable">$file</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"文件可执行"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"文件不可执行"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -f <span class="hljs-variable">$file</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"文件为普通文件"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"文件为特殊文件"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-variable">$file</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"文件是个目录"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"文件不是个目录"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -s <span class="hljs-variable">$file</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"文件不为空"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"文件为空"</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ -e <span class="hljs-variable">$file</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"文件存在"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"文件不存在"</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>文件可读<br>
文件可写<br>
文件可执行<br>
文件为普通文件<br>
文件不是个目录<br>
文件不为空<br>
文件存在</p>
</blockquote>
<hr>
<h2 id="Shell-echo命令"><a class="header-anchor" href="#Shell-echo命令">¶</a>Shell echo命令</h2>
<p>Shell 的 <code>echo</code> 指令与 PHP 的 <code>echo</code> 指令类似，都是用于字符串的输出。命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> string<br></code></pre></div></td></tr></table></figure>
<p>您可以使用<code>echo</code>实现更复杂的输出格式控制。</p>
<h3 id="1-显示普通字符串"><a class="header-anchor" href="#1-显示普通字符串">¶</a>1. 显示普通字符串:</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"It is a test"</span><br></code></pre></div></td></tr></table></figure>
<p>这里的双引号完全可以省略，以下命令与上面实例效果一致：</p>
<blockquote>
<p>echo It is a test</p>
</blockquote>
<h3 id="2-显示转义字符"><a class="header-anchor" href="#2-显示转义字符">¶</a>2. 显示转义字符</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"\"It is a test\""</span><br></code></pre></div></td></tr></table></figure>
<p>结果将是:</p>
<blockquote>
<p>“It is a test”</p>
</blockquote>
<p>同样，双引号也可以省略</p>
<h3 id="3-显示变量"><a class="header-anchor" href="#3-显示变量">¶</a>3. 显示变量</h3>
<p><code>read</code> 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-built_in">read</span> name <br><span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$name</span> It is a test"</span><br></code></pre></div></td></tr></table></figure>
<p>以上代码保存为 <a href="http://test.sh" target="_blank" rel="noopener">test.sh</a>，<code>name</code> 接收标准输入的变量，结果将是:</p>
<blockquote>
<p>[root@www ~]# sh <a href="http://test.sh" target="_blank" rel="noopener">test.sh</a><br>
OK                     #标准输入<br>
OK It is a test        #输出</p>
</blockquote>
<h3 id="4-显示换行"><a class="header-anchor" href="#4-显示换行">¶</a>4. 显示换行</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">"OK! \n"</span> <span class="hljs-comment"># -e 开启转义</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"It is a test"</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>OK!</p>
</blockquote>
<blockquote>
<p>It is a test</p>
</blockquote>
<h3 id="5-显示不换行"><a class="header-anchor" href="#5-显示不换行">¶</a>5. 显示不换行</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">"OK! \c"</span> <span class="hljs-comment"># -e 开启转义 \c 不换行</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"It is a test"</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>OK! It is a test</p>
</blockquote>
<h3 id="6-显示结果定向至文件"><a class="header-anchor" href="#6-显示结果定向至文件">¶</a>6. 显示结果定向至文件</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"It is a test"</span> &gt; myfile<br></code></pre></div></td></tr></table></figure>
<h3 id="7-原样输出字符串，不进行转义或取变量-用单引号"><a class="header-anchor" href="#7-原样输出字符串，不进行转义或取变量-用单引号">¶</a>7. 原样输出字符串，不进行转义或取变量(用单引号)</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">'$name\"'</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>$name&quot;</p>
</blockquote>
<h3 id="8-显示命令执行结果"><a class="header-anchor" href="#8-显示命令执行结果">¶</a>8. 显示命令执行结果</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> `date`<br></code></pre></div></td></tr></table></figure>
<p><strong>注意：</strong> 这里使用的是反引号 `, 而不是单引号 '。</p>
<p>结果将显示当前日期</p>
<blockquote>
<p>Thu Jul 24 10:08:46 CST 2014</p>
</blockquote>
<hr>
<h2 id="Shell-printf-命令"><a class="header-anchor" href="#Shell-printf-命令">¶</a>Shell printf 命令</h2>
<p>上一章节我们学习了 Shell 的 <code>echo</code> 命令，本章节我们来学习 Shell 的另一个输出命令 <code>printf</code>。<br>
<code>printf</code> 命令模仿 C 程序库（library）里的 <code>printf()</code> 程序。<br>
<code>printf</code> 由 POSIX 标准所定义，因此使用 <code>printf</code> 的脚本比使用 <code>echo</code> 移植性好。<br>
<code>printf</code> 使用引用文本或空格分隔的参数，外面可以在 <code>printf</code> 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 <code>printf</code> 不会像 <code>echo</code> 自动添加换行符，我们可以手动添加 <code>\n</code>。<br>
<code>printf</code> 命令的语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">printf</span>  format-string  [arguments...]<br></code></pre></div></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>format-string: 为格式控制字符串</li>
<li>arguments: 为参数列表。</li>
</ul>
<p>实例如下：</p>
<blockquote>
<p>$ echo “Hello, Shell”<br>
Hello, Shell<br>
$ printf “Hello, Shell\n”<br>
Hello, Shell<br>
$</p>
</blockquote>
<p>接下来,我来用一个脚本来体现printf的强大功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br> <br><span class="hljs-built_in">printf</span> <span class="hljs-string">"%-10s %-8s %-4s\n"</span> 姓名 性别 体重kg  <br><span class="hljs-built_in">printf</span> <span class="hljs-string">"%-10s %-8s %-4.2f\n"</span> 郭靖 男 66.1234 <br><span class="hljs-built_in">printf</span> <span class="hljs-string">"%-10s %-8s %-4.2f\n"</span> 杨过 男 48.6543 <br><span class="hljs-built_in">printf</span> <span class="hljs-string">"%-10s %-8s %-4.2f\n"</span> 郭芙 女 47.9876<br></code></pre></div></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>姓名     性别   体重kg<br>
郭靖     男      66.12<br>
杨过     男      48.65<br>
郭芙     女      47.99</p>
</blockquote>
<p><code>%s</code> <code>%c</code> <code>%d</code> <code>%f</code>都是格式替代符<br>
<code>%-10s</code> 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。<br>
<code>%-4.2f</code> 指格式化为小数，其中.2指保留2位小数。</p>
<p>更多实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br> <br><span class="hljs-comment"># format-string为双引号</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">"%d %s\n"</span> 1 <span class="hljs-string">"abc"</span><br><br><span class="hljs-comment"># 单引号与双引号效果一样 </span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">'%d %s\n'</span> 1 <span class="hljs-string">"abc"</span> <br><br><span class="hljs-comment"># 没有引号也可以输出</span><br><span class="hljs-built_in">printf</span> %s abcdef<br><br><span class="hljs-comment"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用</span><br><span class="hljs-built_in">printf</span> %s abc def<br><br><span class="hljs-built_in">printf</span> <span class="hljs-string">"%s\n"</span> abc def<br><br><span class="hljs-built_in">printf</span> <span class="hljs-string">"%s %s %s\n"</span> a b c d e f g h i j<br><br><span class="hljs-comment"># 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替</span><br><span class="hljs-built_in">printf</span> <span class="hljs-string">"%s and %d \n"</span><br></code></pre></div></td></tr></table></figure>
<p>执行脚本，输出结果如下所示：</p>
<blockquote>
<p>1 abc<br>
1 abc<br>
abcdefabcdefabc<br>
def<br>
a b c<br>
d e f<br>
g h i<br>
j<br>
and 0</p>
</blockquote>
<h3 id="printf的转义序列"><a class="header-anchor" href="#printf的转义序列">¶</a><code>printf</code>的转义序列</h3>
<table>
<thead>
<tr>
<th style="text-align:left">序列</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\a</td>
<td style="text-align:left">警告字符，通常为ASCII的BEL字符</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">后退</td>
</tr>
<tr>
<td style="text-align:left">\c</td>
<td style="text-align:left">抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td>
</tr>
<tr>
<td style="text-align:left">\f</td>
<td style="text-align:left">换页（formfeed）</td>
</tr>
<tr>
<td style="text-align:left">\n</td>
<td style="text-align:left">换行</td>
</tr>
<tr>
<td style="text-align:left">\r</td>
<td style="text-align:left">回车（Carriage return）</td>
</tr>
<tr>
<td style="text-align:left">\t</td>
<td style="text-align:left">水平制表符</td>
</tr>
<tr>
<td style="text-align:left">\v</td>
<td style="text-align:left">垂直制表符</td>
</tr>
<tr>
<td style="text-align:left">\\</td>
<td style="text-align:left">一个字面上的反斜杠字符</td>
</tr>
<tr>
<td style="text-align:left">\ddd</td>
<td style="text-align:left">表示1到3位数八进制值的字符。仅在格式字符串中有效</td>
</tr>
<tr>
<td style="text-align:left">\0ddd</td>
<td style="text-align:left">表示1到3位的八进制值字符</td>
</tr>
</tbody>
</table>
<p>实例</p>
<blockquote>
<p>$ printf “a string, no processing:&lt;%s&gt;\n” “A\nB”<br>
a string, no processing:&lt;A\nB&gt;</p>
</blockquote>
<blockquote>
<p>$ printf “a string, no processing:&lt;%b&gt;\n” “A\nB”<br>
a string, no processing:<A
B></p>
</blockquote>
<blockquote>
<p>$ printf “<a href="http://www.runoob.com" target="_blank" rel="noopener">www.runoob.com</a> \a”<br>
<a href="http://www.runoob.com" target="_blank" rel="noopener">www.runoob.com</a> $                  #不换行</p>
</blockquote>
<hr>
<h2 id="Shell-test-命令"><a class="header-anchor" href="#Shell-test-命令">¶</a>Shell <code>test</code> 命令</h2>
<p>Shell中的 <code>test</code> 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>
<h3 id="数值测试"><a class="header-anchor" href="#数值测试">¶</a>数值测试</h3>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-eq</td>
<td style="text-align:left">等于则为真</td>
</tr>
<tr>
<td style="text-align:left">-ne</td>
<td style="text-align:left">不等于则为真</td>
</tr>
<tr>
<td style="text-align:left">-gt</td>
<td style="text-align:left">大于则为真</td>
</tr>
<tr>
<td style="text-align:left">-ge</td>
<td style="text-align:left">大于等于则为真</td>
</tr>
<tr>
<td style="text-align:left">-lt</td>
<td style="text-align:left">小于则为真</td>
</tr>
<tr>
<td style="text-align:left">-le</td>
<td style="text-align:left">小于等于则为真</td>
</tr>
</tbody>
</table>
<h4 id="实例演示："><a class="header-anchor" href="#实例演示：">¶</a>实例演示：</h4>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">num1=100<br>num2=100<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> $[num1] -eq $[num2]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">'两个数相等！'</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">'两个数不相等！'</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>两个数相等！</p>
</blockquote>
<p>代码中的 [] 执行基本的算数运算，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>a=5<br>b=6<br><br>result=$[a+b] <span class="hljs-comment"># 注意等号两边不能有空格</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">"result 为： <span class="hljs-variable">$result</span>"</span><br></code></pre></div></td></tr></table></figure>
<p>结果为:</p>
<blockquote>
<p>result 为： 11</p>
</blockquote>
<h3 id="字符串测试"><a class="header-anchor" href="#字符串测试">¶</a>字符串测试</h3>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">等于则为真</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">不相等则为真</td>
</tr>
<tr>
<td style="text-align:left">-z 字符串</td>
<td style="text-align:left">字符串的长度为零则为真</td>
</tr>
<tr>
<td style="text-align:left">-n 字符串</td>
<td style="text-align:left">字符串的长度不为零则为真</td>
</tr>
</tbody>
</table>
<p>实例演示：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">num1=<span class="hljs-string">"ru1noob"</span><br>num2=<span class="hljs-string">"runoob"</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> <span class="hljs-variable">$num1</span> = <span class="hljs-variable">$num2</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">'两个字符串相等!'</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">'两个字符串不相等!'</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>两个字符串不相等!</p>
</blockquote>
<h3 id="文件测试"><a class="header-anchor" href="#文件测试">¶</a>文件测试</h3>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-e 文件名</td>
<td style="text-align:left">如果文件存在则为真</td>
</tr>
<tr>
<td style="text-align:left">-r 文件名</td>
<td style="text-align:left">如果文件存在且可读则为真</td>
</tr>
<tr>
<td style="text-align:left">-w 文件名</td>
<td style="text-align:left">如果文件存在且可写则为真</td>
</tr>
<tr>
<td style="text-align:left">-x 文件名</td>
<td style="text-align:left">如果文件存在且可执行则为真</td>
</tr>
<tr>
<td style="text-align:left">-s 文件名</td>
<td style="text-align:left">如果文件存在且至少有一个字符则为真</td>
</tr>
<tr>
<td style="text-align:left">-d 文件名</td>
<td style="text-align:left">如果文件存在且为目录则为真</td>
</tr>
<tr>
<td style="text-align:left">-f 文件名</td>
<td style="text-align:left">如果文件存在且为普通文件则为真</td>
</tr>
<tr>
<td style="text-align:left">-c 文件名</td>
<td style="text-align:left">如果文件存在且为字符型特殊文件则为真</td>
</tr>
<tr>
<td style="text-align:left">-b 文件名</td>
<td style="text-align:left">如果文件存在且为块特殊文件则为真</td>
</tr>
</tbody>
</table>
<p>实例演示：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /bin<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> -e ./bash<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">'文件已存在!'</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">'文件不存在!'</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>文件已存在!</p>
</blockquote>
<p>另外，Shell还提供了与( <code>-a</code> )、或( <code>-o </code>)、非( <code>!</code> )三个逻辑操作符用于将测试条件连接起来，其优先级为：&quot;<code>!</code>“最高，”<code>-a</code>“次之，”<code>-o</code>&quot;最低。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /bin<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> -e ./notFile -o -e ./bash<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">'至少有一个文件存在!'</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">'两个文件都不存在'</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>至少有一个文件存在!</p>
</blockquote>
<hr>
<h2 id="Shell-流程控制"><a class="header-anchor" href="#Shell-流程控制">¶</a>Shell 流程控制</h2>
<p>和Java、PHP等语言不一样，sh的流程控制不可为空，如(以下为PHP流程控制写法)：</p>
<figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">"q"</span>])) &#123;<br>    search(q);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 不做任何事情</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在sh/bash里可不能这么写，如果<code>else</code>分支没有语句执行，就不要写这个<code>else</code>。</p>
<h3 id="if-else"><a class="header-anchor" href="#if-else">¶</a><code>if else</code></h3>
<h4 id="if"><a class="header-anchor" href="#if">¶</a><code>if</code></h4>
<p><code>if</code> 语句语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> condition<br><span class="hljs-keyword">then</span><br>    command1 <br>    command2<br>    ...<br>    commandN <br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>写成一行（适用于终端命令提示符）：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ $(ps -ef | grep -c <span class="hljs-string">"ssh"</span>) -gt 1 ]; <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">"true"</span>; <span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>末尾的<code>fi</code>就是<code>if</code>倒过来拼写，后面还会遇到类似的。</p>
<h4 id="if-else-v2"><a class="header-anchor" href="#if-else-v2">¶</a><code>if else</code></h4>
<p><code>if else</code> 语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> condition<br><span class="hljs-keyword">then</span><br>    command1 <br>    command2<br>    ...<br>    commandN<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<h4 id="if-else-if-else"><a class="header-anchor" href="#if-else-if-else">¶</a><code>if else-if else</code></h4>
<p><code>if else-if else</code> 语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> condition1<br><span class="hljs-keyword">then</span><br>    command1<br><span class="hljs-keyword">elif</span> condition2 <br><span class="hljs-keyword">then</span> <br>    command2<br><span class="hljs-keyword">else</span><br>    commandN<br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>以下实例判断两个变量是否相等：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">a=10<br>b=20<br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> == <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"a 等于 b"</span><br><span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"a 大于 b"</span><br><span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"a 小于 b"</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">"没有符合的条件"</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>a 小于 b</p>
</blockquote>
<p><code>if else</code>语句经常与<code>test</code>命令结合使用，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">num1=$[2*3]<br>num2=$[1+5]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> $[num1] -eq $[num2]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">'两个数字相等!'</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">'两个数字不相等!'</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>两个数字相等!</p>
</blockquote>
<h3 id="for-循环"><a class="header-anchor" href="#for-循环">¶</a><code>for</code> 循环</h3>
<p>与其他编程语言类似，Shell支持<code>for</code>循环。</p>
<p><code>for</code>循环一般格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> item1 item2 ... itemN<br><span class="hljs-keyword">do</span><br>    command1<br>    command2<br>    ...<br>    commandN<br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>
<p>写成一行：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> item1 item2 ... itemN; <span class="hljs-keyword">do</span> command1; command2… <span class="hljs-keyword">done</span>;<br></code></pre></div></td></tr></table></figure>
<p>当变量值在列表里，<code>for</code>循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的shell命令和语句。<code>in</code>列表可以包含替换、字符串和文件名。</p>
<p><code>in</code>列表是可选的，如果不用它，<code>for</code>循环使用命令行的位置参数。</p>
<p>例如，顺序输出当前列表中的数字：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> loop <span class="hljs-keyword">in</span> 1 2 3 4 5<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"The value is: <span class="hljs-variable">$loop</span>"</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>The value is: 1<br>
The value is: 2<br>
The value is: 3<br>
The value is: 4<br>
The value is: 5</p>
</blockquote>
<p>顺序输出字符串中的字符：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> str <span class="hljs-keyword">in</span> <span class="hljs-string">'This is a string'</span><br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$str</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>This is a string</p>
</blockquote>
<h3 id="while-语句"><a class="header-anchor" href="#while-语句">¶</a><code>while</code> 语句</h3>
<p><code>while</code>循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> condition<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>
<p>以下是一个基本的<code>while</code>循环，测试条件是：如果<code>int</code>小于等于5，那么条件返回真。<code>int</code>从0开始，每次循环处理时，<code>int</code>加1。运行上述脚本，返回数字1到5，然后终止。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>int=1<br><span class="hljs-keyword">while</span>(( <span class="hljs-variable">$int</span>&lt;=5 ))<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$int</span><br>    <span class="hljs-built_in">let</span> <span class="hljs-string">"int++"</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>
<p>运行脚本，输出：</p>
<blockquote>
<p>1<br>
2<br>
3<br>
4<br>
5<br>
使用中使用了 Bash <code>let</code> 命令，它用于执行一个或多个表达式，变量计算中不需要加上 <code>$</code> 来表示变量，具体可查阅：<a href="http://www.runoob.com/linux/linux-comm-let.html" target="_blank" rel="noopener">Bash let</a> 命令</p>
</blockquote>
<p>。<br>
while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<code>&lt;Ctrl-D&gt;</code>结束循环。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">'按下 &lt;CTRL-D&gt; 退出'</span><br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">'输入你最喜欢的网站名: '</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> FILM<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"是的！<span class="hljs-variable">$FILM</span> 是一个好网站"</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>
<p>运行脚本，输出类似下面：</p>
<blockquote>
<p>按下 <code>&lt;CTRL-D&gt;</code> 退出<br>
输入你最喜欢的网站名:菜鸟教程<br>
是的！菜鸟教程 是一个好网站</p>
</blockquote>
<h4 id="无限循环"><a class="header-anchor" href="#无限循环">¶</a>无限循环</h4>
<p>无限循环语法格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> :<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> (( ; ; ))<br></code></pre></div></td></tr></table></figure>
<h3 id="until-循环"><a class="header-anchor" href="#until-循环">¶</a><code>until</code> 循环</h3>
<p><code>until</code> 循环执行一系列命令直至条件为 <code>true</code> 时停止。<br>
<code>until</code> 循环与 <code>while</code> 循环在处理方式上刚好相反。<br>
一般 <code>while</code> 循环优于 <code>until</code> 循环，但在某些时候—也只是极少数情况下，<code>until</code> 循环更加有用。</p>
<p><code>until</code> 语法格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">until condition<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>
<p><code>condition</code> 一般为条件表达式，如果返回值为 <code>false</code>，则继续执行循环体内的语句，否则跳出循环。<br>
以下实例我们使用 <code>until</code> 命令来输出 0 ~ 9 的数字：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>a=0<br><br>until [ ! <span class="hljs-variable">$a</span> -lt 10 ]<br><span class="hljs-keyword">do</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span><br>   a=`expr <span class="hljs-variable">$a</span> + 1`<br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果为：</p>
<blockquote>
<p>0<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9</p>
</blockquote>
<h3 id="case"><a class="header-anchor" href="#case">¶</a><code>case</code></h3>
<p>Shell <code>case</code>语句为多选择语句。可以用<code>case</code>语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。<code>case</code>语句格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">case</span> 值 <span class="hljs-keyword">in</span><br>模式1)<br>    command1<br>    command2<br>    ...<br>    commandN<br>    ;;<br>模式2）<br>    command1<br>    command2<br>    ...<br>    commandN<br>    ;;<br><span class="hljs-keyword">esac</span><br></code></pre></div></td></tr></table></figure>
<p><code>case</code>工作方式如上所示。取值后面必须为单词<code>in</code>，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 <code>;;</code>。<br>
取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 <code>*</code> 捕获该值，再执行后面的命令。<br>
下面的脚本提示输入1到4，与每一种模式进行匹配：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">'输入 1 到 4 之间的数字:'</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">'你输入的数字为:'</span><br><span class="hljs-built_in">read</span> aNum<br><span class="hljs-keyword">case</span> <span class="hljs-variable">$aNum</span> <span class="hljs-keyword">in</span><br>    1)  <span class="hljs-built_in">echo</span> <span class="hljs-string">'你选择了 1'</span><br>    ;;<br>    2)  <span class="hljs-built_in">echo</span> <span class="hljs-string">'你选择了 2'</span><br>    ;;<br>    3)  <span class="hljs-built_in">echo</span> <span class="hljs-string">'你选择了 3'</span><br>    ;;<br>    4)  <span class="hljs-built_in">echo</span> <span class="hljs-string">'你选择了 4'</span><br>    ;;<br>    *)  <span class="hljs-built_in">echo</span> <span class="hljs-string">'你没有输入 1 到 4 之间的数字'</span><br>    ;;<br><span class="hljs-keyword">esac</span><br></code></pre></div></td></tr></table></figure>
<p>输入不同的内容，会有不同的结果，例如：</p>
<blockquote>
<p>输入 1 到 4 之间的数字:<br>
你输入的数字为:<br>
3<br>
你选择了 3</p>
</blockquote>
<h3 id="跳出循环"><a class="header-anchor" href="#跳出循环">¶</a>跳出循环</h3>
<p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：<code>break</code>和<code>continue</code>。</p>
<h4 id="break命令"><a class="header-anchor" href="#break命令">¶</a><code>break</code>命令</h4>
<p><code>break</code>命令允许跳出所有循环（终止执行后面的所有循环）。</p>
<p>下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用<code>break</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">while</span> :<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> -n <span class="hljs-string">"输入 1 到 5 之间的数字:"</span><br>    <span class="hljs-built_in">read</span> aNum<br>    <span class="hljs-keyword">case</span> <span class="hljs-variable">$aNum</span> <span class="hljs-keyword">in</span><br>        1|2|3|4|5) <span class="hljs-built_in">echo</span> <span class="hljs-string">"你输入的数字为 <span class="hljs-variable">$aNum</span>!"</span><br>        ;;<br>        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">"你输入的数字不是 1 到 5 之间的! 游戏结束"</span><br>            <span class="hljs-built_in">break</span><br>        ;;<br>    <span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<blockquote>
<p>输入 1 到 5 之间的数字:3<br>
你输入的数字为 3!<br>
输入 1 到 5 之间的数字:7<br>
你输入的数字不是 1 到 5 之间的! 游戏结束</p>
</blockquote>
<h4 id="continue"><a class="header-anchor" href="#continue">¶</a><code>continue</code></h4>
<p><code>continue</code>命令与<code>break</code>命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>
<p>对上面的例子进行修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">while</span> :<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> -n <span class="hljs-string">"输入 1 到 5 之间的数字: "</span><br>    <span class="hljs-built_in">read</span> aNum<br>    <span class="hljs-keyword">case</span> <span class="hljs-variable">$aNum</span> <span class="hljs-keyword">in</span><br>        1|2|3|4|5) <span class="hljs-built_in">echo</span> <span class="hljs-string">"你输入的数字为 <span class="hljs-variable">$aNum</span>!"</span><br>        ;;<br>        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">"你输入的数字不是 1 到 5 之间的!"</span><br>            <span class="hljs-built_in">continue</span><br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">"游戏结束"</span><br>        ;;<br>    <span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br></code></pre></div></td></tr></table></figure>
<p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 <code>echo &quot;游戏结束&quot;</code> 永远不会被执行。</p>
<h3 id="esac"><a class="header-anchor" href="#esac">¶</a><code>esac</code></h3>
<p><code>case</code>的语法和C family语言差别很大，它需要一个<code>esac</code>（就是<code>case</code>反过来）作为结束标记，每个<code>case</code>分支用右圆括号，用两个分号表示<code>break</code>。</p>
<hr>
<h3 id="Shell-函数"><a class="header-anchor" href="#Shell-函数">¶</a>Shell 函数</h3>
<p>linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p>
<p>shell中函数的定义格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">[ <span class="hljs-keyword">function</span> ] funname [()]<br><br>&#123;<br><br>    action;<br><br>    [<span class="hljs-built_in">return</span> int;]<br><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>可以带<code>function fun()</code> 定义，也可以直接<code>fun()</code> 定义,不带任何参数。</li>
<li>参数返回，可以显示加：<code>return</code> 返回，如果不加，将以最后一条命令运行结果，作为返回值。 <code>return</code>后跟数值n(0-255</li>
</ol>
<p>下面的例子定义了一个函数并进行调用：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br><br><span class="hljs-function"><span class="hljs-title">demoFun</span></span>()&#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"这是我的第一个 shell 函数!"</span><br>&#125;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"-----函数开始执行-----"</span><br>demoFun<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"-----函数执行完毕-----"</span><br></code></pre></div></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>-----函数开始执行-----<br>
这是我的第一个 shell 函数!<br>
-----函数执行完毕-----</p>
</blockquote>
<p>下面定义一个带有return语句的函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br><br><span class="hljs-function"><span class="hljs-title">funWithReturn</span></span>()&#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"这个函数会对输入的两个数字进行相加运算..."</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"输入第一个数字: "</span><br>    <span class="hljs-built_in">read</span> aNum<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"输入第二个数字: "</span><br>    <span class="hljs-built_in">read</span> anotherNum<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"两个数字分别为 <span class="hljs-variable">$aNum</span> 和 <span class="hljs-variable">$anotherNum</span> !"</span><br>    <span class="hljs-built_in">return</span> $((<span class="hljs-variable">$aNum</span>+<span class="hljs-variable">$anotherNum</span>))<br>&#125;<br>funWithReturn<br><span class="hljs-built_in">echo</span> <span class="hljs-string">"输入的两个数字之和为 $? !"</span><br></code></pre></div></td></tr></table></figure>
<p>输出类似下面：</p>
<blockquote>
<p>这个函数会对输入的两个数字进行相加运算…<br>
输入第一个数字:<br>
1<br>
输入第二个数字:<br>
2<br>
两个数字分别为 1 和 2 !<br>
输入的两个数字之和为 3 !</p>
</blockquote>
<p>函数返回值在调用该函数后通过 <code>$?</code> 来获得。</p>
<p><strong>注意</strong>：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>
<h3 id="函数参数"><a class="header-anchor" href="#函数参数">¶</a>函数参数</h3>
<p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 <code>$n</code> 的形式来获取参数的值，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数…</p>
<p>带参数的函数示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># author:菜鸟教程</span><br><span class="hljs-comment"># url:www.runoob.com</span><br><br><span class="hljs-function"><span class="hljs-title">funWithParam</span></span>()&#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"第一个参数为 <span class="hljs-variable">$1</span> !"</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"第二个参数为 <span class="hljs-variable">$2</span> !"</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"第十个参数为 <span class="hljs-variable">$10</span> !"</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"第十个参数为 <span class="hljs-variable">$&#123;10&#125;</span> !"</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"第十一个参数为 <span class="hljs-variable">$&#123;11&#125;</span> !"</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"参数总数有 <span class="hljs-variable">$#</span> 个!"</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"作为一个字符串输出所有参数 $* !"</span><br>&#125;<br>funWithParam 1 2 3 4 5 6 7 8 9 34 73<br></code></pre></div></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>第一个参数为 1 !<br>
第二个参数为 2 !<br>
第十个参数为 10 !<br>
第十个参数为 34 !<br>
第十一个参数为 73 !<br>
参数总数有 11 个!<br>
作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</p>
</blockquote>
<p><font color=red><strong>注意，<code>$10</code> 不能获取第十个参数，获取第十个参数需要<code>${10}</code>。当n&gt;=10时，需要使用<code>${n}</code>来获取参数。</strong></font></p>
<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数处理</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$#</td>
<td style="text-align:left">传递到脚本的参数个数</td>
</tr>
<tr>
<td style="text-align:left">$*</td>
<td style="text-align:left">以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td style="text-align:left">$$</td>
<td style="text-align:left">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td style="text-align:left">$!</td>
<td style="text-align:left">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td style="text-align:left">$@</td>
<td style="text-align:left">与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td style="text-align:left">$-</td>
<td style="text-align:left">显示Shell使用的当前选项，与<code>set</code>命令功能相同。</td>
</tr>
<tr>
<td style="text-align:left">$?</td>
<td style="text-align:left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Linux</tag>
        <tag>Shell</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>mod_wsgi出现503 service temporarily unavailable解决办法</title>
    <url>/2018/10/24/mod_wsgi%E5%87%BA%E7%8E%B0503-service-temporarily-unavailable%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h1>mod_wsgi出现503 service temporarily unavailable解决办法</h1>
<hr>
<h2 id="现象"><a class="header-anchor" href="#现象">¶</a>现象</h2>
<p>前端显示：</p>
<div class="hljs code-wrapper"><pre><code>503 service temporarily unavailable
</code></pre></div>
<p>后台日志：</p>
<div class="hljs code-wrapper"><pre><code>[wsgi:error] [pid 21399:tid 140274344871680] (11)Resource temporarily unavailable: [client 172.68.27.190:18983] mod_wsgi (pid=21399): Unable to connect to WSGI daemon process 'site' on '/var/run/wsgi.21137.0.1.sock' after multiple attempts as listener backlog limit was exceeded.
</code></pre></div>
<h2 id="解决方案："><a class="header-anchor" href="#解决方案：">¶</a>解决方案：</h2>
<p>根据<a href="http://modwsgi.readthedocs.io/en/develop/configuration-directives/WSGIDaemonProcess.html" target="_blank" rel="noopener">mod_wsgi文档</a>修改相关配置，例如：</p>
<div class="hljs code-wrapper"><pre><code>WSGIDaemonProcess site python-path=/var/www/site:/var/www/site/env/lib/python3.6/site-packages home=/var/www/site processes=2 threads=60 graceful-timeout=30 maximum-requests=1000 restart-interval=30
</code></pre></div>
<blockquote>
<p><a href="https://github.com/GrahamDumpleton/mod_wsgi/issues/228" target="_blank" rel="noopener">Github原贴</a></p>
</blockquote>
<h2 id="扩展"><a class="header-anchor" href="#扩展">¶</a>扩展</h2>
<blockquote>
<p><code>listener backlog limit</code>并非表示服务器最大能够处理的连接数，服务器最大能够处理的连接数依赖于服务器所配置的最大进程或线程数。而listen backlog是告诉内核在一个socket监听队列外等待的最大连接数的一个socket配置。如果等待队列已潢，那么以后的连接请求都将被拒绝。<br>
根据uwsgi手册，可以通过<code>-l</code>选项指定listen backlog：</p>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">-l|--listen &lt;num&gt;<br>   <span class="hljs-builtin-name">set</span>  socket  listen<span class="hljs-built_in"> queue </span><span class="hljs-keyword">to</span> &lt;n&gt; (default 100, maximum is system<br>   dependent)<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><a href="https://stackoverflow.com/questions/12340047/uwsgi-your-server-socket-listen-backlog-is-limited-to-100-connections" target="_blank" rel="noopener">stackoverflow原贴</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>疑难</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Web</tag>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SSH config文件</title>
    <url>/2018/10/24/%E4%BD%BF%E7%94%A8SSH-config%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1>使用SSH config文件</h1>
<hr>
<p>[TOC]</p>
<hr>
<p>ssh的介绍及使用参看：<a href="http://daemon369.github.io/ssh/2015/03/16/01-brief-introduction-for-ssh" target="_blank" rel="noopener">SSH简介</a>、<a href="http://daemon369.github.io/ssh/2015/03/08/generating-ssh-keys" target="_blank" rel="noopener">创建SSH密钥对</a>。</p>
<h2 id="配置文件"><a class="header-anchor" href="#配置文件">¶</a>配置文件</h2>
<p><code>ssh</code>程序可以从以下途径获取配置参数：</p>
<ol>
<li>命令行选项</li>
<li>用户配置文件 (~/.ssh/config)</li>
<li>系统配置文件(/etc/ssh/ssh_config)</li>
</ol>
<p>配置文件可分为多个配置区段，每个配置区段使用<code>host</code>来区分。我们可以在命令行中输入不同的<code>host</code>来加载不同的配置段。</p>
<p>对每一个配置项来说，首次获取的参数值将被采用，因此通用的设置应该放到文件的后面，特定<code>host</code>相关的配置项应放到文件的前面。</p>
<hr>
<h2 id="常用配置项"><a class="header-anchor" href="#常用配置项">¶</a>常用配置项</h2>
<p>下面介绍一些常用的<code>SSH</code>配置项：</p>
<h3 id="Host"><a class="header-anchor" href="#Host">¶</a>Host</h3>
<p><code>Host</code>配置项标识了一个配置区段。</p>
<p><code>ssh</code>配置项参数值可以使用通配符：<code>*</code>代表0～n个非空白字符，<code>?</code>代表一个非空白字符，<code>!</code>表示例外通配。</p>
<p>我们可以在系统配置文件中看到一个匹配所有<code>host</code>的默认配置区段：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ cat /etc/ssh/ssh_config | grep <span class="hljs-string">'^Host'</span><br>Host *<br></code></pre></div></td></tr></table></figure>
<p>这里有一些默认配置项，我们可以在用户配置文件中覆盖这些默认配置。</p>
<h3 id="GlobalKnownHostsFile"><a class="header-anchor" href="#GlobalKnownHostsFile">¶</a>GlobalKnownHostsFile</h3>
<p>指定一个或多个全局认证主机缓存文件，用来缓存通过认证的远程主机的密钥，多个文件用空格分隔。默认缓存文件为：/etc/ssh/ssh_known_hosts, /etc/ssh/ssh_known_hosts2.</p>
<h3 id="HostName"><a class="header-anchor" href="#HostName">¶</a>HostName</h3>
<p>指定远程主机名，可以直接使用数字IP地址。如果主机名中包含 ‘%h’ ，则实际使用时会被命令行中的主机名替换。</p>
<h3 id="IdentityFile"><a class="header-anchor" href="#IdentityFile">¶</a>IdentityFile</h3>
<p>指定密钥认证使用的私钥文件路径。默认为 ~/.ssh/id_dsa, ~/.ssh/id_ecdsa, ~/.ssh/id_ed25519 或 ~/.ssh/id_rsa 中的一个。文件名称可以使用以下转义符：</p>
<div class="hljs code-wrapper"><pre><code>'%d' 本地用户目录
'%u' 本地用户名称
'%l' 本地主机名
'%h' 远程主机名
'%r' 远程用户名
</code></pre></div>
<p>可以指定多个密钥文件，在连接的过程中会依次尝试这些密钥文件。</p>
<h3 id="Port"><a class="header-anchor" href="#Port">¶</a>Port</h3>
<p>指定远程主机端口号，默认为 22 。</p>
<h3 id="User"><a class="header-anchor" href="#User">¶</a>User</h3>
<p>指定登录用户名。</p>
<p>UserKnownHostsFile<br>
指定一个或多个用户认证主机缓存文件，用来缓存通过认证的远程主机的密钥，多个文件用空格分隔。默认缓存文件为： ~/.ssh/known_hosts, ~/.ssh/known_hosts2.</p>
<p>还有更多参数的介绍，可以参看用户手册：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ man ssh config<br></code></pre></div></td></tr></table></figure>
<h2 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h2>
<p>以下连接为例：</p>
<div class="hljs code-wrapper"><pre><code>SSH 服务器： ssh.test.com
端口号： 2200
账户： user
密钥文件： ~/.ssh/id_rsa_test
</code></pre></div>
<p>1. 密码认证登录方式为：</p>
<div class="hljs code-wrapper"><pre><code>$ ssh -p 2200 -i ~/.ssh/id_rsa_test user@ssh.test.com
user@ssh.test.com's password:
</code></pre></div>
<p>2. 密钥认证登录方式：</p>
<div class="hljs code-wrapper"><pre><code>$ ssh-copy-id -i ~/.ssh/id_rsa_test user@ssh.test.com
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
user@ssh.test.com's password:

Number of key(s) added: 1

Now try logging into the machine, with:   &quot;ssh 'user@ssh.test.com'&quot;
and check to make sure that only the key(s) you wanted were added.

$ ssh user@ssh.test.com
</code></pre></div>
<p>3. 使用配置文件方式</p>
<p>有如下配置文件：</p>
<div class="hljs code-wrapper"><pre><code>$ vim ~/.ssh/config
Host sshtest
    HostName ssh.test.com
    User user
    Port 2200
    IdentityFile ~/.ssh/id_rsa_test

Host ssttest2
    HostName ssh.test2.com
    User user2
    Port 2345
    IdentityFile ~/.ssh/id_rsa_test2
</code></pre></div>
<p>使用配置文件登录：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ssh sshtest<br></code></pre></div></td></tr></table></figure>
<h2 id="环境"><a class="header-anchor" href="#环境">¶</a>环境</h2>
<ul>
<li>Ubuntu</li>
<li>macOs High Sierra(10.13.2)</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>利用gitlab pages和hexo搭建一个个人博客</title>
    <url>/2018/10/24/%E5%88%A9%E7%94%A8gitlab-pages%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1>利用gitlab pages和hexo搭建一个个人博客</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="1-使用github-pages存在的问题"><a class="header-anchor" href="#1-使用github-pages存在的问题">¶</a>1. 使用github pages存在的问题</h2>
<p>目前网上有很多利用github pages和hexo搭建个人博客的教程，但是github目前拒绝了百度蜘蛛的爬取，因此如果希望自己的博客能够被百度收录，就需要采用一些别的方法托管。之前网上有一些利用coding.net进行托管共百度爬取的方法，但是最近coding.net进行了改版，在打开托管的个人pages时会强行加入一个5s的等待跳转页面，导致百度的蜘蛛无法正确爬取到博客的内容。因此，这篇文章将手把手教你如何用gitlab托管你的博客，实现让百度可以爬取你的博客内容。</p>
<h2 id="2-安装必要环境"><a class="header-anchor" href="#2-安装必要环境">¶</a>2. 安装必要环境</h2>
<p>以下操作均在windows10的环境下进行，其他的环境操作如果有问题请自行进行必要的修改。</p>
<h3 id="2-1-安装nodejs"><a class="header-anchor" href="#2-1-安装nodejs">¶</a>2.1 安装nodejs</h3>
<p>最新版的nodejs可以在这里获取，下载后直接安装即可，安装完后打开cmd，输入npm -v，如果能输出版本号则说明安装成功。</p>
<p>###2.2 安装git</p>
<p>git的安装和配置请自行百度，这里就不详细写了，这是git的<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">下载地址</a></p>
<h3 id="2-3-安装hexo"><a class="header-anchor" href="#2-3-安装hexo">¶</a>2.3 安装hexo</h3>
<p>如果已经完成了以上两步，在一个私人文件夹下打开cmd，运行</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-cli -g<br>hexo init blog<br><span class="hljs-built_in">cd</span> blog<br>npm install<br>hexo server<br></code></pre></div></td></tr></table></figure>
<p>如果一切正常，在浏览器中访问http://localhost:4000/就可以看到运行在本地的博客了。</p>
<h2 id="3-将博客部署到gitlab-pages上"><a class="header-anchor" href="#3-将博客部署到gitlab-pages上">¶</a>3. 将博客部署到gitlab pages上</h2>
<h3 id="3-1-添加ssh-key"><a class="header-anchor" href="#3-1-添加ssh-key">¶</a>3.1 添加ssh-key</h3>
<p>在gitlab完成注册后，首先访问这里，向你的帐户添加ssh keys，ssh keys的生成可以参考如下的步骤，打开2.2安装的Git Bash，输入如下命令(自行替换其中的用户名和邮箱信息)</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">"Boyuan"</span><br>git config --global user.email <span class="hljs-string">"work@aiboy.pub"</span><br>ssh-keygen -t rsa -C <span class="hljs-string">"work@aiboy.pub"</span><br></code></pre></div></td></tr></table></figure>
<p>最终生成的文件一般位于C:\Users\UserName.ssh文件夹下，打开id_rsa.pub，将里面的所有内容添加到这里。</p>
<h3 id="3-2-新建一个项目"><a class="header-anchor" href="#3-2-新建一个项目">¶</a>3.2 新建一个项目</h3>
<p>接着点页面右上角的+号，新建一个项目。项目名为”<a href="http://username.gitlab.io" target="_blank" rel="noopener">username.gitlab.io</a>”，其中username为你的gitlab账号用户名，项目类型选择Private</p>
<h3 id="3-3-添加-gitlab-ci-yml文件"><a class="header-anchor" href="#3-3-添加-gitlab-ci-yml文件">¶</a>3.3 添加.gitlab-ci.yml文件</h3>
<p>利用gitlab部署你的博客和github最大不同在于，在github上部署博客需要先在本地生成各种页面文件，然后再推送到github上就可以直接访问了。而使用gitlab则需要在服务器端完成生成和部署两个阶段，应该需要在项目的根目录下添加一个.gitlab-ci.yml文件用来指导服务器如何处理你提交的源文件。一个完整可用的.gitlab-ci.yml如下，当时node版本为8.11.2，具体查看<a href="https://gitlab.com/pages" target="_blank" rel="noopener">Git Pages Examples</a> 相应示例（本例是<a href="https://gitlab.com/pages/hexo" target="_blank" rel="noopener">hexo</a>）.gitlab-ci.yml文件中的node版本。</p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">before_script:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">apt-get</span> <span class="hljs-string">update</span> <span class="hljs-string">-qq</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">apt-get</span> <span class="hljs-string">install</span> <span class="hljs-string">-y</span> <span class="hljs-string">-qq</span> <span class="hljs-string">pandoc</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">node:8.11.2</span><br><span class="hljs-attr">pages:</span><br>  <span class="hljs-attr">cache:</span><br>    <span class="hljs-attr">paths:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">node_modules/</span><br>  <span class="hljs-attr">script:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">hexo-cli</span> <span class="hljs-string">-g</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>  <span class="hljs-comment"># 下面这个突然不能用了</span><br>  <span class="hljs-comment">#- hexo deploy</span><br>  <span class="hljs-comment"># 用下面这个</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">hexo</span> <span class="hljs-string">g</span><br>  <span class="hljs-attr">artifacts:</span><br>    <span class="hljs-attr">paths:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">public</span><br>  <span class="hljs-attr">only:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br></code></pre></div></td></tr></table></figure>
<h3 id="3-4-修改站点配置文件-更换主题"><a class="header-anchor" href="#3-4-修改站点配置文件-更换主题">¶</a>3.4 修改站点配置文件&amp;更换主题</h3>
<p>这里推荐大家使用NexT主题，这也是本站目前使用的主题，具体的安装步骤可以参考这里，有一点需要注意的是，将themes\next\目录下的.git文件夹删除。<br>
下面主要还需要对项目根目录下的_config.yml进行修改</p>
<p>接下来，在项目根目录下运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git init<br>git remote add origin git@gitlab.com:feixiang/feixiang.gitlab.io.git<br>git add .<br>git commit -m <span class="hljs-string">"init blog"</span><br>git push -u origin master<br></code></pre></div></td></tr></table></figure>
<p>以上第二句命令请根据自己的项目名称进行调整。<br>
完成推送后，访问你的项目主页，如果看到passed的图标，就表示构建成功了，访问https://username.gitlab.io/ 就可以看到自己刚刚建立的博客了。<br>
如果需要添加新的文章，将文章的md文件保存到source -&gt; _posts文件夹下然后重新执行推送就可以了，服务器端完成构建后，如果没有错误就会出现在你的博客页面上。<br>
到此何如在gitlab上搭建一个博客就说完了，如果想绑定自己的域名实现让百度爬取请继续往下看。</p>
<h2 id="4-绑定个人域名"><a class="header-anchor" href="#4-绑定个人域名">¶</a>4. 绑定个人域名</h2>
<h3 id="4-1-一般绑定"><a class="header-anchor" href="#4-1-一般绑定">¶</a>4.1 一般绑定</h3>
<p>修改_config.yml文件中的url地址为http://你的域名，重新提交，服务器端编译通过后，在项目主页访问Settings-&gt;Pages-&gt;New Domain，输入你的自己的域名就可以了。<a href="http://xn--username-z09lq7i01hwtdbze36ama8c426a63ntn7ctgs4q0a6hfhsvk63auq0l.gitlab.io" target="_blank" rel="noopener">然后去你的域名注册商那添加一条指向username.gitlab.io</a>. 的CNAME记录记录，输入你的域名，看看是不是可以访问了。<br>
利用百度爬虫抓取，可以看到可以成功抓取。图一是使用gatlab托管的抓取状态，图二是利用github抓取的状态。</p>
<p><img src="https://img-blog.csdn.net/20170516224527573?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ludGVyX2V2ZW5pbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="抓取1"></p>
<p><img src="https://img-blog.csdn.net/20170516224547089?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2ludGVyX2V2ZW5pbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="抓取2"></p>
<h3 id="4-2-添加SSL证书"><a class="header-anchor" href="#4-2-添加SSL证书">¶</a>4.2 添加SSL证书</h3>
<ul>
<li>在腾讯云（或其它）上申请TrustAsia证书（免费一年），申请成功后下载，使用压缩包中的Nginx中的证书。</li>
<li>将Nginx中的_your.domain.com_bundle.crt的内容复制到4.1中New Pages Domain页面中的Certificate (PEM)中。<br>
将_your.domain.com.key中的内容复制到Key (PEM)中，提交。</li>
</ul>
<h3 id="4-3-验证域名归属"><a class="header-anchor" href="#4-3-验证域名归属">¶</a>4.3 验证域名归属</h3>
<p>根据Gitlab<a href="https://docs.gitlab.com/ee/user/project/pages/getting_started_part_three.html#tl-dr" target="_blank" rel="noopener">官方文档</a>分析：</p>
<ul>
<li>若域名为一级域名（可能会有其它用处，如邮件服务器等），则在域名解析处添加形如（根据Gitlab验证页面修改实际记录值）如下记录：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">From</th>
<th style="text-align:left">DNS Record</th>
<th style="text-align:left">To</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://domain.com" target="_blank" rel="noopener">domain.com</a></td>
<td style="text-align:left">A</td>
<td style="text-align:left">35.185.44.232</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://domain.com" target="_blank" rel="noopener">domain.com</a></td>
<td style="text-align:left">TXT</td>
<td style="text-align:left">gitlab-pages-verification-code=00112233445566778899aabbccddeeff</td>
</tr>
</tbody>
</table>
<ul>
<li>若域名为二级域名（仅用做Gitlab Pages，不运行其它服务），则在域名解析处添加形如（根据Gitlab验证页面修改实际记录值）如下记录：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">From</th>
<th style="text-align:left">DNS Record</th>
<th style="text-align:left">To</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://subdomain.domain.com" target="_blank" rel="noopener">subdomain.domain.com</a></td>
<td style="text-align:left">CNAME</td>
<td style="text-align:left"><a href="http://namespace.gitlab.io" target="_blank" rel="noopener">namespace.gitlab.io</a></td>
</tr>
<tr>
<td style="text-align:left">_gitlab-pages-verification-code.subdomain.domain.com</td>
<td style="text-align:left">TXT</td>
<td style="text-align:left">gitlab-pages-verification-code=00112233445566778899aabbccddeeff</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Hexo 免费搭建属于自己的个人博客</title>
    <url>/2018/10/23/%E4%BD%BF%E7%94%A8-Hexo-%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1>使用 Hexo 免费搭建属于自己的个人博客</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="安装搭建博客必须的环境"><a class="header-anchor" href="#安装搭建博客必须的环境">¶</a>安装搭建博客必须的环境</h2>
<ol>
<li>安装 Git<br>
这里就不说怎么安装了，相信会看这篇文章的一般都已经装了。</li>
<li>申请 GitHub 账号<br>
<code>博客</code> 的 <code>远程创库</code>、<code>域名</code>、<code>服务器</code> 等都和 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 有关，这个必须要。</li>
<li>安装 Node.js<br>
前往 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js 官网</a> 下载最新版本的安装包安装即可。<br>
<img src="https://upload-images.jianshu.io/upload_images/1930874-31fc3087c49f43af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="安装Node.js"></li>
<li>安装 Hexo<br>
打开终端，输入以下命令安装 Hexo ，安装时间可能有点长，要多等一下。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-cli -g<br></code></pre></div></td></tr></table></figure>
<h2 id="开始搭建博客"><a class="header-anchor" href="#开始搭建博客">¶</a>开始搭建博客</h2>
<p>以上环境必须全部安装完成后，才能开始搭建 <code>博客</code>。</p>
<h3 id="1-创建-GitHub-仓库"><a class="header-anchor" href="#1-创建-GitHub-仓库">¶</a>1. 创建 GitHub 仓库</h3>
<p>打开 GitHub 创建一个仓库，Repository name 为 <a href="http://xxx.github.io" target="_blank" rel="noopener">xxx.github.io</a>，xxx 处就是你 GitHub 的用户名，也就是前面 Owner 处显示的名字，命名必须这样，不能更改，这个仓库的名字也会是 博客 搭建完成后的域名。<br>
<img src="https://upload-images.jianshu.io/upload_images/1930874-6fe8a4a5a643e017.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="创建GitHub仓库"></p>
<h3 id="2-初始化-Hexo-博客"><a class="header-anchor" href="#2-初始化-Hexo-博客">¶</a>2. 初始化 Hexo 博客</h3>
<p>打开终端，执行以下命令初始化 博客，初始化完成后，你的系统根目录中会多一个名为 Blog 的文件夹，Blog 也可以更改成自己喜欢的名字，初始化时间也比较久，耐心等一下。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo init Blog<br></code></pre></div></td></tr></table></figure>
<h3 id="3-下载博客主题"><a class="header-anchor" href="#3-下载博客主题">¶</a>3. 下载博客主题</h3>
<ul>
<li>
<p><code>博客</code> 初始化完成以后，会有一个自带的 <code>博客主题</code> ，在 <code>Blog / themes </code>文件夹下，但是比较丑，你可以下载一个自己喜欢的 <code>博客主题</code> 。</p>
</li>
<li>
<p>这里是 <code>博客主题</code> 的 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">下载地址</a> ，只需要到主题对应的 <code>GitHub</code> 仓库将主题 <code>clone</code> 下来即可，这是我使用的主题 <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank" rel="noopener">下载地址</a> 。</p>
</li>
<li>
<p><code>clone</code> 完成后，将主题文件夹复制到 <code>Blog</code> 文件夹下的 <code>themes</code> 文件夹中。</p>
</li>
<li>
<p>启用 About 页（限archer主题，其它主题查看相应文档）</p>
<ul>
<li>在<strong>hexo目录</strong>下执行</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo new page <span class="hljs-string">"about"</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>在hexo目录下<code>source/about/index.md</code>中添加字段<code>layout: about</code>（这个字段必须有且不可更改为其他），<code>title</code>字段修改为about页的标题（自行修改），正文为about页的内容（自行修改），例如：</li>
</ul>
  <figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">---<br>title: 这是自我介绍的题目<br>layout: about<br>---<br>这是一段自我介绍<br></code></pre></div></td></tr></table></figure>
<ul>
<li>在<strong>主题配置文件</strong>中添加以下字段，<code>enable</code>字段控制是否开启about，<code>image</code>字段内容为about页的banner图像地址，不填写则默认使用首页banner图像。</li>
</ul>
  <figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">'/intro/about-page.jpg'</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="4-修改博客配置文件"><a class="header-anchor" href="#4-修改博客配置文件">¶</a>4. 修改博客配置文件</h3>
<ul>
<li>
<p>打开 <code>Blog</code> 文件夹下的 <code>_config.yml</code> 文件，修改其中的配置。</p>
</li>
<li>
<p>下面把几个必须修改的配置列出来按需求修改即可，配置的键值之间一定要有空格，否则会报错，想了解更多配置点击 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">这里</a> 。</p>
  <figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">Jonzzs</span>  <span class="hljs-string">//博客的标题</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">个人博客</span> <span class="hljs-string">//博客的副标题</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">将来的你</span> <span class="hljs-string">一定会感激现在拼命的自己</span> <span class="hljs-string">//博客的描述</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">Jonzzs</span> <span class="hljs-string">//博客作者的名字</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-Hans</span> <span class="hljs-string">//语言中文</span><br><br><span class="hljs-attr">theme:</span> <span class="hljs-string">new-vno</span> <span class="hljs-string">//刚刚复制到</span> <span class="hljs-string">themes</span> <span class="hljs-string">文件夹下的主题名称</span><br><br><span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">git</span> <span class="hljs-string">//使用</span> <span class="hljs-string">Git</span> <span class="hljs-string">发布</span><br>    <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/Jonzzs/Jonzzs.github.io.git</span> <span class="hljs-string">//刚创建的</span> <span class="hljs-string">Github</span> <span class="hljs-string">仓库地址</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>关于主题的配置在各自主题文件夹下的 _config.yml 文件中修改。</p>
</li>
</ul>
<h3 id="5-写博客文章"><a class="header-anchor" href="#5-写博客文章">¶</a>5. 写博客文章</h3>
<ul>
<li>
<p>接下来可以开始写你的第一篇 <code>博客</code> 文章了，博客文章保存在 <code>Blog / source / _posts</code> 文件夹下，格式为 <code>MarkDown</code> 格式，也就是 <code>.md</code> 后缀的文件，编码格式为 <code>UTF-8</code> ，否则会显示乱码。<br>
<strong>例如</strong>： 创建一个名为 <code>测试文章.md</code> 的文件，内容为：</p>
  <figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">---<br>title: 测试文章 //文章的标题<br>date: 2017-05-03 17:47 //文章的发布时间<br>categories: 测试分类 //分类名称<br>tags: 测试标签 //标签名称<br>photos: http://jonzzs.cn/images/Jonzzs.jpg //需要展示的图片地址<br>---<br><span class="hljs-code">    </span><br> &gt; 这是一篇测试文章。<br></code></pre></div></td></tr></table></figure>
<p><strong>注意</strong>：每一篇文章中，开头都必须有 — 之间的那些参数，参数 : 后面必须有空格，文章的 标题 是必填的，否则文章不会显示在博客中，其他参数看自己的需求填写，categories 、tags 、photos 这三个参数可填写多个，填写多个时用 [ xx, xx ] 格式区分，例如：</p>
  <figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">---<br>title: 测试文章 //文章的标题<br>date: 2017-05-03 17:47 //文章的发布时间<br>categories: [测试分类1, 测试分类2, 测试分类3] //分类名称<br>tags: [测试标签1, 测试标签2, 测试标签3] //标签名称<br>photos: [http://jonzzs.cn/images/Jonzzs.jpg, http://jonzzs.cn/images/Jonzzs.jpg, http://jonzzs.cn/images/Jonzzs.jpg] //需要展示的图片地址<br>---<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>如果要在博客的首页显示每篇文章的 <code>摘要</code> ，只要在文章中加入以下 <code>分隔符</code> 即可，该 <code>分隔符</code> 之前的所有内容都会被自动截取为文章的 <code>摘要</code> 。</p>
  <figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-comment">&lt;!-- more --&gt;</span></span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="6-本地测试博客"><a class="header-anchor" href="#6-本地测试博客">¶</a>6. 本地测试博客</h3>
<ul>
<li>
<p>打开终端 <code>cd</code> 到 <code>Blog</code> 目录下，输入以下命令：</p>
  <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo s<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>接着浏览器中输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就能够看到 <code>博客</code> 的搭建效果。</p>
</li>
</ul>
<h2 id="发布博客"><a class="header-anchor" href="#发布博客">¶</a>发布博客</h2>
<p>本地显示没问题以后，就可以将 <code>博客</code> 发布到 <code>GitHub</code> 服务器上了。</p>
<h3 id="1-安装自动部署发布插件"><a class="header-anchor" href="#1-安装自动部署发布插件">¶</a>1. 安装自动部署发布插件</h3>
<p>第一次配置时需要安装 <code>hexo-deployer-git</code> 自动部署发布工具，打开终端 <code>cd</code> 到 <code>Blog</code> 目录下，执行以下命令安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></div></td></tr></table></figure>
<h3 id="2-发布博客到服务器"><a class="header-anchor" href="#2-发布博客到服务器">¶</a>2. 发布博客到服务器</h3>
<ul>
<li>打开终端 <code>cd</code> 到 <code>Blog</code> 目录下，输入以下命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></div></td></tr></table></figure>
<ul>
<li>如果这是你的第一次，终端可能会让你输入 <code>Github</code> 的邮箱和密码，输入完成后，就会把你的 <code>博客</code> 自动上传至 <code>Github</code> 了。</li>
<li>以后在每一次添加新的 <code>博客</code> 文章或者改变配置时，执行一下这个命令就可以直接发布了。<br>
发布完成后，浏览器中输入之前创建的 <code>Github</code> 仓库名，就能访问到你搭建的 博客 了，我的是 <code>carzpurzkey.github.io</code> 。</li>
</ul>
<hr>
<blockquote>
<p>简单的 <code>博客</code> 搭建流程就是这样了，还有很多不错的 <a href="https://hexo.io/plugins/" target="_blank" rel="noopener">插件</a> ，比如 <code>评论</code>、<code>标签</code>、<code>统计</code> 等等，这些自己去研究并慢慢完善自己的博客吧。</p>
</blockquote>
<h2 id="使用-码云-来托管-Hexo-搭建的博客"><a class="header-anchor" href="#使用-码云-来托管-Hexo-搭建的博客">¶</a>使用 码云 来托管 Hexo 搭建的博客</h2>
<ol>
<li>
<p>首先进入 <a href="https://gitee.com" target="_blank" rel="noopener">码云</a> 创建一个仓库，<code>仓库名称</code> 和 <code>仓库路径</code> 都必须和你的 <code>用户名</code> 也就是上面的 <code>归属</code> 一样。<br>
<img src="https://upload-images.jianshu.io/upload_images/1930874-ef54f8b245f993a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="创建仓库"></p>
</li>
<li>
<p>打开本地 <code>博客</code> 下的 <code>_config.yml</code> 文件，将刚才创建的仓库 <code>Git</code> 地址配置进去。<br>
<img src="https://upload-images.jianshu.io/upload_images/1930874-732a1474b74dae5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/772/format/webp" alt="仓库Git地址"></p>
</li>
<li>
<p>添加托管</p>
</li>
</ol>
<ul>
<li>
<p>如果想使用 GitHub 和 码云 同时托管 博客 ，就这样配置：</p>
  <figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>    <span class="hljs-attr">repo:</span><br>        <span class="hljs-attr">github:</span> <span class="hljs-string">https://github.com/Jonzzs/Jonzzs.github.io.git</span><br>        <span class="hljs-attr">oschina:</span> <span class="hljs-string">https://git.oschina.net/Jonzzs/Jonzzs.git</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>如果只想使用 码云 托管 博客 ，就这样配置：</p>
  <figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>    <span class="hljs-attr">repo:</span> <span class="hljs-string">https://git.oschina.net/Jonzzs/Jonzzs.git</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<ol start="4">
<li>
<p>保存文件后打开终端 <code>cd</code> 到 <code>博客</code> 目录下，使用以下命令重新部署一下博客。</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>再次打开刚才 <code>码云</code> 上创建的仓库刷新一下，博客 的 <code>HTML</code> 页面应该已经传到仓库中了，打开 <code>服务</code> 中的 <code>Pages</code>，点击 <code>启动服务</code> 。<br>
<img src="https://upload-images.jianshu.io/upload_images/1930874-4556b0dc9fa60ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="Pages"></p>
</li>
<li>
<p>此时你就可以使用 <code>用户名.gitee.io</code> 来访问你的 <code>博客</code> 了。<br>
<img src="https://upload-images.jianshu.io/upload_images/1930874-be5eeac4cb380f7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="jonzzs.gitee.io"></p>
</li>
</ol>
<blockquote>
<p>大功告成，使用 <code>码云</code> 托管 <code>博客</code> 后访问速度会快很多，大家块试试看吧。</p>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>git</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>git 学习笔记</title>
    <url>/2018/10/22/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>git学习笔记</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="时光穿梭机"><a class="header-anchor" href="#时光穿梭机">¶</a>时光穿梭机</h2>
<h3 id="版本回退"><a class="header-anchor" href="#版本回退">¶</a>版本回退</h3>
<ol>
<li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。此命令是将工作目录中的修改撤回到与本地版本库一致。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ol>
<h3 id="工作区与暂存区"><a class="header-anchor" href="#工作区与暂存区">¶</a>工作区与暂存区</h3>
<ol>
<li><code>git diff</code> 是你工作区跟仓库（仓库也叫版本库）的比较，这个时候可以看你开发过程中修改了哪些内容</li>
<li><code>git diff --cached</code> 是看你stage区和仓库分支上的比较，你add后但是没有commit， 这个时候只是在stage中，可以确认下修改是否正确，如果正确无误可以commit合并到分支。</li>
<li>在<code>git commit</code>后stage区并不会清空（原贴有错误）。</li>
</ol>
<h3 id="撤消修改"><a class="header-anchor" href="#撤消修改">¶</a>撤消修改</h3>
<ul>
<li>命令<code>git checkout -- readme.txt</code>意思就是，把readme.txt文件在工作区的修改（从版本库）全部撤销，这里有两种情况：</li>
</ul>
<p>1. 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<div class="hljs code-wrapper"><pre><code>原布局：
    workdir            stage                 master
     test               test                  test

修改后：
    workdir            stage                 master
    test_mod            test                  test

git checkout -- readme.txt后：
    workdir            stage                 master
     test               test                  test
</code></pre></div>
<p>2. 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<div class="hljs code-wrapper"><pre><code>原布局：
    workdir            stage                 master
     test               test                  test

修改后并git add后又修改：
    workdir            stage                 master
    test_mod_mod      test_mod                test

git checkout -- readme.txt后：
    workdir            stage                 master
    test_mod          test_mod                  test
</code></pre></div>
<p>  <strong>总之，就是让这个文件回到最近一次<code>git commit</code>（修改后未<code>git add</code>）或<code>git add</code>（修改后已<code>git add</code>）时的状态。</strong></p>
<ul>
<li>命令<code>git reset HEAD file</code>意思就是，可以把暂存区的修改撤销掉（unstage），重新放回工作区。</li>
<li>小结：
<ul>
<li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li>
<li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，<strong>分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作</strong>。</li>
<li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</li>
</ul>
</li>
</ul>
<p>  笔记：</p>
<ul>
<li><code>git checkout -- file</code>是<strong>撤回</strong>，重点是使<strong>工作区</strong>文件与邻近的且不一致的区的文件一致。</li>
<li><code>git reset HEAD file</code>是<strong>重置</strong>，重点是将<strong>暂存区</strong>文件重置成<code>git add</code>前的状态。</li>
</ul>
<h3 id="删除文件"><a class="header-anchor" href="#删除文件">¶</a>删除文件</h3>
<ol>
<li>如果你用的<code>rm</code>删除文件，那就相当于只删除了工作区的文件，如果想要恢复，直接用<code>git checkout -- &lt;file&gt;</code>就可以。</li>
<li>如果你用的是<code>git rm</code>删除文件，那就相当于不仅删除了文件，而且还添加到了暂存区，需要先<code>git reset HEAD &lt;file&gt;</code>，然后再<code>git checkout -- &lt;file&gt;</code>。</li>
<li>如果你想彻底把版本库的删除掉，先<code>git rm</code>，再<code>git commit</code>就ok了。</li>
</ol>
<h2 id="远程仓库"><a class="header-anchor" href="#远程仓库">¶</a>远程仓库</h2>
<h3 id="添加远程库"><a class="header-anchor" href="#添加远程库">¶</a>添加远程库</h3>
<ol>
<li>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</li>
<li>关联后，使用命令<code>git push -u origin master</code>第一次推送<code>master</code>分支的所有内容；</li>
<li>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</li>
</ol>
<h2 id="分支管理"><a class="header-anchor" href="#分支管理">¶</a>分支管理</h2>
<h3 id="创建与合并分支"><a class="header-anchor" href="#创建与合并分支">¶</a>创建与合并分支</h3>
<ol>
<li>把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git checkout master<br>git merge dev<br></code></pre></div></td></tr></table></figure>
<p>2. Git分支常用命令：</p>
<ul>
<li>
<p>查看分支：<code>git branch</code></p>
</li>
<li>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
</li>
<li>
<p>切换分支：<code>git checkout &lt;name&gt;</code></p>
</li>
<li>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p>
<blockquote>
<p><strong>注意</strong>：</p>
<hr>
<p>新版本 git 已添加独立分支切换命令 <code>git switch</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建并切换分支</span><br>git switch -c &lt;name&gt;<br><br><span class="hljs-comment"># 切换分支</span><br>git switch &lt;name&gt;<br></code></pre></div></td></tr></table></figure>
</blockquote>
</li>
<li>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
</li>
<li>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
</li>
</ul>
<h3 id="Bug分支"><a class="header-anchor" href="#Bug分支">¶</a>Bug分支</h3>
<ol>
<li>工作区和暂存区是一个公开的工作台，任何分支都会用到，并能看到工作台上最新的内容，只要在工作区、暂存区的改动未能够提交到某一个版本库（分支）中，那么在任何一个分支下都可以看得到这个工作区、暂存区的最新实时改动。</li>
<li>使用<code>git stash</code>就可以将暂存区的修改藏匿起来，使整个工作台看起来都是干净的。所以要清理整个工作台，那么前提是必须先将工作区的内容都<code>git add</code>到暂存区中去。之后在干净的工作台上可以做另外一件紧急事件与藏匿起来的内容是完全独立的。</li>
<li>如果是修改的文件不用<code>git add</code>依然可以<code>git stash</code>，只有新文件才需要<code>git add</code>。</li>
</ol>
<h3 id="Feature分支"><a class="header-anchor" href="#Feature分支">¶</a>Feature分支</h3>
<ul>
<li>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</li>
</ul>
<h3 id="多人协作"><a class="header-anchor" href="#多人协作">¶</a>多人协作</h3>
<ul>
<li>查看远程库信息，使用<code>git remote -v</code>；</li>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>
<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li>
<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>
<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream-to=origin/branch-name branch-name</code>；</li>
<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>
</ul>
<h3 id="Rebase"><a class="header-anchor" href="#Rebase">¶</a>Rebase</h3>
<ul>
<li>只对尚未推送或分享给别人的本地修改执行变基操作清理历史；</li>
<li>从不对已推送至别处的提交执行变基操作。</li>
<li>在重放之前的提交的时候，Git会创建新的提交，也就是说即使你重放的提交与之前的一模一样Git也会将之当做新的独立的提交进行处理。</li>
<li><code>git rebase</code>并不会删除老的提交，也就是说你在对某个分支执行了<code>git rebase</code>操作之后，老的提交仍然会存放在.git文件夹的objects目录下。如果你对于Git是如何存放你的提交不太了解的话可以参考这篇文章：<a href="https://medium.freecodecamp.com/understanding-git-for-real-by-exploring-the-git-directory-1e079c15b807#.6ylqa5e2w" target="_blank" rel="noopener">Understanding git for real by exploring the .git directory</a><br>
<img src="https://image-static.segmentfault.com/206/854/2068544494-5783bdd025d80" alt="rebase"></li>
<li>设你本地有个branch A，服务器上也有branch A，然后你在本地对branch A进行了<code>git rebase</code>，然后出于某种原因必须<code>git push</code>到服务器，那么你必须使用<code>git push --force</code>。
<ol>
<li>如果你能确认branch A没有被其他人<code>git pull</code>过，那么接下来就没什么事了。</li>
<li>如果branch A已经被别人<code>git pull</code>过，那么你必须告诉那些人，在本地将branch A干掉：<code>git branch -D A</code>，然后<code>git fetch</code>，然后重新checkout：<code>git checkout A</code>。</li>
<li>如果branch A已经被别人git pull过，而且那些人在本地对branch A做了几个commit，那么，你必须让他们先<code>git push</code>上去之后，你再<code>git rebase</code>，然后参考步骤2。</li>
</ol>
</li>
</ul>
<h2 id="标签管理"><a class="header-anchor" href="#标签管理">¶</a>标签管理</h2>
<h3 id="创建标签"><a class="header-anchor" href="#创建标签">¶</a>创建标签</h3>
<ul>
<li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</li>
<li><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li>
<li>命令<code>git tag</code>可以查看所有标签。</li>
<li><strong>标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</strong></li>
<li>用GPG签名tag：<code>git tab -s &lt;tagbane&gt; -m &quot;blablabla...&quot;</code>。<a href="http://arondight.me/2016/04/17/%E4%BD%BF%E7%94%A8GPG%E7%AD%BE%E5%90%8DGit%E6%8F%90%E4%BA%A4%E5%92%8C%E6%A0%87%E7%AD%BE/" target="_blank" rel="noopener">GPG详解</a></li>
</ul>
<h3 id="操作标签"><a class="header-anchor" href="#操作标签">¶</a>操作标签</h3>
<ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
</ul>
<h2 id="子模块"><a class="header-anchor" href="#子模块">¶</a>子模块</h2>
<h3 id="使用前提"><a class="header-anchor" href="#使用前提">¶</a>使用前提</h3>
<p>经常碰到这种情况：当你在一个Git 项目上工作时，你需要在其中使用另外一个Git 项目。也许它是一个第三方开发的Git 库或者是你独立开发和并在多个父项目中使用的。这个情况下一个常见的问题产生了：你想将两个项目单独处理但是又需要在其中一个中使用另外一个。</p>
<p>在Git 中你可以用子模块<code>submodule</code>来管理这些项目，<code>submodule</code>允许你将一个Git 仓库当作另外一个Git 仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。</p>
<h3 id="添加子模块"><a class="header-anchor" href="#添加子模块">¶</a>添加子模块</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git submodule add https://github.com/maonx/vimwiki-assets.git assets<br></code></pre></div></td></tr></table></figure>
<h3 id="查看子模块"><a class="header-anchor" href="#查看子模块">¶</a>查看子模块</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git submodule<br> e33f854d3f51f5ebd771a68da05ad0371a3c0570 assets (heads/master)<br></code></pre></div></td></tr></table></figure>
<h3 id="更新子模块"><a class="header-anchor" href="#更新子模块">¶</a>更新子模块</h3>
<ul>
<li>
<p>更新项目内子模块到最新版本</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git submodule update<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>更新子模块为远程项目的最新版本</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git submodule update --remote<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
<h3 id="克隆包含子模块的项目"><a class="header-anchor" href="#克隆包含子模块的项目">¶</a>克隆包含子模块的项目</h3>
<h4 id="方式一：克隆父项目，再更新子模块"><a class="header-anchor" href="#方式一：克隆父项目，再更新子模块">¶</a>方式一：克隆父项目，再更新子模块</h4>
<ol>
<li>
<p>克隆父项目</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/maonx/vimwiki-assets.git assets<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>查看子模块</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git submodule<br> -e33f854d3f51f5ebd771a68da05ad0371a3c0570 assets<br></code></pre></div></td></tr></table></figure>
<p>子模块前面有一个<code>-</code>，说明子模块文件还未检入（空文件夹）。</p>
</li>
<li>
<p>初始化子模块</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git submodule init<br>Submodule <span class="hljs-string">'assets'</span> (https://github.com/maonx/vimwiki-assets.git) registered <span class="hljs-keyword">for</span> path <span class="hljs-string">'assets'</span><br></code></pre></div></td></tr></table></figure>
<p>初始化模块只需在克隆父项目后运行一次。</p>
</li>
<li>
<p>更新子模块</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git submodule update<br>Cloning into <span class="hljs-string">'assets'</span>...<br>remote: Counting objects: 151, <span class="hljs-keyword">done</span>.<br>remote: Compressing objects: 100% (80/80), <span class="hljs-keyword">done</span>.<br>remote: Total 151 (delta 18), reused 0 (delta 0), pack-reused 70<br>Receiving objects: 100% (151/151), 1.34 MiB | 569.00 KiB/s, <span class="hljs-keyword">done</span>.<br>Resolving deltas: 100% (36/36), <span class="hljs-keyword">done</span>.<br>Checking connectivity... <span class="hljs-keyword">done</span>.<br>Submodule path <span class="hljs-string">'assets'</span>: checked out <span class="hljs-string">'e33f854d3f51f5ebd771a68da05ad0371a3c0570'</span><br></code></pre></div></td></tr></table></figure>
</li>
</ol>
<h4 id="方式二：递归克隆整个项目"><a class="header-anchor" href="#方式二：递归克隆整个项目">¶</a>方式二：递归克隆整个项目</h4>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/maonx/vimwiki-assets.git assets --recursive<br></code></pre></div></td></tr></table></figure>
<p>递归克隆整个项目，子模块已经同时更新了，一步到位。</p>
<h3 id="修改子模块"><a class="header-anchor" href="#修改子模块">¶</a>修改子模块</h3>
<p>在子模块中修改文件后，直接提交到远程项目分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git add .<br>$ git ci -m <span class="hljs-string">"commit"</span><br>$ git push origin HEAD:master<br></code></pre></div></td></tr></table></figure>
<h3 id="删除子模块"><a class="header-anchor" href="#删除子模块">¶</a>删除子模块</h3>
<p><strong>删除子模块比较麻烦，需要手动删除相关的文件，否则在添加子模块时有可能出现错误</strong>。</p>
<ol>
<li>
<p>删除子模块文件夹</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git rm --cached assets<br>$ rm -rf assets<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>删除<code>.gitmodules</code>文件中相关子模块信息</p>
<figure class="highlight toml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs toml"><span class="hljs-section">[submodule "assets"]</span><br><span class="hljs-attr">path</span> = assets<br><span class="hljs-attr">url</span> = https://github.com/maonx/vimwiki-assets.git<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>删除<code>.git/config</code>中的相关子模块信息</p>
<figure class="highlight toml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs toml"><span class="hljs-section">[submodule "assets"]</span><br><span class="hljs-attr">url</span> = https://github.com/maonx/vimwiki-assets.git<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>删除<code>.git</code>文件夹中的相关子模块文件</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ rm -rf .git/modules/assets<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>关闭GNOME activity页面左边的dock</title>
    <url>/2018/10/22/%E5%85%B3%E9%97%ADGNOME-activity%E9%A1%B5%E9%9D%A2%E5%B7%A6%E8%BE%B9%E7%9A%84dock/</url>
    <content><![CDATA[<h1>关闭GNOME activity页面左边的dock</h1>
<p>************—</p>
<p>[TOC]</p>
<hr>
<ol>
<li>
<p>安装并配置“Dash to Dock”扩展。</p>
</li>
<li>
<p>编辑下面的文件：</p>
 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo vi /usr/share/gnome-shell/extensions/ubuntu-dock@ubuntu.com/extension.js<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>找到如下代码块，将其中的<code>let to_enable = true;</code>改成<code>let to_enable = false</code>：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">conditionallyenabledock</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> to_enable = <span class="hljs-literal">false</span>;<br>    runningExtensions = ExtensionSystem.extensionOrder;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; runningExtensions.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (runningExtensions[i] === <span class="hljs-string">"dash-to-dock@micxgx.gmail.com"</span>) &#123;<br>            to_enable = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// enable or disable dock depending on dock status and to_enable state</span><br>    <span class="hljs-keyword">if</span> (to_enable &amp;&amp; !dockManager) &#123;<br>        dockManager = <span class="hljs-keyword">new</span> Docking.DockManager();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!to_enable &amp;&amp; dockManager) &#123;<br>        dockManager.destroy();<br>        dockManager = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>重启会话或按<code>Alt + F2</code>并键入<code>restart</code>。</p>
</li>
</ol>
<blockquote>
<p><a href="https://askubuntu.com/questions/975387/why-do-i-have-two-docks-in-ubuntu-17-10-desktop" target="_blank" rel="noopener">原贴</a></p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GPG 使用</title>
    <url>/2018/10/22/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8GPG/</url>
    <content><![CDATA[<h1>GPG使用</h1>
<hr>
<p>Pretty Good Privacy</p>
<h3 id="GPG是什么"><a class="header-anchor" href="#GPG是什么">¶</a>GPG是什么</h3>
<p>提GPG 之前需要提一个软件叫PGP。PGP 是“Pretty Good Privacy” 的缩写，中文直译为“完美隐私”，名字言简意赅，上来就把软件的用途拍用户脸上。然而PGP 不是自由软件，所以自由软件基金会决定开发一个替代PGP 的自由软件，于是有了GPG（GnuPG）。</p>
<p>GPG 可以提供对信息、文件的签名和验证，或者是加密和解密，主要用于不安全网络上的信息传输。为此GPG 需要一个密钥环，GPG 使用私钥和公钥分别完成签名和加密，对应地验证和解密由公钥和私钥完成。</p>
<h3 id="主钥、从钥、公钥、私钥"><a class="header-anchor" href="#主钥、从钥、公钥、私钥">¶</a>主钥、从钥、公钥、私钥</h3>
<p>然而GPG 密钥环并不只有一对公钥和私钥，如果称公钥和其对应的私钥为一个密钥对的话，那么一个GPG 密钥环可以拥有很多个密钥对，每一个密钥对都由一个钥匙号（key ID）标识，被称为钥匙。其中有一个钥匙拥有签名其他钥匙的功能（可以在密钥环中创建钥匙），这个钥匙被称为主钥，其他的钥匙则被称为从钥。<br>
下面列出了我在使用的一个密钥环，首先是公钥。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ gpg --list-keys<br>/home/&lt;user&gt;/.gnupg/pubring.kbx<br>---------------------------------<br>pub   rsa4096/B66CC194 2016-04-15 [SC]<br>uid         [ 绝对 ] Arondight &lt;shell_way@foxmail.com&gt;<br>sub   rsa4096/F96E3CB7 2016-04-15 [E]<br></code></pre></div></td></tr></table></figure>
<p>然后是私钥。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ gpg --list-secret-keys<br>/home/&lt;user&gt;/.gnupg/pubring.kbx<br>---------------------------------<br>sec   rsa4096/B66CC194 2016-04-15 [SC]<br>uid         [ 绝对 ] Arondight &lt;shell_way@foxmail.com&gt;<br></code></pre></div></td></tr></table></figure>
<p>GPG 列出的每个密钥环第一行一定是主钥，其余的则为从钥，可以看到上面的密钥环中只有一个主钥和一个从钥。每个密钥后面有许多信息描述它的属性，例如sec rsa4096/B66CC194 2016-04-15 [SC] 代表这是一个主钥的私钥，加密算法为rsa，长度4096 位，主钥的钥匙号为B66CC194，创建于2016 年4 月15 日，功能为SC。</p>
<p>不难看出一个GPG 密钥环一共有四种类型的密钥，如果按照上面指令的样例输出来看的话则如下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">代表</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sec</td>
<td style="text-align:center">SECret key</td>
<td style="text-align:center">主钥的私钥</td>
</tr>
<tr>
<td style="text-align:center">pub</td>
<td style="text-align:center">PUBlic key</td>
<td style="text-align:center">主钥的公钥</td>
</tr>
<tr>
<td style="text-align:center">ssb</td>
<td style="text-align:center">Secret SuBkey</td>
<td style="text-align:center">从钥的私钥</td>
</tr>
<tr>
<td style="text-align:center">sub</td>
<td style="text-align:center">public SUBkey</td>
<td style="text-align:center">从钥的公钥</td>
</tr>
</tbody>
</table>
<p>至于这些钥匙的作用可以查看它们的功能，常用的功能有三种。</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">代表</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">Signing</td>
<td style="text-align:center">签名和验证信息</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">Encryption</td>
<td style="text-align:center">加密和解密信息</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">Certification</td>
<td style="text-align:center">签名和验证钥匙</td>
</tr>
</tbody>
</table>
<p>注意功能是针对一个钥匙而言的，由其中的公钥和私钥共同完成。其中加密和解密分别由钥匙的公钥和私钥完成，签名和验证则分别由私钥和公钥完成。一般地，GPG 密钥环中钥匙的公钥需要公布到网络上，也就意味着：</p>
<ol>
<li>所有人都能用你公布的公钥加密信息，加密后的信息只有持有私钥的你才能够解密。</li>
<li>你可以使用自己持有的私钥签名信息，所有人都能够用你公布的公钥验证签名的合法性。</li>
</ol>
<p>默认地，GPG 生成的密钥环，主钥用于签名和验证，从钥用于加密和解密。</p>
<h2 id="签名"><a class="header-anchor" href="#签名">¶</a>签名</h2>
<h3 id="生成密钥"><a class="header-anchor" href="#生成密钥">¶</a>生成密钥</h3>
<p>首先需要生成一个GPG 密钥环，GPG 在生成密钥的时候会使用一个根据你的操作生成的随机数，所以你可以在GPG 生成密钥的时候多做一些操作，例如点鼠标、敲键盘、复制文件等等。你可以利用dd 指令在生成密钥的期间做一些读写操作以让随机数字发生器获得足够的熵数。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ sudo dd <span class="hljs-keyword">if</span>=/dev/random of=/dev/null bs=4M<br></code></pre></div></td></tr></table></figure>
<p>然后可以生成GPG 密钥环，推荐使用–full-gen-key 选项来启用所有的功能。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ gpg --full-gen-key<br></code></pre></div></td></tr></table></figure>
<p>其中需要注意的事情有以下几项：</p>
<ol>
<li>密钥种类：形如<code>method1 and method2</code> 的选项是生成主钥和一个从钥，默认可以用于签名和加密，形如<code>method</code> 的选项只生成主钥，默认只能用于签名。</li>
<li>密钥长度：越长越安全，同时加密解密的时间花费越多，选择一个你认为合理的长度。</li>
<li>有效期限：你需要选择一个你认为合理的有效期限，钥匙到期后，签名将失效，GPG 服务器也会删除其公钥，所以一般来说你需要使用一个永不过期的钥匙。</li>
<li>钥匙密码：一定要为你的钥匙设置一个足够强壮的密码！</li>
</ol>
<h3 id="上传公钥到服务器"><a class="header-anchor" href="#上传公钥到服务器">¶</a>上传公钥到服务器</h3>
<p>现在你可以将你的公钥上传到任意GPG 服务器上了，这可以方便他人导入公钥以验证你的签名。通过服务器的交换机制，全球所有的GPG 服务器都会得到你的公钥。你可以列出你现在所拥有的公钥。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ gpg --list-keys<br>/home/&lt;user&gt;/.gnupg/pubring.kbx<br>---------------------------------<br>pub   rsa4096/B66CC194 2016-04-15 [SC]<br>uid         [ 绝对 ] Arondight &lt;shell_way@foxmail.com&gt;<br>sub   rsa4096/F96E3CB7 2016-04-15 [E]<br></code></pre></div></td></tr></table></figure>
<p>可以看到两个公钥，分别属于主钥<code>B66CC194</code> 和从钥<code>F96E3CB7</code>。上传时指定主钥的钥匙号（key ID）即可，GPG 会将密钥环中的公钥上传到指定的服务器。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ gpg --keyserver keys.gnupg.net --send-keys &lt;key ID&gt;<br></code></pre></div></td></tr></table></figure>
<h3 id="上传公钥到GitHub"><a class="header-anchor" href="#上传公钥到GitHub">¶</a>上传公钥到GitHub</h3>
<p>GitHub 刚刚发布了支持GPG 签名的消息，所以你可以选择使用GitHub 托管你的仓库。首先你需要以文本形式导出你主钥的公钥。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ gpg -a -o gnupg.pub --<span class="hljs-built_in">export</span> &lt;key ID&gt;<br></code></pre></div></td></tr></table></figure>
<p>然后打开你的GitHub 密钥管理界面，根据文件<code>gnupg.pub</code> 为你的GitHub 账户配置用于验证签名的公钥。</p>
<blockquote>
<p>注意：这一步不是必须的，你不一定要使用GitHub，或许你更喜欢使用其他的商业产品，或者自己搭建一个Git 服务器。Git 本身就是支持GPG 签名的，GitHub 对GPG 的支持仅是把验证结果在网页上显示出来（使用你上传的公钥）。</p>
</blockquote>
<h3 id="导出指纹"><a class="header-anchor" href="#导出指纹">¶</a>导出指纹</h3>
<p>然而不幸的是，任何人都可以冒充你的名义上传公钥到GPG 服务器，所以对方搜到以你的名义发布的公钥，不一定真的是你发布的。为了避免这个问题，你需要公布主钥的指纹。GPG 导入公钥后需要手动设置信任度。这时候对方就可以通过对比计算得到的主钥指纹和你提供的主钥指纹，来确定导入的主钥的合法性。</p>
<p>你可以像下面一样导出指纹。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ gpg --fingerprint &lt;key ID&gt; | perl -nE <span class="hljs-string">'$.-2 or s/^\h+// and print'</span> | tee fingerprint<br></code></pre></div></td></tr></table></figure>
<p>然后将<code>fingerprint</code> 文件提交到你的项目仓库中，或者公布在网络的其他位置。</p>
<ol>
<li>你只需（只能）导出主钥的指纹，对方也只需要验证主钥的指纹，因为主钥的公钥可以验证从钥。</li>
<li>你可以通过<code>--export-ownertrust</code> 和<code>--import-ownertrust</code> 来直接导出和导入信任度，但是不推荐这样做。</li>
</ol>
<h3 id="签名提交和标签"><a class="header-anchor" href="#签名提交和标签">¶</a>签名提交和标签</h3>
<p>首先你需要为Git 设置一个用于签名的私钥，通常来说所有的个人项目都用一个私钥进行签名，所以建议设置为全局配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git config --global user.signingkey &lt;key ID&gt;<br></code></pre></div></td></tr></table></figure>
<p>然后就可以使用这个私钥来签名提交。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git commit -S<br></code></pre></div></td></tr></table></figure>
<p>或者签名标签了。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git tag -s &lt;tag&gt;<br></code></pre></div></td></tr></table></figure>
<p>如果你想全局默认使用GPG 签名提交，可以全局将<code>commit.gpgsign</code> 设置为<code>true</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git config --global commit.gpgsign <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure>
<h3 id="关于私钥"><a class="header-anchor" href="#关于私钥">¶</a>关于私钥</h3>
<p>任何情况向下都不要把私钥泄露给除了你之外的任何人。如果需要向对方发送加密信息，请让对方提供指纹，导入对方的公钥进行加密，而不要用自己的公钥加密后再把自己的私钥发送过去。</p>
<h2 id="验证"><a class="header-anchor" href="#验证">¶</a>验证</h2>
<h3 id="获得公钥"><a class="header-anchor" href="#获得公钥">¶</a>获得公钥</h3>
<p>你可以根据你得到的信息在任何GPG 服务器上查找对应的公钥，典型的例如查看指纹（后8 位数字为钥匙号），然后根据得到的钥匙号到服务器上查找钥匙。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ gpg --keyserver keys.gnupg.net --search-keys &lt;key ID&gt;<br></code></pre></div></td></tr></table></figure>
<p>选择对应的编号，会自动下载并导入该公钥。你也可以根据用户名和邮箱进行查找。</p>
<h3 id="设置信任"><a class="header-anchor" href="#设置信任">¶</a>设置信任</h3>
<p>导入后的公钥需要设置信任度才能使用该公钥进行验证，你可以通过类似下面的指令编辑该公钥的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ gpg --edit-key &lt;key ID&gt;<br></code></pre></div></td></tr></table></figure>
<p>你所看到的应该是一个文本交互界面，下面是一个样例。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">gpg (GnuPG) 2.1.11; Copyright (C) 2016 Free Software Foundation, Inc.<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.<br>pub  rsa4096/B66CC194<br>     创建于：2016-04-15  有效至：永不过期  可用于：SC<br>     信任度：未知        有效性：未知<br>sub  rsa4096/F96E3CB7<br>     创建于：2016-04-15  有效至：永不过期  可用于：E<br>[ 未知 ] (1). Arondight &lt;shell_way@foxmail.com&gt;<br>gpg&gt;<br></code></pre></div></td></tr></table></figure>
<p>你可以键入<code>fpr</code> 来打印这个主钥的指纹，和你得到的主钥指纹进行对比，如果一致则键入<code>trust</code> 来设置主钥的信任度。如果主钥被设置为绝对可信的（ultimately），GPG 会根据主钥的公钥验证从钥的签名，最终完成信任建立。最后键入<code>quit</code>退出。</p>
<h3 id="验证签名"><a class="header-anchor" href="#验证签名">¶</a>验证签名</h3>
<p>现在你可以用导入的公钥来验证你<code>git clone</code> 下来的仓库的提交和标签了，同样你需要首先告诉Git 应该使用哪个公钥对这个仓库进行验证。一般来说不同作者的项目公钥都不同，建议不要将用于验证的公钥设置为全局。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git config user.signingkey &lt;key ID&gt;<br>然后可以像下面这样验证一个提交。<br></code></pre></div></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git verify-commit &lt;commit ID&gt;<br></code></pre></div></td></tr></table></figure>
<p>或者验证一个标签。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git tag -v &lt;tag&gt;<br></code></pre></div></td></tr></table></figure>
<h2 id="扩展阅读"><a class="header-anchor" href="#扩展阅读">¶</a>扩展阅读</h2>
<h3 id="签名和验证"><a class="header-anchor" href="#签名和验证">¶</a>签名和验证</h3>
<table>
<thead>
<tr>
<th style="text-align:center">动作</th>
<th style="text-align:center">指令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">二进制方式签名文件</td>
<td style="text-align:center"><code>gpg -u &lt;key ID&gt; -s &lt;file&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">纯文本方式签名文件</td>
<td style="text-align:center"><code>gpg -u &lt;key ID&gt; --clearsign &lt;file&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">签名文件并独立存放签名</td>
<td style="text-align:center"><code>gpg -u &lt;key ID&gt; --detach-sign &lt;file&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">验证文件</td>
<td style="text-align:center"><code>gpg --verify-files &lt;file&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">通过独立的签名文件验证文件</td>
<td style="text-align:center"><code>gpg --verify-files &lt;file_sig&gt; &lt;file&gt;</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果不指定<code>-u</code> 选项，会使用第一个密钥环中主钥的私钥进行签名。</p>
</blockquote>
<h3 id="加密和解密"><a class="header-anchor" href="#加密和解密">¶</a>加密和解密</h3>
<table>
<thead>
<tr>
<th style="text-align:center">动作</th>
<th style="text-align:center">指令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">二进制方式加密文件</td>
<td style="text-align:center"><code>gpg -r &lt;key ID&gt; -e &lt;file&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">纯文本方式加密文件</td>
<td style="text-align:center"><code>gpg -r &lt;key ID&gt; -a -e &lt;file&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">解密文件</td>
<td style="text-align:center"><code>gpg &lt;file&gt;</code></td>
</tr>
</tbody>
</table>
<ul>
<li>这里你需要指定从钥的钥匙号，如果<code>-r</code> 选项被省略，GPG 会交互式的请求一个钥匙号。</li>
<li>如果你想在加密的同时签名文件，在加密指令中额外指定一个<code>-s</code>选项。</li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Web</tag>
        <tag>GPG</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux使用手册</title>
    <url>/2018/10/19/Tmux%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1>Tmux使用手册</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="导读"><a class="header-anchor" href="#导读">¶</a>导读</h2>
<p>  我一直信奉简洁至上的原则，桌面窗口的数量越少，我的心情就越放松，开发的效率也就越高。反之，杂乱的桌面，暴涨的 Chrome tab 数量，或是无数的终端窗口，它们会逐步侵占我的注意力，分散我的思维，最终令我难以专注。因此桌面上我很少放文件，使用 Chrome 时常点 <a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall" target="_blank" rel="noopener">OneTab</a> 回收标签页，切进终端时使用 tmux 管理窗口。<br>
  那么，有没有可能开机后不需要任何操作，本地的十几种 web 开发服务就自动运行？当然我不希望连续弹出十几个窗口或是 tab，我需要的是静默无感知的启用服务，然后还能快速地进入到现场进行操作，web 服务运行时不占据终端窗口，关闭 iTem2 后操作现场不会被销毁。诸如此类，tmux 都能实现，除了这些，tmux 还能做得更多更好。<br>
  到目前为止，tmux 帮助我两年有余，它带给我许多惊喜。独乐不如众乐，愿你也能一同享受 tmux 带来的快乐。</p>
<hr>
<h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2>
<p>  tmux 是一款优秀的终端复用软件，它比 Screen 更加强大，至于如何强大，网上有大量的文章讨论了这点，本文不再重复。tmux 之所以受人们喜爱，主要得益于以下三处功能：</p>
<ul>
<li>丝滑分屏（split），虽然 iTem2 也提供了横向和竖向分屏功能，但这种分屏功能非常拙劣，完全等同于屏幕新开一个窗口，新开的 pane 不会自动进入到当前目录，也没有记住当前登录状态。这意味着如果我 ssh 进入到远程服务器时，iTem2 新开的 pane 中，我依然要重新走一遍 ssh 登录的老路（omg）。tmux 就不会这样，tmux 窗口中，新开的 pane，默认进入到之前的路径，如果是 ssh 连接，登录状态也依旧保持着，如此一来，我就可以随意的增删 pane，这种灵活性，好处不言而喻。</li>
<li>保护现场（attach），即使命令行的工作只进行到一半，关闭终端后还可以重新进入到操作现场，继续工作。对于 ssh 远程连接而言，即使网络不稳定也没有关系，掉线后重新连接，可以直奔现场，之前运行中的任务，依旧在跑，就好像从来没有离开过一样；特别是在远程服务器上运行耗时的任务，tmux 可以帮你一直保持住会话。如此一来，你就可以随时随地放心地进行移动办公，只要你附近的计算机装有 tmux（没有你也可以花几分钟装一个），你就能继续刚才的工作。</li>
<li>会话共享（适用于结对编程或远程教学），将 tmux 会话的地址分享给他人，这样他们就可以通过 SSH 接入该会话。如果你要给同事演示远程服务器的操作，他不必直勾勾地盯着你的屏幕，借助 tmux，他完全可以进入到你的会话，然后静静地看着他桌面上你风骚的键盘走位，只要他愿意，甚至还可以录个屏。</li>
</ul>
<p>  以上，只是主要功能，更多功能还在后头，接下来我将详细地介绍 tmux 的使用技巧。</p>
<hr>
<h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2>
<p>  首先安装之。<br>
  在 Mac 中安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 先安装Homebrew，有则跳过</span><br>ruby -e <span class="hljs-string">"<span class="hljs-variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span><br><span class="hljs-comment"># 安装tmux</span><br>brew install tmux<br></code></pre></div></td></tr></table></figure>
<p>  在 Linux 中安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install tmux<br></code></pre></div></td></tr></table></figure>
<hr>
<h2 id="基本概念"><a class="header-anchor" href="#基本概念">¶</a>基本概念</h2>
<p>  开始之前，我们先了解下基本概念：<br>
  tmux 采用 C/S 模型构建，输入 tmux 命令就相当于开启了一个服务器，此时默认将新建一个会话，然后会话中默认新建一个窗口，窗口中默认新建一个面板。会话、窗口、面板之间的联系如下：</p>
<ul>
<li>
<p>一个 tmux session（会话）可以包含多个 window（窗口），窗口默认充满会话界面，因此这些窗口中可以运行相关性不大的任务。</p>
</li>
<li>
<p>一个 window 又可以包含多个 pane（面板），窗口下的面板，都处于同一界面下，这些面板适合运行相关性高的任务，以便同时观察到它们的运行情况。</p>
</li>
</ul>
<p><img src="https://rabbituzki-blog-images.oss-cn-beijing.aliyuncs.com/tmux/tmux01.png" alt="基本概念"></p>
<hr>
<h2 id="会话"><a class="header-anchor" href="#会话">¶</a>会话</h2>
<h3 id="新建会话"><a class="header-anchor" href="#新建会话">¶</a>新建会话</h3>
<p>  新建一个 tmux session 非常简单，语法为 <code>tmux new -s session-name</code>，也可以简写为 tmux，为了方便管理，建议指定会话名称，如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmux <span class="hljs-comment"># 新建一个无名称的会话</span><br>tmux new -s demo <span class="hljs-comment"># 新建一个名称为demo的会话</span><br></code></pre></div></td></tr></table></figure>
<h3 id="断开当前会话"><a class="header-anchor" href="#断开当前会话">¶</a>断开当前会话</h3>
<p>  会话中操作了一段时间，我希望断开会话同时下次还能接着用，怎么做？此时可以使用 <code>detach</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmux detach <span class="hljs-comment"># 断开当前会话，会话在后台运行</span><br></code></pre></div></td></tr></table></figure>
<p>  也许你觉得这个太麻烦了，是的，tmux 的会话中，我们已经可以使用 tmux 快捷键了。使用快捷键组合 Ctrl+b+d，三次按键就可以断开当前会话。</p>
<h3 id="进入之前的会话"><a class="header-anchor" href="#进入之前的会话">¶</a>进入之前的会话</h3>
<p>  断开会话后，想要接着上次留下的现场继续工作，就要使用到 tmux 的 <code>attach</code> 命令了，语法为 <code>tmux attach-session -t session-name</code>，可简写为<code>tmux a -t session-name</code> 或 <code>tmux a</code>。通常我们使用如下两种方式之一即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmux a <span class="hljs-comment"># 默认进入第一个会话</span><br>tmux a -t demo <span class="hljs-comment"># 进入到名称为demo的会话</span><br></code></pre></div></td></tr></table></figure>
<h3 id="关闭会话"><a class="header-anchor" href="#关闭会话">¶</a>关闭会话</h3>
<p>  会话的使命完成后，一定是要关闭的。我们可以使用 tmux 的 <code>kill</code> 命令，<code>kill</code> 命令有 <code>kill-pane</code>、<code>kill-server</code>、<code>kill-session</code>  和 <code>kill-window</code> 共四种，其中 <code>kill-session</code> 的语法为 <code>tmux kill-session -t session-name</code>。如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmux <span class="hljs-built_in">kill</span>-session -t demo <span class="hljs-comment"># 关闭demo会话</span><br>tmux <span class="hljs-built_in">kill</span>-server <span class="hljs-comment"># 关闭服务器，所有的会话都将关闭</span><br></code></pre></div></td></tr></table></figure>
<h3 id="查看所有会话"><a class="header-anchor" href="#查看所有会话">¶</a>查看所有会话</h3>
<p>  管理会话的第一步就是要查看所有的会话，我们可以使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmux list-session <span class="hljs-comment"># 查看所有会话</span><br>tmux ls <span class="hljs-comment"># 查看所有会话，提倡使用简写形式</span><br></code></pre></div></td></tr></table></figure>
<p>  如果刚好处于会话中怎么办？别担心，我们可以使用对应的 tmux 快捷键Ctrl+b+s，此时 tmux 将打开一个会话列表，按上下键（↑↓︎）或者鼠标滚轮，可选中目标会话，按左右键（←→︎）可收起或展开会话的窗口，选中目标会话或窗口后，按回车键即可完成切换。</p>
<p><img src="https://rabbituzki-blog-images.oss-cn-beijing.aliyuncs.com/tmux/tmux02.png" alt="查看会话"></p>
<h2 id="Tmux-快捷指令"><a class="header-anchor" href="#Tmux-快捷指令">¶</a>Tmux 快捷指令</h2>
<p>  关于快捷指令，首先要认识到的是：tmux 的所有指令，都包含同一个前缀，默认为 Ctrl+b，输入完前缀过后，控制台激活，命令按键才能生效。前面 tmux 会话相关的操作中，我们共用到了两个快捷键 Ctrl+b+d、Ctrl+b+s，但这仅仅是冰山一角，欲窥 tmux 庞大的快捷键体系，请看下表。</p>
<p>表一：系统指令。</p>
<table>
<thead>
<tr>
<th style="text-align:center">前缀</th>
<th style="text-align:center">指令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">?</td>
<td style="text-align:center">显示快捷键帮助文档</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">d</td>
<td style="text-align:center">断开当前会话</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">D</td>
<td style="text-align:center">选择要断开的会话</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">Ctrl+z</td>
<td style="text-align:center">挂起当前会话</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">r</td>
<td style="text-align:center">强制重载当前会话</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">s</td>
<td style="text-align:center">显示会话列表用于选择并切换</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">:</td>
<td style="text-align:center">进入命令行模式，此时可直接输入ls等命令</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">[</td>
<td style="text-align:center">进入复制模式，按q退出</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">]</td>
<td style="text-align:center">粘贴复制模式中复制的文本</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">~</td>
<td style="text-align:center">列出提示信息缓存</td>
</tr>
</tbody>
</table>
<p>表二：窗口（window）指令。</p>
<table>
<thead>
<tr>
<th style="text-align:center">前缀</th>
<th style="text-align:center">指令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">c</td>
<td style="text-align:center">新建窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">关闭当前窗口（关闭前需输入y or n确认）</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">0~9</td>
<td style="text-align:center">切换到指定窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">p</td>
<td style="text-align:center">切换到上一窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">n</td>
<td style="text-align:center">切换到下一窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">w</td>
<td style="text-align:center">打开窗口列表，用于且切换窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">,</td>
<td style="text-align:center">重命名当前窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">.</td>
<td style="text-align:center">修改当前窗口编号（适用于窗口重新排序）</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">f</td>
<td style="text-align:center">快速定位到窗口（输入关键字匹配窗口名称）</td>
</tr>
</tbody>
</table>
<p>表三：面板（pane）指令。</p>
<table>
<thead>
<tr>
<th style="text-align:center">前缀</th>
<th style="text-align:center">指令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">&quot;</td>
<td style="text-align:center">当前面板上下一分为二，下侧新建面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">%</td>
<td style="text-align:center">当前面板左右一分为二，右侧新建面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">x</td>
<td style="text-align:center">关闭当前面板（关闭前需输入y or n确认）</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">z</td>
<td style="text-align:center">最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增）</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">!</td>
<td style="text-align:center">将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效）</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">;</td>
<td style="text-align:center">切换到最后一次使用的面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">q</td>
<td style="text-align:center">显示面板编号，在编号消失前输入对应的数字可切换到相应的面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">{</td>
<td style="text-align:center">向前置换当前面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">}</td>
<td style="text-align:center">向后置换当前面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">Ctrl+o</td>
<td style="text-align:center">顺时针旋转当前窗口中的所有面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">方向键</td>
<td style="text-align:center">移动光标切换面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">o</td>
<td style="text-align:center">选择下一面板</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">空格键</td>
<td style="text-align:center">在自带的面板布局中循环切换</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">Alt+方向键</td>
<td style="text-align:center">以5个单元格为单位调整当前面板边缘</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">Ctrl+方向键</td>
<td style="text-align:center">以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖）</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">t</td>
<td style="text-align:center">显示时钟</td>
</tr>
</tbody>
</table>
<p>  tmux 的丝滑分屏功能正是得益于以上系统、窗口、面板的快捷指令，只要你愿意，你就可以解除任意的快捷指令，然后绑上你喜欢的指令，当然这就涉及到它的可配置性了，请继续往下读。</p>
<hr>
<h2 id="灵活的配置性"><a class="header-anchor" href="#灵活的配置性">¶</a>灵活的配置性</h2>
<p>  除了快捷指令外，tmux 还提供了类似 vim 的配置性功能。可配置性是软件的一项进阶级功能，只有具备了可配置性，软件才有了鲜活的个性，用户才能体会到操作的快感。</p>
<h3 id="修改指令前缀"><a class="header-anchor" href="#修改指令前缀">¶</a>修改指令前缀</h3>
<p>  相信只要你用过几次 tmux，就会发现 Ctrl+b 指令前缀，着实不太方便。这两个键相距太远，按键成本太高了。因此我们首先需要将它更换为距离更近的 Ctrl+a 组合键，或者不常用的 ` 键（当然其他键也是可以的）。<br>
  tmux 的用户级配置文件为 <em>~/.tmux.conf</em>（没有的话就创建一个），修改快捷指令，只需要增加如下三行即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g prefix C<span class="hljs-_">-a</span> <span class="hljs-comment">#</span><br>unbind C-b <span class="hljs-comment"># C-b即Ctrl+b键，unbind意味着解除绑定</span><br><span class="hljs-built_in">bind</span> C<span class="hljs-_">-a</span> send-prefix <span class="hljs-comment"># 绑定Ctrl+a为新的指令前缀</span><br><br><span class="hljs-comment"># 从tmux v1.6版起，支持设置第二个指令前缀</span><br><span class="hljs-built_in">set</span>-option -g prefix2 ` <span class="hljs-comment"># 设置一个不常用的`键作为指令前缀，按键更快些</span><br></code></pre></div></td></tr></table></figure>
<p>  修改的 <em>~/.tmux.conf</em> 配置文件有如下两种方式可以令其生效：</p>
<ul>
<li>restart tmux。</li>
<li>在 tmux 窗口中，先按下 Ctrl+b 指令前缀，然后按下系统指令 <code>:</code>，进入到命令模式后输入 <code>source-file ~/.tmux.conf</code>，回车后生效。</li>
</ul>
<p>  既然快捷指令如此方便，更为优雅的做法是新增一个加载配置文件的快捷指令 ，这样就可以随时随地 load 新的配置了，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 绑定快捷键为r</span><br><span class="hljs-built_in">bind</span> r <span class="hljs-built_in">source</span>-file ~/.tmux.conf \; display-message <span class="hljs-string">"Config reloaded.."</span><br></code></pre></div></td></tr></table></figure>
<p>  请特别注意，在已经创建的窗口中，即使加载了新的配置，旧的配置依然有效（只要你新加的功能没有覆盖旧的配置，因此如果你第一次绑定快捷指令为 x 键，然后又改为绑定 y 键，那么 x 和 y 都将有效），新建会话不受此影响，将直接采用新的配置。<br>
  既然我们已经迈出配置化的第一步，那么接下来我们可以做得更多。</p>
<h3 id="新增面板"><a class="header-anchor" href="#新增面板">¶</a>新增面板</h3>
<p>  tmux 中，使用最多的功能之一就是新增一个面板。水平方向新增面板的指令是 prefix + &quot; ，垂直方向是 prefix + %，&quot; 和 % 需要两个键同时按下才能完成，加上指令前缀至少需要3~4次按键才能组成一个完整的指令，同时这个两个键也不够醒目和方便，因此我们可以绑定两个更常用的指令 <code>-</code>、<code>|</code>，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">unbind <span class="hljs-string">'"'</span><br><span class="hljs-built_in">bind</span> - splitw -v -c <span class="hljs-string">'#&#123;pane_current_path&#125;'</span> <span class="hljs-comment"># 垂直方向新增面板，默认进入当前目录</span><br>unbind %<br><span class="hljs-built_in">bind</span> | splitw -h -c <span class="hljs-string">'#&#123;pane_current_path&#125;'</span> <span class="hljs-comment"># 水平方向新增面板，默认进入当前目录</span><br></code></pre></div></td></tr></table></figure>
<h3 id="开启鼠标支持"><a class="header-anchor" href="#开启鼠标支持">¶</a>开启鼠标支持</h3>
<p>  默认情况下，tmux 的多窗口之间的切换以及面板大小调整，需要输入指令才能完成，这一过程，涉及到的指令较多，而且操作麻烦，特别是面板大小调整，指令难以一步到位，这个时候开启鼠标支持就完美了。<br>
  对于tmux v2.1(2015.10.28) 之前的版本，需加入如下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">setw -g mode-mouse on <span class="hljs-comment"># 支持鼠标选取文本等</span><br>setw -g mouse-resize-pane on <span class="hljs-comment"># 支持鼠标拖动调整面板的大小(通过拖动面板间的分割线)</span><br>setw -g mouse-select-pane on <span class="hljs-comment"># 支持鼠标选中并切换面板</span><br>setw -g mouse-select-window on <span class="hljs-comment"># 支持鼠标选中并切换窗口(通过点击状态栏窗口名称)</span><br></code></pre></div></td></tr></table></figure>
<p>  有的地方可能会出现 <code>set-window-option</code> 的写法，<code>setw</code> 就是它的别名。<br>
  对于 tmux v2.1 及以上的版本，仅需加入如下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span>-option -g mouse on <span class="hljs-comment"># 等同于以上4个指令的效果</span><br></code></pre></div></td></tr></table></figure>
<p>  需要注意的是，开启鼠标支持后，iTem2 默认的鼠标选中即复制功能需要同时按下 Alt 键，才会生效。</p>
<h3 id="快速面板切换"><a class="header-anchor" href="#快速面板切换">¶</a>快速面板切换</h3>
<p>  鼠标支持确实能带来很大的便捷性，特别是对于习惯了鼠标操作的 tmux 新手，但对于键盘爱好者而言，这不是什么好消息，对他们而言，双手不离键盘是基本素质。<br>
虽然指令前缀加方向键可以切换面板，但方向键太远，不够快，不够 Geek。没关系，我们可以将面板切换升级为熟悉的 h、j、k、l 键位。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 绑定hjkl键为面板切换的上下左右键</span><br><span class="hljs-built_in">bind</span> -r k select-pane -U <span class="hljs-comment"># 绑定k为↑</span><br><span class="hljs-built_in">bind</span> -r j select-pane -D <span class="hljs-comment"># 绑定j为↓</span><br><span class="hljs-built_in">bind</span> -r h select-pane -L <span class="hljs-comment"># 绑定h为←</span><br><span class="hljs-built_in">bind</span> -r l select-pane -R <span class="hljs-comment"># 绑定l为→</span><br></code></pre></div></td></tr></table></figure>
<p>  <code>-r</code> 表示可重复按键，大概 500ms 之内，重复的 h、j、k、l 按键都将有效，完美支持了快速切换的 Geek 需求。<br>
  除了上下左右外， 还有几个快捷指令可以设置。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> -r e lastp <span class="hljs-comment"># 选择最后一个面板</span><br><span class="hljs-built_in">bind</span> -r ^e last <span class="hljs-comment"># 选择最后一个窗口</span><br><br><span class="hljs-built_in">bind</span> -r ^u swapp -U <span class="hljs-comment"># 与前一个面板交换位置</span><br><span class="hljs-built_in">bind</span> -r ^d swapp -D <span class="hljs-comment"># 与后一个面板交换位置</span><br></code></pre></div></td></tr></table></figure>
<h3 id="面板大小调整"><a class="header-anchor" href="#面板大小调整">¶</a>面板大小调整</h3>
<p>  习惯了全键盘操作后，命令的便捷性不言而喻。既然面板切换的指令都可以升级，面板大小调整的指令自然也不能落后。如下配置就可以升级你的操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 绑定Ctrl+hjkl键为面板上下左右调整边缘的快捷指令</span><br><span class="hljs-built_in">bind</span> -r ^k resizep -U 10 <span class="hljs-comment"># 绑定Ctrl+k为往↑调整面板边缘10个单元格</span><br><span class="hljs-built_in">bind</span> -r ^j resizep -D 10 <span class="hljs-comment"># 绑定Ctrl+j为往↓调整面板边缘10个单元格</span><br><span class="hljs-built_in">bind</span> -r ^h resizep -L 10 <span class="hljs-comment"># 绑定Ctrl+h为往←调整面板边缘10个单元格</span><br><span class="hljs-built_in">bind</span> -r ^l resizep -R 10 <span class="hljs-comment"># 绑定Ctrl+l为往→调整面板边缘10个单元格</span><br></code></pre></div></td></tr></table></figure>
<p>  以上，<code>resizep</code> 即 <code>resize-pane</code> 的别名。</p>
<h3 id="面板最大化"><a class="header-anchor" href="#面板最大化">¶</a>面板最大化</h3>
<p>  当窗口中面板的数量逐渐增多时，每个面板的空间就会逐渐减少。为了保证有足够的空间显示内容，tmux 从 v1.8 版本起，提供了面板的最大化功能，输入 tmux-prefix+z，就可以最大化当前面板至窗口大小，只要再重复输入一次，便恢复正常。那么 tmux v1.8 以下的版本，怎么办呢？别急，有大神提供了如下的解决方案。<br>
  首先编写一个 zoom 脚本，该脚本通过新建一个窗口，交换当前面板与新的窗口默认面板位置，来模拟最大的功能；通过重复一次按键，还原面板位置，并关闭新建的窗口，来模拟还原功能，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#!/bin/bash -f</span><br>currentwindow=`tmux list-window | tr <span class="hljs-string">'\t'</span> <span class="hljs-string">' '</span> | sed -n -e <span class="hljs-string">'/(active)/s/^[^:]*: *\([^ ]*\) .*/\1/gp'</span>`;<br>currentpane=`tmux list-panes | sed -n -e <span class="hljs-string">'/(active)/s/^\([^:]*\):.*/\1/gp'</span>`;<br>panecount=`tmux list-panes | wc | sed -e <span class="hljs-string">'s/^ *//g'</span> -e <span class="hljs-string">'s/ .*$//g'</span>`;<br>inzoom=`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$currentwindow</span> | sed -n -e <span class="hljs-string">'/^zoom/p'</span>`;<br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$panecount</span> -ne 1 ]; <span class="hljs-keyword">then</span><br>    inzoom=<span class="hljs-string">""</span>;<br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$inzoom</span> ]; <span class="hljs-keyword">then</span><br>    lastpane=`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$currentwindow</span> | rev | cut -f 1 -d <span class="hljs-string">'@'</span> | rev`;<br>    lastwindow=`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$currentwindow</span> | cut -f 2- -d <span class="hljs-string">'@'</span> | rev | cut -f 2- -d <span class="hljs-string">'@'</span> | rev`;<br>    tmux select-window -t <span class="hljs-variable">$lastwindow</span>;<br>    tmux select-pane -t <span class="hljs-variable">$lastpane</span>;<br>    tmux swap-pane -s <span class="hljs-variable">$currentwindow</span>;<br>    tmux <span class="hljs-built_in">kill</span>-window -t <span class="hljs-variable">$currentwindow</span>;<br><span class="hljs-keyword">else</span><br>    newwindowname=zoom@<span class="hljs-variable">$currentwindow</span>@<span class="hljs-variable">$currentpane</span>;<br>    tmux new-window -d -n <span class="hljs-variable">$newwindowname</span>;<br>    tmux swap-pane -s <span class="hljs-variable">$newwindowname</span>;<br>    tmux select-window -t <span class="hljs-variable">$newwindowname</span>;<br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure>
<p>  不妨将该脚本存放在 <em>~/.tmux</em> 目录中（没有则新建目录），接下来只需要绑定一个快捷指令就行，如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">unbind z<br><span class="hljs-built_in">bind</span> z run <span class="hljs-string">". ~/.tmux/zoom"</span><br></code></pre></div></td></tr></table></figure>
<h3 id="窗口变为面板"><a class="header-anchor" href="#窗口变为面板">¶</a>窗口变为面板</h3>
<p>  通过上面的 zoom 脚本，面板可以轻松地最大化为一个新的窗口。那么反过来，窗口是不是可以最小化为一个面板呢？</p>
<blockquote>
<p>试想这样一个场景：当你打开多个窗口后，然后想将其中几个窗口合并到当前窗口中，以便对比观察输出。</p>
</blockquote>
<p>  实际上，你的要求就是将其它窗口变成面板，然后合并到当前窗口中。对于这种操作，我们可以在当前窗口，按下 prefix + :，打开命令行，然后输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">join-pane -s window01 <span class="hljs-comment"># 合并名称为window01的窗口的默认（第一个）面板到当前窗口中</span><br>join-pane -s window01.1 <span class="hljs-comment"># .1显式指定了第一个面板，.2就是第二个面板(我本地将面板编号起始值设置为1，默认是0)</span><br></code></pre></div></td></tr></table></figure>
<p>   每次执行 <code>join-pane</code> 命令都会合并一个面板，并且指定的窗口会减少一个面板，直到面板数量为 0，窗口关闭。<br>
  除了在当前会话中操作外，<code>join-pane</code> 命令甚至可以从其它指定会话中合并面板，格式为 <code>join-pane -s [session_name]:[window].[pane]</code>，如 <code>join-pane -s 2:1.1</code> 即合并第二个会话的第一个窗口的第一个面板到当前窗口，当目标会话的窗口和面板数量为 0 时，会话便会关闭。</p>
<blockquote>
<p>注：上一节中的 <code>swap-pane</code> 命令与 <code>join-pane</code> 语法基本一致。</p>
</blockquote>
<h3 id="其他配置"><a class="header-anchor" href="#其他配置">¶</a>其他配置</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> m <span class="hljs-built_in">command</span>-prompt <span class="hljs-string">"splitw -h 'exec man %%'"</span>   <span class="hljs-comment"># 绑定m键为在新的panel打开man</span><br><span class="hljs-comment"># 绑定P键为开启日志功能，如下，面板的输出日志将存储到桌面</span><br><span class="hljs-built_in">bind</span> P pipe-pane -o <span class="hljs-string">"cat &gt;&gt;~/Desktop/#W.log"</span> \; display <span class="hljs-string">"Toggled logging to ~/Desktop/#W.log"</span><br></code></pre></div></td></tr></table></figure>
<h3 id="恢复用户空间"><a class="header-anchor" href="#恢复用户空间">¶</a>恢复用户空间</h3>
<p>  tmux 会话中，Mac 的部分命令如 <code>osascript</code>、<code>open</code>、<code>pbcopy</code> 或 <code>pbpaste</code>等可能会失效（失效命令未列全）。<br>
  部分 bug 列表如下：</p>
<ul>
<li><a href="https://apple.stackexchange.com/questions/174779/unable-to-run-display-notification-using-osascript-in-a-tmux-session" target="_blank" rel="noopener">applescript - Unable to run ‘display notification’ using osascript in a tmux session</a></li>
<li><a href="https://stackoverflow.com/questions/30404944/open-command-doesnt-work-properly-inside-tmux/30412054#30412054" target="_blank" rel="noopener">osx - “open” command doesn’t work properly inside tmux</a></li>
<li><a href="https://stackoverflow.com/questions/16618992/cant-paste-into-macvim/16661806#16661806" target="_blank" rel="noopener">clipboard - Can’t paste into MacVim</a></li>
</ul>
<p>  对此，我们可以通过安装 reattach-to-user-namespace 包装程序来解决这个问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">brew install reattach-to-user-namespace<br></code></pre></div></td></tr></table></figure>
<p>  在 <em>~/.tmux.conf</em> 中添加配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g default-command <span class="hljs-string">"reattach-to-user-namespace -l <span class="hljs-variable">$SHELL</span>"</span><br></code></pre></div></td></tr></table></figure>
<p>  这样你的交互式 shell 最终能够重新连接到用户级的命名空间。由于连接状态能够被子进程继承，故以上配置保证了所有从 shell 启动的命令能够被正确地连接。<br>
  有些时候，我们可能会在不同的操作系统中共享配置文件，如果你的 tmux 版本大于 1.9，我们还可以使用 <code>if-shell</code> 来判断是否 Mac 系统，然后再指定  <code>default-command</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span>-shell <span class="hljs-string">'test "$(uname -s)" = Darwin'</span> <span class="hljs-string">'set-option -g default-command "exec reattach-to-user-namespace -l $SHELL"'</span><br></code></pre></div></td></tr></table></figure>
<p>  对于 tmux v1.8 及更早的版本，可以使用如下包装后的配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span>-option -g default-command <span class="hljs-string">'command -v reattach-to-user-namespace &gt;/dev/null &amp;&amp; exec reattach-to-user-namespace -l "$SHELL" || exec "$SHELL"'</span><br></code></pre></div></td></tr></table></figure>
<p>  以上，<code>$SHELL</code> 对应于你的默认 Shell，通常是 <em>/usr/bin/bash</em> 或 <em>/usr/local/bin/zsh</em>。</p>
<hr>
<h2 id="复制模式"><a class="header-anchor" href="#复制模式">¶</a>复制模式</h2>
<p>  tmux 中操作文本，自然离不开复制模式，通常使用复制模式的步骤如下：</p>
<ol>
<li>输入 `+[ 进入复制模式</li>
<li>按下 空格键 开始复制，移动光标选择复制区域</li>
<li>按下 回车键 复制选中文本并退出复制模式</li>
<li>按下 `+] 粘贴文本</li>
</ol>
<p>  查看复制模式默认的快捷键风格：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmux show-window-options -g mode-keys <span class="hljs-comment"># mode-keys emacs</span><br></code></pre></div></td></tr></table></figure>
<p>  默认情况下，快捷键为 emacs 风格。<br>
  为了让复制模式更加方便，我们可以将快捷键设置为熟悉的 vi 风格，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">setw -g mode-keys vi <span class="hljs-comment"># 开启vi风格后，支持vi的C-d、C-u、hjkl等快捷键</span><br></code></pre></div></td></tr></table></figure>
<h3 id="自定义复制和选择快捷键"><a class="header-anchor" href="#自定义复制和选择快捷键">¶</a>自定义复制和选择快捷键</h3>
<p>  除了快捷键外，复制模式的启用、选择、复制、粘贴等按键也可以向 vi 风格靠拢。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> Escape copy-mode <span class="hljs-comment"># 绑定esc键为进入复制模式</span><br><span class="hljs-built_in">bind</span> -t vi-copy v begin-selection <span class="hljs-comment"># 绑定v键为开始选择文本</span><br><span class="hljs-built_in">bind</span> -t vi-copy y copy-selection <span class="hljs-comment"># 绑定y键为复制选中文本</span><br><span class="hljs-built_in">bind</span> p pasteb <span class="hljs-comment"># 绑定p键为粘贴文本（p键默认用于进入上一个窗口，不建议覆盖）</span><br></code></pre></div></td></tr></table></figure>
<p>  以上，绑定 v、y 两键的设置只在 tmux v2.4 版本以下才有效，对于 v2.4 及以上的版本，绑定快捷键需要使用 <code>-T</code> 选项，发送指令需要使用 <code>-X</code> 选项，请参考如下设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> -T copy-mode-vi v send-keys -X begin-selection<br><span class="hljs-built_in">bind</span> -T copy-mode-vi y send-keys -X copy-selection-and-cancel<br></code></pre></div></td></tr></table></figure>
<h3 id="Buffer-缓存"><a class="header-anchor" href="#Buffer-缓存">¶</a>Buffer 缓存</h3>
<p>  tmux 复制操作的内容默认会存进 buffer 里，buffer 是一个粘贴缓存区，新的缓存总是位于栈顶，它的操作命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmux list-buffers <span class="hljs-comment"># 展示所有的 buffers</span><br>tmux show-buffer [-b buffer-name] <span class="hljs-comment"># 显示指定的 buffer 内容</span><br>tmux choose-buffer <span class="hljs-comment"># 进入 buffer 选择页面(支持jk上下移动选择，回车选中并粘贴 buffer 内容到面板上)</span><br>tmux <span class="hljs-built_in">set</span>-buffer <span class="hljs-comment"># 设置buffer内容</span><br>tmux load-buffer [-b buffer-name] file-path <span class="hljs-comment"># 从文件中加载文本到buffer缓存</span><br>tmux save-buffer [-a] [-b buffer-name] path <span class="hljs-comment"># 保存tmux的buffer缓存到本地</span><br>tmux paste-buffer <span class="hljs-comment"># 粘贴buffer内容到会话中</span><br>tmux delete-buffer [-b buffer-name] <span class="hljs-comment"># 删除指定名称的buffer</span><br></code></pre></div></td></tr></table></figure>
<p>  以上 buffer 操作在不指定 <code>buffer-name</code> 时，默认处理是栈顶的 buffer 缓存。<br>
  在 tmux 会话的命令行输入时，可以省略上述 tmux 前缀，其中 <code>list-buffers</code> 的操作如下所示：</p>
<p><img src="https://rabbituzki-blog-images.oss-cn-beijing.aliyuncs.com/tmux/tmux06.png" alt="list-buffers"></p>
<p>  <code>choose-buffer</code> 的操作如下所示：</p>
<p><img src="https://rabbituzki-blog-images.oss-cn-beijing.aliyuncs.com/tmux/tmux06.png" alt="choose-buffer"></p>
<p>  默认情况下，buffers 内容是独立于系统粘贴板的，它存在于 tmux 进程中，且可以在会话间共享。</p>
<h3 id="使用系统粘贴板"><a class="header-anchor" href="#使用系统粘贴板">¶</a>使用系统粘贴板</h3>
<p>  存在于 tmux 进程中的 buffer 缓存，虽然可以在会话间共享，但不能直接与系统粘贴板共享，不免有些遗憾。幸运的是，现在我们有成熟的方案来实现这个功能。</p>
<h4 id="在-Linux-上使用粘贴板"><a class="header-anchor" href="#在-Linux-上使用粘贴板">¶</a>在 Linux 上使用粘贴板</h4>
<p>  通常，Linux 中可以使用 xclip 工具来接入系统粘贴板。<br>
  首先，需要安装 xclip。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt-get install xclip<br></code></pre></div></td></tr></table></figure>
<p>  然后，<em>.tmux.conf</em> 的配置如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># buffer缓存复制到Linux系统粘贴板</span><br><span class="hljs-built_in">bind</span> C-c run <span class="hljs-string">" tmux save-buffer - | xclip -i -sel clipboard"</span><br><span class="hljs-comment"># Linux系统粘贴板内容复制到会话</span><br><span class="hljs-built_in">bind</span> C-v run <span class="hljs-string">" tmux set-buffer \"<span class="hljs-variable">$(xclip -o -sel clipboard)</span>\"; tmux paste-buffer"</span><br></code></pre></div></td></tr></table></figure>
<p>  按下 prefix + Ctrl + c 键，buffer 缓存的内容将通过 xclip 程序复制到粘贴板，按下 prefix + Ctrl + v 键，tmux 将通过 xclip 访问粘贴板，然后由 <code>set-buffer</code> 命令设置给 buffer 缓存，最后由 <code>paste-buffer</code> 粘贴到 tmux 会话中。</p>
<h4 id="在-Mac-上使用粘贴板"><a class="header-anchor" href="#在-Mac-上使用粘贴板">¶</a>在 Mac 上使用粘贴板</h4>
<p>  我们都知道，Mac 自带 pbcopy 和 pbpaste 命令，分别用于复制和粘贴，但在 tmux 命令中它们却不能正常运行。这里我将详细介绍下原因：</p>
<blockquote>
<p>Mac 的粘贴板服务是在引导命名空间注册的。命名空间存在层次之分，更高级别的命名空间拥有访问低级别命名空间（如 root 引导命名空间）的权限，反之却不行。流程创建的属于 Mac 登录会话的一部分，它会被自动包含在用户级的引导命名空间中，因此只有用户级的命名空间才能访问粘贴板服务。tmux 使用守护进程(3)库函数创建其服务器进程，在 Mac OS X 10.5 中，苹果改变了守护进程(3)的策略，将生成的过程从最初的引导命名空间移到了根引导命名空间。而根引导命名空间访问权限较低，这意味着 tmux 服务器，和它的子进程，一同失去了原引导命名空间的访问权限（即无权限访问粘贴板服务）。</p>
</blockquote>
<p>  如此，我们可以使用一个小小的包装程序来重新连接到合适的命名空间，然后执行访问用户级命名空间的粘贴板服务，这个包装程序就是 <code>reattach-to-user-namespace</code>。<br>
  那么，Mac 下 <em>.tmux.conf</em> 的配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># buffer缓存复制到Mac系统粘贴板</span><br><span class="hljs-built_in">bind</span> C-c run <span class="hljs-string">"tmux save-buffer - | reattach-to-user-namespace pbcopy"</span><br><span class="hljs-comment"># Mac系统粘贴板内容复制到会话</span><br><span class="hljs-built_in">bind</span> C-v run <span class="hljs-string">"reattach-to-user-namespace pbpaste | tmux load-buffer - \; paste-buffer -d"</span><br></code></pre></div></td></tr></table></figure>
<p>  <code>reattach-to-user-namespace</code> 作为包装程序来访问 Mac 粘贴板，按下 prefix + Ctrl + c 键，buffer 缓存的内容将复制到粘贴板，按下prefix + Ctrl + v键，粘贴板的内容将通过 <code>load-buffer</code> 加载，然后由 <code>paste-buffer</code> 粘贴到 tmux 会话中。<br>
  为了在复制模式中使用 Mac 系统的粘贴板，可做如下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 绑定y键为复制选中文本到Mac系统粘贴板</span><br><span class="hljs-built_in">bind</span>-key -T copy-mode-vi <span class="hljs-string">'y'</span> send-keys -X copy-pipe-and-cancel <span class="hljs-string">'reattach-to-user-namespace pbcopy'</span><br><span class="hljs-comment"># 鼠标拖动选中文本，并复制到Mac系统粘贴板</span><br><span class="hljs-built_in">bind</span>-key -T copy-mode-vi MouseDragEnd1Pane send -X copy-pipe-and-cancel <span class="hljs-string">"pbcopy"</span><br></code></pre></div></td></tr></table></figure>
<p>  完成以上配置后记得重启 tmux 服务器。至此，复制模式中，按 y 键将保存选中的文本到 Mac 系统粘贴板，随后按 Command + v 键便可粘贴。</p>
<hr>
<h2 id="保存-Tmux-会话"><a class="header-anchor" href="#保存-Tmux-会话">¶</a>保存 Tmux 会话</h2>
<p>  信息时代，数据尤为重要。tmux 保护现场的能力依赖于 tmux 进程，如果进程退出，则意味着会话数据的丢失，因此关机重启后，tmux 中的会话将被清空，这不是我们想要见到的。幸运的是，目前有这样两款插件：Tmux Resurrect 和 Tmux Continuum，可以永久保存 tmux 会话（它们均适用于 tmux v1.9 及以上版本）。</p>
<h3 id="Tmux-Resurrect"><a class="header-anchor" href="#Tmux-Resurrect">¶</a>Tmux Resurrect</h3>
<p>  Tmux Resurrect 无须任何配置，就能够备份 tmux 会话中的各种细节，包括窗口、面板的顺序、布局、工作目录，运行程序等等数据。因此它能在系统重启后完全地恢复会话。由于其幂等的恢复机制，它不会试图去恢复一个已经存在的窗口或者面板，所以，即使你不小心多恢复了几次会话，它也不会出现问题，这样主动恢复时我们就不必担心手抖多按了一次。另外，如果你是 tmuxinator 用户，我也建议你迁移到 tmux-resurrect 插件上来，具体请参考 <a href="https://github.com/tmux-plugins/tmux-resurrect/blob/master/docs/migrating_from_tmuxinator.md#migrating-from-tmuxinator" target="_blank" rel="noopener">Migrating from tmuxinator</a>。<br>
  Tmux Resurrec 安装过程如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.tmux<br>mkdir plugins<br>git <span class="hljs-built_in">clone</span> https://github.com/tmux-plugins/tmux-resurrect.git<br></code></pre></div></td></tr></table></figure>
<p>  安装后需在 <em>~/.tmux.conf</em> 中增加一行配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">run-shell ~/.tmux/plugins/tmux-resurrect/resurrect.tmux<br></code></pre></div></td></tr></table></figure>
<p>  至此安装成功，按下 prefix + r 重载 tmux 配置。<br>
  Tmux Resurrec 提供如下两个操作：</p>
<ul>
<li>保存，快捷指令是 prefix + Ctrl + s，tmux 状态栏在保存开始，保存后分别提示“Saving…”，“Tmux environment saved !”。</li>
<li>恢复，快捷指令是 prefix + Ctrl + r，tmux 状态栏在恢复开始，恢复后分别提示“Restoring…”，“Tmux restore complete !”。</li>
</ul>
<p>  保存时，tmux 会话的详细信息会以文本文件的格式保存到 <em>~/.tmux/resurrect</em> 目录，恢复时则从此处读取，由于数据文件是明文的，因此你完全可以自由管理或者编辑这些会话状态文件（如果备份频繁，记得定期清除历史备份）。</p>
<h4 id="可选的配置"><a class="header-anchor" href="#可选的配置">¶</a>可选的配置</h4>
<p>  Tmux Resurrec 本身是免配置开箱即用的，但同时也提供了如下选项以便修改其默认设置。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g @resurrect-save <span class="hljs-string">'S'</span> <span class="hljs-comment"># 修改保存指令为S</span><br><span class="hljs-built_in">set</span> -g @resurrect-restore <span class="hljs-string">'R'</span> 修改恢复指令为R<br><span class="hljs-comment"># 修改会话数据的保持路径，此处不能使用除了$HOME, $HOSTNAME, ~之外的环境变量</span><br><span class="hljs-built_in">set</span> -g @resurrect-dir <span class="hljs-string">'/some/path'</span><br></code></pre></div></td></tr></table></figure>
<p>  默认情况下只有一个保守的列表项（即 vi vim nvim emacs man less more tail top htop irssi mutt）可以恢复，对此 Restoring programs doc 解释了怎么去恢复额外的项目。</p>
<h4 id="进阶的备份"><a class="header-anchor" href="#进阶的备份">¶</a>进阶的备份</h4>
<p>  除了基础备份外，Tmux Resurrec 还提供进阶的备份功能，如下所示：</p>
<ul>
<li>恢复 vim 和 neovim 会话</li>
<li>恢复面板内容</li>
<li>恢复 shell 的历史记录（实验性功能）</li>
</ul>
<p>  进阶的备份功能默认不开启，需要特别配置。</p>
<p>1. 恢复 vim 和 neovim 会话，需要完成如下两步：</p>
<ul>
<li>通过 vim 的 vim-obsession 插件保存 vim/neovim 会话。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.vim/bundle<br>git <span class="hljs-built_in">clone</span> git://github.com/tpope/vim-obsession.git<br>vim -u NONE -c <span class="hljs-string">"helptags vim-obsession/doc"</span> -c q<br></code></pre></div></td></tr></table></figure>
<ul>
<li>在 <em>~/.tmux.conf</em> 中增加两行配置：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g @resurrect-strategy-vim <span class="hljs-string">'session'</span> <span class="hljs-comment"># for vim</span><br><span class="hljs-built_in">set</span> -g @resurrect-strategy-nvim <span class="hljs-string">'session'</span> <span class="hljs-comment"># for neovim</span><br></code></pre></div></td></tr></table></figure>
<p>2. 恢复面板内容，需在 <em>~/.tmux.conf</em> 中增加一行配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g @resurrect-capture-pane-contents <span class="hljs-string">'on'</span> <span class="hljs-comment"># 开启恢复面板内容功能</span><br></code></pre></div></td></tr></table></figure>
<p>  目前使用该功能时，请确保 tmux 的 <code>default-command</code> 没有包含 <code>&amp;&amp;</code> 或者 <code>||</code> 操作符，否则将导致 bug。（查看 <code>default-command</code> 的值，请使用命令 <code>tmux show -g default-command</code>。）</p>
<p>3. 恢复 shell 的历史记录，需在 <em>~/.tmux.conf</em> 中增加一行配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g @resurrect-save-shell-history <span class="hljs-string">'on'</span><br></code></pre></div></td></tr></table></figure>
<p>  由于技术的限制，保存时，只有无前台任务运行的面板，它的 shell 历史记录才能被保存。</p>
<h3 id="Tmux-Continuum"><a class="header-anchor" href="#Tmux-Continuum">¶</a>Tmux Continuum</h3>
<p>  可能你嫌手动保存和恢复太过麻烦，别担心，这不是问题。Tmux Continuum  在 Tmux Resurrec 的基础上更进一步，现在保存和恢复全部自动化了，如你所愿，可以无感使用 tmux，不用再担心备份问题。<br>
  Tmux Continuum 安装过程如下所示（它依赖 Tmux Resurrect，请保证已安装 Tmux Resurrect 插件）：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.tmux/plugins<br>git <span class="hljs-built_in">clone</span> https://github.com/tmux-plugins/tmux-continuum.git<br></code></pre></div></td></tr></table></figure>
<p>  安装后需在 <em>~/.tmux.conf</em> 中增加一行配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">run-shell ~/.tmux/plugins/tmux-continuum/continuum.tmux<br></code></pre></div></td></tr></table></figure>
<p>  Tmux Continuum 默认每隔 15mins 备份一次，我设置的是一天一次：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g @continuum-save-interval <span class="hljs-string">'1440'</span><br></code></pre></div></td></tr></table></figure>
<p>  <strong>关闭自动备份</strong>，只需设置时间间隔为 0 即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g @continuum-save-interval <span class="hljs-string">'0'</span><br></code></pre></div></td></tr></table></figure>
<p>  想要在 <strong>tmux 启动时就恢复最后一次保存的会话环境</strong>，需增加如下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g @continuum-restore <span class="hljs-string">'on'</span> <span class="hljs-comment"># 启用自动恢复</span><br></code></pre></div></td></tr></table></figure>
<p>  如果不想要启动时自动恢复的功能了，直接移除上面这行就行。想要绝对确定自动恢复不会发生，就在用户根目录下创建一个 <em>tmux_no_auto_restore</em> 空文件（创建命令：<code>touch ~/tmux_no_auto_restore</code>），该文件存在时，自动恢复将不触发。<br>
  对于 tmux 高级用户（可能就是你）而言，同时运行多个 tmux 服务器也是有可能的。你可能并不希望后面启用的几个 tmux 服务器自动恢复或者自动保存会话。因此 Tmux Continuum 会优先在第一个启用的 tmux 服务器中生效，随后启用的 tmux 服务器不再享受自动恢复或自动保存会话的待遇。<br>
  实际上，不管 Tmux Continuum 功能有没有启用，或者多久保存一次，我们都有办法从状态栏知晓。Tmux Continuum 提供了一个查看运行状态的插值 <code>#{continuum_status}</code>，它支持 <code>status-right</code> 和 <code>status-left</code> 两种状态栏设置，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g status-right <span class="hljs-string">'Continuum status: #&#123;continuum_status&#125;'</span><br></code></pre></div></td></tr></table></figure>
<p>  tmux 运行时，<code>#{continuum_status}</code> 将显示保存的时间间隔（单位为分钟），此时状态栏会显示：</p>
<div class="hljs code-wrapper"><pre><code>Continuum status: 1440
</code></pre></div>
<p>  如果其自动保存功能关闭了，那么状态栏会显示：</p>
<div class="hljs code-wrapper"><pre><code>Continuum status: off
</code></pre></div>
<p>  借助 Tmux Continuum 插件，Mac 重启时，我们甚至可以选择在 Terminal 或者 iTerm2 中自动全屏启用 tmux。<br>
  为此，需在 <em>~/.tmux.conf</em> 中增加一行配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g @continuum-boot <span class="hljs-string">'on'</span><br></code></pre></div></td></tr></table></figure>
<p>  Mac 下，自动启用 tmux 还支持如下选项：</p>
<ul>
<li><code>set -g @continuum-boot-options 'fullscreen'</code>，Terminal 自动全屏，tmux 命令在 Terminal 中执行。</li>
<li><code>set -g @continuum-boot-options 'iterm'</code>，iTerm2 替换 Terminal 应用，tmux 命令在 iTerm2 中执行。</li>
<li><code>set -g @continuum-boot-options 'iterm,fullscreen'</code>，iTerm2 自动全屏，tmux 命令在 iTerm2 中执行。<br>
  Linux 中则没有这些选项，它只能设置为自动启用 tmux 服务器。</li>
</ul>
<h3 id="Tpm"><a class="header-anchor" href="#Tpm">¶</a>Tpm</h3>
<p>  以上，我们直接安装了 tmux 插件。这没有问题，可当插件越来越多时，我们就会需要统一的插件管理器。因此官方提供了 tpm（支持 tmux v1.9 及以上版本）。<br>
  tpm 安装过程如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.tmux/plugins<br>git <span class="hljs-built_in">clone</span> https://github.com/tmux-plugins/tpm<br></code></pre></div></td></tr></table></figure>
<p>  安装后需在 <em>~/.tmux.conf</em> 中增加如下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 默认需要引入的插件</span><br><span class="hljs-built_in">set</span> -g @plugin <span class="hljs-string">'tmux-plugins/tpm'</span><br><span class="hljs-built_in">set</span> -g @plugin <span class="hljs-string">'tmux-plugins/tmux-sensible'</span><br><br><span class="hljs-comment"># 引入其他插件的示例</span><br><span class="hljs-comment"># set -g @plugin 'github_username/plugin_name' # 格式：github用户名/插件名</span><br><span class="hljs-comment"># set -g @plugin 'git@github.com/user/plugin' # 格式：git@github插件地址</span><br><br><span class="hljs-comment"># 初始化tmux插件管理器(保证这行在~/.tmux.conf的非常靠后的位置)</span><br>run <span class="hljs-string">'~/.tmux/plugins/tpm/tpm'</span><br></code></pre></div></td></tr></table></figure>
<p>  然后按下 prefix + r 重载 tmux 配置，使得 tpm 生效。<br>
  基于 tpm 插件管理器，安装插件仅需如下两步：</p>
<ol>
<li>在 <em>~/.tmux.conf</em> 中增加新的插件，如 <code>set -g @plugin '...'</code>。</li>
<li>按下 prefix + I 键下载插件，并刷新 tmux 环境。</li>
</ol>
<p>  <strong>更新插件</strong>，请按下 prefix + U 键，选择待更新的插件后，回车确认并更新。<br>
  <strong>卸载插件</strong>，需如下两步：</p>
<ol>
<li>在 <em>~/.tmux.conf</em> 中移除插件所在行。</li>
<li>按下 prefix + alt + u 移除插件。</li>
</ol>
<h2 id="会话共享"><a class="header-anchor" href="#会话共享">¶</a>会话共享</h2>
<h3 id="结对编程"><a class="header-anchor" href="#结对编程">¶</a>结对编程</h3>
<p>  tmux 多会话连接实时同步的功能，使得结对编程成为了可能，这也是开发者最喜欢的功能之一。现在就差一步了，就是借助 tmate 把 tmux 会话分享出去。</p>
<p>  tmate 是 tmux 的管理工具，它可以轻松的创建 tmux 会话，并且自动生成 ssh 链接。</p>
<p>  安装 tmate</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">brew install tmate<br></code></pre></div></td></tr></table></figure>
<p>  使用 tmate 新建一个 tmux 会话</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmate<br></code></pre></div></td></tr></table></figure>
<p>此时屏幕下方会显示 ssh url，如下所示：</p>
<p><img src="https://rabbituzki-blog-images.oss-cn-beijing.aliyuncs.com/tmux/tmux07.png" alt="ssh url"></p>
<p>  查看 tmate 生成的 ssh 链接</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmate show-messages<br></code></pre></div></td></tr></table></figure>
<p>  生成的 ssh url 如下所示，其中一个为只读，另一个可编辑。</p>
<p><img src="https://rabbituzki-blog-images.oss-cn-beijing.aliyuncs.com/tmux/tmux08.png" alt="ssh url"></p>
<h3 id="共享账号-组会话"><a class="header-anchor" href="#共享账号-组会话">¶</a>共享账号 &amp; 组会话</h3>
<p>  使用 tmate 远程共享 tmux 会话，受制于多方的网络质量，必然会存在些许延迟。如果共享会话的多方拥有同一个远程服务器的账号，那么我们可以使用组会话解决这个问题。<br>
  先在远程服务器上新建一个公共会话，命名为 groupSession。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmux new -s groupSession<br></code></pre></div></td></tr></table></figure>
<p>  其他用户不去直接连接这个会话，而是通过创建一个新的会话来加入上面的公共会话 groupSession。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmux new -t groupSession -s otherSession<br></code></pre></div></td></tr></table></figure>
<p>  此时两个用户都可以在同一个会话里操作，就会好像第二个用户连接到了 groupSession 的会话一样。此时两个用户都可以创建新建的窗口，新窗口的内容依然会实时同步，但是其中一个用户切换到其它窗口，对另外一个用户没有任何影响，因此在这个共享的组会话中，用户各自的操作可以通过新建窗口来执行。即使第二个用户关闭 otherSession 会话，共享会话 groupSession 依然存在。<br>
  组会话在共享的同时，又保留了相对的独立，非常适合结对编程场景，它是结对编程最简单的方式，如果账号不能共享，我们就要使用下面的方案了。</p>
<h3 id="独立账号-Socket-共享会话"><a class="header-anchor" href="#独立账号-Socket-共享会话">¶</a>独立账号 &amp; Socket 共享会话</h3>
<p>  开始之前我们需要确保用户对远程服务器上同一个目录拥有相同的读写权限，假设这个目录为 <em>/var/tmux/</em>。<br>
  使用 <code>new-session</code>（简写 <code>new</code>）创建会话时，使用的是默认的 socket 位置，默认 socket 无法操作，所以我们需要创建一个指定 socket 文件的会话。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmux -S /var/tmux/sharefile<br></code></pre></div></td></tr></table></figure>
<p>  另一个用户进入时，需要指定 socket 文件加入会话。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmux -S /var/tmux/sharefile attach<br></code></pre></div></td></tr></table></figure>
<p>  这样，两个不同的用户就可以共享同一个会话了。<br>
  通常情况下，不同的用户使用不同的配置文件来创建会话，但是，使用指定 socket 文件创建的 tmux 会话，会话加载的是第一个创建会话的用户的 <em>~/.tmux.conf</em> 配置文件，随后加入会话的其他用户，依然使用同一份配置文件。</p>
<h2 id="Tmux-优化"><a class="header-anchor" href="#Tmux-优化">¶</a>Tmux 优化</h2>
<p>  要想 tmux 更加人性化、性能更佳，不妨参考下如下配置。</p>
<h3 id="设置窗口面板起始序号"><a class="header-anchor" href="#设置窗口面板起始序号">¶</a>设置窗口面板起始序号</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g base-index 1 <span class="hljs-comment"># 设置窗口的起始下标为1</span><br><span class="hljs-built_in">set</span> -g pane-base-index 1 <span class="hljs-comment"># 设置面板的起始下标为1</span><br></code></pre></div></td></tr></table></figure>
<h3 id="自定义状态栏"><a class="header-anchor" href="#自定义状态栏">¶</a>自定义状态栏</h3>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g status-utf8 on <span class="hljs-comment"># 状态栏支持utf8</span><br><span class="hljs-built_in">set</span> -g status-interval 1 <span class="hljs-comment"># 状态栏刷新时间</span><br><span class="hljs-built_in">set</span> -g status-justify left <span class="hljs-comment"># 状态栏列表左对齐</span><br>setw -g monitor-activity on <span class="hljs-comment"># 非当前窗口有内容更新时在状态栏通知</span><br><br><span class="hljs-built_in">set</span> -g status-bg black <span class="hljs-comment"># 设置状态栏背景黑色</span><br><span class="hljs-built_in">set</span> -g status-fg yellow <span class="hljs-comment"># 设置状态栏前景黄色</span><br><span class="hljs-built_in">set</span> -g status-style <span class="hljs-string">"bg=black, fg=yellow"</span> <span class="hljs-comment"># 状态栏前景背景色</span><br><br><span class="hljs-built_in">set</span> -g status-left <span class="hljs-string">"#[bg=#FF661D] ❐ #S "</span> <span class="hljs-comment"># 状态栏左侧内容</span><br><span class="hljs-built_in">set</span> -g status-right <span class="hljs-string">'Continuum status: #&#123;continuum_status&#125;'</span> <span class="hljs-comment"># 状态栏右侧内容</span><br><span class="hljs-built_in">set</span> -g status-left-length 300 <span class="hljs-comment"># 状态栏左边长度300</span><br><span class="hljs-built_in">set</span> -g status-right-length 500 <span class="hljs-comment"># 状态栏左边长度500</span><br><br><span class="hljs-built_in">set</span> -wg window-status-format <span class="hljs-string">" #I #W "</span> <span class="hljs-comment"># 状态栏窗口名称格式</span><br><span class="hljs-built_in">set</span> -wg window-status-current-format <span class="hljs-string">" #I:#W#F "</span> <span class="hljs-comment"># 状态栏当前窗口名称格式(#I：序号，#w：窗口名称，#F：间隔符)</span><br><span class="hljs-built_in">set</span> -wg window-status-separator <span class="hljs-string">""</span> <span class="hljs-comment"># 状态栏窗口名称之间的间隔</span><br><span class="hljs-built_in">set</span> -wg window-status-current-style <span class="hljs-string">"bg=red"</span> <span class="hljs-comment"># 状态栏当前窗口名称的样式</span><br><span class="hljs-built_in">set</span> -wg window-status-last-style <span class="hljs-string">"fg=red"</span> <span class="hljs-comment"># 状态栏最后一个窗口名称的样式</span><br><br><span class="hljs-built_in">set</span> -g message-style <span class="hljs-string">"bg=#202529, fg=#91A8BA"</span> <span class="hljs-comment"># 指定消息通知的前景、后景色</span><br></code></pre></div></td></tr></table></figure>
<h3 id="开启-256-colors-支持"><a class="header-anchor" href="#开启-256-colors-支持">¶</a>开启 256 colors 支持</h3>
<p>  默认情况下，tmux 中使用 vim 编辑器，文本内容的配色和直接使用 vim 时有些差距，此时需要开启 256 colors 的支持，配置如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g default-terminal <span class="hljs-string">"screen-256color"</span><br></code></pre></div></td></tr></table></figure>
<p>  或者：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g default-terminal <span class="hljs-string">"tmux-256color"</span><br></code></pre></div></td></tr></table></figure>
<p>  或者启动 tmux 时增加参数 -2：</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> tmux=<span class="hljs-string">'tmux -2'</span> <span class="hljs-comment"># Force tmux to assume the terminal supports 256 colours</span><br></code></pre></div></td></tr></table></figure>
<h3 id="关闭默认的-rename-机制"><a class="header-anchor" href="#关闭默认的-rename-机制">¶</a>关闭默认的 rename 机制</h3>
<p>  tmux 默认会自动重命名窗口，频繁的命令行操作，将频繁触发重命名，比较浪费 CPU 性能，性能差的计算机上，问题可能更为明显。建议添加如下配置关闭 rename 机制。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">setw -g automatic-rename off<br>setw -g allow-rename off<br></code></pre></div></td></tr></table></figure>
<h3 id="去掉小圆点"><a class="header-anchor" href="#去掉小圆点">¶</a>去掉小圆点</h3>
<p>  tmux 默认会同步同一个会话的操作到所有会话连接的终端窗口中，这种同步机制，限制了窗口的大小为最小的会话连接。因此当你开一个大窗口去连接会话时，实际的窗口将自动调整为最小的那个会话连接的窗口，终端剩余的空间将填充排列整齐的小圆点，如下所示。</p>
<p><img src="https://rabbituzki-blog-images.oss-cn-beijing.aliyuncs.com/tmux/tmux03.png" alt="dot"></p>
<p>  为了避免这种问题，我们可以在连接会话的时候，断开其他的会话连接。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmux a -d<br></code></pre></div></td></tr></table></figure>
<p>  如果已经进入了 tmux 会话中，才发现这种问题，这个时候可以输入命令达到同样的效果。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">`: a -d<br></code></pre></div></td></tr></table></figure>
<p><img src="https://rabbituzki-blog-images.oss-cn-beijing.aliyuncs.com/tmux/tmux04.gif" alt="remove dot"></p>
<h2 id="脚本化的-Tmux"><a class="header-anchor" href="#脚本化的-Tmux">¶</a>脚本化的 Tmux</h2>
<p>  tmux 作为终端复用软件，支持纯命令行操作也是其一大亮点。你既可以启用可视化界面创建会话，也可以运行脚本生成会话，对于 tmux 依赖者而言，编写几个 tmux 脚本批量维护会话列表，快速重启、切换、甚至分享部分会话都是非常方便的。可能会有人说为什么不用 Tmux Resurrect 呢？是的，Tmux Resurrect 很好，一键恢复也很诱人，但是对于一个维护大量 tmux 会话的用户而言，一键恢复可能不见得好，分批次恢复可能是他（她）更想要的，脚本化的 tmux 就很好地满足了这点。<br>
  脚本中创建 tmux 会话时，由于不需要开启可视化界面，需要输入 <code>-d</code> 参数指定会话后台运行，如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmux new -s init -d <span class="hljs-comment"># 后台创建一个名称为init的会话</span><br></code></pre></div></td></tr></table></figure>
<p>  新建的会话，建议重命令会话的窗口名称，以便后续维护。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 重命名init会话的第一个窗口名称为service</span><br>tmux rename-window -t <span class="hljs-string">"init:1"</span> service<br></code></pre></div></td></tr></table></figure>
<p>  现在，可以在刚才的窗口中输入指令了。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到指定目录并运行python服务</span><br>tmux send -t <span class="hljs-string">"init:service"</span> <span class="hljs-string">"cd ~/workspace/language/python/;python2.7 server.py"</span> Enter<br></code></pre></div></td></tr></table></figure>
<p>  一个面板占用一个窗口可能太浪费了，我们来分个屏吧。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 默认上下分屏</span><br>tmux split-window -t <span class="hljs-string">"init:service"</span><br><span class="hljs-comment"># 切换到指定目录并运行node服务</span><br>tmux send -t <span class="hljs-string">"init:service"</span> <span class="hljs-string">'cd ~/data/louiszhai/node-webserver/;npm start'</span> Enter<br></code></pre></div></td></tr></table></figure>
<p>  现在一个窗口拥有上下两个面板，是时候创建一个新的窗口来运行更多的程序了。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 新建一个名称为tool的窗口</span><br>tmux neww -a -n tool -t init <span class="hljs-comment"># neww等同于new window</span><br><span class="hljs-comment"># 运行weinre调试工具</span><br>tmux send -t <span class="hljs-string">"init:tool"</span> <span class="hljs-string">"weinre --httpPort 8881 --boundHost -all-"</span> Enter<br></code></pre></div></td></tr></table></figure>
<p>  另外新建窗口运行程序，有更方便的方式，比如使用 processes 选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">tmux neww-n processes ls <span class="hljs-comment"># 新建窗口并执行命令，命令执行结束后窗口将关闭</span><br>tmux neww-n processes top <span class="hljs-comment"># 由于top命令持续在前台运行，因此窗口将保留，直到top命令退出</span><br></code></pre></div></td></tr></table></figure>
<p>  新的窗口，我们尝试下水平分屏。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 水平分屏</span><br>tmux split-window -h -t <span class="hljs-string">"init:tool"</span><br><span class="hljs-comment"># 切换到指定目录并启用aria2 web管理后台</span><br>tmux send -t <span class="hljs-string">"init:tool"</span> <span class="hljs-string">"cd ~/data/tools/AriaNg/dist/;python -m SimpleHTTPServer 10108"</span> Enter<br></code></pre></div></td></tr></table></figure>
<p>  类似的脚本，我们可以编写一打，这样快速重启、切换、甚至分享会话都将更加便捷。</p>
<h2 id="开启自动启用-Web-服务器"><a class="header-anchor" href="#开启自动启用-Web-服务器">¶</a>开启自动启用 Web 服务器</h2>
<p>  开机自动准备工作环境是一个很好的idea，但却不好实现。对于程序员而言，一个开机即用的计算机会节省大量的初始化操作，特别是前端工程师，本地常常会启用多个服务器，每次开机挨个启动将耗时耗力。为此，在遇到 tmux 之前，我常常拖延重启计算机的时机，一度连续运行 Mac 一月之久，直到它不堪重负。<br>
  有了 tmux 脚本化的基础，开机自动启用 web 服务器就不在话下了，接杯水的时间，计算机就重启恢复了满血。如下是操作步骤：<br>
  首先，上面的 tmux 脚本，可以合并到同一个文件中，指定文件权限为可执行，并命名为 <em><a href="http://init.sh" target="_blank" rel="noopener">init.sh</a></em>（名称可自取）。</p>
<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">chmod u+x ./init.sh<br></code></pre></div></td></tr></table></figure>
<p>  然后，打开 系统偏好设置 - 用户与群组 - 登录项，点击添加按钮 +，选择刚刚保存的 <em><a href="http://init.sh" target="_blank" rel="noopener">init.sh</a></em> 脚本，最终效果如下：</p>
<p><img src="https://rabbituzki-blog-images.oss-cn-beijing.aliyuncs.com/tmux/tmux09.png" alt="init.sh"></p>
<p>  至此，Mac 开机将自动运行 <em><a href="http://init.sh" target="_blank" rel="noopener">init.sh</a></em> 脚本，自动启用 web 服务器。<br>
  完成了上面这些配置，就真正实现了一键开机。<br>
  最后，附上我本地的配置文件<a href="https://github.com/Louiszhai/tmux/blob/master/.tmux.conf" target="_blank" rel="noopener"><em>.tmux.conf</em></a>，以及启动脚本 <a href="https://github.com/Louiszhai/tmux/blob/master/init.sh" target="_blank" rel="noopener"><em>init.sh</em></a>。明天就是国庆了，祝大家国庆快乐！</p>
<blockquote>
<p>参考资料：</p>
<hr>
<ul>
<li>路易斯 . Tmux使用手册 [EB/OL] . <a href="https://louiszhai.github.io/2017/09/30/tmux/" target="_blank" rel="noopener">https://louiszhai.github.io/2017/09/30/tmux/</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法手册</title>
    <url>/2018/10/18/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1>Markdown 语法手册</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="1-斜体和粗体"><a class="header-anchor" href="#1-斜体和粗体">¶</a>1. 斜体和粗体</h2>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-emphasis">*斜体*</span>或<span class="hljs-emphasis">_斜体_</span><br><span class="hljs-strong">**粗体**</span><br><span class="hljs-strong">***加粗斜体**</span>*<br>~~ 删除线 ~~<br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<ul>
<li><em>这是一段斜体</em></li>
<li><strong>这是一段粗体</strong></li>
<li><em><strong>这是一段加粗斜体</strong></em></li>
<li><s>这是一段删除线</s></li>
</ul>
<hr>
<h2 id="2-分级标题"><a class="header-anchor" href="#2-分级标题">¶</a>2. 分级标题</h2>
<p>第一种写法：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">这是一个一级标题<br>================<br>这是一个二级标题<br>----------------<br></code></pre></div></td></tr></table></figure>
<p>第二种写法：</p>
<div class="hljs code-wrapper"><pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
</code></pre></div>
<p>由于用了<code>[TOC]</code>标记编辑器会把所有标题写到目录大纲中，在这里写的演示标题也会列进去，所以就不演示了。同学们自己在编辑器中观察，很简单，一级标题字号最大，依级递减。</p>
<hr>
<h2 id="3-超链接"><a class="header-anchor" href="#3-超链接">¶</a>3.超链接</h2>
<p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。</p>
<h3 id="3-1-行内式"><a class="header-anchor" href="#3-1-行内式">¶</a>3.1. 行内式</h3>
<p>语法说明：</p>
<ul>
<li>[]里写链接文字，()里写链接地址, ()中的&quot;&quot;中可以为链接指定 <code>title</code> 属性，<code>title</code>属性可加可不加。<code>title</code> 属性的效果是鼠标悬停在链接上会出现指定的 <code>title</code> 文字。[链接文字](链接地址 “链接标题”) 这样的形式。链接地址与链接标题前有一个空格。</li>
</ul>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">欢迎来到[<span class="hljs-string">梵居闹市</span>](<span class="hljs-link">http://blog.leanote.com/freewalk</span>)<br>欢迎来到[<span class="hljs-string">梵居闹市</span>](<span class="hljs-link">http://blog.leanote.com/freewalk "梵居闹市"</span>)<br></code></pre></div></td></tr></table></figure>
<p>显示效果：<br>
欢迎来到<a href="http://blog.leanote.com/freewalk" target="_blank" rel="noopener">梵居闹市</a><br>
欢迎来到<a href="http://blog.leanote.com/freewalk" target="_blank" rel="noopener" title="梵居闹市">梵居闹市</a></p>
<h3 id="3-2-参考式"><a class="header-anchor" href="#3-2-参考式">¶</a>3.2. 参考式</h3>
<p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p>
<p>语法说明： <br>
参考式链接分为两部分，文中的写法[链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。<br>
如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>
[链接文字]：链接地址的形式，见代码的最后一行。<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">我经常去的几个网站[<span class="hljs-string">Google</span>][<span class="hljs-symbol">1</span>]、[<span class="hljs-string">Leanote</span>][<span class="hljs-symbol">2</span>]以及[<span class="hljs-string">自己的博客</span>][<span class="hljs-symbol">3</span>]<br>[<span class="hljs-string">Leanote 笔记</span>][<span class="hljs-symbol">2</span>]是一个不错的[<span class="hljs-string">网站</span>][<span class="hljs-symbol"></span>]。<br><br>[<span class="hljs-symbol">1</span>]:<span class="hljs-link">http://www.google.com "Google"</span><br>[<span class="hljs-symbol">2</span>]:<span class="hljs-link">http://www.leanote.com "Leanote"</span><br>[<span class="hljs-symbol">3</span>]:<span class="hljs-link">http://http://blog.leanote.com/freewalk "梵居闹市"</span><br>[<span class="hljs-symbol">网站</span>]:<span class="hljs-link">http://http://blog.leanote.com/freewalk</span><br></code></pre></div></td></tr></table></figure>
<p>显示效果：<br>
我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]<br>
[Leanote 笔记][2]是一个不错的[网站][]。<br>
[1]:<a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a> “Google”<br>
[2]:<a href="http://www.leanote.com" target="_blank" rel="noopener">http://www.leanote.com</a> “Leanote”<br>
[3]:<a href="http://http" target="_blank" rel="noopener">http://http</a>://blog.leanote.com/freewalk “梵居闹市”<br>
[网站]:<a href="http://http" target="_blank" rel="noopener">http://http</a>://blog.leanote.com/freewalk</p>
<h3 id="3-3-自动链接"><a class="header-anchor" href="#3-3-自动链接">¶</a>3.3. 自动链接</h3>
<p>语法说明： <br>
Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">http:</span>//<span class="hljs-attr">example.com</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">address@example.com</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<p><a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a><br>
<a href="mailto:address@example.com">address@example.com</a></p>
<hr>
<h2 id="4-锚点"><a class="header-anchor" href="#4-锚点">¶</a>4.锚点</h2>
<p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。</p>
<p>注意：</p>
<ol>
<li>Markdown Extra 只支持在标题后插入锚点，其它地方无效。</li>
<li>Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。</li>
</ol>
<p>语法描述：<br>
可把鼠标放到 Github 的标题上进行观察，如下图</p>
<p><img src="https://static.oschina.net/uploads/img/201707/19103223_ugM1.png" alt="anchor"></p>
<ul>
<li>任意 1-6 个 # 标注的标题都会被添加上同名的锚点链接</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">[<span class="hljs-string">标题1</span>](<span class="hljs-link">#标题1</span>) <br>[<span class="hljs-string">标题2</span>](<span class="hljs-link">#标题2</span>) <br>[<span class="hljs-string">标题3</span>](<span class="hljs-link">#标题3</span>) <br><br><span class="hljs-section"># 标题1</span><br><span class="hljs-section">## 标题2</span><br><span class="hljs-section">### 标题3</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>锚点跳转的标识名称，可使用任意字符，大写字母要转换成小写</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">[<span class="hljs-string">Github标题1</span>](<span class="hljs-link">#github标题1</span>)<br><br><span class="hljs-section">### Github标题1</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>多单词锚点的空格用 - 代替</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">[<span class="hljs-string">Github 标题2 Test</span>](<span class="hljs-link">#github-标题2-test</span>)<br><br><span class="hljs-section">### Github 标题2 Test</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>多级序号需要去除 .</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">[<span class="hljs-string">2.3. Github 标题</span>](<span class="hljs-link">#23-github-标题</span>)<br><br><span class="hljs-section">### 2.3. Github 标题</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>注意: 非英文的锚点字符，在单击跳转时，在浏览器的 url 中会按照规则进行 encode 和 decode</p>
</blockquote>
<hr>
<h2 id="5-列表"><a class="header-anchor" href="#5-列表">¶</a>5. 列表</h2>
<h3 id="5-1-无序列表"><a class="header-anchor" href="#5-1-无序列表">¶</a>5.1. 无序列表</h3>
<p>使用 *，+，- 表示无序列表。<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">- </span>无序列表项 一<br><span class="hljs-bullet">- </span>无序列表项 二<br><span class="hljs-bullet">- </span>无序列表项 三<br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<ul>
<li>无序列表项 一</li>
<li>无序列表项 二</li>
<li>无序列表项 三</li>
</ul>
<h3 id="5-2-有序列表"><a class="header-anchor" href="#5-2-有序列表">¶</a>5.2. 有序列表</h3>
<p>有序列表则使用数字接着一个英文句点。<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">1. </span>有序列表项 一<br><span class="hljs-bullet">2. </span>有序列表项 二<br><span class="hljs-bullet">3. </span>有序列表项 三<br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<h3 id="5-3-定义型列表"><a class="header-anchor" href="#5-3-定义型列表">¶</a>5.3. 定义型列表</h3>
<p>语法说明：</p>
<p>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)</p>
<p>代码：</p>
<div class="hljs code-wrapper"><pre><code>Markdown
:    轻量级文本标记语言，可以转换成 html，pdf 等格式（左侧有一个可见的冒号和四个不可见的空格）
代码块 2
:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）
    代码块（左侧有八个不可见的空格）
</code></pre></div>
<p>显示效果：</p>
<p>Markdown<br>
:    轻量级文本标记语言，可以转换成 html，pdf 等格式（左侧有一个可见的冒号和四个不可见的空格）</p>
<p>代码块 2<br>
:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</p>
<div class="hljs code-wrapper"><pre><code>    代码块（左侧有八个不可见的空格）
</code></pre></div>
<h3 id="5-4-列表缩进"><a class="header-anchor" href="#5-4-列表缩进">¶</a>5.4. 列表缩进</h3>
<p>语法说明：<br>
列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。<br>
要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：</p>
<ul>
<li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 <br>
那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 <br>
软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</li>
<li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 <br>
寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 <br>
但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ <br>
悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li>
</ul>
<p>但是如果你懒，那也行： <br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*   </span>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 <br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ <br><span class="hljs-bullet">*   </span>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 <br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ <br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。<br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<ul>
<li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 <br>
那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 <br>
软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</li>
<li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 <br>
寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 <br>
但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ <br>
悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li>
</ul>
<h3 id="5-5-包含段落的列表"><a class="header-anchor" href="#5-5-包含段落的列表">¶</a>5.5. 包含段落的列表</h3>
<p>语法说明：<br>
列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：</p>
<ul>
<li>
<p>轻轻的我走了， 正如我轻轻的来；<br>
我轻轻的招手， 作别西天的云彩。 <br>
那河畔的金柳， 是夕阳中的新娘；<br>
波光里的艳影， 在我的心头荡漾。 <br>
软泥上的青荇， 油油的在水底招摇；<br>
在康河的柔波里， 我甘心做一条水草！</p>
<p>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 <br>
寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 <br>
但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</p>
</li>
<li>
<p>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</p>
</li>
</ul>
<p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*   </span>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。    <br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！<br>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 <br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 <br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ <br><span class="hljs-bullet">*    </span>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。<br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<ul>
<li>
<p>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 <br>
那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 <br>
软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</p>
<p>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 <br>
寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 <br>
但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</p>
</li>
<li>
<p>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</p>
</li>
</ul>
<h3 id="5-6-包含引用的列表"><a class="header-anchor" href="#5-6-包含引用的列表">¶</a>5.6. 包含引用的列表</h3>
<p>语法说明：<br>
如果要在列表项目内放进引用，那 &gt; 就需要缩进：<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">*   </span>阅读的方法:<br><span class="hljs-code">    &gt; 打开书本。</span><br><span class="hljs-code">    &gt; 打开电灯。</span><br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<ul>
<li>阅读的方法:
<blockquote>
<p>打开书本。<br>
打开电灯</p>
</blockquote>
</li>
</ul>
<h3 id="5-7-包含代码区块的引用"><a class="header-anchor" href="#5-7-包含代码区块的引用">¶</a>5.7. 包含代码区块的引用</h3>
<p>语法说明： <br>
如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</p>
<ul>
<li>
<p>列表项包含一个列表区块：</p>
<div class="hljs code-wrapper"><pre><code>  &lt;代码写在这&gt;
</code></pre></div>
</li>
</ul>
<h3 id="5-8-一个特殊情况"><a class="header-anchor" href="#5-8-一个特殊情况">¶</a>5.8. 一个特殊情况</h3>
<p>在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法：</p>
<div class="hljs code-wrapper"><pre><code>1986. What a great season.
</code></pre></div>
<p>会显示成：</p>
<ul>
<li>
<ol start="1986">
<li>What a great season</li>
</ol>
</li>
</ul>
<p>What a great season.<br>
换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠：</p>
<div class="hljs code-wrapper"><pre><code>1986\. What a great season.
</code></pre></div>
<p>会显示成：</p>
<p>1986. What a great season.</p>
<hr>
<h2 id="6-引用"><a class="header-anchor" href="#6-引用">¶</a>6. 引用</h2>
<p>语法说明：<br>
引用需要在被引用的文本前加上&gt;符号。<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 这是一个有两段文字的引用,</span><br><span class="hljs-quote">&gt; 无意义的占行文字1.</span><br><span class="hljs-quote">&gt; 无意义的占行文字2.</span><br><span class="hljs-quote">&gt; </span><br><span class="hljs-quote">&gt; 无意义的占行文字3.</span><br><span class="hljs-quote">&gt; 无意义的占行文字4.</span><br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<blockquote>
<p>这是一个有两段文字的引用, <br>
无意义的占行文字1. <br>
无意义的占行文字2.</p>
</blockquote>
<blockquote>
<p>无意义的占行文字3. <br>
无意义的占行文字4.</p>
</blockquote>
<p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ：</p>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 这是一个有两段文字的引用,</span><br>无意义的占行文字1.<br>无意义的占行文字2.<br><br><span class="hljs-quote">&gt; 无意义的占行文字3.</span><br>无意义的占行文字4.<br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<blockquote>
<p>这是一个有两段文字的引用, <br>
无意义的占行文字1. <br>
无意义的占行文字2.</p>
</blockquote>
<blockquote>
<p>无意义的占行文字3. <br>
无意义的占行文字4.</p>
</blockquote>
<h3 id="6-1-引用的多层嵌套"><a class="header-anchor" href="#6-1-引用的多层嵌套">¶</a>6.1. 引用的多层嵌套</h3>
<p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">&gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白<br><br>&gt;&gt; 自己看教程！ - 愤青<br><br><span class="hljs-quote">&gt; 教程在哪？ - 小白</span><br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<blockquote>
<blockquote>
<blockquote>
<p>请问 Markdwon 怎么用？ - 小白</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>自己看教程！ - 愤青</p>
</blockquote>
</blockquote>
<blockquote>
<p>教程在哪？ - 小白</p>
</blockquote>
<h3 id="6-2-引用其它要素"><a class="header-anchor" href="#6-2-引用其它要素">¶</a>6.2. 引用其它要素</h3>
<p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 1.   这是第一行列表项。</span><br><span class="hljs-quote">&gt; 2.   这是第二行列表项。</span><br><span class="hljs-quote">&gt; </span><br><span class="hljs-quote">&gt; 给出一些例子代码：</span><br><span class="hljs-quote">&gt; </span><br><span class="hljs-quote">&gt;     return shell_exec("echo $input | $markdown_script");</span><br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<blockquote>
<ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>
<p>给出一些例子代码：</p>
<div class="hljs code-wrapper"><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre></div>
</blockquote>
<hr>
<h2 id="7-插入图像"><a class="header-anchor" href="#7-插入图像">¶</a>7. 插入图像</h2>
<p>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。</p>
<p>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p>
<h3 id="7-1-行内式"><a class="header-anchor" href="#7-1-行内式">¶</a>7.1. 行内式</h3>
<p>语法说明：![图片Alt](图片地址 “图片Title”)<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">美丽花儿： <br>![<span class="hljs-string">美丽花儿</span>](<span class="hljs-link">http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg "美丽花儿"</span>)<br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<p>美丽花儿：<br>
<img src="http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg" alt="美丽花儿" title="美丽花儿"></p>
<h3 id="7-2-参考式"><a class="header-anchor" href="#7-2-参考式">¶</a>7.2. 参考式</h3>
<p>语法说明：<br>
在文档要插入图片的地方写![图片Alt][标记]</p>
<p>在文档的最后写上[标记]:图片地址 “Title”</p>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">美丽花儿：<br>![<span class="hljs-string">美丽花儿</span>][<span class="hljs-symbol">flower</span>]<br><br>[<span class="hljs-symbol">flower</span>]:<span class="hljs-link">http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg  "美丽花儿"</span><br></code></pre></div></td></tr></table></figure>
<p>显示效果：<br>
美丽花儿：<br>
<img src="http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg" alt="美丽花儿" title="美丽花儿"></p>
<hr>
<h2 id="8-内容目录"><a class="header-anchor" href="#8-内容目录">¶</a>8. 内容目录</h2>
<p>在段落中填写 [TOC] 以显示全文内容的目录结构。<br>
效果参见最上方的目录</p>
<hr>
<h2 id="9-注脚"><a class="header-anchor" href="#9-注脚">¶</a>9. 注脚</h2>
<p>语法说明：</p>
<p>在需要添加注脚的文字后加上脚注名字 [^注脚名字] ,称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p>
<p>注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经 Markdown 转换后，也会自动归类到文章的最后。<br>
代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">使用 Markdown<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Markdown是一种纯文本标记语言
">[1]</span></a></sup>可以效率的书写文档,直接转换成 HTML<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="HyperText Markup Language 超文本标记语言
">[2]</span></a></sup>, 你可以使用 Leanote[^Le] 编辑器进行书写。<br><br>[<span class="hljs-symbol">^1</span>]:<span class="hljs-link">Markdown是一种纯文本标记语言</span><br><br>[<span class="hljs-symbol">^2</span>]:<span class="hljs-link">HyperText Markup Language 超文本标记语言</span><br><br>[<span class="hljs-symbol">^Le</span>]:<span class="hljs-link">开源笔记平台，支持Markdown和笔记直接发为博文`</span><br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<p>使用 Markdown<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Markdown是一种纯文本标记语言
">[1]</span></a></sup>可以效率的书写文档,直接转换成 HTML<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="HyperText Markup Language 超文本标记语言
">[2]</span></a></sup>, 你可以使用Leanote<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 编辑器进行书写。</p>
<p>注：脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。</p>
<hr>
<h2 id="10-LaTeX-公式"><a class="header-anchor" href="#10-LaTeX-公式">¶</a>10. LaTeX 公式</h2>
<h3 id="10-1-表示行内公式："><a class="header-anchor" href="#10-1-表示行内公式：">¶</a>10.1. <code>$</code> 表示行内公式：</h3>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">质能守恒方程可以用一个很简洁的方程式 $E&#x3D;mc^2$ 来表达。<br></code></pre></div></td></tr></table></figure>
<p>显示效果：<br>
质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>
<h3 id="10-2-表示整行公式："><a class="header-anchor" href="#10-2-表示整行公式：">¶</a>10.2 <code>$$</code> 表示整行公式：</h3>
<p>代码：</p>
<div class="hljs code-wrapper"><pre><code>$$\sum_{i=1}^n a_i=0$$
$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$
$$\sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}$$
</code></pre></div>
<p>显示效果：</p>
<p>$$\sum_{i=1}^n a_i=0$$<br>
$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$<br>
$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p>
<p>访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p>
<hr>
<p>代码：</p>
<figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">st=&gt;start: Start:&gt;https://www.zybuluo.com<br>io=&gt;inputoutput: verification<br>op=&gt;operation: Your Operation<br>cond=&gt;condition: Yes or No?<br>sub=&gt;subroutine: Your Subroutine<br>e=&gt;<span class="hljs-keyword">end</span><br>st-&gt;io-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;sub-&gt;io<br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<div id="flowchart-0" class="flow-chart"></div>
<p>更多语法参考：<a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">流程图语法参考</a></p>
<hr>
<h2 id="12-表格"><a class="header-anchor" href="#12-表格">¶</a>12. 表格</h2>
<p>语法说明：</p>
<ul>
<li>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。</li>
<li>列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。</li>
<li>第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。</li>
</ul>
<p>代码：<br>
简单方式写表格：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">学号|姓名|分数<br>-|-|-<br>小明|男|75<br>小红|女|79<br>小陆|男|92<br></code></pre></div></td></tr></table></figure>
<p>原生方式写表格：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">|学号|姓名|分数|<br>|-|-|-|<br>|小明|男|75|<br>|小红|女|79|<br>|小陆|男|92|<br></code></pre></div></td></tr></table></figure>
<p>为表格第二列指定方向：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">产品|价格<br>-|-:<br>Leanote 高级账号|60元/年<br>Leanote 超级账号|120元/年<br></code></pre></div></td></tr></table></figure>
<p>显示效果：<br>
简单方式写表格：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>小明</td>
<td>男</td>
<td>75</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>79</td>
</tr>
<tr>
<td>小陆</td>
<td>男</td>
<td>92</td>
</tr>
</tbody>
</table>
<p>原生方式写表格：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>小明</td>
<td>男</td>
<td>75</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>79</td>
</tr>
<tr>
<td>小陆</td>
<td>男</td>
<td>92</td>
</tr>
</tbody>
</table>
<p>为表格第二列指定方向：</p>
<table>
<thead>
<tr>
<th>产品</th>
<th style="text-align:right">价格</th>
</tr>
</thead>
<tbody>
<tr>
<td>Leanote 高级账号</td>
<td style="text-align:right">60元/年</td>
</tr>
<tr>
<td>Leanote 超级账号</td>
<td style="text-align:right">120元/年</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="13-分隔线"><a class="header-anchor" href="#13-分隔线">¶</a>13. 分隔线</h2>
<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">* </span><span class="hljs-emphasis">* *</span><br><span class="hljs-emphasis">***</span><br><span class="hljs-strong">*****</span><br><span class="hljs-bullet">- </span>- -<br>---------------------------------------<br></code></pre></div></td></tr></table></figure>
<p>显示效果都一样：</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<h2 id="14-代码"><a class="header-anchor" href="#14-代码">¶</a>14 代码</h2>
<p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。<br>
语法说明：</p>
<ol>
<li>插入行内代码，即插入一个单词或者一句代码的情况，使用`code`这样的形式插入。</li>
<li>插入多行代码，可以使用缩进或者“` code “`,具体看示例。<br>
注意： 缩进式插入前方必须有空行</li>
</ol>
<h3 id="14-1-行内式"><a class="header-anchor" href="#14-1-行内式">¶</a>14.1. 行内式</h3>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">C语言里的函数 <span class="hljs-code">`scanf()`</span> 怎么使用？<br></code></pre></div></td></tr></table></figure>
<p>显示效果：<br>
C语言里的函数 <code>scanf()</code> 怎么使用？</p>
<h3 id="14-2-缩进式多行代码"><a class="header-anchor" href="#14-2-缩进式多行代码">¶</a>14.2. 缩进式多行代码</h3>
<p>缩进 4 个空格或是 1 个制表符<br>
一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。<br>
代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello world\n"</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<div class="hljs code-wrapper"><pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    printf(&quot;Hello world\n&quot;);
}
</code></pre></div>
<h3 id="14-3-用六个-包裹多行代码"><a class="header-anchor" href="#14-3-用六个-包裹多行代码">¶</a>14.3. 用六个 ` 包裹多行代码</h3>
<p>代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><br><span class="hljs-code">```</span><br><span class="hljs-code">#include &lt;stdio.h&gt;</span><br><span class="hljs-code">int main(void)</span><br><span class="hljs-code">&#123;</span><br><span class="hljs-code">    printf("Hello world\n");</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code"></span><br><span class="hljs-code">```</span><br></code></pre></div></td></tr></table></figure>
<p>显示效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello world\n"</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="14-4-HTML-原始码"><a class="header-anchor" href="#14-4-HTML-原始码">¶</a>14.4. HTML 原始码</h2>
<p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：<br>
代码：<br>
第一个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"footer"</span>&gt;</span><br>    © 2004 Foo Corporation<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>第二个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">"2"</span>&gt;</span>值班人员<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期一<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期二<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期三<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>李强<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>张明<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>王平<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>显示效果：<br>
第一个例子：</p>
<div class="footer">
   © 2004 Foo Corporation
</div>
<p>第二个例子：</p>
<table>
    <tr>
        <th rowspan="2">值班人员</th>
        <th>星期一</th>
        <th>星期二</th>
        <th>星期三</th>
    </tr>
    <tr>
        <td>李强</td>
        <td>张明</td>
        <td>王平</td>
    </tr>
</table>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start:>https://www.zybuluo.com
io=>inputoutput: verification
op=>operation: Your Operation
cond=>condition: Yes or No?
sub=>subroutine: Your Subroutine
e=>end
st->io->op->cond
cond(yes)->e
cond(no)->sub->io</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Markdown是一种纯文本标记语言
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>HyperText Markup Language 超文本标记语言
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section><hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>开源笔记平台，支持Markdown和笔记直接发为博文 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>《C语言程序设计·现代方法（第二版）》学习笔记 -- 之一</title>
    <url>/2018/10/18/%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%C2%B7%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
    <content><![CDATA[<h1>《C语言程序设计现代方法第二版》学习笔记一</h1>
<hr>
<p>[toc]</p>
<hr>
<h2 id="第二章-C语言基本概念"><a class="header-anchor" href="#第二章-C语言基本概念">¶</a>第二章 C语言基本概念</h2>
<h3 id="2-4-变量和赋值"><a class="header-anchor" href="#2-4-变量和赋值">¶</a>2.4 变量和赋值</h3>
<h4 id="2-4-5-初始化（P15）"><a class="header-anchor" href="#2-4-5-初始化（P15）">¶</a>2.4.5 初始化（P15）</h4>
<p>  当程序开始执行时，某些变量会被自动设置为0，而大多数变量则不会。如果试图访问未初始化的变量，可能会得到不可预知的结果。</p>
<h3 id="2-7-标识符（P19）"><a class="header-anchor" href="#2-7-标识符（P19）">¶</a>2.7 标识符（P19）</h3>
<p>  标准库中函数的名字只能包含小写字母。</p>
<h3 id="第二章FAQ（P22-P23）"><a class="header-anchor" href="#第二章FAQ（P22-P23）">¶</a>第二章FAQ（P22~P23）</h3>
<ol>
<li>（在C99中）如果main函数声明中的返回类型是<code>int</code>，程序会向操作系统返回0;否则程序会返回一个不确定的值。</li>
<li>依据C标准，编译器必须用一个空格字符替换每条注释语句。</li>
<li>传统风格的注释（<code>/*...*/</code>）不允许嵌套;C99注释（以<code>//</code>开头）可以嵌套在传统风格的注释中。</li>
</ol>
<hr>
<h2 id="第三章-格式化输入-输出"><a class="header-anchor" href="#第三章-格式化输入-输出">¶</a>第三章 格式化输入/输出</h2>
<h3 id="3-1-printf函数"><a class="header-anchor" href="#3-1-printf函数">¶</a>3.1 <code>printf</code>函数</h3>
<h4 id="3-1-1-转换说明（P28）"><a class="header-anchor" href="#3-1-1-转换说明（P28）">¶</a>3.1.1 转换说明（P28）</h4>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">float</span> x;<br>    <br>    i = <span class="hljs-number">40</span>;<br>    x = <span class="hljs-number">839.21f</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|%d|%5d|%-5d|%5.3d|n"</span>, i, i, i, );<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|%10.3f|%10.3e|%-10g|\n"</span>, x, x, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>输出：</p>
<p>|40|   40|40   |  040|</p>
<p>|   839.210| 8.392e+02|839.21    |</p>
<h4 id="3-2-1-scanf的工作方法（P30）"><a class="header-anchor" href="#3-2-1-scanf的工作方法（P30）">¶</a>3.2.1 <code>scanf</code>的工作方法（P30）</h4>
<p>  对于格式串中的第一个转换说明，<code>scanf</code>函数从输入的数据中定位适当类型的项，并在必要时跳过空格。然后，<code>scanf</code>函数诗篇数据项，并且在遇到 <strong>不可能属于此项的字符（笔记：如果不可能属于此项的字符为本次读取的第一个字符，则<code>scanf</code>立即停止。否则将此字符放回原位，在下次读取时作为第一个读取的字符。参考P31例子）</strong> 时停止。如果读入数据项成功，那么<code>scanf</code>函数会继续处理格式串的剩余部分；如果某一项不能成功读入，那么<code>scanf</code>函数将不再查看格式串的剩余部分（或余下的输入数据）而立即返回。</p>
<p>  在寻找数的起始位置时，<code>scanf</code>函数会忽略空白字符。因此，我们可以把数字放在同一行或者分散在几行内输入。</p>
<h4 id="3-2-3易混淆的printf函数和scanf函数（P32）"><a class="header-anchor" href="#3-2-3易混淆的printf函数和scanf函数（P32）">¶</a>3.2.3易混淆的<code>printf</code>函数和<code>scanf</code>函数（P32）</h4>
<p>  <code>printf</code>格式串结党以<code>\n</code>结尾，但是在<code>scanf</code>格式串末尾旋转换行符通常是一个坏主意。对<code>scanf</code>函数来说，格式串中的换行符等价于空格，两者都会引发<code>scanf</code>函数提前进入下一个非空白字符。例如，如果格式串是&quot;<code>%d\n</code>&quot;，那么函数将跳过空白字符，读取一个整数，然后跳到下一个非空白字符处。像这样的格式串可能会导致交互式程序一直“挂起”直到用户输入一个非空白字符为止。</p>
<h3 id="第三章FAQ（P33）"><a class="header-anchor" href="#第三章FAQ（P33）">¶</a>第三章FAQ（P33）</h3>
<p>  <code>%i</code>与<code>%d</code>区别：<code>%i</code>可以为十进制、八进制（0开头）、十六进制（0x或0X开头）的数，<code>%d</code>只识别十进制数。</p>
<hr>
<h2 id="第四章-表达式"><a class="header-anchor" href="#第四章-表达式">¶</a>第四章 表达式</h2>
<h3 id="4-2-赋值运算符"><a class="header-anchor" href="#4-2-赋值运算符">¶</a>4.2 赋值运算符</h3>
<h4 id="4-2-1简单赋值（P40）"><a class="header-anchor" href="#4-2-1简单赋值（P40）">¶</a>4.2.1简单赋值（P40）</h4>
<p>  大多数C语言运算符不会改变操作数的值，但是也有一些会改变。由于这类运算符所做的不再仅仅是计算出值，所以称它们有副作用。如<code>i = 0</code>求值产生的结果为0，并（作为副作用）把0值赋给i。</p>
<h4 id="4-2-3复合赋值（P41）"><a class="header-anchor" href="#4-2-3复合赋值（P41）">¶</a>4.2.3复合赋值（P41）</h4>
<ol>
<li>
<p>在极少数情况下，由于v自身的副作用，<code>v += e</code>不等同于<code>v = v + e</code> <strong>（笔记：<code>v += e</code>中v的值只计算一次，而<code>v = v + e</code>中v的值会计算两次。如：<code>a[i++] += 2</code>中i会自增一次，<code>a[i++] = a[i++] + 2</code>中i会自增两次）</strong>。类似的说明也适用于其它复合赋值运算符。</p>
</li>
<li>
<p>复合赋值运算符有着和=运算符一样的特性。特别是，它们都是右结合的，所以</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">i += j += k<br></code></pre></div></td></tr></table></figure>
<p>意味着</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">i += (j += k)<br></code></pre></div></td></tr></table></figure>
<h3 id="4-5表达式语句（P45）"><a class="header-anchor" href="#4-5表达式语句（P45）">¶</a>4.5表达式语句（P45）</h3>
<p>  任何表达式都可以用作语句。<code>i * j - 1</code>因为i和j没有变化，所以这条语句没有任何作用。</p>
<hr>
<h2 id="第五章-选择语句"><a class="header-anchor" href="#第五章-选择语句">¶</a>第五章 选择语句</h2>
<h3 id="5-2-if语句"><a class="header-anchor" href="#5-2-if语句">¶</a>5.2 <code>if</code>语句</h3>
<h4 id="5-2-4-“悬空else”的问题（P56）"><a class="header-anchor" href="#5-2-4-“悬空else”的问题（P56）">¶</a>5.2.4 “悬空<code>else</code>”的问题（P56）</h4>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (y != <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> (x != <span class="hljs-number">0</span>)<br>        result = x / y;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error: y is equal to 0\n"</span>);<br></code></pre></div></td></tr></table></figure>
<p>  C语言遵循的规则是<code>else</code>子句应该属于离它最近的且还未和其它<code>else</code>匹配的<code>if</code>语句。</p>
<h4 id="5-2-7-C99中的布尔值（P58）"><a class="header-anchor" href="#5-2-7-C99中的布尔值（P58）">¶</a>5.2.7 C99中的布尔值（P58）</h4>
<p>  在C99中提供了<code>_Bool</code>型，<font color=red><strong><code>_Bool</code>是无符号整型，但只能赋值为0或1，一般来说，往<code>_Bool</code>变量中存储非零值会导致变量赋值为1</strong></font>。<br>
  除了<code>_Bool</code>类型的宝座，C99还提供了一个新的头&lt;stdbool.h&gt;。该问提供了<code>bool</code>宏来代表<code>_Bool</code>，<code>true</code>来代表1，<code>false</code>来代表0。</p>
<h3 id="5-3-switch语句"><a class="header-anchor" href="#5-3-switch语句">¶</a>5.3 <code>switch</code>语句</h3>
<ol>
<li><code>switch</code>后边必须跟着由圆括号括起来的<font color=red><strong>整型</strong></font>表达式，不能用浮点数和字符串。</li>
<li><code>case</code>后跟<font color=red><strong>常量表达式</strong></font>，如<code>5 + 10</code>。</li>
</ol>
<h3 id="第五章FAQ（P63-P64）"><a class="header-anchor" href="#第五章FAQ（P63-P64）">¶</a>第五章FAQ（P63~P64）</h3>
<ol>
<li>当<code>int</code>型和<code>float</code>型的值混合在一个条件表达式中时（如<code>i &gt; 0 ? i : f</code>）表达式类型为<code>float</code>型。如果<code>i &gt; 0</code>为真，那么变量i转化为<code>float</code>型后的值就是表达式的值。</li>
<li>C89标准指出，以下划线后跟一个大写字母开头的名字是保留字，程序员不应该使用。</li>
</ol>
<hr>
<h2 id="第六章-循环"><a class="header-anchor" href="#第六章-循环">¶</a>第六章 循环</h2>
<h3 id="6-3-for语句"><a class="header-anchor" href="#6-3-for语句">¶</a>6.3 <code>for</code>语句</h3>
<h4 id="6-3-4-逗号运算符（P76）"><a class="header-anchor" href="#6-3-4-逗号运算符（P76）">¶</a>6.3.4 逗号运算符（P76）</h4>
<ol>
<li>形式：表达式1, 表达式2</li>
<li>实现方式：第一步，计算表达式1并且扔掉计算出的值。第二步，计算表达式2，把这个值作为整个表达式的值。</li>
<li>例如：<code>i = 1</code>, <code>j = 2</code>, <code>k = i + j</code>解释为<code>((i = 1), (j = 2)), (k = (i + j))</code></li>
</ol>
<h3 id="6-4-退出循环"><a class="header-anchor" href="#6-4-退出循环">¶</a>6.4 退出循环</h3>
<h4 id="6-4-3-goto语句（P79）"><a class="header-anchor" href="#6-4-3-goto语句（P79）">¶</a>6.4.3 <code>goto</code>语句（P79）</h4>
<ol>
<li><code>break</code>语句的目标是包含该语句的循环结束之<font color=red><strong>后</strong></font>的那一点，而<code>continue</code>语句的目标是循环结束之<font color=red><strong>前</strong></font>的那一点。</li>
<li><code>goto</code>语句不可以用于绕过变长数组。</li>
</ol>
<h3 id="第六章FAQ（P83-P84）"><a class="header-anchor" href="#第六章FAQ（P83-P84）">¶</a>第六章FAQ（P83~P84）</h3>
<ol>
<li>早期编译器中无限循环<code>for(;;)</code>比<code>while(1)</code>高效；新编译器性能无差别。</li>
<li>空语句可以有如下用途：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">&#123;<br>    ...<br>    <span class="hljs-keyword">goto</span> end_of_stmt;<br>    end_of_stmt: ;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<hr>
<h2 id="第七章-基本类型"><a class="header-anchor" href="#第七章-基本类型">¶</a>第七章 基本类型</h2>
<h3 id="7-1整数类型（P89"><a class="header-anchor" href="#7-1整数类型（P89">¶</a>7.1整数类型（P89)</h3>
<p>  <code>short int</code>、<code>int</code>、<code>long int</code>取值范围有可能是一样的。但C标准规定<code>int</code>取值范围不能比<code>short int</code>小，<code>long int</code>取值范围不能比<code>int</code>小。</p>
<h4 id="7-1-4整数溢出（P91）"><a class="header-anchor" href="#7-1-4整数溢出（P91）">¶</a>7.1.4整数溢出（P91）</h4>
<ol>
<li>有符号整数溢出行为未定义。</li>
<li>无符号整数溢出为对<code>2n</code>取模，其中<code>n</code>是用于存储结果的位数。例如，如果对无符号的16位数65535加1，其结果可以保证为0。</li>
</ol>
<h3 id="7-3字符类型"><a class="header-anchor" href="#7-3字符类型">¶</a>7.3字符类型</h3>
<h4 id="7-3-1字符操作（P95）"><a class="header-anchor" href="#7-3-1字符操作（P95）">¶</a>7.3.1字符操作（P95）</h4>
<p>  C语言把字符当作小整数进行处理。</p>
<h4 id="7-3-7用getchar和putchar读-写字符"><a class="header-anchor" href="#7-3-7用getchar和putchar读-写字符">¶</a>7.3.7用<code>getchar</code>和<code>putchar</code>读/写字符</h4>
<p>  在同一个程序中混合使用<code>getchr</code>函数和<code>scanf</code>函数时，要注意<code>scanf</code>函数倾向于遗留下它“扫视”过但未读取的字符（包括换行符）。考虑下面程序段：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter an integer: "</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;i);<br> <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter a command: "</span>);<br> <br>command = getchar();<br></code></pre></div></td></tr></table></figure>
<p>  在读入<code>i</code>的同时，<code>scanf</code>函数调用将会留下没有消耗掉的任意字符，包括（但不限于）换行符。<code>getchar</code>函数随后将取回第一个剩余字符，但这不是我们所希望的结果。</p>
<h3 id="7-4类型转换（P100）"><a class="header-anchor" href="#7-4类型转换（P100）">¶</a>7.4类型转换（P100）</h3>
<p>  当发生下列情况时会进行隐匿转换。</p>
<ul>
<li>当算术表达式或逻辑表达式中操作数的类型不相同时。（C语言执行所谓的常用算术转换）</li>
<li>当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。</li>
<li>当函数调用中的实参类型与其对应的形参类型不匹配时。</li>
<li>当<code>return</code>语句中表达式的类型和函数返回值的类型不匹配时。</li>
</ul>
<h4 id="7-4-1常用算术转换（P101）"><a class="header-anchor" href="#7-4-1常用算术转换（P101）">¶</a>7.4.1常用算术转换（P101）</h4>
<ol>
<li>
<p>任一操作数是浮点类型的情况。</p>
<div class="hljs code-wrapper"><pre><code>         long double
               ^
               |
            double
               ^
               |
             float
</code></pre></div>
</li>
<li>
<p>两个操作数的类型都不是浮点类型的情况。</p>
<div class="hljs code-wrapper"><pre><code>        unsigned long int
                 ^
                 |
              long int
                 ^
                 |
           unsigned int
                 ^
                 |
                int
</code></pre></div>
</li>
</ol>
<p>  有一种特殊情况，只有在<code>long int</code>类型和<code>unsigned int</code>类型长度（比如32位）相同时才会发生。在这类情况下，如果一个操作数的类型是<code>long int</code>，而另一个的类型是<code>unsiged int</code>，那么两个操作数都会转换成<code>unsigned long int</code>类型。C语言把（类型名）视为一元运算符。一元运算符的优先级高于二元运算符，所以编译器会把表达。</p>
<p>  当把有符号操作数和无符号操作数组合时，把有符号操作数“转换”成无符号的值。转换过程中需要加上或者减去<code>n + 1</code>的倍数，其中<code>n</code>是无符号类型能表示的最大值。这条规则可能会导致某此隐蔽的编程错误。</p>
<p>  假设<code>int</code>类型的变量<code>i</code>的值为-10，而<code>unsigned int</code>类型的变量<code>u</code>的值为10。如果用&lt;运算符比较变量<code>i</code>和变量<code>u</code>，那么期望的结果应该是1（真）。但是，在比较前，变量<code>i</code>转换成为<code>unsigned int</code>类型。因为负数不能被表示成无符号整数，所以转换后的值不再为-10，而是加上4294967296的结果（假定4294967296是最大的无符号整数），即4294967286。因而<code>i &lt; u</code>比较的结果将为0。有些编译器会在程序试图比较有符号与无符号时给出一条类似“comparison between signed and unsigned”的警告消息。</p>
<p>  由于此类陷阱的存在，所以最好尽量避免使用无符号整数，特别是不要把它和有符号整数混合使用。</p>
<h4 id="7-4-2赋值过程中的转换（P102）"><a class="header-anchor" href="#7-4-2赋值过程中的转换（P102）">¶</a>7.4.2赋值过程中的转换（P102）</h4>
<p>  把某种类型的值赋给类型更狭小的变量时，如果该值在变量类型范围之外，那么将会得到无意义的结果（甚至更糟）。<br>
  如果浮点常量被赋值给<code>float</code>型变量时，一个很好的方法是在浮点常量尾部加上后辍<code>f</code>。</p>
<h4 id="7-4-4强制类型转换（P103）"><a class="header-anchor" href="#7-4-4强制类型转换（P103）">¶</a>7.4.4强制类型转换（P103）</h4>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">float</span> quotient;<br><span class="hljs-keyword">int</span> dividend, divisor;<br> <br>quotient = (<span class="hljs-keyword">float</span>) dividend / divisor;<br></code></pre></div></td></tr></table></figure>
<p>  变量<code>divisor</code>不需要进行强制类型转换，因为把变量<code>dividend</code>强制錾成<code>float</code>类型会迫使编译器把<code>divisor</code>也转换成<code>float</code>类型。C语言把（类型名）视为一元运算符。一元运算符的优先级高于二元运算符，所以编译器会把表达式</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">(<span class="hljs-keyword">float</span>) dividend / divisor<br></code></pre></div></td></tr></table></figure>
<p>  解释为</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">((<span class="hljs-keyword">float</span>) dividend) / divisor<br></code></pre></div></td></tr></table></figure>
<h3 id="7-6-sizeof运算符（P106）"><a class="header-anchor" href="#7-6-sizeof运算符（P106）">¶</a>7.6 <code>sizeof</code>运算符（P106）</h3>
<p>  显示<code>sizeof</code>值时要注意，因为<code>sizeof</code>表达式的类型是<code>size_t</code>，这是一种由实现定义的类型。在C89中，最好在显示前把表达式的值转换成一种已知的类型。<code>size_t</code>一定是无符号整型，所以最安全的方法是把<code>sizeof</code>表达式强制转换成<code>unsigned long</code>类型。(C89中最大的无符号类型)，然后使用转换说明答题<code>%lu</code>显示。</p>
<p>  在C99中，<code>size_t</code>类型可以比<code>unsigned long</code>更长。但C99中的<code>printf</code>可以直接显示<code>size_t</code>类型值而不需要强制转换。方法是在转换说明中的一般整数（通常用<code>u</code>）代码前使用字母<code>z</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Size of int: %zu\n"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)); <span class="hljs-comment">/* C99 only */</span><br></code></pre></div></td></tr></table></figure>
<h3 id="第七章FAQ（P107）"><a class="header-anchor" href="#第七章FAQ（P107）">¶</a>第七章FAQ（P107）</h3>
<p>  只要有符号整数的值不是负值，就可以用<code>%o</code>和<code>%x</code>显示。这些转换导致<code>printf</code>函数把有符号整数看成无符号的；换句话说，<code>printf</code>函数将假设符号位是数的绝对值部分。只要符号位为0，就没问题。如果符号位为1，那么<code>printf</code>函数将显示出一个走出预期的大数。没有直接的方法可以书写负数的八进制或十六进制形式。幸运的是，需要这样做的情况非常少。当然，我们可以判定这个数是否是负数，然后自己显示一个负号：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-%x"</span>, -i);<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%x"</span>, i);<br></code></pre></div></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>《C语言程序设计·现代方法（第二版）》学习笔记 -- 之二</title>
    <url>/2018/10/18/%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%C2%B7%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
    <content><![CDATA[<h1>《C语言程序设计现代方法第二版》学习笔记二</h1>
<hr>
<p>[TOC]</p>
<hr>
<h2 id="第八章"><a class="header-anchor" href="#第八章">¶</a>第八章</h2>
<h3 id="8-1-一维数组"><a class="header-anchor" href="#8-1-一维数组">¶</a>8.1 一维数组</h3>
<h4 id="8-1-1-数组下标（P114）"><a class="header-anchor" href="#8-1-1-数组下标（P114）">¶</a>8.1.1 数组下标（P114）</h4>
<ol>
<li>C语言不要求检查下标的范围。当下标超出范围时，程序可能执行不可预知的行为。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>], i; <br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) <br>    a[i] = <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>
<p> 对于某些编译器来说，这个表面上正确的<code>for</code>语句却产生了一个无限循环！当变量<code>i</code>的值变为10时，程序将数值0存储在<code>a[10]</code>中。但是<code>a[10]</code>这个元素并不存在，所以在元素<code>a[9]</code>后数值0立刻进入内存。如果内存中变量<code>i</code>旋转在<code>a[9]</code>的后边（这是有可能的），那么变量<code>i</code>将会被重置为0，进而导致循环重新开始。</p>
<ol start="2">
<li>当数组下标有副作用时一定要注意：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; N)<br>    a[i] = b[i++];<br></code></pre></div></td></tr></table></figure>
<p> 表达式<code>a[i] = b[i++]</code>访问并修改i的值，如4.4节所述，这样会导致未定义的行为。</p>
<h4 id="8-1-2数组初始化（P115）"><a class="header-anchor" href="#8-1-2数组初始化（P115）">¶</a>8.1.2数组初始化（P115）</h4>
<ol>
<li>如果初始化式比数组短，好么数组中剩余元素赋值为0。利用这一特性，可以很容易地把数组初始化为全0：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br></code></pre></div></td></tr></table></figure>
<ol start="2">
<li>初始化式完全为空是非法的，初始化式比要初始化的数组长也是非法的。</li>
<li>如果给定了初始化式，可以活力掉数组的长度。</li>
</ol>
<h4 id="8-1-3指定初始化式（P116）"><a class="header-anchor" href="#8-1-3指定初始化式（P116）">¶</a>8.1.3指定初始化式（P116）</h4>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">int</span> a[<span class="hljs-number">15</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">29</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">48</span>&#125;;<br></code></pre></div></td></tr></table></figure>
<p> 可以使用指定初始化式写为：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">int</span> a[<span class="hljs-number">15</span>] = &#123;[<span class="hljs-number">14</span>] = <span class="hljs-number">48</span>, [<span class="hljs-number">9</span>] = <span class="hljs-number">7</span>, [<span class="hljs-number">2</span>] = <span class="hljs-number">29</span>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="8-2-多维数组"><a class="header-anchor" href="#8-2-多维数组">¶</a>8.2 多维数组</h3>
<h4 id="8-2-1多维数组初始化（P120）"><a class="header-anchor" href="#8-2-1多维数组初始化（P120）">¶</a>8.2.1多维数组初始化（P120）</h4>
<ol>
<li>在多维数组中省略掉内层花括号可能是很危险的，因为额外的元素（更糟的情况是丢失的元素）将会影响剩下的初始化式。省略花括号会引起某些编译器产生类似“missing braces around initialiezer”这样的警告消息。</li>
<li>C99指定初始化式对多维数组也有效。例如，可以这样创建2x2的单位矩阵：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">double</span> ident[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span>, [<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1.0</span>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="第八章FAQ（P123）"><a class="header-anchor" href="#第八章FAQ（P123）">¶</a>第八章FAQ（P123）</h3>
<ol>
<li>编译器在处理初始化式列表时，会记录下一个待初始化的数组元素的位置。正常情况下，下一个元素是刚被初始化的元素后面的那个。但是，当列表中出现初始化式时，下一个元素会被强制为指示符对应的元素，即使该元素已经被初始化了：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">int</span> a [] = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, [<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>  下面逐步分析编译器处理数组a的初始化式的操作：</p>
<ul>
<li>用4初始化元素0，下一个待初始化的是元素1；</li>
<li>用9初始化元素1，下一个待初始化的是元素2；</li>
<li>用1初始化元素2，下一个待初始化的是元素3；</li>
<li>用8初始化元素3，下一个待初始化的是元素4；</li>
<li>[0]指示符导致下一个元素是元素0，所以用5初始化元素0（替换先前存储的4）.下一个待初始化的是元素1；</li>
<li>用7初始化元素1（替换先前存储的9）.下一个待初始化的是元素2（跟本例不相关，因为已经到达列表末尾）。<br>
  最终效果跟下面的声明一样：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>&#125;;<br></code></pre></div></td></tr></table></figure>
<p> <font color: red><strong>因此，数组的长度为4。</strong></font></p>
<p>2. 在程序执行过程中，遇到变长数组声明时通常就为该变长数组分配内存空间了。用<code>goto</code>语句绕过变长数组的声明可能会导致程序对未分配空间的数组中的元素进行访问。</p>
<hr>
<h2 id="第九章-函数"><a class="header-anchor" href="#第九章-函数">¶</a>第九章 函数</h2>
<h3 id="9-1-函数的定义和调用"><a class="header-anchor" href="#9-1-函数的定义和调用">¶</a>9.1 函数的定义和调用</h3>
<h4 id="9-1-1函数定义（P132）"><a class="header-anchor" href="#9-1-1函数定义（P132）">¶</a>9.1.1函数定义（P132）</h4>
<ol>
<li>下列规则用来管理返回类型：</li>
</ol>
<ul>
<li><font color=red><strong>函数不能返回数组，但关于返回类型没有其它限制。</strong></font></li>
<li>指定返回类型是<code>void</code>类型说明函数没有返回值。</li>
<li><font color=red><strong>如果省略返回类型，C89会假定函数返回值的类型是<code>int</code>类型，但在C99中这是不合法的。</strong></font></li>
</ul>
<ol start="2">
<li><font color=red><strong>如果函数没有形式参数，那么在圆括号内应该出现<code>void</code>。</strong></font></li>
<li>对于返回类型为<code>void</code>的函数，其函数体可以为空。</li>
</ol>
<h4 id="9-1-2函数调用（P133）"><a class="header-anchor" href="#9-1-2函数调用（P133）">¶</a>9.1.2函数调用（P133）</h4>
<ol>
<li>如果丢失圆括号，那么将无法进行函数调用：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_pun</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    ...<br>&#125;<br><br>print_pun; <span class="hljs-comment">/* WRONG */</span><br></code></pre></div></td></tr></table></figure>
<p>  这样的结果是合法的（虽然没有意义）表达式语句，而且看上去这语句是正确的，但是这条语句不起任何作用。一些编译器会发出一条类似“statement with no effect”的警告。</p>
<p>2. 在C语言中，“强制转换成<code>void</code>”是对“抛弃”的一种客气的说法。使用<code>(void)</code>可以使别人清楚编写者是故意抛弃返回值的，而不是忘记了。</p>
<h3 id="9-2函数声明（P135）"><a class="header-anchor" href="#9-2函数声明（P135）">¶</a>9.2函数声明（P135）</h3>
<p>  C99遵循这样的规则：在调用一个函数之前，必须先对其进行声明或定义。调用函数时，如果此前编译器未见到该函数的声明或定义，会导致出错。</p>
<h4 id="9-3-2数组型实际参数（P138）"><a class="header-anchor" href="#9-3-2数组型实际参数（P138）">¶</a>9.3.2数组型实际参数（P138）</h4>
<ol>
<li>当形式参数是一维数组时，可以（而且是通常情况下）不说明数组的长度：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a [])</span> </span>&#123; <span class="hljs-comment">/* no length specified*/</span><br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>2. C语言没有为函数提供任务简便的方法来确定传递给它的数组的长度；如果函数需要，我们必须把长度作为额外的参数提供出来。</p>
<p>3. 虽然可以用运算符<code>sizeof</code>计算出数组变量的长度，但是它无法给出关于数组型形式参数的正确答案。</p>
<p>4. 如果形式参数是多维数组，声明参数时<font color=red><strong>只能省略第一维长度</strong></font>。</p>
<h3 id="9-3-实际参数"><a class="header-anchor" href="#9-3-实际参数">¶</a>9.3 实际参数</h3>
<h4 id="9-3-3变长数组形式参数（P140）"><a class="header-anchor" href="#9-3-3变长数组形式参数（P140）">¶</a>9.3.3变长数组形式参数（P140）</h4>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum_array</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> a[n])</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="9-3-4在数组参数声明中使用static（P141）"><a class="header-anchor" href="#9-3-4在数组参数声明中使用static（P141）">¶</a>9.3.4在数组参数声明中使用<code>static</code>（P141）</h4>
<p>  在下面这个例子中，将<code>static</code>放在数字3之前表明数组a的长度至少可以保证是3：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum_array</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[<span class="hljs-keyword">static</span> <span class="hljs-number">3</span>], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>  这样使用<code>static</code>不会对程序的行为有任何影响。<code>static</code>的存在只不过是一个“提示”，C编译器可以据此生成更快的指令来访问数组。<font color=red><strong>如果数组参数是多维的，<code>static</code>仅可用于第一维（例如，指定二维数组的行数）</strong></font>。</p>
<h4 id="9-3-5复合字面量（P141）"><a class="header-anchor" href="#9-3-5复合字面量（P141）">¶</a>9.3.5复合字面量（P141）</h4>
<ol>
<li>复合字面量是通过其包含的元素而创建的没有名字的数组：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">total = sum_array((<span class="hljs-keyword">int</span> [])&#123;<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;, <span class="hljs-number">5</span>);<br></code></pre></div></td></tr></table></figure>
<p>2. 可以指明数组长度，如<code>(int[4]){1, 9, 2, 1}</code>，这种方式等同于<code>(int[]){1, 9, 2,1}</code>。</p>
<p>3. 如果要求复合字面量为“只读”，可以在类型前加上const，如(const int []){5, 4}。</p>
<h3 id="9-5程序终止（P143）"><a class="header-anchor" href="#9-5程序终止（P143）">¶</a>9.5程序终止（P143）</h3>
<p>  <code>exit</code>函数、<code>EXIT_SUCCESS</code>、<code>EXIT_FAILURE</code>位于<code>&lt;stdlib.h&gt;</code>中。</p>
<h3 id="第九章FAQ（P149）"><a class="header-anchor" href="#第九章FAQ（P149）">¶</a>第九章FAQ（P149）</h3>
<p>  如果几个函数具有相同的返回类型，那么可以把它们的声明合并，事实上，C语言甚至允许把函数声明和变量声明合并在一起：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">double</span> x, y, average(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b);<br></code></pre></div></td></tr></table></figure>
<hr>
<h2 id="第十章-程序结构"><a class="header-anchor" href="#第十章-程序结构">¶</a>第十章 程序结构</h2>
<h3 id="10-1-局部变量"><a class="header-anchor" href="#10-1-局部变量">¶</a>10.1 局部变量</h3>
<h4 id="10-1-1静态局部变量（P156）"><a class="header-anchor" href="#10-1-1静态局部变量（P156）">¶</a>10.1.1静态局部变量（P156）</h4>
<ol>
<li>在局部变量声明中旋转单词<code>static</code>可以使变量具有静态存储期限而不再是自动存储期限。因为具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。</li>
<li>静态局部变量始终有块作用域，所以它对其他函数是不可见的。概括来说，静态变量是对其它函数隐藏数据的地方，但是它会为将来同一个函数的再调用保留这些数据。</li>
</ol>
<h3 id="10-2外部变量（P156）"><a class="header-anchor" href="#10-2外部变量（P156）">¶</a>10.2外部变量（P156）</h3>
<ul>
<li>外部变量（有时称为全局变量）的性质不同于局部变量的性质：</li>
</ul>
<blockquote>
<ul>
<li>静态存储期限。就如同声明为static的局部变量一样，外部变量拥有静态存储期限。存储在外部变量中的值将永久保留下来。</li>
<li>文件作用域。外部变量拥有文件作用域：从变量被声明的点开始一直到所在文件的末尾。因此，跟随在外部变量声明之后的所有函数都可以访问（并修改）它。</li>
</ul>
</blockquote>
<hr>
<h2 id="第十二章-指针和数组"><a class="header-anchor" href="#第十二章-指针和数组">¶</a>第十二章 指针和数组</h2>
<h3 id="12-2-指针用于数组处理（P186）"><a class="header-anchor" href="#12-2-指针用于数组处理（P186）">¶</a>12.2 指针用于数组处理（P186）</h3>
<p>  后缀<code>++</code>的优先级高于<code>*</code>，所以编译器把<code>*p++ = j</code>看成是<code>*(p++) = j</code>。<code>p++</code>的值是<code>p</code>。（因为使用后缀<code>++</code>，所以<code>p</code>只有在表达式计算出来后才可能自增。）因此，<code>*(p++)</code>的值将是<code>*p</code>，即<code>p</code>当前指向的对象。</p>
<h3 id="12-3用数组名作为指针（P188）"><a class="header-anchor" href="#12-3用数组名作为指针（P188）">¶</a>12.3用数组名作为指针（P188）</h3>
<p> 虽然可以把数组名用作指针，但是不能给数组名赋新的值。试图使数组名指向其它地方是错误的：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">while</span> (*a != <span class="hljs-number">0</span>)<br>    a++; <span class="hljs-comment">/* WRONG */</span><br></code></pre></div></td></tr></table></figure>
<h3 id="第十二章FAQ"><a class="header-anchor" href="#第十二章FAQ">¶</a>第十二章FAQ</h3>
<p>  <code>i[a]</code>和<code>a[i]</code>是一样的。对于编译器而言<code>i[a]</code>等同于<code>*(i + a)</code>，也就是<code>*(a + i)</code>。而<code>*(a + i)</code>也就是<code>a[i]</code>。</p>
<hr>
<h2 id="第十四章-预处理器"><a class="header-anchor" href="#第十四章-预处理器">¶</a>第十四章 预处理器</h2>
<h3 id="14-3-宏定义"><a class="header-anchor" href="#14-3-宏定义">¶</a>14.3 宏定义</h3>
<h4 id="14-3-1简单的宏（P228）"><a class="header-anchor" href="#14-3-1简单的宏（P228）">¶</a>14.3.1简单的宏（P228）</h4>
<p>  不要在宏定义中放置任何额外的符号，否则它们会被作为替换列表的一部分。一种常见的错误是在宏定义中使用<code>=</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N = 100 <span class="hljs-comment">/* WRONG */</span></span><br>...<br><span class="hljs-keyword">int</span> a[N]; <span class="hljs-comment">/*becomes int a[= 100] */</span><br></code></pre></div></td></tr></table></figure>
<h4 id="14-3-2带参数的宏（P229）"><a class="header-anchor" href="#14-3-2带参数的宏（P229）">¶</a>14.3.2带参数的宏（P229）</h4>
<ol>
<li>带参数的宏（也称为函数式宏）的定义有如下格式：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> 标识符(x1, x2, ..., xn) 替换列表</span><br></code></pre></div></td></tr></table></figure>
<p>  在宏的名字和左括号之间必须没有空格。如果有空格，预处理器会认为是在定义一个简单的宏，其中<code>(x1, x2, ..., xn)</code>是替换列表的一部分。</p>
<p>2. 使用带参数的宏替代真正的函数有两个优点：</p>
<ul>
<li>
<p>程序可能会稍微快些。程序执行时调用函数通常会有些额外的开销——存储上下文信息、复制参数的值等，而调用宏则没有这些运行开销。（注意，C99的内联函数为我们提供了一种不使用宏而避免这一开销的办法。）</p>
</li>
<li>
<p>宏更“通用”。与函数的参数不同，宏的参数没有类型。因此，只要预处理后的程序依然是合法的，宏可以接受任何类型的参数。例如，我们可以使用<code>MAX</code>宏从两个数中选出较大的一个，数的类型可以是<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>等。<br>
3. 但是带参数的宏也有一些缺点：</p>
</li>
<li>
<p>编译后的代码通常会变大。</p>
</li>
<li>
<p>宏参数没有类型检查。</p>
</li>
<li>
<p>无法用一个指针来指向一个宏。</p>
</li>
<li>
<p>宏可能会不止一次地计算它的参数。考虑下面的例子，其中<code>MAX</code>的一个参数有副作用：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">n = MAX(i++, j);<br></code></pre></div></td></tr></table></figure>
<p>  下面是这条语句在预处理之后的结果：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">n = ((i++)&gt;(j)?(i++):(j));<br></code></pre></div></td></tr></table></figure>
<p>  如果<code>i</code>大于<code>j</code>，那么<code>i</code>可能会被（错误地）增加两次，同时<code>n</code>可能被赋予错误的值。</p>
<h4 id="14-3-3-运算符（P231）"><a class="header-anchor" href="#14-3-3-运算符（P231）">¶</a>14.3.3 <code>#</code>运算符（P231）</h4>
<p>  <code>#</code>运算符将宏的一个参数转换为字符串字面量。它仅允许出现在带参数的宏的替换列表中。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PRINT_INT(n) printf(#n <span class="hljs-meta-string">" = %d\n"</span>, n)</span><br></code></pre></div></td></tr></table></figure>
<p>  调用</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">PRINT_INT(i/j);<br></code></pre></div></td></tr></table></figure>
<p>  会变为：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"i/j"</span> <span class="hljs-string">" = %d\n"</span>, i/j);<br></code></pre></div></td></tr></table></figure>
<h4 id="14-3-4-运算符（P231）"><a class="header-anchor" href="#14-3-4-运算符（P231）">¶</a>14.3.4 ##运算符（P231）</h4>
<ol>
<li><code>##</code>运算符被称为“记号粘合”。</li>
<li><code>##</code>运算符可以将两个记号（如标识符）“粘合”在一起，成为一个记号。如果其中一个操作数是宏参数，“粘合”会在形式参数被相应的实际参数替换后发生。考虑下面的宏：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MK_ID(n) i##n</span><br></code></pre></div></td></tr></table></figure>
<p>  当<code>MK_ID</code>被调用时（比如<code>MK_ID(1)</code>），预处理器首先使用实际参数（这个例子中是1）替换形式参数<code>n</code>。接着，预处理器将i和1合并成为一个记号（i1）。下面的声明使用<code>MK_ID</code>创建了3个标识符：</p>
<figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">int MK_ID(1), MK_ID(2), MK_ID(3);<br></code></pre></div></td></tr></table></figure>
<p>  预处理后这一声明变为：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">int</span> i1, i2, i3;<br></code></pre></div></td></tr></table></figure>
<p>3. 使用宏实现泛型：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GENERIC_MAX(type) \</span><br> <br>type type##_max(type x , type y) \<br>&#123; \<br>    <span class="hljs-keyword">return</span> x &gt; y ? x : y; \<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>4. C11标准泛型（使用<code>_Generic</code>宏）：<br>
  <code>_Generic(表达式,类型匹配列表,default: 默认表达式)</code>，如</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GENERAL_ABS(x) _Generic((x), int:abs, float:fabsf, double:fabs)(x)</span><br> <br>GENERAL_ABS(<span class="hljs-number">-12</span>); <span class="hljs-comment">//将被展开为abs(-12)</span><br> <br>GENERAL_ABS(<span class="hljs-number">-12.04</span>); <span class="hljs-comment">//将被展开为fabsf(-12.04)</span><br> <br>GENERAL_ABS(<span class="hljs-number">-13.09876</span>); <span class="hljs-comment">//将被展开为fabs(-13.09876)</span><br></code></pre></div></td></tr></table></figure>
<h4 id="14-3-5宏的通用属性（P232）"><a class="header-anchor" href="#14-3-5宏的通用属性（P232）">¶</a>14.3.5宏的通用属性（P232）</h4>
<p>  宏定义的作用范围通常到出现这个宏的文件末尾。由于宏是由预处理器处理的，<font color=red><strong>它们不遵从通常的作用域规则。定义在函数中的宏并不是仅在函数内起作用，而是作用到文件末尾</strong></font>。</p>
<h4 id="14-3-6宏定义中的圆括号（P233）"><a class="header-anchor" href="#14-3-6宏定义中的圆括号（P233）">¶</a>14.3.6宏定义中的圆括号（P233）</h4>
<p>  一个宏定义中加圆括号的规则：</p>
<blockquote>
<p><font color=red><strong>如果宏的替换列表中有运算符，那么将替换列表放在圆括号中。</strong></font></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TWO_PI (2 * 3.14159)</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><font color=red><strong>如果宏有参数，每个参数每次在替换列表中出现时都要放在圆括号中。</strong></font></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SCALE(x) ((x) * 10)</span><br></code></pre></div></td></tr></table></figure>
<h4 id="14-3-10空的宏参数（P236）"><a class="header-anchor" href="#14-3-10空的宏参数（P236）">¶</a>14.3.10空的宏参数（P236）</h4>
<ol>
<li>C99允许宏调用中的任意或所有参数为空。当然这样的调用需要有和一般调用一样的多逗号（这样容易看出哪些参数被省略了）。如</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ADD(x, y) (x + y)</span><br></code></pre></div></td></tr></table></figure>
<p>  经过预处理之后，语句</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">i = ADD(j, k);<br></code></pre></div></td></tr></table></figure>
<p>  变成</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">i = (j + k);<br></code></pre></div></td></tr></table></figure>
<p>  而赋值语句</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">i = ADD(,k);<br></code></pre></div></td></tr></table></figure>
<p>  则变为</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">i = (+k);<br></code></pre></div></td></tr></table></figure>
<p>2. 当空参数是<code>#</code>或<code>##</code>运算符的操作数时，用法有特殊规定。</p>
<ul>
<li>如果空的实际参数被#运算符“字符串化”，则结果为<code>&quot;&quot;</code>（空字符串）。</li>
<li>如果<code>##</code>运算符之后的一个实际参数为空，它将会被不可见的“位置标记”记号代替。把原始的记号与位置标记记号相连接，得到的还是原始的记号（位置记号消失了）。如果连接两个位置标记记号，得到的是一个位置标记记号。宏扩展完成后，位置标记记号从程序中消失。</li>
</ul>
<h4 id="14-3-11参数个数可变的宏（P237）"><a class="header-anchor" href="#14-3-11参数个数可变的宏（P237）">¶</a>14.3.11参数个数可变的宏（P237）</h4>
<p>  例子：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEST(condition, ...) ((condition)?\</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Passed test:%s\n"</span>, #condition): \<br>    <span class="hljs-built_in">printf</span>(__VA_ARGS__))<br><br>TEST(voltage &lt;= max_voltage,<br>        <span class="hljs-string">"Voltage %d exceeds %d\n"</span>, voltage, max_voltage);<br></code></pre></div></td></tr></table></figure>
<h4 id="14-3-12-func-标识符（P237）"><a class="header-anchor" href="#14-3-12-func-标识符（P237）">¶</a>14.3.12 <code>__func__</code>标识符（P237）</h4>
<p>  其作用相当于在函数体的一开始包含如下声明：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __func__[] = <span class="hljs-string">"function_name"</span>;<br></code></pre></div></td></tr></table></figure>
<h3 id="14-5-宏定义"><a class="header-anchor" href="#14-5-宏定义">¶</a>14.5 宏定义</h3>
<h4 id="14-5-1-error指令（P241）"><a class="header-anchor" href="#14-5-1-error指令（P241）">¶</a>14.5.1 <code>#error</code>指令（P241）</h4>
<p>  遇到<code>#error</code>指令预示着程序中出现了严重的错误，有些编译器会立即终止编译而不再检查其它错误。使用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> INT_MAX &lt; 100000</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">error</span> int type is too small</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<h3 id="第十四章FAQ（P243）"><a class="header-anchor" href="#第十四章FAQ（P243）">¶</a>第十四章FAQ（P243）</h3>
<ol>
<li><code>#</code>单独占一行为空指令，它没有任何作用。一些程序员用空指令作为条件编译模块之间的间隔：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> INT_MAX &lt; 100000</span><br>#<br><span class="hljs-meta">#<span class="hljs-meta-keyword">error</span> int type is too small</span><br>#<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<p>2. 建议在下面的条件下使用宏来替代字符或字符串字面量：</p>
<ul>
<li>常量不止一次地使用。</li>
<li>以后可能需要修改常量。</li>
</ul>
<p>3. 如果要被“字符串化”的参数包含&quot;或\字符，#运算符会将&quot;转换为\&quot;，\转换为\\。<br>
4. <font color=red><strong>替换列表中依赖##的宏通常不能嵌套调用</strong></font>。<br>
5. 在执行预处理指令前，先处理注释，并把源代码分为多个预处理记号。因此，<code>#if</code>和<code>#endif</code>之间的未终止的注释引起错误消息。此外，不成对的单引号或双引号字符也可能导致未定义的行为。</p>
<hr>
<h2 id="第十五章-编写大型程序"><a class="header-anchor" href="#第十五章-编写大型程序">¶</a>第十五章 编写大型程序</h2>
<h3 id="15-2-头文件"><a class="header-anchor" href="#15-2-头文件">¶</a>15.2 头文件</h3>
<h4 id="15-2-6-保护头文件（P253）"><a class="header-anchor" href="#15-2-6-保护头文件（P253）">¶</a>15.2.6 保护头文件（P253）</h4>
<p>  如果文件只包含宏定义、函数原型和/或变量声明，那么不会有任何困难。然而，<font color=red><strong>如果文件包含类型定义，则会带来编译错误</strong></font>。为防止头文件多次包含，用<code>#ifndef</code>和<code>#endif</code>指令来封闭文件的内容。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> BOOLEAN_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOOLEAN_H</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Bool;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure>
<h3 id="第十五章FAQ（P265）"><a class="header-anchor" href="#第十五章FAQ（P265）">¶</a>第十五章FAQ（P265）</h3>
<p>  共享数组应该按照下列方式声明：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> a[];<br></code></pre></div></td></tr></table></figure>
<p>  <font color=red><strong>但用下列写法代替是不合法的</strong></font>：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> *a;<br></code></pre></div></td></tr></table></figure>
<p>  虽然<font color=red><strong>在用于表达式时，数组“衰退”成指针</strong></font>。但在变量声明中，数组和指针是截然不同的两种类型。</p>
<hr>
<h2 id="第十六章-结构、联合和枚举"><a class="header-anchor" href="#第十六章-结构、联合和枚举">¶</a>第十六章 结构、联合和枚举</h2>
<h3 id="16-1-结构变量"><a class="header-anchor" href="#16-1-结构变量">¶</a>16.1 结构变量</h3>
<h4 id="16-1-1结构变量的声明（P267）"><a class="header-anchor" href="#16-1-1结构变量的声明（P267）">¶</a>16.1.1结构变量的声明（P267）</h4>
<p>  结构的成员在内存中是按照声明的顺序存储的。</p>
<h4 id="16-1-3指定初始化（P269）"><a class="header-anchor" href="#16-1-3指定初始化（P269）">¶</a>16.1.3指定初始化（P269）</h4>
<p>  示例：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">&#123;.number = <span class="hljs-number">528</span>, <span class="hljs-string">"Disk drive"</span>, .on_hand = <span class="hljs-number">10</span>&#125;<br></code></pre></div></td></tr></table></figure>
<p>  值<code>&quot;Disk drive&quot;</code>的前面并没有指示符，<font color=red><strong>所以编译器会认为它用于初始化结构中位于<code>number</code>之后的成员。初始化式中没有涉及的成员都设为0</strong></font>。</p>
<h4 id="16-1-4对结构的操作（P270）"><a class="header-anchor" href="#16-1-4对结构的操作（P270）">¶</a>16.1.4对结构的操作（P270）</h4>
<ol>
<li>结构可以用<code>=</code>运算符复制。<font color=red><strong>对结构进行复制时，嵌在结构内的数组也得到了复制</strong></font>。一些程序员利用这种性质来产生“空”结构，以封装稍候将进行复制的数组：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>]; &#125; a1, a2;<br> <br>a1 = a2; <span class="hljs-comment">/* legal, since a1 and a2 are structures */</span><br></code></pre></div></td></tr></table></figure>
<p>2. <font color=red><strong>不能使用运算符<code>==</code>和<code>!=</code>来判定两个结构相等还是不等</strong></font>。</p>
<h3 id="16-3-嵌套的数组和结构"><a class="header-anchor" href="#16-3-嵌套的数组和结构">¶</a>16.3 嵌套的数组和结构</h3>
<h4 id="16-3-3结构数组的初始化（P275）"><a class="header-anchor" href="#16-3-3结构数组的初始化（P275）">¶</a>16.3.3结构数组的初始化（P275）</h4>
<p>  可以有如下初始方式：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">part</span> <span class="hljs-title">inventory</span>[100] = &#123;</span>[<span class="hljs-number">0</span>].number = <span class="hljs-number">528</span>, [<span class="hljs-number">0</span>].on_hand = <span class="hljs-number">10</span>, [<span class="hljs-number">0</span>].name[<span class="hljs-number">0</span>] = <span class="hljs-string">'\0'</span>&#125;;<br></code></pre></div></td></tr></table></figure>
<h3 id="第十六章FAQ（P288）"><a class="header-anchor" href="#第十六章FAQ（P288）">¶</a>第十六章FAQ（P288）</h3>
<ol>
<li>对于在不同文件中定义的结构来说，如果<font color=red><strong>它们的成员具有同样的名字并且顺序一样，且标记相同</strong></font>，那么它们是兼容的，相应的成员类型也是兼容的。<font color=red><strong>具有兼容类型的变量可以互相赋值</strong></font>。</li>
<li>枚举常量的值可以用作下标。</li>
</ol>
<h2 id="第十七章-指针的高级应用"><a class="header-anchor" href="#第十七章-指针的高级应用">¶</a>第十七章 指针的高级应用</h2>
<h3 id="17-3-动态分配数组"><a class="header-anchor" href="#17-3-动态分配数组">¶</a>17.3 动态分配数组</h3>
<h4 id="17-3-2-calloc函数（P300）"><a class="header-anchor" href="#17-3-2-calloc函数（P300）">¶</a>17.3.2 <code>calloc</code>函数（P300）</h4>
<p>  <code>calloc</code>函数会将内存初始化为0，<code>malloc</code>、<code>realloc</code>函数不会。</p>
<h3 id="17-4-释放存储空间"><a class="header-anchor" href="#17-4-释放存储空间">¶</a>17.4 释放存储空间</h3>
<h4 id="17-4-1-free函数（P301）"><a class="header-anchor" href="#17-4-1-free函数（P301）">¶</a>17.4.1 <code>free</code>函数（P301）</h4>
<p>  <font color=red><strong><code>free</code>函数参数可以是空指针，此时<code>free</code>调用不起作用</strong></font>。</p>
<h3 id="17-7-指向函数的指针"><a class="header-anchor" href="#17-7-指向函数的指针">¶</a>17.7 指向函数的指针</h3>
<h4 id="17-7-1函数指针作为参数（P314）"><a class="header-anchor" href="#17-7-1函数指针作为参数（P314）">¶</a>17.7.1函数指针作为参数（P314）</h4>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">integrate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> (*f)(<span class="hljs-keyword">double</span>), <span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>  等同于</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">integrate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> f(<span class="hljs-keyword">double</span>), <span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span></span>;<br></code></pre></div></td></tr></table></figure>
<h3 id="17-8受限指针（P318）"><a class="header-anchor" href="#17-8受限指针（P318）">¶</a>17.8受限指针（P318）</h3>
<p>  如果指针<code>p</code>指向的对象在之后需要修改，那么该对象不会允许通过除指针<code>p</code>之外的任何方式访问（其它访问对象的方式包括让另一个指针指向同一个对象，或者让指针<code>p</code>指向命名变量）。</p>
<h3 id="第十七章FAQ（P322）"><a class="header-anchor" href="#第十七章FAQ（P322）">¶</a>第十七章FAQ（P322）</h3>
<ol>
<li>两个结构都含有指向对方的指针成员的情况：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s1</span>;</span> <span class="hljs-comment">/* incomplete declaration of s1 */</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s2</span> &#123;</span><br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s1</span> *<span class="hljs-title">p</span>;</span><br>    ...<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s1</span> &#123;</span><br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s2</span> *<span class="hljs-title">p</span>;</span><br>    ...<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>  <code>s1</code>的第一处声明创建了一个不完整的结构类型，因为我们没有指明s1的成员。`s1的第二处声明通过描述结构的成员“完善”了该类型。</p>
<p>2. 存在惯用法：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">p = <span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(*p));<br></code></pre></div></td></tr></table></figure>
<p>  可以避免用错误的参数调用<code>malloc</code>函数（导致分配的内存过大或过小）。因为<code>sizeof</code>并不对<code>*p</code>求值，所以此用法合法。</p>
<h2 id="第十八章-声明"><a class="header-anchor" href="#第十八章-声明">¶</a>第十八章 声明</h2>
<h3 id="18-2-存储类型"><a class="header-anchor" href="#18-2-存储类型">¶</a>18.2 存储类型</h3>
<h4 id="18-2-1变量的性质（P329）"><a class="header-anchor" href="#18-2-1变量的性质（P329）">¶</a>18.2.1变量的性质（P329）</h4>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">       <span class="hljs-comment">//|----静态存储期限</span><br><span class="hljs-keyword">int</span> i; <span class="hljs-comment">//+----文件作用域</span><br>       <span class="hljs-comment">//|----外部链接</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>           <span class="hljs-comment">//|-----自动存储期限</span><br>    <span class="hljs-keyword">int</span> j; <span class="hljs-comment">//+-----块作用域</span><br>           <span class="hljs-comment">//|------无链接</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="18-2-2-auto存储类型（P329）"><a class="header-anchor" href="#18-2-2-auto存储类型（P329）">¶</a>18.2.2 auto存储类型（P329）</h4>
<p>  <code>auto</code>存储类型只对属于块的变量有效。<code>auto</code>存储类型几乎从来不用明确地指明，因为对于在块内部声明的变量，它是默认的。</p>
<h4 id="18-2-3-static存储类型（P329）"><a class="header-anchor" href="#18-2-3-static存储类型（P329）">¶</a>18.2.3 <code>static</code>存储类型（P329）</h4>
<p>1.</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">              <span class="hljs-comment">//|----静态存储期限</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i; <span class="hljs-comment">//+----文件作用域</span><br>              <span class="hljs-comment">//|----**内部**链接</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>                  <span class="hljs-comment">//|-----**静态**存储期限</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j; <span class="hljs-comment">//+-----块作用域</span><br>                  <span class="hljs-comment">//|------无链接</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<div class="hljs code-wrapper"><pre><code>`static`的此种用法可以用来实现一种称为信息隐藏的技术。
</code></pre></div>
<p>2. <code>static</code>变量具有以下一些有趣的性质：</p>
<ul>
<li>块内的<code>static</code>变量只在程序执行前进行一次初始化，而<code>auto</code>变量则会在每次出现时进行初始化（当然，需假设它有初始化式）。</li>
<li><font color=red><strong>每次函数被递归调用时，它都会获得一组新的<code>auto</code>变量。但是，如果函数含有<code>static</code>变量，那么此函数的全部调用都可以共享这个<code>static</code>变量</strong></font>。</li>
<li><font color=red><strong>虽然函数不应该返回指向<code>auto</code>变量的指针，但是函数返回指向<code>static</code>变量的指针是没有错误的</strong></font>。</li>
</ul>
<h4 id="18-2-4-extern存储类型（P330）"><a class="header-anchor" href="#18-2-4-extern存储类型（P330）">¶</a>18.2.4 <code>extern</code>存储类型（P330）</h4>
<p>1. 变量是<code>extern</code>声明不是定义这一规则有一个例外：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>
<p>  这条规则可以防止多个<code>extern</code>声明用不同方法对变量进行初始化。<br>
2.</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">              <span class="hljs-comment">//|----静态存储期限</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> i; <span class="hljs-comment">//+----文件作用域</span><br>              <span class="hljs-comment">//|     |----在文件较早的位置（任何函数定义的外部）声明为static，那么它具有内部链接</span><br>              <span class="hljs-comment">//|-----+</span><br>              <span class="hljs-comment">//      |----通常情况下为外部链接</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>                  <span class="hljs-comment">//|-----静态存储期限</span><br>    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> j; <span class="hljs-comment">//+-----块作用域</span><br>                  <span class="hljs-comment">//|-----通常情况下为外部链接</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="18-2-5-register存储类型（P331）"><a class="header-anchor" href="#18-2-5-register存储类型（P331）">¶</a>18.2.5 <code>register</code>存储类型（P331）</h4>
<ol>
<li>指明变量的存储类型是<code>register</code>是一种请求，而不是命令。编译器可以选择把<code>register</code>型变量存储在内存中。</li>
<li>由于寄存器没有地址，所以对<code>register</code>变量使用取地址运算符<code>&amp;</code>是非法的。即使编译器选择把变量存储在内存中，这一限制仍适用。</li>
<li><code>register</code>存储类型最好用于需要频繁进行访问或更新的变量。例如，在<code>for</code>语句中的循环控制变量就比较适合声明为<code>register</code>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum_array</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        sum += a[i];<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="18-4-声明符"><a class="header-anchor" href="#18-4-声明符">¶</a>18.4 声明符</h3>
<h4 id="18-4-1解释复杂声明（P335）"><a class="header-anchor" href="#18-4-1解释复杂声明（P335）">¶</a>18.4.1解释复杂声明（P335）</h4>
<p>  下面两条简单的规则可以用来理解任何声明：</p>
<ul>
<li>始终从内往外读声明符。</li>
<li>在作选择时，始终使<code>[]</code>和<code>()</code>优先于<code>*</code>。</li>
</ul>
<h3 id="18-5初始化式（P337）"><a class="header-anchor" href="#18-5初始化式（P337）">¶</a>18.5初始化式（P337）</h3>
<ol>
<li>控制初始化式的额外规则：</li>
</ol>
<ul>
<li>具有静态存储期限的变量的初始化式必须是常量。</li>
<li>自动存储期限的变量的初始化式不需要是常量。</li>
<li>仅当变量具有静态存储期限时，包含在花括号中的数组、结构或联合的初始化式必须只包含常量表达式，不允许有变量或函数调用。</li>
</ul>
<p>2. 变量的初始化值依赖于变量的存储期限：</p>
<ul>
<li><font color=red><strong>具有自动存储期限的变量没有默认的初始值。不能预测自动变量的初始值，而且每次变量变为有效时值可能不同</strong></font>。</li>
<li>具有静态存储期限的变量默认情况下值为零。用<code>calloc</code>分配的内存是简单的给字节位置零，而静态变量不同于此，它是基于类型的正确初始化，即整型变量初始化为0，浮点变量初始化为0.0，而指针则初始化为空指针。</li>
</ul>
<h3 id="18-6内联函数（P339，本节内容来自C语言inline详细讲解）"><a class="header-anchor" href="#18-6内联函数（P339，本节内容来自C语言inline详细讲解）">¶</a>18.6内联函数（P339，本节内容来自<a href="http://www.cnblogs.com/cnmaizi/archive/2011/01/19/1939686.html" target="_blank" rel="noopener">C语言<code>inline</code>详细讲解</a>）</h3>
<ol>
<li><code>static inline</code>（GCC和C99标准一致）：这个函数大部分表现和普通的<code>static</code>函数一样，只不过在调用这种函数的时候，gcc会在其调用处将其汇编码展开编译而不为这个函数生成独立的汇编码。除了以下几种情况外：</li>
</ol>
<ul>
<li>函数的地址被使用的时候。如通过函数指针对函数进行了间接调用。这种情况下就不得不为<code>static inline</code>函数生成独立的汇编码，否则它没有自己的地址。</li>
<li>其他一些无法展开的情况，比如函数本身有递归调用自身的行为等。</li>
</ul>
<p>2. <code>inline</code>（GCC）：相对于C99的<code>inline</code>来说，GCC的<code>inline</code>更容易理解：可以认为它是一个普通全局函数加上了<code>inline</code>的属性。即在其定义所在文件内，它的表现和<code>static inline</code>一致：在能展开的时候会被内联展开编译。但是为了能够在文件外调用它，gcc一定会为它生成一份独立的汇编码，以便在外部进行调用。即从文件外部看来，它和一个普通的<code>extern</code>的函数无异。<br>
3. <code>extern inline</code>（GCC）：gcc的<code>extern inline</code>十分古怪：一个<code>extern inline</code>的函数只会被内联进去，而绝对不会生成独立的汇编码！即使是通过指针应用或者是递归调用也不会让编译器为它生成汇编码，在这种时候对此函数的调用会被处理成一个外部引用。另外，<code>extern inline</code>的函数允许和外部函数重名，即在存在一个外部定义的全局库函数的情况下，再定义一个同名的<code>extern inline</code>函数也是合法的。以下用例子具体说明一下<code>extern inline</code>的特点：</p>
<p>foo.c:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> -a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br>    a = foo(a);   <span class="hljs-comment">/* ① */</span><br>    p_foo = foo;  <span class="hljs-comment">/* ② */</span><br>    b = p_foo(b); <span class="hljs-comment">/* ③ */</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>  在这个文件内，gcc不会生成<code>foo</code>函数的汇编码。在<code>func1</code>中的调用点①，编译器会将上面定义的<code>foo</code>函数数在这里内联展开编译，其表现类似于普通<code>inline</code>函数。因为这样的调用是能够进行内联处理的。而在②处，引用了<code>foo</code>函数的地址。但是注意：编译器是绝对不会为<code>extern inline</code>函数生成独立汇编码的！所以在这种非要个函数地址不可的情况下，编译器不得不将其处理为外部引用，在链接的时候链接到外部的<code>foo</code>函数去（填写外部函数的地址）。这时如果外部没有再定义全局的<code>foo</code>函数的话就会在链接时产生<code>foo</code>函数未定义的错误。<br>
假设在另一个文件里面也定义了一个全局函数<code>foo</code>：</p>
<p>foo2.c:</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>  那么在上面那个例子里面，后面一个对<code>foo</code>函数地址的引用就会在链接时被指到这个foo2.c中定义的<code>foo</code>函数去。也就是说：①调用<code>foo</code>函数的结果是<code>a = -a</code>，因为其内联了foo.c内的<code>foo</code>函数；而③调用的结果则是<code>b = b</code>，因为其实际上调用的是foo2.c里面的<code>foo</code>函数！<br>
  gcc的<code>extern inline</code>函数的用法相当奇怪，使用的范围也非常狭窄：几乎没有什么情况会需要用它。 C99中，也没有关于<code>extern inline</code>这样的描述，所以不建议大家使用<code>extern inline</code>，除非你明确理解了这种用法的意义并且有充足的理由使用它！</p>
<p>4. <code>inline</code>（C99标准）：如果一个inline函数在文件范围内没有被声明为<code>extern</code>的话，这个函数在文件内的表现就和gcc的<code>extern inline</code>相似：在本文件内调用时允许编译器使用本文件内定义的这个内联版本，但同时也允许外部存在同名的全局函数。只是比较奇怪的是C99居然没有指定编译器是否必须在本文件内使用这个<code>inline</code>的版本而是让编译器厂家自己来决定，相当模糊的定义。<br>
  <font color=red><strong>如果在文件内把这个<code>inline</code>函数声明为<code>extern</code>，则这个<code>inline</code>函数的表现就和gcc的<code>inline</code>一致了：这个函数即成为一个“external definition”（可以简单理解为全局函数）：可以在外部被调用，并且在程序内仅能存在一个这样名字的定义。</strong></font></p>
<p>5. <code>extern inline</code>（C99标准）：C99标准没有见到<code>extern inline</code>的用法。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>C</tag>
      </tags>
  </entry>
</search>
