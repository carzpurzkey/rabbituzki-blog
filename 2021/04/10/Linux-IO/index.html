

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicon.ico">
  <link rel="icon" type="image/png" href="/images/favicon.ico">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="When in doubt, use brute force.">
  <meta name="author" content="Rabbituzki">
  <meta name="keywords" content="">
  <title>Linux I/O 模式及 select、poll 和 epoll 详解 - Rabbituzki 的笔记们</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/gruvbox-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"blog.rabbituzki.com.cn","root":"/","version":"1.8.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"❡"},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":true,"baidu":"a9b0666290f750544a1900dff36c0349","google":"UA-127726236-2","gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"TMgxzCpM2zFnsClsMHJY2LLc-gzGzoHsz","app_key":"1kPLieLtoBQWf0w6iNxLqkMV","server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Rabbituzki 的笔记们</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/images/background1.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Linux I/O 模式及 select、poll 和 epoll 详解">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-10 00:00" pubdate>
        2021年4月10日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      79
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Linux I/O 模式及 select、poll 和 epoll 详解</h1>
            
            <div class="markdown-body">
              <p>同步 I/O 和异步 I/O，阻塞 I/O 和非阻塞 I/O 分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。</p>
<blockquote>
<p>注意：</p>
<hr>
<p>本文讨论的背景是 Linux 环境下的网络 I/O。</p>
</blockquote>
<h2 id="一、概念说明"><a class="header-anchor" href="#一、概念说明">¶</a>一、概念说明</h2>
<p>在进行解释之前，首先要说明几个概念：</p>
<ul>
<li>用户空间和内核空间</li>
<li>进程切换</li>
<li>进程的阻塞</li>
<li>文件描述符</li>
<li>缓存 I/O</li>
</ul>
<h3 id="1-用户空间与内核空间"><a class="header-anchor" href="#1-用户空间与内核空间">¶</a>1. 用户空间与内核空间</h3>
<p>现在操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对 Linux 操作系统而言，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，而将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<h3 id="2-进程切换"><a class="header-anchor" href="#2-进程切换">¶</a>2. 进程切换</h3>
<p>为了控制进程的执行，内核必须有能力挂起正在 CPU 上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新 PCB 信息。</li>
<li>把进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其 PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理机上下文。</li>
</ol>
<blockquote>
<p>注：总而言之就是很耗资源，具体的可以参考这篇文章：<a href="http://guojing.me/linux-kernel-architecture/posts/process-switch/" target="_blank" rel="noopener">进程切换</a>。</p>
</blockquote>
<h3 id="3-进程的阻塞"><a class="header-anchor" href="#3-进程的阻塞">¶</a>3. 进程的阻塞</h3>
<p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语（block），使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<strong>当进程进入阻塞状态，是不占用CPU资源的</strong>。</p>
<h3 id="4-文件描述符-fd"><a class="header-anchor" href="#4-文件描述符-fd">¶</a>4. 文件描述符 <code>fd</code></h3>
<p>文件描述符（file descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。<br>
文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</p>
<h3 id="5-缓存-I-O"><a class="header-anchor" href="#5-缓存-I-O">¶</a>5. 缓存 I/O</h3>
<p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（page cache）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<blockquote>
<p>缓存 I/O 的缺点：</p>
<hr>
<p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
</blockquote>
<h2 id="二、I-O-模式"><a class="header-anchor" href="#二、I-O-模式">¶</a>二、I/O 模式</h2>
<p>刚才说了，对于一次 I/O 访问（以 <code>read</code> 举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个 <code>read</code> 操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p>正式因为这两个阶段，Linux 系统产生了下面五种网络模式的方案。</p>
<ul>
<li>阻塞 I/O（blocking I/O）</li>
<li>非阻塞 I/O（nonblocking I/O）</li>
<li>I/O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I/O（ signal driven I/O）</li>
<li>异步 I/O（asynchronous I/O）</li>
</ul>
<blockquote>
<p>注：由于 signal driven I/O 在实际中并不常用，所以我这只提及剩下的四种 I/O 模式。</p>
</blockquote>
<h3 id="1-阻塞-I-O（blocking-IO）"><a class="header-anchor" href="#1-阻塞-I-O（blocking-IO）">¶</a>1. 阻塞 I/O（blocking IO）</h3>
<p>在 Linux 中，默认情况下所有的 socket 都是阻塞的，一个典型的读操作流程大概是这样：</p>
<p><img src="https://blog-1255671825.cos.ap-beijing-fsi.myqcloud.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/Linux-IO/1.png" alt="2.1"></p>
<p>当用户进程调用了 <code>recvfrom</code> 这个系统调用，内核就开始了 I/O 的第一个阶段：准备数据（对于网络 I/O 来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的 UDP 包。这个时候内核就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当内核一直等到数据准备好了，它就会将数据从内核中拷贝到用户内存，然后内核返回结果，用户进程才解除阻塞的状态，重新运行起来。</p>
<blockquote>
<p>所以，阻塞 I/O 的特点就是在 I/O 执行的两个阶段都被阻塞了。</p>
</blockquote>
<h3 id="2-非阻塞-I-O（nonblocking-IO）"><a class="header-anchor" href="#2-非阻塞-I-O（nonblocking-IO）">¶</a>2. 非阻塞 I/O（nonblocking IO）</h3>
<p>Linux 下，可以通过设置 socket 使其变为非阻塞的。当对一个非阻塞 socket 执行读操作时，流程是这个样子：</p>
<p><img src="https://blog-1255671825.cos.ap-beijing-fsi.myqcloud.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/Linux-IO/2.png" alt="2.2"></p>
<p>当用户进程发出 <code>read</code> 操作时，如果内核中的数据还没有准备好，那么它并不会阻塞用户进程，而是立刻返回一个 error。从用户进程角度讲 ，它发起一个 <code>read</code> 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 <code>read</code> 操作。一旦内核中的数据准备好了，并且又再次收到了用户进程的系统调用，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<blockquote>
<p>所以，非阻塞 I/O 的特点是用户进程需要<strong>不断的主动询问</strong>内核数据好了没有。</p>
</blockquote>
<h3 id="3-I-O-多路复用（I-O-multiplexing）"><a class="header-anchor" href="#3-I-O-多路复用（I-O-multiplexing）">¶</a>3. I/O 多路复用（I/O multiplexing）</h3>
<p>I/O 多路复用就是我们说的 <code>select</code>、<code>poll</code> 和 <code>epoll</code>，有些地方也称这种 I/O 方式为事件驱动 I/O（event driven I/O）。<code>select</code>/<code>epoll</code> 的好处就在于单个进程就可以同时处理多个网络连接的 I/O。它的基本原理就是 <code>select</code><br>
<code>poll</code> 和 <code>epoll</code> 这三个函数会不断的轮询所负责的所有 socket，当某 个socket 有数据到达了，就通知用户进程。</p>
<p><img src="https://blog-1255671825.cos.ap-beijing-fsi.myqcloud.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/Linux-IO/3.png" alt="2.3"></p>
<p><strong>当用户进程调用了 <code>select</code>，那么整个进程会被阻塞</strong>，而同时，内核会“监视”所有 <code>select</code> 负责的 socket，当任何一个 socket 中的数据准备好了，<code>select</code> 就会返回。这个时候用户进程再调用 <code>read</code> 操作，将数据从内核拷贝到用户进程。</p>
<blockquote>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，<code>select()</code> 函数就可以返回。</p>
</blockquote>
<p>这个图和阻塞 I/O 的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个系统调用（<code>select</code> 和 <code>recvfrom</code>），而阻塞 I/O 只调用了一个系统调用（<code>recvfrom</code>）。但是，用 <code>select</code> 的优势在于它可以同时处理多个连接。</p>
<p>所以，如果处理的连接数不是很高的话，使用 <code>select</code>/<code>epoll</code> 的 Web 服务器不一定比使用多线程 + 阻塞 I/O 的 Web 服务器性能更好，可能延迟还更大。<code>select</code>/<code>epoll</code> 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
<p>在 I/O 多路复用模式中，实际中，对于每一个 socket，一般都设置成为非阻塞的，但是，如上图所示，整个用户的进程其实是一直被阻塞的。只不过进程是被 <code>select</code> 这个函数阻塞，而不是被 socket I/O 给阻塞的。</p>
<h3 id="4-异步-I-O（asynchronous-IO）"><a class="header-anchor" href="#4-异步-I-O（asynchronous-IO）">¶</a>4. 异步 I/O（asynchronous IO）</h3>
<p>Linux下的异步 I/O 其实用得很少。先看一下它的流程：</p>
<p><img src="https://blog-1255671825.cos.ap-beijing-fsi.myqcloud.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/Linux-IO/4.png" alt="2.4"></p>
<p>用户进程发起 <code>read</code> 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个异步 <code>read</code> 之后，首先它会立刻返回，所以不会对用户进程产生任何阻塞。然后，内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个信号量，告诉它 <code>read</code> 操作完成了。</p>
<h3 id="5-总结"><a class="header-anchor" href="#5-总结">¶</a>5. 总结</h3>
<h4 id="阻塞和非阻塞的区别"><a class="header-anchor" href="#阻塞和非阻塞的区别">¶</a>阻塞和非阻塞的区别</h4>
<p>调用阻塞 I/O 会一直阻塞住对应的进程直到操作完成，而非阻塞 I/O 在内核还准备数据的情况下会立刻返回。</p>
<h4 id="同步-I-O-和异步-IO-的区别"><a class="header-anchor" href="#同步-I-O-和异步-IO-的区别">¶</a>同步 I/O 和异步 IO 的区别</h4>
<p>在说明同步 I/O 和异步 I/O 的区别之前，需要先给出两者的定义。POSIX 的定义是这样子的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked;</li>
</ul>
<p>两者的区别就在于同步 I/O 做“I/O operation”的时候会将进程阻塞。按照这个定义，之前所述的阻塞 I/O，非阻塞 I/O，I/O 多路复用都属于同步 I/O。<br>
有人会说，非阻塞 I/O 并没有被阻塞啊。这里有个非常“狡猾”的地方，定义中所指的“I/O operation”是指真实的 I/O 操作，就是例子中的 <code>recvfrom</code> 这个系统调用。非阻塞 I/O 在执行 <code>recvfrom</code> 这系统调用的时候，如果内核的数据没有准备好，这时候不会阻塞进程。但是，当内核中数据准备好的时候，<code>recvfrom</code> 会将数据从内核拷贝到用户内存中，这个时候进程是被阻塞了，在这段时间内，进程是被阻塞的。<br>
而异步 I/O 则不一样，当进程发起 I/O 操作之后，就直接返回再也不理睬了，直到内核发送一个信号，告诉进程说 I/O 完成。在这整个过程中，进程完全没有被阻塞。<br>
各个 I/O 模式的比较如图所示：</p>
<p><img src="https://blog-1255671825.cos.ap-beijing-fsi.myqcloud.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/Linux-IO/5.png" alt="2.5.2"></p>
<p>通过上面的图片，可以发现非阻塞 I/O 和异步 I/O 的区别还是很明显的。在非阻塞 I/O 中，虽然进程大部分时间都不会被阻塞，但是它仍然要求进程去主动地检查 I/O 状态，并且当数据准备完成以后，也需要进程主动的再次调用 <code>recvfrom</code> 来将数据拷贝到用户内存。而异步 I/O 则完全不同。它就像是用户进程将整个 I/O 操作交给了他人（内核）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查 I/O 操作的状态，也不需要主动的去拷贝数据。</p>
<h2 id="三、I-O-多路复用之-select、poll-及-epoll-详解"><a class="header-anchor" href="#三、I-O-多路复用之-select、poll-及-epoll-详解">¶</a>三、I/O 多路复用之 <code>select</code>、<code>poll</code> 及 <code>epoll</code> 详解</h2>
<p><code>select</code>、<code>poll</code> 和 <code>epoll</code> 都是 I/O 多路复用的机制。I/O 多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但 <code>select</code>、<code>poll</code> 和 <code>epoll</code> 本质上都是同步 I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I/O 则无需自己负责进行读写，异步 I/O 的实现会负责把数据从内核拷贝到用户空间。（这里啰嗦下）</p>
<h3 id="1-select"><a class="header-anchor" href="#1-select">¶</a>1. <code>select</code></h3>
<figure class="highlight c"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p><code>select</code> 函数监视的文件描述符分3类，分别是 <code>writefds</code>、<code>readfds</code>、和 <code>exceptfds</code>。调用后 <code>select</code> 函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有 <code>except</code>），或者超时（<code>timeout</code> 指定等待时间，如果立即返回设为 <code>NULL</code> 即可），函数返回。当 <code>select</code> 函数返回后，可以 通过遍历 <code>fdset</code>，来找到就绪的描述符。</p>
<p><code>select</code> 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。<code>select</code> 的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 <code>1024</code>，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p>
<h3 id="2-poll"><a class="header-anchor" href="#2-poll">¶</a>2. <code>poll</code></h3>
<figure class="highlight c"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">poll</span> <span class="hljs-params">(struct pollfd *fds, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nfds, <span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></div></td></tr></table></figure>
<p>不同于 <code>select</code> 使用三个位图来表示三个 <code>fdset</code> 的方式，<code>poll</code> 使用一个 <code>pollfd</code> 的指针实现。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span><br>    <span class="hljs-keyword">int</span> fd; <span class="hljs-comment">/* file descriptor */</span><br>    short events; <span class="hljs-comment">/* requested events to watch */</span><br>    short revents; <span class="hljs-comment">/* returned events witnessed */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><code>pollfd</code> 结构包含了要监视的 <code>event</code> 和发生的 <code>event</code>，不再使用 <code>select</code> “参数-值”传递的方式。同时，<code>pollfd</code> 并没有最大数量限制（但是数量过大后性能也是会下降）。 和 <code>select</code> 函数一样，<code>poll</code> 返回后，需要轮询 <code>pollfd</code> 来获取就绪的描述符。</p>
<blockquote>
<p>从上面看，<code>select</code> 和 <code>poll</code> 都需要在返回后，<strong>通过遍历文件描述符来获取已经就绪的 socket</strong>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
</blockquote>
<h3 id="3-epoll"><a class="header-anchor" href="#3-epoll">¶</a>3. <code>epoll</code></h3>
<p><code>epoll</code> 是在 2.6 内核中提出的，是之前的 <code>select</code> 和 <code>poll</code> 的增强版本。相对于 <code>select</code> 和 <code>poll</code> 来说，<code>epoll</code> 更加灵活，没有描述符限制。<code>epoll</code> 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的拷贝只需一次。</p>
<h4 id="epoll-操作过程"><a class="header-anchor" href="#epoll-操作过程">¶</a><code>epoll</code> 操作过程</h4>
<p><code>epoll</code> 操作过程需要三个接口，分别如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大<br>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, struct epoll_event * events, <span class="hljs-keyword">int</span> maxevents, <span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></div></td></tr></table></figure>
<ol>
<li><code>int epoll_create(int size);</code><br>
创建一个 <code>epoll</code> 的句柄，<code>size</code> 用来告诉内核这个监听的数目一共有多大，这个参数不同于 <code>select()</code> 中的第一个参数，给出最大监听的 <code>fd</code> + 1 的值。</li>
</ol>
<blockquote>
<p>注意：</p>
<hr>
<p><strong>参数 <code>size</code> 并不是限制了 <code>epoll</code> 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</strong></p>
</blockquote>
<p>当创建好 <code>epoll</code> 句柄后，它就会占用一个 <code>fd</code> 值，在 linux 下如果查看 <em>/proc/进程id/fd/</em>，是能够看到这个 <code>fd</code> 的，所以在使用完 <code>epoll</code> 后，必须调用 <code>close()</code> 关闭，否则可能导致 <code>fd</code> 被耗尽。</p>
<ol start="2">
<li>
<p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code><br>
函数是对指定描述符 <code>fd</code> 执行 <code>op</code> 操作。</p>
<ul>
<li><code>epfd</code>：是 <code>epoll_create()</code> 的返回值。</li>
<li><code>op</code>：表示操作，用三个宏来表示：添加 <code>EPOLL_CTL_ADD</code>，删除 <code>EPOLL_CTL_DEL</code>，修改 <code>EPOLL_CTL_MOD</code>。分别添加、删除和修改对 <code>fd</code> 的监听事件。</li>
<li><code>fd</code>：是需要监听的 <code>fd</code>（文件描述符）</li>
<li><code>epoll_event</code>：是告诉内核需要监听什么事，<code>struct epoll_event</code> 结构如下：</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span><br>  <span class="hljs-keyword">__uint32_t</span> events;  <span class="hljs-comment">/* Epoll events */</span><br>  <span class="hljs-keyword">epoll_data_t</span> data;  <span class="hljs-comment">/* User data variable */</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p><code>events</code> 可以是以下几个宏的集合：</p>
<ul>
<li><code>EPOLLIN</code>：表示对应的文件描述符可以读（包括对端 socket 正常关闭）；</li>
<li><code>EPOLLOUT</code>：表示对应的文件描述符可以写；</li>
<li><code>EPOLLPRI</code>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li>
<li><code>EPOLLERR</code>：表示对应的文件描述符发生错误；</li>
<li><code>EPOLLHUP</code>：表示对应的文件描述符被挂断；</li>
<li><code>EPOLLET</code>： 将 <code>epoll</code> 设为边缘触发（Edge Triggered）模式，这是相对于水平触发（Level Triggered）来说的。</li>
<li><code>EPOLLONESHOT</code>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到 <code>epoll</code> 队列里。</li>
</ul>
</li>
<li>
<p><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code><br>
等待 <code>epfd</code> 上的 IO 事件，最多返回 <code>maxevents</code> 个事件。<br>
参数 <code>events</code> 用来从内核得到事件的集合，<code>maxevents</code> 告之内核这个 <code>events</code> 有多大，这个 <code>maxevents</code> 的值不能大于创建 <code>epoll_create()</code> 时的 <code>size</code>，参数<code> timeout</code> 是超时时间（毫秒，<code>0</code> 会立即返回，<code>-1</code> 将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回 <code>0</code> 表示已超时。</p>
</li>
</ol>
<h4 id="工作模式"><a class="header-anchor" href="#工作模式">¶</a>工作模式</h4>
<p><code>epoll</code> 对文件描述符的操作有两种模式：LT（level trigger）和 ET（edge trigger）。LT 模式是默认模式，LT 模式与 ET 模式的区别如下：</p>
<ul>
<li>LT模式：当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序可以不立即处理该事件</strong>。下次调用 <code>epoll_wait</code> 时，会再次响应应用程序并通知此事件。</li>
<li>ET模式：当 <code>epoll_wait</code> 检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序必须立即处理该事件</strong>。如果不处理，下次调用 <code>epoll_wait</code> 时，不会再次响应应用程序并通知此事件。</li>
</ul>
<h5 id="1-LT模式"><a class="header-anchor" href="#1-LT模式">¶</a>1. LT模式</h5>
<p>LT（level triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 <code>fd</code> 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<h5 id="2-ET模式"><a class="header-anchor" href="#2-ET模式">¶</a>2. ET模式</h5>
<p>ET（edge-triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过 <code>epoll</code> 告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了（比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个 <code>EWOULDBLOCK</code> 错误）。但是请注意，如果一直不对这个 <code>fd</code> 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。</p>
<p>ET 模式在很大程度上减少了 <code>epoll</code> 事件被重复触发的次数，因此效率要比 LT 模式高。<code>epoll</code> 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h5 id="3-总结"><a class="header-anchor" href="#3-总结">¶</a>3. 总结</h5>
<p>假如有这样一个例子：</p>
<ol>
<li>我们已经把一个用来从管道中读取数据的文件句柄（RFD）添加到 <code>epoll</code> 描述符</li>
<li>这个时候从管道的另一端被写入了 2KB 的数据</li>
<li>调用 <code>epoll_wait(2)</code>，并且它会返回 RFD，说明它已经准备好读取操作</li>
<li>然后我们读取了 1KB 的数据</li>
<li>调用 <code>epoll_wait(2)</code>…</li>
</ol>
<p>LT 模式：<br>
如果是 LT 模式，那么在第 5 步调用 <code>epoll_wait(2)</code> 之后，仍然能受到通知。</p>
<p>ET 模式：<br>
如果我们在第 1 步将 RFD 添加到 <code>epoll</code> 描述符的时候使用了 <code>EPOLLET</code> 标志，那么在第 5 步调用 <code>epoll_wait(2)</code> 之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第 5 步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p>
<p>当使用 <code>epoll</code> 的 ET 模型来工作时，当产生了一个 <code>EPOLLIN</code> 事件后，<br>
读数据的时候需要考虑的是当 <code>recv()</code> 返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">while</span>(rs)&#123;<br>  buflen = recv(activeevents[i].data.fd, buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span>(buflen &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</span><br>    <span class="hljs-comment">// 在这里就当作是该次事件已处理处.</span><br>    <span class="hljs-keyword">if</span>(errno == EAGAIN)&#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(buflen == <span class="hljs-number">0</span>)&#123;<br>     <span class="hljs-comment">// 这里表示对端的socket已正常关闭.</span><br>  &#125;<br><br> <span class="hljs-keyword">if</span>(buflen == <span class="hljs-keyword">sizeof</span>(buf)&#123;<br>      rs = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 需要再次读取</span><br> &#125;<br> <span class="hljs-keyword">else</span>&#123;<br>      rs = <span class="hljs-number">0</span>;<br> &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>Linux 中的 <code>EAGAIN</code> 含义</p>
<p>Linux 环境下开发经常会碰到很多错误（设置 <code>errno</code>），其中 <code>EAGAIN</code> 是其中比较常见的一个错误（比如用在非阻塞操作中）。<br>
从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞（non-blocking）操作（对文件或 socket）的时候。</p>
<p>例如，以 <code>O_NONBLOCK</code> 的标志打开文件/socket/FIFO，如果你连续做 <code>read</code> 操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，<code>read</code> 函数会返回一个错误 <code>EAGAIN</code>，提示你的应用程序现在没有数据可读请稍后再试。<br>
又例如，当一个系统调用（比如 <code>fork</code>）因为没有足够的资源（比如虚拟内存）而执行失败，返回 <code>EAGAIN</code> 提示其再调用一次（也许下次就能成功）。</p>
<h4 id="代码演示"><a class="header-anchor" href="#代码演示">¶</a>代码演示</h4>
<p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IPADDRESS   <span class="hljs-meta-string">"127.0.0.1"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PORT        8787</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE     1024</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LISTENQ     5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FDSIZE      1000</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EPOLLEVENTS 100</span><br><br>listenfd = socket_bind(IPADDRESS,PORT);<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">events</span>[<span class="hljs-title">EPOLLEVENTS</span>];</span><br><br><span class="hljs-comment">//创建一个描述符</span><br>epollfd = epoll_create(FDSIZE);<br><br><span class="hljs-comment">//添加监听描述符事件</span><br>add_event(epollfd,listenfd,EPOLLIN);<br><br><span class="hljs-comment">//循环等待</span><br><span class="hljs-keyword">for</span> ( ; ; )&#123;<br>    <span class="hljs-comment">//该函数返回已经准备好的描述符事件数目</span><br>    ret = epoll_wait(epollfd,events,EPOLLEVENTS,<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//处理接收到的连接</span><br>    handle_events(epollfd,events,ret,listenfd,buf);<br>&#125;<br><br><span class="hljs-comment">//事件处理函数</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle_events</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,struct epoll_event *events,<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">int</span> listenfd,<span class="hljs-keyword">char</span> *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-keyword">int</span> i;<br>     <span class="hljs-keyword">int</span> fd;<br>     <span class="hljs-comment">//进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。</span><br>     <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; num;i++)<br>     &#123;<br>         fd = events[i].data.fd;<br>        <span class="hljs-comment">//根据描述符的类型和事件类型进行处理</span><br>         <span class="hljs-keyword">if</span> ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))<br>            handle_accpet(epollfd,listenfd);<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN)<br>            do_read(epollfd,fd,buf);<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLOUT)<br>            do_write(epollfd,fd,buf);<br>     &#125;<br>&#125;<br><br><span class="hljs-comment">//添加事件</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add_event</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">int</span> state)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>;</span><br>    ev.events = state;<br>    ev.data.fd = fd;<br>    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);<br>&#125;<br><br><span class="hljs-comment">//处理接收到的连接</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle_accpet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,<span class="hljs-keyword">int</span> listenfd)</span></span>&#123;<br>     <span class="hljs-keyword">int</span> clifd;     <br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">cliaddr</span>;</span>     <br>     <span class="hljs-keyword">socklen_t</span>  cliaddrlen;     <br>     clifd = accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);     <br>     <span class="hljs-keyword">if</span> (clifd == <span class="hljs-number">-1</span>)         <br>     perror(<span class="hljs-string">"accpet error:"</span>);     <br>     <span class="hljs-keyword">else</span> &#123;         <br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"accept a new client: %s:%d\n"</span>,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);                       <span class="hljs-comment">//添加一个客户描述符和事件         </span><br>         add_event(epollfd,clifd,EPOLLIN);     <br>     &#125; <br>&#125;<br><br><span class="hljs-comment">//读处理</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">do_read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">char</span> *buf)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> nread;<br>    nread = <span class="hljs-built_in">read</span>(fd,buf,MAXSIZE);<br>    <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">-1</span>)     &#123;         <br>        perror(<span class="hljs-string">"read error:"</span>);         <br>        <span class="hljs-built_in">close</span>(fd); <span class="hljs-comment">//记住close fd        </span><br>        delete_event(epollfd,fd,EPOLLIN); <span class="hljs-comment">//删除监听 </span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nread == <span class="hljs-number">0</span>)     &#123;         <br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"client close.\n"</span>);<br>        <span class="hljs-built_in">close</span>(fd); <span class="hljs-comment">//记住close fd       </span><br>        delete_event(epollfd,fd,EPOLLIN); <span class="hljs-comment">//删除监听 </span><br>    &#125;     <br>    <span class="hljs-keyword">else</span> &#123;         <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"read message is : %s"</span>,buf);        <br>        <span class="hljs-comment">//修改描述符对应的事件，由读改为写         </span><br>        modify_event(epollfd,fd,EPOLLOUT);     <br>    &#125; <br>&#125;<br><br><span class="hljs-comment">//写处理</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">do_write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">char</span> *buf)</span> </span>&#123;     <br>    <span class="hljs-keyword">int</span> nwrite;     <br>    nwrite = <span class="hljs-built_in">write</span>(fd,buf,<span class="hljs-built_in">strlen</span>(buf));     <br>    <span class="hljs-keyword">if</span> (nwrite == <span class="hljs-number">-1</span>)&#123;         <br>        perror(<span class="hljs-string">"write error:"</span>);        <br>        <span class="hljs-built_in">close</span>(fd);   <span class="hljs-comment">//记住close fd       </span><br>        delete_event(epollfd,fd,EPOLLOUT);  <span class="hljs-comment">//删除监听    </span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        modify_event(epollfd,fd,EPOLLIN); <br>    &#125;    <br>    <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,MAXSIZE); <br>&#125;<br><br><span class="hljs-comment">//删除事件</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete_event</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">int</span> state)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>;</span><br>    ev.events = state;<br>    ev.data.fd = fd;<br>    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);<br>&#125;<br><br><span class="hljs-comment">//修改事件</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modify_event</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epollfd,<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">int</span> state)</span></span>&#123;     <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>;</span><br>    ev.events = state;<br>    ev.data.fd = fd;<br>    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);<br>&#125;<br><br><span class="hljs-comment">//注：另外一端我就省了</span><br></code></pre></div></td></tr></table></figure>
<h2 id="四、epoll-总结"><a class="header-anchor" href="#四、epoll-总结">¶</a>四、<code>epoll</code> 总结</h2>
<p>在 <code>select</code>/<code>poll</code> 中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而 <code>epoll</code> 事先通过 <code>epoll_ctl()</code> 来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似回调的机制，迅速激活这个文件描述符，当进程调用 <code>epoll_wait()</code> 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是 <code>epoll</code> 的魅力所在。)</p>
<p><code>epoll</code> 的优点主要是一下几个方面：</p>
<ol>
<li>
<p>监视的描述符数量不受限制，它所支持的 <code>fd</code> 上限是最大可以打开文件的数目，这个数字一般远大于 2048,举个例子,在 1GB 内存的机器上大约是 10 万左右，具体数目可以<code>cat /proc/sys/fs/file-max</code>察看,一般来说这个数目和系统内存关系很大。<code>select</code> 的最大缺点就是进程打开的 <code>fd</code> 是有数量限制的。这对于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案（Apache就是这样实现的），不过虽然 linux 上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</p>
</li>
<li>
<p>IO 的效率不会随着监视 <code>fd</code> 的数量的增长而下降。<code>epoll</code> 不同于 <code>select</code> 和 <code>poll</code>轮询的方式，而是通过每个 <code>fd</code> 定义的回调函数来实现的。只有就绪的 <code>fd</code> 才会执行回调函数。</p>
</li>
</ol>
<blockquote>
<p>注意：</p>
<hr>
<p>如果没有大量的 idle-connection 或者 dead-connection，<code>epoll</code> 的效率并不会比 <code>select</code>/<code>poll</code> 高很多，但是当遇到大量的 idle-connection，就会发现 <code>epoll</code> 的效率大大高于 <code>select</code>/<code>poll</code>。</p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Linux/">Linux</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/13/ASP.NET%20Core%20%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ASP.NET Core 认证与授权</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/10/ASP.NET-Core-3.1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">
                        <span class="hidden-mobile">ASP.NET Core 3.1 学习笔记（一）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('vcomments', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "TMgxzCpM2zFnsClsMHJY2LLc-gzGzoHsz",
          app_key: "1kPLieLtoBQWf0w6iNxLqkMV",
          placeholder: "说点什么....",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: true,
          recordIP: true,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the
    <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments powered by Valine.</a>
  </noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     Powered by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> &nbsp;and&nbsp; <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?a9b0666290f750544a1900dff36c0349";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  
    <!-- Google Analytics -->
    <script defer>
      window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) };
      ga.l = +new Date;
      ga('create', 'UA-127726236-2', 'auto');
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
